<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/design/she-ji-mo-shi/"/>
      <url>/design/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="24大设计模式和7个原则"><a href="#24大设计模式和7个原则" class="headerlink" title="24大设计模式和7个原则"></a>24大设计模式和7个原则</h1><h2 id="7个原则"><a href="#7个原则" class="headerlink" title="7个原则"></a>7个原则</h2><h3 id="单一职责原则【SINGLE-RESPONSIBILITY-PRINCIPLE】"><a href="#单一职责原则【SINGLE-RESPONSIBILITY-PRINCIPLE】" class="headerlink" title="单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】"></a>单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】</h3><p>一个类负责一项职责。</p><h3 id="里氏替换原则【LISKOV-SUBSTITUTION-PRINCIPLE】"><a href="#里氏替换原则【LISKOV-SUBSTITUTION-PRINCIPLE】" class="headerlink" title="里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】"></a>里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】</h3><p> 继承与派生的规则。</p><h3 id="依赖倒置原则【DEPENDENCE-INVERSION-PRINCIPLE】"><a href="#依赖倒置原则【DEPENDENCE-INVERSION-PRINCIPLE】" class="headerlink" title="依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】"></a>依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】</h3><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。</p><h3 id="接口隔离原则【INTERFACE-SEGREGATION-PRINCIPLE】"><a href="#接口隔离原则【INTERFACE-SEGREGATION-PRINCIPLE】" class="headerlink" title="接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】"></a>接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】</h3><p>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</p><h3 id="迪米特法则【LOW-OF-DEMETER】"><a href="#迪米特法则【LOW-OF-DEMETER】" class="headerlink" title="迪米特法则【LOW OF DEMETER】"></a>迪米特法则【LOW OF DEMETER】</h3><p> 低耦合，高内聚。</p><h3 id="开闭原则【OPEN-CLOSE-PRINCIPLE】"><a href="#开闭原则【OPEN-CLOSE-PRINCIPLE】" class="headerlink" title="开闭原则【OPEN CLOSE PRINCIPLE】"></a>开闭原则【OPEN CLOSE PRINCIPLE】</h3><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><h3 id="组合-x2F-聚合复用原则【Composition-x2F-Aggregation-Reuse-Principle-CARP-】"><a href="#组合-x2F-聚合复用原则【Composition-x2F-Aggregation-Reuse-Principle-CARP-】" class="headerlink" title="组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】"></a>组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】</h3><p> 尽量使用组合和聚合少使用继承的关系来达到复用的原则。</p><h2 id="24大设计模式"><a href="#24大设计模式" class="headerlink" title="24大设计模式"></a>24大设计模式</h2><p><img src="/attachment/c8526e18ad6aa3bfc619658562abf956.png"></p><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p><img src="/attachment/8d50c3aa7f9e61c8bc93fcee6ccd3d3e.png"></p><h2 id="知识体系图"><a href="#知识体系图" class="headerlink" title="知识体系图"></a>知识体系图</h2><p><img src="/attachment/d75c87b65403a8b230a3bb8a845ad281.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/design/xing-wei-mo-shi/xing-wei-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/xing-wei-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="行为模式-Overview"><a href="#行为模式-Overview" class="headerlink" title="行为模式 Overview"></a>行为模式 Overview</h1><pre><code class="line-numbers language-ccard">type: folder_brief_livestyle: stripnoteOnly: true </code></pre><p>行为模式负责对象间的高效沟通和职责委派。</p><p><img src="/attachment/68ca4afe9f6628e7e60ea019c49bee25.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/design/jie-gou-mo-shi/jie-gou-mo-shi/"/>
      <url>/design/jie-gou-mo-shi/jie-gou-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="结构模式-Overview"><a href="#结构模式-Overview" class="headerlink" title="结构模式 Overview"></a>结构模式 Overview</h1><pre><code class="line-numbers language-ccard">type: folder_brief_livestyle: stripnoteOnly: true </code></pre><p>结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</p><p><img src="/attachment/3ba8c59f183b2adf2357af09b4f12679.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/design/chuang-jian-mo-shi/chuang-jian-mo-shi/"/>
      <url>/design/chuang-jian-mo-shi/chuang-jian-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="【设计模式】创新模式-Overview"><a href="#【设计模式】创新模式-Overview" class="headerlink" title="【设计模式】创新模式 Overview"></a>【设计模式】创新模式 Overview</h1><pre><code class="line-numbers language-ccard">type: folder_brief_livestyle: stripnoteOnly: true </code></pre><p>创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。</p><p><img src="/attachment/5bc8f19cad798f48ff3540f027b31f63.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程"><a href="#【Java-多线程并发】-线程" class="headerlink" title="【Java 多线程并发】 线程"></a>【Java 多线程并发】 线程</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程date: 2023-07-10 14:15tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 线程</code></pre><h2 id="【Java-多线程并发】-线程，进程，协程的详细解释"><a href="#【Java-多线程并发】-线程，进程，协程的详细解释" class="headerlink" title="【Java 多线程并发】 线程，进程，协程的详细解释"></a>【Java 多线程并发】 线程，进程，协程的详细解释</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-Java中线程的创建和运行"><a href="#【Java-多线程并发】-Java中线程的创建和运行" class="headerlink" title="【Java 多线程并发】 Java中线程的创建和运行"></a>【Java 多线程并发】 Java中线程的创建和运行</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-线程睡眠、阻塞、挂起、终止"><a href="#【Java-多线程并发】-线程睡眠、阻塞、挂起、终止" class="headerlink" title="【Java 多线程并发】 线程睡眠、阻塞、挂起、终止"></a>【Java 多线程并发】 线程睡眠、阻塞、挂起、终止</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-线程的通知与等待"><a href="#【Java-多线程并发】-线程的通知与等待" class="headerlink" title="【Java 多线程并发】 线程的通知与等待"></a>【Java 多线程并发】 线程的通知与等待</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-线程中断"><a href="#【Java-多线程并发】-线程中断" class="headerlink" title="【Java 多线程并发】 线程中断"></a>【Java 多线程并发】 线程中断</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-join-方法"><a href="#【Java-多线程并发】-join-方法" class="headerlink" title="【Java 多线程并发】 join()方法"></a>【Java 多线程并发】 join()方法</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-Thread"><a href="#【Java-多线程并发】-Thread" class="headerlink" title="【Java 多线程并发】 Thread"></a>【Java 多线程并发】 Thread</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-Runnable"><a href="#【Java-多线程并发】-Runnable" class="headerlink" title="【Java 多线程并发】 Runnable"></a>【Java 多线程并发】 Runnable</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-Future机制"><a href="#【Java-多线程并发】-Future机制" class="headerlink" title="【Java 多线程并发】 Future机制"></a>【Java 多线程并发】 Future机制</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-ThreadLocal"><a href="#【Java-多线程并发】-ThreadLocal" class="headerlink" title="【Java 多线程并发】 ThreadLocal"></a>【Java 多线程并发】 ThreadLocal</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 直接内存</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-直接内存"><a href="#【Java-JVM】-直接内存" class="headerlink" title="【Java JVM】 直接内存"></a>【Java JVM】 直接内存</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 直接内存date: 2023-07-10 08:00tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 直接内存</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>直接内存是在 Java 堆外的、直接向系统申请的内存区间。来源于 NIO，通过存在堆中的 DirectByteBuffer 操作 Native 内存。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区</li></ul><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><h3 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h3><p>不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。<mark>直接内存是在 Java 堆外的、直接向系统申请的内存区间</mark>。来源于 NIO，通过存在堆中的 DirectByteBuffer 操作 Native 内存。通常，访问直接内存的速度会优于 Java 堆，即<mark>读写性能高</mark>。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区</li></ul><h3 id="非直接缓存区"><a href="#非直接缓存区" class="headerlink" title="非直接缓存区"></a>非直接缓存区</h3><p>使用 IO 读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p><p><img src="/attachment/fe14cff1e4035d45eed46f6fbdd19219.png"></p><p>也可能导致 OutOfMemoryError 异常</p><pre><code class="line-numbers language-java">Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory    at java.nio.Bits.reserveMemory(Bits.java:693)    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)    at com.atguigu.java.BufferTest2.main(BufferTest2.java:20)</code></pre><p>由于直接内存在 Java 堆外，因此它的大小不会直接受限于-Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><ul><li>分配回收成本较高</li><li>不受 JVM 内存回收管理</li></ul><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置。如果不指定，默认与堆的最大值-Xmx 参数值一致</p><p><img src="/attachment/1bd031027aba4b7ba6c4c823994e1870.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 排序</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-排序"><a href="#【Redis】-排序" class="headerlink" title="【Redis】 排序"></a>【Redis】 排序</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 排序date: 2023-07-09 14:07tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 排序</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。</p><p>本章将对SORT命令的实现原理进行介绍，并说明包括ASC、DESC、ALPHA、LIMIT、STORE、BY、GET在内的所有SORT命令选项的实现原理。</p><ul><li>SORT命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作。</li><li>在默认情况下，SORT命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序。</li><li>如果SORT命令使用了ALPHA选项，那么SORT命令假设被排序键包含的都是字符串值，并且以字符串的方式来进行排序。</li><li>SORT命令的排序操作由快速排序算法实现。</li><li>SORT命令会根据用户是否使用了DESC选项来决定是使用升序对比还是降序对比来比较被排序的元素，升序对比会产生升序排序结果，被排序的元素按值的大小从小到大排列，降序对比会产生降序排序结果，被排序的元素按值的大小从大到小排列。</li><li>当SORT命令使用了BY选项时，命令使用其他键的值作为权重来进行排序操作。</li><li>当SORT命令使用了LIMIT选项时，命令只保留排序结果集中LIMIT选项指定的元素。</li><li>当SORT命令使用了GET选项时，命令会根据排序结果集中的元素，以及GET选项给定的模式，查找并返回其他键的值，而不是返回被排序的元素。</li><li>当SORT命令使用了STORE选项时，命令会将排序结果集保存在指定的键里面。</li><li>当SORT命令同时使用多个选项时，命令先执行排序操作（可用的选项为ALPHA、ASC或DESC、BY），然后执行LIMIT选项，之后执行GET选项，再之后执行STORE选项，最后才将排序结果集返回给客户端。</li><li>除了GET选项之外，调整选项的摆放位置不会影响SORT命令的排序结果。</li></ul><h2 id="SORT-lt-key-gt-命令的实现"><a href="#SORT-lt-key-gt-命令的实现" class="headerlink" title="SORT<key>命令的实现"></a>SORT&lt;key&gt;命令的实现</h2><p>SORT命令的最简单执行形式为：</p><pre><code class="line-numbers language-shell">SORT &lt;key&gt;</code></pre><p>这个命令可以对一个包含数字值的键key进行排序。</p><p>服务器执行SORT numbers命令的详细步骤如下：<br>1）创建一个和numbers列表长度相同的数组，该数组的每个项都是一个redis.h/redisSortObject结构。<br>2）遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系，如图21-2所示。<br>3）遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面，如图21-3所示。<br>4）根据数组项u.score属性的值，对数组进行数字值排序，排序后的数组项按u.score属性的值从小到大排列，如图21-4所示。<br>5）遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端，程序首先访问数组的索引0，返回u.score值为1.0的列表项”1”；然后访问数组的索引1，返回u.score值为2.0的列表项”2”；最后访问数组的索引2，返回u.score值为3.0的列表项”3”。</p><p><img src="/attachment/7f58ee61186466651879c634c72c190b.png"></p><p><img src="/attachment/6225efc06c70ead035d058fbbc9ec735.png"></p><p><img src="/attachment/e77f29d96d42f41435a7b05146d29fd8.png"></p><p><img src="/attachment/e9d851b2fbdac6b77d4710b5edbe7b38.png"></p><h3 id="ALPHA选项的实现"><a href="#ALPHA选项的实现" class="headerlink" title="ALPHA选项的实现"></a>ALPHA选项的实现</h3><p>通过使用ALPHA选项，SORT命令可以对包含字符串值的键进行排序：</p><pre><code class="line-numbers language-shell">SORT &lt;key&gt; ALPHA</code></pre><p>以下命令展示了如何使用SORT命令对一个包含三个字符串值的集合键进行排序：</p><p>服务器执行SORT fruits ALPHA命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素，如图21-5所示。<br>3）根据obj指针所指向的集合元素，对数组进行字符串排序，排序后的数组项按集合元素的字符串值从小到大排列：因为”apple”、”banana”、”cherry “三个字符串的大小顺序为”apple”&lt;”banana”&lt;”cherry “，所以排序后数组的第一项指向”apple”元素，第二项指向”banana”元素，第三项指向”cherry “元素，如图21-6所示。<br>4）遍历数组，依次将数组项的obj指针所指向的元素返回给客户端。</p><p><img src="/attachment/86587c78daa3cf927085ffc47dcf8659.png"></p><h3 id="ASC选项和DESC选项的实现"><a href="#ASC选项和DESC选项的实现" class="headerlink" title="ASC选项和DESC选项的实现"></a>ASC选项和DESC选项的实现</h3><p>在默认情况下，SORT命令执行升序排序，排序后的结果按值的大小从小到大排列，以下<br>两个命令是完全等价的：</p><pre><code class="line-numbers language-shell">SORT &lt;key&gt;SORT &lt;key&gt; ASC</code></pre><h3 id="BY选项的实现"><a href="#BY选项的实现" class="headerlink" title="BY选项的实现"></a>BY选项的实现</h3><p>在默认情况下，SORT命令使用被排序键包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置。</p><p><img src="/attachment/135b6f1d6931168e1bfb17cb76f37d6d.png"></p><h3 id="带有ALPHA选项的BY选项的实现"><a href="#带有ALPHA选项的BY选项的实现" class="headerlink" title="带有ALPHA选项的BY选项的实现"></a>带有ALPHA选项的BY选项的实现</h3><p>服务器执行SORT fruits BY*-id ALPHA命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素。<br>3）遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式<code>*-id</code>，查找相应的权重键：<br>将各个数组项的u.cmpobj指针分别指向相应的权重键（一个字符串对象）。<br>5）以各个数组项的权重键的值为权重，对数组执行字符串排序<br>6）遍历数组，依次将数组项的obj指针所指向的集合元素返回给客户端。</p><p><img src="/attachment/40203b5ca3358319d79409433799a9fa.png"></p><p><img src="/attachment/5310dc891c0206b6067e85075ada558c.png"></p><p><img src="/attachment/03b8b5231809d6e52de8b23f58d46969.png"></p><h2 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h2><p>通过LIMIT选项，我们可以让SORT命令只返回其中一部分已排序的元素。<br>LIMIT选项的格式为<code>LIMIT&lt;offset&gt;&lt;count&gt;</code>：</p><ul><li>offset参数表示要跳过的已排序元素数量。</li><li>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量。</li></ul><p>服务器执行SORT alphabet ALPHA LIMIT 0 4命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于alphabet集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向alphabet集合的各个元素，如图21-15所示。<br>3）根据obj指针所指向的集合元素，对数组进行字符串排序，排序后的数组如图21-16所示。<br>4）根据选项LIMIT 0 4，将指针移动到数组的索引0上面，然后依次访问array [0]、array [1]、array [2]、array [3]这4个数组项，并将数组项的obj指针所指向的元素”a”、”b”、”c”、”d”返回给客户端。<br>服务器执行SORT alphabet ALPHA LIMIT 2 3命令时的第一至第三步都和执行SORTalphabet ALPHA LIMIT 0 4命令时的步骤一样，只是第四步有所不同，上面的第4步如下：<br>4）根据选项LIMIT 2 3，将指针移动到数组的索引2上面，然后依次访问array [2]、array [3]、array [4]这3个数组项，并将数组项的obj指针所指向的元素”c”、”d”、”e”返回给客户端。</p><p><img src="/attachment/e78b5b5a95e94ea157fc343f7fe2223c.png"></p><p><img src="/attachment/1b5637327392cd5f3d8afecc6bd176b4.png"></p><h2 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h2><p>在默认情况下，SORT命令在对键进行排序之后，总是返回被排序键本身所包含的元素。</p><p>通过使用GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p><p>服务器执行SORT students ALPHA GET*-name命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于students集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向students集合的各个元素，<br>3）根据obj指针所指向的集合元素，对数组进行字符串排序<br>4）遍历数组，根据数组项obj指针所指向的集合元素，以及GET选项所给定的模式， 查找响应的键<br>5）遍历查找程序返回的三个键，并向客户端返回它们的值：<br>6）遍历数组，根据数组项obj指针所指向的集合元素，以及两个GET选项所给定的*-name模式和*-birth模式，查找相应的键：<br>7）遍历查找程序返回的六个键，并向客户端返回它们的值：</p><p><img src="/attachment/7336d92037d0f3ea7d26215cd0c370e3.png"></p><h2 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h2><p>通过使用STORE选项，我们可以将排序结果保存在指定的键里面，并在有需要时重用这个排序结果：</p><p>服务器执行SORT students ALPHA STORE sorted_students命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于students集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向students集合的各个元素。<br>3）根据obj指针所指向的集合元素，对数组进行字符串排序。<br>4）检查sorted_students键是否存在，如果存在的话，那么删除该键。<br>5）设置sorted_students为空白的列表键。<br>6）遍历数组，将排序后的三个元素”jack”、”peter”和”tom”依次推入sorted_students列表的末尾，相当于执行命令RPUSH sorted_students”jack”、”peter”、”tom”。<br>7）遍历数组，向客户端返回”jack”、”peter”、”tom”三个元素。</p><h2 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h2><h3 id="选项的执行顺序"><a href="#选项的执行顺序" class="headerlink" title="选项的执行顺序"></a>选项的执行顺序</h3><p>1）排序：在这一步，命令会使用ALPHA、ASC或DESC、BY这几个选项，对输入键进行排序，并得到一个排序结果集。<br>2）限制排序结果集的长度：在这一步，命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中。<br>3）获取外部键：在这一步，命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。<br>4）保存排序结果集：在这一步，命令会使用STORE选项，将排序结果集保存到指定的键上面去。<br>5）向客户端返回排序结果集：在最后这一步，命令遍历排序结果集，并依次向客户端返回排序结果集中的元素。</p><h3 id="选项的摆放顺序"><a href="#选项的摆放顺序" class="headerlink" title="选项的摆放顺序"></a>选项的摆放顺序</h3><p>另外要提醒的一点是，调用SORT命令时，除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 Lua脚本</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-Lua脚本"><a href="#【Redis】-Lua脚本" class="headerlink" title="【Redis】 Lua脚本"></a>【Redis】 Lua脚本</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 Lua脚本date: 2023-07-09 13:56tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 Lua脚本</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p><ul><li>Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性、安全性等方面的需要。</li><li>Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令。</li><li>Redis使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能。</li><li>EVAL命令为客户端输入的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。</li><li>EVALSHA命令通过直接调用Lua环境中已定义的函数来执行脚本。</li><li>SCRIPT FLUSH命令会清空服务器lua_scripts字典中保存的脚本，并重置Lua环境。</li><li>SCRIPT EXISTS命令接受一个或多个SHA1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。</li><li>SCRIPT LOAD命令接受一个Lua脚本为参数，为该脚本在Lua环境中创建函数，并将脚本保存到lua_scripts字典中。</li><li>服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行情况时，客户端可以通过向服务器发送SCRIPT KILL命令来让钩子停止正在执行的脚本，或者发送SHUTDOWN nosave命令来让钩子关闭整个服务器。</li><li>主服务器复制EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的方法和复制普通Redis命令一样，只要将相同的命令传播给从服务器就可以了。</li><li>主服务器在复制EVALSHA命令时，必须确保所有从服务器都已经载入了EVALSHA命令指定的SHA1校验和所对应的Lua脚本，如果不能确保这一点的话，主服务器会将EVALSHA命令转换成等效的EVAL命令，并通过传播EVAL命令来获得相同的脚本执行效果。</li></ul><h2 id="创建并修改Lua环境"><a href="#创建并修改Lua环境" class="headerlink" title="创建并修改Lua环境"></a>创建并修改Lua环境</h2><p>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境（environment），<br>并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。<br>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成：<br>1）创建一个基础的Lua环境，之后的所有修改都是针对这个环境进行的。<br>2）载入多个函数库到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作。<br>3）创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中执行Redis命令的redis.call函数。<br>4）使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本中引入副作用。<br>5）创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排序，从而消除这些命令的不确定性。<br>6）创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。<br>7）对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全局变量添加到Lua环境中。<br>8）将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本。接下来的各个小节将分别介绍这些步骤。</p><h2 id="Lua环境协作组件"><a href="#Lua环境协作组件" class="headerlink" title="Lua环境协作组件"></a>Lua环境协作组件</h2><p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的lua_scripts字典。</p><h3 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h3><p>因为执行Redis命令必须有相应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。</p><p>Lua脚本使用redis.call函数或者redis.pcall函数执行一个Redis命令，需要完成以下步骤：<br>1）Lua环境将redis.call函数或者redis.pcall函数想要执行的命令传给伪客户端。<br>2）伪客户端将脚本想要执行的命令传给命令执行器。<br>3）命令执行器执行伪客户端传给它的命令，并将命令的执行结果返回给伪客户端。<br>4）伪客户端接收命令执行器返回的命令结果，并将这个命令结果返回给Lua环境。<br>5）Lua环境在接收到命令结果之后，将该结果返回给redis.call函数或者redis.pcall函数。<br>6）接收到结果的redis.call函数或者redis.pcall函数会将命令结果作为函数返回值返回给脚本中的调用者。</p><p><img src="/attachment/3679632435845ee77164fdd1aa82de68.png"></p><p><img src="/attachment/b01d7cb6f4c142e04421d0a1684cccdf.png"></p><h3 id="lua-scripts字典"><a href="#lua-scripts字典" class="headerlink" title="lua_scripts字典"></a>lua_scripts字典</h3><pre><code class="line-numbers language-c">struct redisServer {    // ...    dict *lua_scripts;    // ...};</code></pre><h2 id="EVAL命令的实现"><a href="#EVAL命令的实现" class="headerlink" title="EVAL命令的实现"></a>EVAL命令的实现</h2><p>EVAL命令的执行过程可以分为以下三个步骤：<br>1）根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。<br>2）将客户端给定的脚本保存到lua_scripts字典，等待将来进一步使用。<br>3）执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</p><h2 id="EVALSHA命令的实现"><a href="#EVALSHA命令的实现" class="headerlink" title="EVALSHA命令的实现"></a>EVALSHA命令的实现</h2><p>可以用伪代码来描述这一原理：</p><pre><code class="line-numbers language-c">def EVALSHA(sha1):    # 拼接出函数的名字    # 例如：f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91    func_name = "f_" + sha1    # 查看这个函数在Lua 环境中是否存在    if function_exists_in_lua_env(func_name):        # 如果函数存在，那么执行它        execute_lua_function(func_name)    else:        # 如果函数不存在，那么返回一个错误        send_script_error("SCRIPT NOT FOUND")</code></pre><h2 id="脚本管理命令的实现"><a href="#脚本管理命令的实现" class="headerlink" title="脚本管理命令的实现"></a>脚本管理命令的实现</h2><h3 id="SCRIPT-FLUSH"><a href="#SCRIPT-FLUSH" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h3><p>SCRIPT FLUSH命令用于清除服务器中所有和Lua脚本有关的信息，这个命令会释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境。</p><h3 id="SCRIPT-EXISTS"><a href="#SCRIPT-EXISTS" class="headerlink" title="SCRIPT EXISTS"></a>SCRIPT EXISTS</h3><p>SCRIPT EXISTS命令根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p><h3 id="SCRIPT-LOAD"><a href="#SCRIPT-LOAD" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h3><p>SCRIPT LOAD命令所做的事情和EVAL命令执行脚本时所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典里面。</p><h3 id="SCRIPT-KILL"><a href="#SCRIPT-KILL" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h3><p>如果服务器设置了lua-time-limit配置选项，那么在每次执行Lua脚本之前，服务器都会在Lua环境里面设置一个超时处理钩子（hook）。<br>超时处理钩子在脚本运行期间，会定期检查脚本已经运行了多长时间，一旦钩子发现脚本的运行时间已经超过了lua-time-limit选项设置的时长，钩子将定期在脚本运行的间隙中，查看是否有SCRIPT KILL命令或者SHUTDOWN命令到达服务器。</p><p><img src="/attachment/ab65ef386f8f3ad28189f4fc103ce021.png"></p><h2 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h2><p>与其他普通Redis命令一样，当服务器运行在复制模式之下时，具有写性质的脚本命令也会被复制到从服务器，这些命令包括EVAL命令、EVALSHA命令、SCRIPT FLUSH命令，以及SCRIPT LOAD命令。</p><h3 id="复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令"><a href="#复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令" class="headerlink" title="复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令"></a>复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令</h3><p><img src="/attachment/47da079ce18611e1d9b0427d785804db.png"></p><h3 id="复制EVALSHA命令"><a href="#复制EVALSHA命令" class="headerlink" title="复制EVALSHA命令"></a>复制EVALSHA命令</h3><h4 id="判断传播EVALSHA命令是否安全的方法"><a href="#判断传播EVALSHA命令是否安全的方法" class="headerlink" title="判断传播EVALSHA命令是否安全的方法"></a>判断传播EVALSHA命令是否安全的方法</h4><h4 id="清空repl-scriptcache-dict字典"><a href="#清空repl-scriptcache-dict字典" class="headerlink" title="清空repl_scriptcache_dict字典"></a>清空repl_scriptcache_dict字典</h4><h4 id="EVALSHA命令转换成EVAL命令的方法"><a href="#EVALSHA命令转换成EVAL命令的方法" class="headerlink" title="EVALSHA命令转换成EVAL命令的方法"></a>EVALSHA命令转换成EVAL命令的方法</h4><p>1）根据SHA1校验和sha1，在lua_scripts字典中查找sha1对应的Lua脚本script。<br>2）将原来的EVALSHA命令请求改写成EVAL命令请求，并且将校验和sha1改成脚本script，至于numkey s、key、arg等参数则保持不变。</p><h4 id="传播EVALSHA命令的方法"><a href="#传播EVALSHA命令的方法" class="headerlink" title="传播EVALSHA命令的方法"></a>传播EVALSHA命令的方法</h4><p><img src="/attachment/89eafd3932d4c4af0e3e2990a5336123.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 发布和订阅</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-fa-bu-he-ding-yue/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-fa-bu-he-ding-yue/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-发布和订阅"><a href="#【Redis】-发布和订阅" class="headerlink" title="【Redis】 发布和订阅"></a>【Redis】 发布和订阅</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 发布和订阅date: 2023-07-09 13:30tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 发布和订阅</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。</p><p>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。</p><p><img src="/attachment/e0bbc535676b4582378334c66bd6694d.png"></p><ul><li><strong>服务器状态</strong>在<strong>pubsub_channels字典</strong>保存了<strong>所有频道的订阅关系</strong>：SUBSCRIBE命令负责将客户端和被订阅的频道关联到这个字典里面，而UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关联。</li><li><strong>服务器状态</strong>在<strong>pubsub_patterns链表</strong>保存了<strong>所有模式的订阅关系</strong>：PSUBSCRIBE命令负责将客户端和被订阅的模式记录到这个链表中，而PUNSUBSCRIBE命令则负责移除客户端和被退订模式在链表中的记录。</li><li>PUBLISH命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息，通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息。</li><li>PUBSUB命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的。</li></ul><h2 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h2><p>当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立起了一种订阅关系。</p><p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端：</p><pre><code class="line-numbers language-c">struct redisServer {    // ...    // 保存所有频道的订阅关系    dict *pubsub_channels;    // ...};</code></pre><p><img src="/attachment/13416e5e120317f97edd7793a20758d4.png"></p><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><pre><code class="line-numbers language-shell">SUBSCRIBE "news.sport" "news.movie"</code></pre><p><img src="/attachment/799d9ace72090fd41c5b82dc16c0e00b.png"></p><p>SUBSCRIBE命令的实现可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def subscribe(*all_input_channels):    # 遍历输入的所有频道    for channel in all_input_channels:        # 如果channel 不存在于pubsub_channels 字典（没有任何订阅者）        # 那么在字典中添加channel 键，并设置它的值为空链表        if channel not in server.pubsub_channels:            server.pubsub_channels[channel] = []        # 将订阅者添加到频道所对应的链表的末尾        server.pubsub_channels[channel].append(client)</code></pre><h3 id="退订频道"><a href="#退订频道" class="headerlink" title="退订频道"></a>退订频道</h3><p>UNSUBSCRIBE命令的行为和SUBSCRIBE命令的行为正好相反</p><pre><code class="line-numbers language-shell">UNSUBSCRIBE "news.sport" "news.movie"</code></pre><p><img src="/attachment/94b730d8e5a9c7f1016613609182464f.png"></p><p>UNSUBSCRIBE命令的实现可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def unsubscribe(*all_input_channels):    # 遍历要退订的所有频道    for channel in all_input_channels:        # 在订阅者链表中删除退订的客户端        server.pubsub_channels[channel].remove(client)        # 如果频道已经没有任何订阅者了（订阅者链表为空）        # 那么将频道从字典中删除        if len(server.pubsub_channels[channel]) == 0:            server.pubsub_channels.remove(channel)</code></pre><h2 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h2><p>服务器也将所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性里面：</p><pre><code class="line-numbers language-c">struct redisServer {// ...// 保存所有模式订阅关系list *pubsub_patterns;// ...};</code></pre><p>pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsub Pattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端：</p><pre><code class="line-numbers language-c">typedef struct pubsubPattern {    // 订阅模式的客户端    redisClient *client;    // 被订阅的模式    robj *pattern;} pubsubPattern;</code></pre><p><img src="/attachment/b09d32632c35e8e4b35a472866bfbf56.png"></p><p><img src="/attachment/bb09d4fac2b511566fa6abdd857a8249.png"></p><h3 id="PSUBSCRIBE"><a href="#PSUBSCRIBE" class="headerlink" title="PSUBSCRIBE"></a>PSUBSCRIBE</h3><p>PSUBSCRIBE命令的实现原理可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def psubscribe(*all_input_patterns):    # 遍历输入的所有模式    for pattern in all_input_patterns:        # 创建新的pubsubPattern 结构        # 记录被订阅的模式，以及订阅模式的客户端        pubsubPattern = create_new_pubsubPattern()        pubsubPattern.client = client        pubsubPattern.pattern = pattern        # 将新的pubsubPattern        追加到pubsub_patterns 链表末尾        server.pubsub_patterns.append(pubsubPattern)</code></pre><p><img src="/attachment/6c9d441d311613716d919559dcc57860.png"></p><h3 id="PUNSUBSCRIBE"><a href="#PUNSUBSCRIBE" class="headerlink" title="PUNSUBSCRIBE"></a>PUNSUBSCRIBE</h3><p><img src="/attachment/95be4f088930c0594c05dc87acd37087.png"></p><p>PUNSUBSCRIBE命令的实现原理可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def punsubscribe(*all_input_patterns):    # 遍历所有要退订的模式    for pattern in all_input_patterns:        # 遍历pubsub_patterns 链表中的所有pubsubPattern 结构        for pubsubPattern in server.pubsub_patterns:            #            如果当前客户端和pubsubPattern 记录的客户端相同            # 并且要退订的模式也和pubsubPattern 记录的模式相同            if client == pubsubPattern.client and pattern == pubsubPattern.pattern:                # 那么将这个pubsubPattern 从链表中删除                server.pubsub_patterns.remove(pubsubPattern)</code></pre><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>当一个Redis客户端执行<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：<br>1）将消息message发送给channel频道的所有订阅者。<br>2）如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。</p><h3 id="将消息发送给频道订阅者"><a href="#将消息发送给频道订阅者" class="headerlink" title="将消息发送给频道订阅者"></a>将消息发送给频道订阅者</h3><p><img src="/attachment/d644ac2c6acee20f01fe9c57174f0bc3.png"></p><p>PUBLISH命令将消息发送给频道订阅者的方法可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def channel_publish(channel, message):    # 如果channel键不存在于pubsub_channels 字典中    # 那么说明channel 频道没有任何订阅者    # 程序不做发送动作，直接返回    if channel not in server.pubsub_channels:        return    # 运行到这里，说明channel 频道至少有一个订阅者    # 程序遍历channel 频道的订阅者链表    # 将消息发送给所有订阅者    for subscriber in server.pubsub_channels[channel]:        send_message(subscriber, message)</code></pre><h3 id="将消息发送给模式订阅者"><a href="#将消息发送给模式订阅者" class="headerlink" title="将消息发送给模式订阅者"></a>将消息发送给模式订阅者</h3><p>因为服务器状态中的pubsub_patterns链表记录了所有模式的订阅关系，所以为了将消息发送给所有与channel频道相匹配的模式的订阅者，PUBLISH命令要做的就是遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端。</p><p>PUBLISH命令的实现可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def publish(channel, message):    # 将消息发送给channel 频道的所有订阅者    channel_publish(channel, message)    # 将消息发送给所有和channel 频道相匹配的模式的订阅者    pattern_publish(channel, message)</code></pre><h2 id="查看订阅信息"><a href="#查看订阅信息" class="headerlink" title="查看订阅信息"></a>查看订阅信息</h2><h3 id="PUBSUB-CHANNELS"><a href="#PUBSUB-CHANNELS" class="headerlink" title="PUBSUB CHANNELS"></a>PUBSUB CHANNELS</h3><p><code>PUBSUB CHANNELS[pattern]</code>子命令用于返回服务器当前被订阅的频道，其中pattern参数是可选的：</p><ul><li>如果不给定pattern参数，那么命令返回服务器当前被订阅的所有频道。</li><li>如果给定pattern参数，那么命令返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道。</li></ul><p>这个子命令是通过遍历服务器pubsub_channels字典的所有键（每个键都是一个被订阅的频道），然后记录并返回所有符合条件的频道来实现的，这个过程可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def pubsub_channels(pattern=None):    # 一个列表，用于记录所有符合条件的频道    channel_list = []    # 遍历服务器中的所有频道    # （也即是pubsub_channels 字典的所有键）    for channel in server.pubsub_channels:        # 当以下两个条件的任意一个满足时，将频道添加到链表里面：        #1 ）用户没有指定pattern 参数        #2 ）用户指定了pattern 参数，并且channel 和pattern 匹配        if (pattern is None) or match(channel, pattern):            channel_list.append(channel)    # 向客户端返回频道列表    return channel_list</code></pre><p><img src="/attachment/5cb3e19068600d52f278dab2f76695bf.png"></p><h3 id="PUBSUB-NUMSUB"><a href="#PUBSUB-NUMSUB" class="headerlink" title="PUBSUB NUMSUB"></a>PUBSUB NUMSUB</h3><p><code>PUBSUB NUMSUB[channel-1 channel-2...channel-n]</code>子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。</p><p>这个子命令是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的（订阅者链表的长度就是频道订阅者的数量），这个过程可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def pubsub_numsub(*all_input_channels):    # 遍历输入的所有频道    for channel in all_input_channels:        # 如果pubsub_channels 字典中没有channel 这个键        # 那么说明channel 频道没有任何订阅者        if channel not in server.pubsub_channels:            # 返回频道名            reply_channel_name(channel)            # 订阅者数量为0            reply_subscribe_count(0)        # 如果pubsub_channels 字典中存在channel 键        # 那么说明channel 频道至少有一个订阅者        else:            # 返回频道名            reply_channel_name(channel)            # 订阅者链表的长度就是订阅者数量            reply_subscribe_count(len(server.pubsub_channels[channel]))</code></pre><p><img src="/attachment/6be7a421f800f74c88c293bee6d604e6.png"></p><h3 id="PUBSUB-NUMPAT"><a href="#PUBSUB-NUMPAT" class="headerlink" title="PUBSUB NUMPAT"></a>PUBSUB NUMPAT</h3><p>PUBSUB NUMPAT子命令用于返回服务器当前被订阅模式的数量。这个子命令是通过返回pubsub_patterns链表的长度来实现的，因为这个链表的长度就是服务器被订阅模式的数量，这个过程可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def pubsub_numpat():    # pubsub_patterns 链表的长度就是被订阅模式的数量    reply_pattern_count(len(server.pubsub_patterns))</code></pre><p><img src="/attachment/71436e54ca721c4b9faa043fbd4c2288.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 监视器</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-jian-shi-qi/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-jian-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-监视器"><a href="#【Redis】-监视器" class="headerlink" title="【Redis】 监视器"></a>【Redis】 监视器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 监视器date: 2023-07-09 13:24tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 监视器</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行 MONITOR 命令，客户端就成为了监视器，<strong>实时接收打印服务器处理的命令</strong>。当客户端发送请求时，服务器除了执行，还会将相关信息发送给所有监视器。</p><p>·客户端可以通过执行MONITOR命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息。<br>·当一个客户端从普通客户端变为监视器时，该客户端的REDIS_MONITOR标识会被打开。<br>·服务器将所有监视器都记录在monitors链表中。<br>·每次处理命令请求时，服务器都会遍历monitors链表，将相关信息发送给监视器。</p><h2 id="成为监视器"><a href="#成为监视器" class="headerlink" title="成为监视器"></a>成为监视器</h2><p>redisServer 中有 monitors 链表，记录所有成为监视器的客户端。如果某个客户端发送 MONITOR 命令，就会打开它的<code>REDIS_MONITOR</code>标志，并插入到链表的<strong>尾部</strong>。</p><h2 id="向监视器发送命令信息"><a href="#向监视器发送命令信息" class="headerlink" title="向监视器发送命令信息"></a>向监视器发送命令信息</h2><p>服务器处理命令前都会调用<code>replicationFeedMonitors</code>函数，将相关信息发送给各个监视器。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 慢查询日志</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-man-cha-xun-ri-zhi/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-man-cha-xun-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-慢查询日志"><a href="#【Redis】-慢查询日志" class="headerlink" title="【Redis】 慢查询日志"></a>【Redis】 慢查询日志</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 慢查询日志date: 2023-07-09 13:23tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 慢查询日志</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求。可通过两个参数配置：</p><ul><li><code>slowlog-log-slower-than</code>：执行时间超过多少微秒的命令会被记录到日志上。</li><li><code>slowlog-max-len</code>：指定服务器最多保存多少条慢查询日志，超过时会删除最久的那条日志。</li></ul><p>可以使用<code>CONSIG SET slowlog-log-slower-than &lt;microsecond&gt;</code>直接<strong>修改配置</strong>，使用<code>SLOWLOG GET</code>来<strong>查询慢查询日志</strong>。</p><ul><li>Redis的慢查询日志功能用于记录执行时间超过指定时长的命令。</li><li>Redis服务器将所有的慢查询日志保存在服务器状态的slowlog链表中，每个链表节点都包含一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志。</li><li>打印和删除慢查询日志可以通过遍历slowlog链表来完成。</li><li>slowlog链表的长度就是服务器所保存慢查询日志的数量。</li><li>新的慢查询日志会被添加到slowlog链表的表头，如果日志的数量超过slowlog-max-len选项的值，那么多出来的日志会被删除。</li></ul><h2 id="慢查询记录的保存"><a href="#慢查询记录的保存" class="headerlink" title="慢查询记录的保存"></a>慢查询记录的保存</h2><p>相关慢查询日志的属性记录在 redisServer 中：</p><pre><code class="line-numbers language-c">struct redisServer {​    //下一条慢查询日志的ID，初始为0，每产生一条就加1    long long slowlog_entry_id;    //保存了所有慢查询日志的链表    list *slow1og;    //服务器配置slowlog-log-slower-than选项的值    long 1ong slowlog_1og_slower_than;    //服务器配置slowlog-max-len选项的值    unsigned long slowlog_max_len;    // ...};</code></pre><p>slowlog 是一个链表，有几个节点就表示有几条慢查询日志，节点是一个 slowlogEntry 实例：</p><pre><code class="line-numbers language-c">typedef struct slow1ogEntry {    //唯一标识符    long 1ong id;    //命令执行时的时间，格式为UNIX时间戥    time_t time;    //执行命令消耗的时间，以微秒为单位    1ong long duration;    //命令与命令参数    robj **argv;    //命令与命令参数的数量    int argc;} slowlogEntry;​</code></pre><p>新添加的日志会呗放到 slowlog 的表头。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 事务</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-shi-wu/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-事务"><a href="#【Redis】-事务" class="headerlink" title="【Redis】 事务"></a>【Redis】 事务</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 事务date: 2023-07-09 13:04tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 事务</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 通过<code>MULTI</code>，<code>EXEC</code>，<code>WATCH</code>等命令实现事务功能。事务是将<strong>多个命令打包</strong>，然后<strong>原子地按顺序地执行</strong>的机制，执行期间服务器<strong>不会中断事务</strong>执行其他客户端的命令请求。下面展示了一次完整事务的执行命令：</p><pre><code class="line-numbers language-shell">redis&gt; MULTIOKredis&gt; SET "name" "The Design and Implementation of Redis"QUEUEDredis&gt; GET "name"QUEUEDredis&gt; EXEC1) OK2) "The Design and Implementation of Redis"</code></pre><ul><li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li><li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li><li>事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。</li><li>带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的REDIS_DIRTY_CAS标志打开。</li><li>只有在客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。</li><li>Redis的事务总是具有ACID中的原子性、一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsy nc选项的值为alway s时，事务也具有耐久性。</li></ul><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>可以看出，事务主要有 3 个阶段：事务开始、命令入队、事务执行。</p><h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p>MULTI 命令表示事务的开始，将客户端从非事务状态切换为事务状态，在 flags 属性中<strong>打开<code>REDIS_MULTI</code>标识</strong>。</p><h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><p>当客户端处于事务状态时，命令不会被立即执行（除了 EXEC、DISCARD、WATCH、MULTI），而是加入事务队列。</p><p><img src="/attachment/39bf9be431678093b83ff18845a86dea.png"></p><h3 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h3><p>客户端的事务状态保存在 mstate 里：</p><pre><code class="line-numbers language-c">typedef struct redisCLient{    //事务状态    multiState mstate;    ...} redisClient;</code></pre><p>事务状态包括<strong>事务队列</strong>和<strong>入队命令计数器</strong>：</p><pre><code class="line-numbers language-c">typedef struct multiState{    //数组，事务队列    multiCmd *commands;    //入队命令计数器    int count;} multiState;</code></pre><p>事务队列的实例结构：</p><pre><code class="line-numbers language-c">typedef struct multiCmd {    //参数    robj **argv;    //参数数量    int argc;    //命令指针    struct redisCommand *cmd;} multiCmd;</code></pre><p>先入队的命令先放入数组，后入队的后放入。</p><p><img src="/attachment/de5fc77137b727a07b95fad0788d938d.png"></p><h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><p>当收到客户端的 EXEC 命令时，将被立即执行，然后服务器遍历客户端的事务队列，保存命令，执行命令给，返回结果给客户端，移除事务标识。</p><h2 id="WATCH-命令的实现"><a href="#WATCH-命令的实现" class="headerlink" title="WATCH 命令的实现"></a>WATCH 命令的实现</h2><p>WATCH 命令是一个<strong>乐观锁</strong>，可以在 EXEC 前<strong>监视任意数量的键</strong>，如果在 EXEC 执行时，键被修改过，服务器将拒绝执行事务。</p><h3 id="使用-WATCH-命令监视数据库键"><a href="#使用-WATCH-命令监视数据库键" class="headerlink" title="使用 WATCH 命令监视数据库键"></a>使用 WATCH 命令监视数据库键</h3><p>每个 Redis 数据库都保存着 watched_keys 字典，键是某个被 WATCHED 命令<strong>监视的键</strong>，值是一个链表，记录所有监视<strong>该键的客户端</strong>。</p><pre><code class="line-numbers language-c">typedef struct redisDb{    //正在被WATCHED命令监视的键    dict *watched_keys;    ...} redisDb；</code></pre><h3 id="监控机制的触发-amp-事务安全"><a href="#监控机制的触发-amp-事务安全" class="headerlink" title="监控机制的触发 &amp; 事务安全"></a>监控机制的触发 &amp; 事务安全</h3><p>在执行数据库修改命令时，都会调用<code>multi.c/touchWatchKey</code>函数对 watched_keys 字典进行检查，查看是否有客户端正在监视刚被命令修改过的键，如果有，将 watched_keys 该键对应的值，也就是监听的客户端都打开<code>REDIS_DIRTY_CAS</code>标识，表示事务的<strong>安全性已经被破坏</strong>。此时，服务器拒绝执行事务。</p><p><img src="/attachment/ce5b85e25e5c8c9c8b192f0adcc9e2b0.png"></p><h2 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h2><p>Redis 的事务有原子性、一致性和隔离性，当 Redis 运行在特定的持久化模式下时，才具有持久性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>Redis 事务队列中的命令，要么全部都执行，要么一个都不执行，因此，具有原子性。Redis 进行事务命令入队时，如果命令<strong>入队出错</strong>，会被<strong>拒绝执行</strong>。但是命令的<strong>语法错误</strong>（<strong>执行错误</strong>），不会导致整个命令不被执行，也就是说 <strong>Redis 不支持事务的回滚机制</strong>。</p><p>下面例子表示发生<strong>入队错误</strong>（一致性时将提到入队错误和执行错误）时，事务中的所有命令都不会被执行：</p><pre><code class="line-numbers language-shell">redis&gt; MULTIOKredis&gt; SET msg "he1lo"QUEUEDredis&gt; GET(error) ERR wrong number of arguments for 'get' commandredis&gt; GET msgQUEUED redis&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors.</code></pre><p>发生执行错误，不影响其他命令的执行：</p><pre><code class="line-numbers language-shell">redis&gt; SET msg "hello" # msg键是一个字符串OKredis&gt; MULTIOKredis&gt; SADD fruit "apple" "banana" "cherry"QUEUEDredis&gt; RPUSH msg "good bye" "bye bye" #错误地对字符串键msg执行列表键的命令QUEUEDredis&gt; SADD alphabet "a" "b" "c"QUEUEDredis&gt; EXEC 1) (integer) 32)(error) WRONGTYPE Operation against a key holding the wrong kind of value3)(integer) 3</code></pre><p>不支持事务回滚是考虑到了复杂性，与其<strong>简单高效的理念不符</strong>，并且 Redis 的设计者认为，Redis 事务的执行时错误通常都是<strong>编程错误</strong>产生的，在开发环境中会有，但生产环境不应该出现，因此，没有设计回滚机制。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性表示在事务的执行前后，成功与否，数据库<strong>都是一致的</strong>，也就是数据符合数据库本身定义和要求，<strong>没有非法或无效错误数据</strong>。</p><p>Redis 通过简单的错误检测来保证一致性。</p><ol><li>入队错误</li></ol><p>在 2.6.5 之后的版本，如果一个事务在入队时出现了命令不存在，Redis 则拒绝执行这个事务。</p><ol start="2"><li>执行错误</li></ol><p>对于命令执行期间发现的错误，<strong>不会影响其他命令</strong>的执行。服务器会识别出错的命令，并进行相应处理，这些命令不会对数据库做修改，不影响一致性。</p><ol start="3"><li>服务器停机</li></ol><p>如果 Redis 在执行过程中停机，数据也是一致的。如果没有开启持久化，重启后数据库是空白的。开启持久化后，重启后会还原到一致状态。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>Redis 是单线程的，并且服务器保证在执行事务期间<strong>不会对事务进行中断</strong>，因此是具有隔离性的。并且队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，因此<strong>没有隔离级别概念</strong>。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>持久性的意思是，事务执行的结果被<strong>永久性地保存</strong>，执行事务的结果不会丢失。因为 Redis 没有单独为事务队列提供持久化功能，所以<strong>取决于持久化模式</strong>，只有 AOF 方式持久化并且 appendsync 的值为 always，而且没有打开<code>no-appendfsync-on-rewrite</code>时，才具有持久性。因为其他方式并不能保证事务的执行结果被第一时间保存到硬盘里。</p><p>注：<code>no-appendfsync-on-rewrite</code>打开后，在执行<code>BGSAVE</code>和<code>BGREWRITEAOF</code>时会暂停对 AOF 文件的同步。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 重点功能</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-chong-dian-gong-neng/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-chong-dian-gong-neng/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-重点功能"><a href="#【Redis】-重点功能" class="headerlink" title="【Redis】 重点功能"></a>【Redis】 重点功能</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 重点功能date: 2023-07-09 13:03tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 重点功能</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>发布和订阅</li></ul><ul><li>事务（事务的实现，WATCH 命令的实现，ACID）</li><li>慢查询日志</li><li>监视器</li></ul><h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><p>undefined</p><p>undefined</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>undefined</p><p>undefined</p><h2 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h2><p>undefined</p><p>undefined</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>undefined</p><p>undefined</p><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>undefined</p><p>undefined</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 cluster 集群</title>
      <link href="/database/redis/redis-duo-ji-ku-de-shi-xian/redis-cluster-ji-qun/"/>
      <url>/database/redis/redis-duo-ji-ku-de-shi-xian/redis-cluster-ji-qun/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-cluster-集群"><a href="#【Redis】-cluster-集群" class="headerlink" title="【Redis】 cluster 集群"></a>【Redis】 cluster 集群</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 cluster 集群date: 2023-07-09 08:47tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 cluster 集群</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>集群是 Redis 提供的<strong>分布式数据库</strong>方案，通过<strong>分片</strong>来进行数据共享并提供复制和故障转移的功能。主要对集群的节点，槽指派，命令执行，重新分片，转向，故障转移，消息进行介绍。</p><ul><li>节点通过<strong>握手</strong>来将其他节点添加到自己所处的集群当中。</li><li>集群中的16384个<strong>槽</strong>可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点。</li><li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个<strong>MOVED错误</strong>，MOVED错误携带的信息可以<strong>指引客户端转向至正在负责相关槽的节点</strong>。</li><li>对Redis集群的重新分片工作是由<strong>redis-trib</strong>负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。</li><li>如果节点A正在<strong>迁移</strong>槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个<strong>ASK错误</strong>，指引客户端到节点B继续查找指定的数据库键。</li><li>MOVED错误表示槽的负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种<strong>临时措施</strong>。</li><li>集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</li><li>集群中的节点通过<strong>发送和接收消息</strong>来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL五种。</li></ul><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>集群由多个节点组成，通过<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>可以将节点连接起来。这个命令主要是将目标节点加入到当前 Redis 所在的集群中。下面从启动节点，集群相关数据结构，命令实现来介绍节点内容。</p><h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>Redis 服务器在启动时会根据 cluster-enable 配置是否为 yes 来决定是否开启集群模式。集群中的节点除了使用 redisServer 之外，还用<code>cluster.h/clusterNode</code>结构、<code>cluster.h/clusterLink</code>结构、<code>cluster.h/clusterState</code>结构来保存集群数据。</p><h3 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h3><p>集群的每个节点都会用 clusterNode 来保存：</p><pre><code class="line-numbers language-c">struct clusterNode {    //创建节点的时间    mstime_t ctime; .    //节点的名字，由40个十六进制字符组成    char name [REDIS_CLUSTER_NAMELEN] ;     //节点标识    //使用各种不同的标识值记录节点的角色(比如主节点或者从节点),    //以及节点目前所处的状态(比如在线或者下线)。    int flags;    //节点当前的配置纪元，用于实现故障转移    uint64_t configEpoch;    //节点的IP地址    char ip[REDIS_IP_STR_LEN] ;    //节点的端口号    int port;    //保存连接节点所需的有关信息    clusterLink *link;    ...};​</code></pre><p>link 属性保存了连接节点所需的有关信息：</p><pre><code class="line-numbers language-c">typedef struct clusterLink {    //连接的创建时间    mstime_t ctime ;    // TCP 套接字描述符    int fd;    //输出缓冲区，保存着等待发送给其他节点的消息( message )。    sds sndbuf;    //输入缓冲区，保存着从其他节点接收到的消息。    sds rcvbuf ;    //与这个连接相关联的节点，如果没有的话就为NULL    struct clusterNode node;} clusterLink;​</code></pre><p>每个节点都保存一个集群状态，记录在当前节点下：</p><pre><code class="line-numbers language-c">typedef struct clusterState {    //指向当前节点的指针    clusterNode *myself;    //集群当前的配置纪元，用于实现故障转移    uint64_t currentEpoch;    //集群当前的状态:是在线还是下线    int state;    //集群中至少处理着一个槽的节点的数量（下一节谈）    int size;    //集群节点名单(包括myself节点)    //键为节点名字，值为节点对应的clusterNode结构    dict *nodes;    ...} clusterState;​</code></pre><h3 id="CLUSTER-MEET-命令的实现"><a href="#CLUSTER-MEET-命令的实现" class="headerlink" title="CLUSTER MEET 命令的实现"></a>CLUSTER MEET 命令的实现</h3><p>通过向节点发送<code>CLUSTER MEET</code>命令，让目标节点加入集群，进行<strong>握手</strong>，执行过程如下：</p><ol><li>客户端发送该命令给节点 A，节点 A 会创建一个节点 B 的 clusterNode 结构，添加到 clusterState.nodes 中。</li><li>解析 IP 地址和端口号，向节点 B 发送 MEET 消息（最后一节会讲消息）。</li><li>同理，节点 B 收到后，会为 A 创建 clusterNode 结构并添加到 nodes。</li><li>节点 B 向 A 发送 PONG 消息。</li><li>节点 A 收到后向 B 发送一条 PING 消息。</li><li>节点 B 收到后直到 A 成功感知到 B，握手完成。</li></ol><p><img src="/attachment/964114e62dce24f3b70e4fb3e369a359.png"></p><p>之后，节点 A 将节点 B 的信息通过 <strong>Gossip 协议</strong>（最后一节消息中将提到）传播给集群中的其他节点。</p><h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p>Redis 通过分片方式保存键值对，集群的整个数据库被分为 <strong>16384</strong> 个槽（slot），数据库的每个键都属于某一个槽，每个节点可处理 0~16384 个槽。当集群中的<strong>每个槽都归某个节点</strong>管理，集群处于上线状态；但凡有一个没人管，集群处于下线状态。</p><p>发送<code>CLUSTER ADDSLOTS &lt;slot&gt; [slot...]</code>命令，可以将槽委派给某个节点负责。下面介绍槽的实现。</p><h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><p>clusterNode 有 slots 和 numslot 属性记录了节点负责处理的槽：</p><pre><code class="line-numbers language-c">struct clusterNode{    //二进制位数组，长度为16384/8=2048字节，    //每个索引8位，根据0和1判断槽是否被该节点负责    unsigned char slot[16384/8];    //负责处理的槽数量    int numslots;    ...}</code></pre><p>比如该节点负责 0~7 的槽，存储结构如下：</p><p><img src="/attachment/76a61c3456d2a35058db14623fa4f679.png"></p><p>通过这种设计，检查某节点<strong>是否负责处理某个槽</strong>或者<strong>让节点负责</strong>某个槽的操作的时间复杂度都为 **O(1)**。</p><h3 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h3><p>节点除了将自己负责的槽记录在<code>clusterNode.slots</code>中，还会将这个数组通过<strong>消息发送</strong>给其他节点，让他们都知道自己负责什么槽。其他节点接收消息后，会对<code>clusterStaste.nodes</code>字典中对应的<code>clusterNode.slots</code>数据进行更新。</p><h3 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h3><p>clusterState 会维护集群中每个节点管理槽的情况：</p><pre><code class="line-numbers language-c">typedef struct slusterState{    clusterNode *slots[16384];    ...}</code></pre><p>如果 slot[i] 指向空，说明该槽<strong>没有被节点管理</strong>；如果指向具体某个 clusterNode 的指针，说明由这个节点管理。</p><p>总结一下，<code>clusterState.slots</code>数组记录<strong>集群中所有槽的信息</strong>；<code>clusterNode.slots</code>数组记录当前节点<strong>负责槽的信息</strong>。前者方便知道某个槽指派给谁，后者方便知道某个槽是否指派给自己，或者发送自己槽的指派信息。（因为被指派后，还需要向其他节点发送消息告知）。</p><p><strong>CLUSTER ADDSLOTS 命令的实现</strong></p><p>这个命令的执行其实就是把上面讲的几小节知识给串起来。主要是用来指派槽给节点负责的，接收该命令后，首先会遍历所有传入的槽（命令入参）是否都是未指派，如果<strong>有一个被指派了就报错</strong>。如果都未指派，将这些槽委派给当前节点，更新<code>clusterState.slots</code>数组指向当前节点的 clusterNode；然后将<code>clusterNode.slots</code>数组中对应的索引<strong>二进制位设置为 1</strong>。最后，<strong>发送消息</strong>告诉集群中其他节点，自己负责这些槽。</p><h2 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h2><p>当客户端对节点发送与数据库键有关的命令时，接收命令的节点会计算属于哪个槽，检查这个槽是否指派给自己（根据 key 的 <strong>CRC-16 校验和 &amp; 16383</strong> 来确定槽号 i，再根据 clusterState.slots[i] 是否指向当前节点的 clusterNode 判断是否自己负责的）。如果不是指派给自己的，就（找负责该槽的 ip 和端口，指引客户端转向它）向客户端<strong>返回 MOVED 错误</strong>，引导客户端指向正确的节点并再次发送命令。</p><p>注：通过<code>CLUSTER KEYSLOT &lt;key&gt;</code>可查看某个 key 对应的槽号。</p><h3 id="MOVED-错误"><a href="#MOVED-错误" class="headerlink" title="MOVED 错误"></a>MOVED 错误</h3><p>MOVED 错误格式为：<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></p><p>在集群模式下，会被隐藏，客户端会进行自动转向并重发命令。节点的转向其实就是<strong>换对应套接字</strong>来发送命令。下面演示了对 7000 端口的节点操作键命令并被引导转向到真正存储该键的服务器（7001 端口）的过程：</p><pre><code class="line-numbers language-shell">127.0.0.1: 7000&gt; SET msg "hello"-&gt; Redirected to slot [6257] located at 127.0.0.1: 7001OK127.0.0.1:7001&gt; GET msg"hello"</code></pre><h3 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h3><p>节点对数据的存储和单机 Redis 的实现是一样的，只不过节点只能使用 0 号库。还需要维护一个<code>slots_to_keys</code>跳跃表关联槽号和键。<strong>分数是槽号，节点就是键</strong>。当节点往数据库添加新键时，节点就会在<code>slots_to_keys</code>中进行<strong>关联</strong>，反之则删除关联。</p><pre><code class="line-numbers language-c">typedef struct clusterState{    zskiplist *slots_to_keys;    ...} clusterState;</code></pre><h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>Redis 集群的重新分片操作可以将任意数量已经指派给某个节点 (源节点) 的槽改为指派给另一个节点(目标节点)，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><p>重新分片通过集群管理软件 redis-trib 执行，步骤如下：</p><ol><li>redis-trib 对目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让<strong>目标节点准备</strong>好，要导入键值对了。</li><li>redis-trib 对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让<strong>源节点准备好</strong>，要转移键值对了。</li><li>redis-trib 向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令， 获得最多 count 个属于槽 slot 的键值对的键名 (key name)，这实际上就是个<strong>批量分片</strong>的意思。</li><li>对于步骤 3 获得的每个键名，redis-trib 都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_ port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>命令，将被选中的键<strong>原子地</strong>从源节点迁移至目标节点。</li><li>重复执行步骤 3 和步骤 4，直到源节点保存的所有属于槽 slot 的键值对都被迁移至目标节点。</li><li>redis-trib 向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_ id&gt;</code>命令，将槽 slot 指派给目标节点，通过<strong>消息发送至整个集群</strong>，让所有节点感知。</li></ol><p>整体迁移的流程图：</p><p><img src="/attachment/1d1652e50cf5d0c46406121dade61a9c.png"></p><h2 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h2><p>当客户端向源节点发送与数据库键相关的命令，并且该键恰好属于<strong>被迁移的槽</strong>时，源节点会先查自己有没有，有就返回；<strong>没有则返回 ASK 错误</strong>，指引客户端向正在导入槽的目标节点发送命令。这个命令和 MOVED 类似，不会直接打印错误。比如端口 7000 是源节点，”love” 键的槽（16198 槽）正在被迁移到 7001 就会这样：</p><pre><code class="line-numbers language-shell">127.0.0.1: 7000&gt; GET "love"-&gt; Redirected to slot [16198] located at 127.0.0.1: 7001"you get the key 'love'"127.0.0.1: 7001&gt;</code></pre><h3 id="CLUSTER-SETSLOT-IMPORTING-的实现"><a href="#CLUSTER-SETSLOT-IMPORTING-的实现" class="headerlink" title="CLUSTER SETSLOT IMPORTING 的实现"></a>CLUSTER SETSLOT IMPORTING 的实现</h3><p>clusterState.importing_slots_from 数组记录当前节点正在从其他节点导入的槽：</p><pre><code class="line-numbers language-c">typedef struct clusterState{    clusterNode *importing_slots_from[16384];    ...}</code></pre><p>一般情况下指向空，当执行<code>CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</code>时，会将目标节点（当前节点）<code>clusterState.importing_slots_from[i]</code>设置为 source_id 所代表节点的 clusterNode。</p><h3 id="CLUSTER-SETSLOT-MIGRATING-的实现"><a href="#CLUSTER-SETSLOT-MIGRATING-的实现" class="headerlink" title="CLUSTER SETSLOT MIGRATING 的实现"></a>CLUSTER SETSLOT MIGRATING 的实现</h3><p>clusterState 结构的 migrating_slot_to 数组记录了当前节点正在迁移至其他节点的槽：</p><pre><code class="line-numbers language-c">typedef struct clusterState{    clusterNode *migrating_slots_to[16384];}</code></pre><p>一般情况下指向空，当执行<code>CLUSTER SERSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</code>时，会将源节点<code>clusterState.migrating_slots_to[i]</code>设置为 target_id 所代表节点的 clusterNode。</p><h3 id="ASK-错误-1"><a href="#ASK-错误-1" class="headerlink" title="ASK 错误"></a>ASK 错误</h3><p>如果收到 key 命令请求的节点所属 key 的槽正好指派给了该节点，找到则返回，如果没找到则检查<code>clusterState.migrating_slots_to[i]</code>，是否正在迁移，如果<strong>正在迁移</strong>，就向客户端返回 ASK 错误，引导其去<strong>导入槽的节点查询</strong>。</p><p>客户端接收到 ASK 错误后，根据 IP 和端口，转向目标节点，然后先向目标节点发送 <strong>ASKING</strong> 命令，再重新发送要执行的命令。</p><h3 id="ASKING-命令"><a href="#ASKING-命令" class="headerlink" title="ASKING 命令"></a>ASKING 命令</h3><p>这个命令的唯一作用就是打开发送该命令客户端的<code>REDIS_ASKING</code>标识。有了这个标识后，节点会<strong>为正在导入的键执行命令</strong>。这个标识是<strong>一次性</strong>的，如果再对刚才的 key 执行相关操作，该节点会返回 MOVED 错误（因为重分片未结束，它不是负责该槽的节点）。下面表示相关判断过程：</p><p><img src="/attachment/b44b0b2f8d1bee902716655139845398.png"></p><p><strong>ASK 错误与 MOVED 错误的区别</strong></p><p>这两个错误都会客户端转向：</p><ul><li>MOVED 错误代表槽的负责权<strong>已经从一个节点到了另一个节点</strong>。</li><li>ASK 错误只是两个节点再迁移槽过程中使用的<strong>临时措施</strong>。</li></ul><h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p>Redis 集群中的节点分主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点（相当于备份，不处理读请求），并在被复制节点下线时，代替下线主节点继续处理命令请求。</p><p>接下来介绍节点的复制方法，检测节点是否下线方法及对下线节点故障转移方法。</p><h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>向节点发送命令<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为指定节点的从节点并对主节点开始复制。主要过程是：</p><ol><li>接收命令节点在<code>lusterState.node</code>字典中找到 node_id 对应节点的 clusterNode，然后将<code>clusterState.myself.slaveof</code>指向这个节点。</li><li>修改<code>clusterState.myself.flags</code>属性，关闭<code>REDIS_NODE_MASTER</code>标识，<strong>打开<code>REDIS_NODE_SLAVE</code>标识</strong>，标识该节点成为从节点。</li><li>调用复制代码，对主节点复制。</li></ol><p>当节点成为从节点并开始复制时，这个信息会通过消息发送给集群中其他节点。</p><h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中每个节点都会定期向其他节点发送 PING 消息，如果没有在规定时间返回 PONG 消息，就会被标记位<strong>疑似下线</strong>。集群中各个节点会互相发送消息来交换各个节点的状态，当一个主节点 A 通过消息得知主节点 B 认为主节点 C 进入疑似下线状态，A 会将 B 的<strong>下线报告添加</strong>到<code>clusterNode.fail_reports</code>链表中。</p><p>链表中每个元素都由 clusterNodeFailReport 组成：</p><pre><code class="line-numbers language-c">struct clusterNodeFailReport{    //报告目标节点已经下线的节点    struct clusterNode *node;    //最后一次从node节点收到下线报告的时间    //程序使用这个时间戳来检查下线报告是否过期    // (与当前时间相差太久的下线报告会被删除)    mstime_t time;} typedef clusterNodeFailReport;</code></pre><p>在一个集群中，<strong>半数以上</strong>负责处理槽的主节点将某个主节点报告为疑似下线后，这个主节点将被<strong>标记为已下线</strong>。并向集群广播一条关于该主节点 FAIL 的消息，所有收到消息的节点都会将其标记为已下线。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>当一个从发现主节点下线后，开始故障转移。具体步骤：</p><ol><li>下线的主节点的所有从节点里面，会有一个从节点被选中。</li><li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点。</li><li>新的主节点会撤销并指派给自己对已下线主节点的槽指派。</li><li>新的主节点向集群广播一条 PONG 消息，让其他节点立即知道新的主节点。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ol><h3 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h3><p>集群选举新主节点的具体过程：</p><ol><li>通过集群的配置纪元确定是哪一次选举，它是一个<strong>自增计数器</strong>，初始值为 0。</li><li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被加一。</li><li>集群里每个负责处理槽的主节点都有<strong>一次投票的机会</strong>，第一个向主节点要求投票的从节点将获得主节点的投票。</li><li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群<strong>广播</strong>一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，要求所有收到这条消息并且具有投票权的主节点向这个从节点投票。</li><li>如果一个主节点具有投票权 (它正在负责处理槽)，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，表示这个主节点支持从节点成为新的主节点。</li><li>每个参与选举的从节点都会接收<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，并根据自己<strong>收到消息的条数</strong>来统计自己获得多少主节点的支持。</li><li>如果集群里有 N 个具有投票权的主节点，那么当一个从节点收集到大于等于 <strong>N/2+1</strong> 支持票时，这个从节点就会当选为新的主节点。</li><li>配置纪元确定每个具有投票权的主节点只能投一次，所以如果有 N 个主节点进行投票，那么具有大于等于 N/2+1 张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li><li>如果在一个配置纪元里没有从节点得到足够的票，那么集群进入一个新的配置纪元，并<strong>再次进行选举</strong>，直到选出新的主节点为止。</li></ol><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>集群中节点主要通过发送消息来传递信息，主要有 5 种：</p><ul><li>MEET 消息：发送者接收到客户端的 MEET 消息时，发送者向接收者发送 MEET 消息，<strong>请求加入</strong>发送者所在集群。</li><li>PING 消息：集群每个节点每隔一秒从已知节点<strong>随机选出 5 个</strong>节点，然后对<strong>最长时间没发</strong> PING 消息的节点进行发送。除此之外，还会将最后一次收到 PONG 消息的节点中，如果时间<strong>超过</strong>配置的<code>cluster-node-timeout</code>选项的<strong>一半</strong>时，也会发送 PING 消息。</li><li>PONG 消息：应答 MEET 或 PING 消息。还可以通过 PONG，告诉其他节点，刷新该节点的相关信息。</li><li>FAIL 消息：当某个主节点判断另一个主节点<strong>已经进入 FAIL 状态</strong>时，当前主节点会向集群<strong>广播</strong>一条关于已下线节点的 FAIL 消息。</li><li>PUBLISH 消息：当节点接收到 PUBLISH 命令时，执行这个命令，并向集群<strong>广播</strong>一条 PUBLISH 消息，所有接收到这条 PUBLISH 消息的节点都会执行相同的 PUBLISH 命令。</li></ul><p>一条消息由消息头和消息正文组成。</p><h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>记录信息发送者的一些信息。比如发送者的当前纪元，发送者名字，发送者的槽指派信息等。接收者可根据发送者的信息来更新发送者的状态。消息头是一个<code>cluster.h/clusterMsg</code>:</p><pre><code class="line-numbers language-c">typedef struct{    //消息的长度(包括这个消息头的长度和消息正文的长度)    uint32_ t totlen;    //消息的类型    uint16_ t type;    //消息正文包含的节点信息数量    //只在发送MEET. PING、PONG这三种Gossip协议消息时使用    uint16_ t count;    //发送者所处的配置纪元    uint64_ t currentEpoch;    //如果发送者是一个主节点，那么这里记录的是发送者的配置纪元    //如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元.    uint64_ t configEpoch;    //发送者的名字(ID)    char sender [REDIS_ CLUSTER_ NAMELEN] ;    //发送者目前的槽指派信息    unsigned char myslots [REDIS_ CLUSTER_ SLOTS/8];    //如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字    //如果发送者是一个主节点，那么这里记录的是REDIS_ NODE NULL NAME    // (一个40字节长，值全为0的字节数组)    char slaveof [REDIS_ CLUSTER_ NAMELEN] ;    //发送者的端口号    uint16_ t port;    //发送者的标识值    uint16_ t flags;    //发送者所处集群的状态    unsigned char state;    //消息的正文(或者说，内容)    union clusterMsgData data;} clusterMsg;</code></pre><p>其中消息正文是一个<code>cluster.h/clusterMsgData</code>结构：</p><pre><code class="line-numbers language-c">union clusterMsgData{    // MEET、 PING、PONG消息的正文    struct{        //每条MEET、PING、pONG消息都包含两个        //clusterMsgDataGossip结构        clusterMsgDataGossip[1];    } ping;        // FAIL消息的正文    struct {    clusterMsgDatafail about;    }fail;​    //PUBLISH消息的正文    struct{        clusterMsgDataPublish msg;    }publish;        //其他消息的正文...};​</code></pre><h3 id="MEET、PING、PONG-消息的实现"><a href="#MEET、PING、PONG-消息的实现" class="headerlink" title="MEET、PING、PONG 消息的实现"></a>MEET、PING、PONG 消息的实现</h3><p>集群中的各个节点通过 <strong>Gossip 协议</strong>来交换各自关于不同节点的状态信息，Gossip 协议由 MEET、PING、PONG 这三种消息实现，他们的的正文就是上面的 ping 结构体。</p><p>因为共用消息正文，所以需要消息头的 type 属性来区分。每次发送这类消息时，发送者都从已知节点中<strong>随机选择两个节点</strong>保存到 clusterMsgDataGossip，因此正文包含两个 clusterMsgDataGossip 结构：</p><pre><code class="line-numbers language-c">typedef struct (    //节点的名字    char nodename [REDIS_CLUSTER_NAMELEN]; .    //最后一次向该节点发送PING消息的时间戳    uint32_ t ping_sent;    //最后一次从该节点接收PONG消息的时间戳    uint32_t pong_received;    //节点的IP地址    char ip[16];    //节点的墙口号    uint16_t port;    //节点的标识值    uint16_t flags;}clusterMsgDataGossip;​</code></pre><p>消息接收者会根据 clusterMsgDataGossip 包含的节点，看是否为第一次接触，如果是的话，需要进行一次握手，记录节点信息；如果已经存在于已知节点中，则对相关节点信息更新。</p><h3 id="FAIL-消息的实现"><a href="#FAIL-消息的实现" class="headerlink" title="FAIL 消息的实现"></a>FAIL 消息的实现</h3><p>在集群节点较多的情况下，单纯使用 Gossip 会带来一些<strong>延迟</strong>，FAIL 消息需要所有节点立刻知道某个主节点下线了，从而尽快判断<strong>是否需要标记为下线或故障转移</strong>。消息正文是一个<code>cluster.h/clusterMsgDatafail</code>结构：</p><pre><code class="line-numbers language-c">typedef struct{    //记录下线节点的名字    char nodename[REDIS_CLUSTER_NAMELEN]}clusterMsgDataFail;</code></pre><p>因为名字都是集群内唯一的，所以可以这么保存。</p><h3 id="PUBLISH-消息的实现"><a href="#PUBLISH-消息的实现" class="headerlink" title="PUBLISH 消息的实现"></a>PUBLISH 消息的实现</h3><p>当集群的某个节点发送<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>时，会引发集群中所有节点都向 channel 发送消息。消息正文是一个<code>cluster.h/clusterMsgDataPublish</code>结构：</p><pre><code class="line-numbers language-c">typedef struct {    uint32_ t channel_len;    uint32_ t message_len;    //定义为8字节只是为了对齐其他消息结构    //实际的长度由保存的内容决定    unsigned char bulk_data[8] ;} clusterMsgDataPublish;​</code></pre><p>bulk_data 保存消息的 channel 和 message 参数。具体是根据对应参数长度识别的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 Sentinel 机制</title>
      <link href="/database/redis/redis-duo-ji-ku-de-shi-xian/redis-sentinel-ji-zhi/"/>
      <url>/database/redis/redis-duo-ji-ku-de-shi-xian/redis-sentinel-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-Sentinel-机制"><a href="#【Redis】-Sentinel-机制" class="headerlink" title="【Redis】 Sentinel 机制"></a>【Redis】 Sentinel 机制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 Sentinel 机制date: 2023-07-09 08:46tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 Sentinel 机制</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Sentinel（哨兵）是 Redis 的<strong>高可用性</strong>的解决方案，由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器以及属下的所有从服务器。当主服务器下线时，自动将下线的某个主服务器属下的某个从服务器<strong>升级</strong>为新的主服务器。从而实现<strong>故障转移</strong>，当原来的主服务器重新上线时，会被降级为从服务器。</p><p>下面展示了哨兵监视主从的状态：</p><p><img src="/attachment/d01e4544a8084f967936e061d0b2823d.png"></p><ul><li>Sentinel只是一个运行在<strong>特殊模式下的Redis服务器</strong>，它使用了和普通模式不同的命令表，所以Sentinel模式能够使用的命令和普通Redis服务器能够使用的命令不同。</li><li>Sentinel会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的<strong>命令连接</strong>和<strong>订阅连接</strong>，其中命令连接用于向主服务器<strong>发送命令请求</strong>，而订阅连接则用于<strong>接收指定频道的消息</strong>。</li><li>Sentinel通过向主服务器发送<strong>INFO命令</strong>来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。</li><li>在一般情况下，Sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送<strong>INFO命令</strong>，当主服务器处于下线状态，或者Sentinel正在对主服务器进行<strong>故障转移</strong>操作时，Sentinel向从服务器发送INFO命令的频率会改为每秒一次。</li><li>对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的__sentinel__:hello频道发送消息来向其他Sentinel宣告自己的存在。</li><li>每个Sentinel也会从__sentinel__:hello频道中接收其他Sentinel发来的信息，并根据这些信息为其他Sentinel创建相应的实例结构，以及命令连接。</li><li>Sentinel只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel与Sentinel之间则<strong>只创建命令连接</strong>。</li><li>Sentinel以每秒一次的频率向实例（包括主服务器、从服务器、其他Sentinel）发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向Sentinel发送无效回复时，Sentinel会将这个实例判断为主观下线。</li><li>当Sentinel将一个主服务器判断为<strong>主观下线</strong>时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意这个主服务器已经进入主观下线状态。</li><li>当Sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为<strong>客观下线</strong>，并发起一次针对主服务器的<strong>故障转移</strong>操作。</li></ul><p>下面主要讲解 Sentinel 系统对主服务器执行故障转移的整个过程。</p><h2 id="启动并初始化-Sentinel"><a href="#启动并初始化-Sentinel" class="headerlink" title="启动并初始化 Sentinel"></a>启动并初始化 Sentinel</h2><p>启动 Sentinel 有两种方式：</p><ul><li><code>redis-sentinel /path/to/your/sentinel.conf</code></li><li><code>redis-server /path/to/your/sentinel.conf --sentinel</code></li></ul><p>俩命令效果相同，启动时需要执行以下步骤：</p><ol><li>初始化服务器。</li><li>将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码。</li><li>初始化 Sentinel 状态。</li><li>根据配置文件，初始化 Sentinel 的监视主服务器列表。</li><li>创建连向主服务器的网络连接。</li></ol><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>Sentinel 实际上是一个特殊的 Redis 服务器，所以很多地方和 Redis 服务器的初始化有些类似。只不过少了 RDB 或 AOF 文件的载入等操作。</p><h3 id="使用-Sentinel-专用代码"><a href="#使用-Sentinel-专用代码" class="headerlink" title="使用 Sentinel 专用代码"></a>使用 Sentinel 专用代码</h3><p>将加载的常量，命令表（决定了 Sentinel 可以执行哪些命令）等替换为 Sentinel 专用的。</p><h3 id="初始化-Sentinel-状态"><a href="#初始化-Sentinel-状态" class="headerlink" title="初始化 Sentinel 状态"></a>初始化 Sentinel 状态</h3><p>初始化一个<code>sentinel.c/sentinelState</code>结构，记录 Sentinel 的状态，保存了服务器中所有与 Sentinel 相关的状态：</p><pre><code class="line-numbers language-c">struct sentinelState{    //当前纪元，选举计数器，用于实现故障转移    uint64_ t current_ epoch;    //（重点）保存了所有被这个sentinel监视的主服务器    //字典的键是主服务器的名字，值是一个指向sentine1RedisInstance结构的指针    dict masters;    //是否进入了TILT模式    int tilt;    //目前正在执行的脚本的数量    int running_ scripts;    //进入TILT模式的时间    mstime_ _t tilt_ start_ time;    //最后一次执行时间处理器的时间    mstime_ t previous_ time ;    //一个FIFO队列，包含了所有需要执行的用户脚本    list *scripts_ queue;}sentinel;</code></pre><h3 id="初始化-master-属性"><a href="#初始化-master-属性" class="headerlink" title="初始化 master 属性"></a>初始化 master 属性</h3><p>master 实例包括主服务器、从服务器或另一个 Sentinel。实例结构如下，了解一下，故障转移的可以先不关注：</p><pre><code class="line-numbers language-c">typedef struct sentinelRedisInstance {    //标识值，记录了实例的类型，以及该实例的当前状态.    int flags;    //实例的名字.    //主服务器的名字由用户在配置文件中设置    //从服务器以及Sentinel 的名字由Sentinel 自动设置    //格式为ip:port    char *name;    //实例的运行ID .    char *runid;    //配置纪元，用于实现故障转移    uint64_t config_epoch;    //实例的地址    sentinelAddr *addr;    // SENTINEL down-after-milliseconds 选项设定的值    //实例无响应多少毫秒之后才会被判断为主观下线    mstime_t down_after_period;    //判断这个实例为客观下线所需的支持投票数量    int quorum;    //在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量    int paral1el_syncs;    //刷新故障迁移状态的最大时限    mstime_t failover_timeout;    // ...} sentinelRedisInstance;​</code></pre><h3 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h3><p>Sentinel 会为监视的主服务器创建两个异步网络连接：</p><ul><li><strong>命令连接</strong>：专用于向主服务器发送命令，接收命令回复。</li><li><strong>订阅连接</strong>：专用于订阅主服务器<code>__sentinel__:hello</code>频道。（由于 Redis 的发布订阅消息不会保存，客户端断线就会丢失，为了不丢失，必须使用专门的频道连接）</li></ul><h2 id="获取主从服务器信息"><a href="#获取主从服务器信息" class="headerlink" title="获取主从服务器信息"></a>获取主从服务器信息</h2><p>Sentinel 默认 1<strong>0 秒一次</strong>通过命令连接被监视的主服务器并发送 <strong>INFO</strong> 命令，获取主服务器信息。主要获取主服务器本身信息（如服务器运行 ID），下属从服务器信息（如 ip，port，offset）。对应属性进行更新，如果没有某个从服务器新信息就会创建一个实例结构，放到主服务器的 slaves 字典中，键为 ip + 端口，值为 sentinelRedisInstance。除了创建新实例，还会创建连接到从服务器的<strong>命令连接</strong>和<strong>订阅连接</strong>。</p><h2 id="向主服务器和从服务器发送消息"><a href="#向主服务器和从服务器发送消息" class="headerlink" title="向主服务器和从服务器发送消息"></a>向主服务器和从服务器发送消息</h2><p>sentinel 默认以两秒一次，向服务器的<code>__sentinel__:hello</code>频道发送消息，命令：</p><p><code>PUBLISH __sentinel__:hello "&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;"</code></p><p>参数包含 sentinel 本身（s__…<em>）和主服务器（m</em>…）的运行 ID，ip，端口号，配置纪元等参数。</p><h2 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h2><p>Sentinel 与一个主服务器或从服务器建立订阅连接后，会发送<code>SUBSCRIBE _sentinel_:hello</code>命令。</p><p>也就是 Sentinel 通过命令连接发送信息到频道，又通过订阅连接接收频道中的信息。一个 Sentinel 发的信息也会被其他 Sentinel 接收，根据信息记录的 Sentinel 运行 id 和接收信息的 Sentinel <strong>运行 id 是否相同</strong>，来决定<strong>是否处理</strong>这条消息。通过这种透明的沟通机制，Sentinel 可以对各自监听的服务器信息进行更新。</p><h3 id="更新-sentinels-字典"><a href="#更新-sentinels-字典" class="headerlink" title="更新 sentinels 字典"></a>更新 sentinels 字典</h3><p>根据接收而来的消息，Sentinel 会更新实例结构中 sentinels 字典保存的所有 Sentinel 实例的信息。键为 Sentinel 的 ip + 端口，值为某个 Sentinel 的实例。消息接收者会检查发送消息的 Sentinel（源 sentinel）结构是否在 sentinels 字典存在则更新，没有则创建实例，和自己相同的 sentinel 不会被放入。</p><pre><code class="line-numbers language-c">typedef struct sentinelRedisInstance{    dict *sentinels;    ...}</code></pre><p>通过这种发布订阅的方式，Sentinel 不需要各自发信息告诉对方，而是监视同一个主服务器的多个 Sentinel 自动发现对方。</p><h3 id="创建连向其他-Sentinel-的命令连接"><a href="#创建连向其他-Sentinel-的命令连接" class="headerlink" title="创建连向其他 Sentinel 的命令连接"></a>创建连向其他 Sentinel 的命令连接</h3><p>sentinel 也会为对方互相创建命令连接，最终监视同一主服务器的多个 sentinel 会形成一个<strong>网络</strong>。但他们互相之间<strong>不会创建订阅连接</strong>，因为他们通过主或从服务器发来的频道来发现未知的 sentinel。</p><p><img src="/attachment/8b0415cc1263e38635f9df6dd08dbb8f.png"></p><h2 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h2><p>Sentinel 默认每秒与创建命令连接的实例（主服务器，从服务器，其他 sentinel）发送 PING 命令，通过回复判断是否在线。如果实例返回除了<code>+PONG</code>，<code>-LOADING</code>，<code>-MASTERRDOWN</code>之外的回复或未及时回复，就认为是<strong>无效回复</strong>。根据配置文件的<code>down-after-milliseconds</code>指定的<strong>主观下线所需时长内</strong>是否一直无效回复，来判断实例是否已经主观下线。下线了就将实例的的 flags 标识属性打开<code>SRI_S_DOWN</code>标识。由于每个 Sentinel 中的主观下线时间配置都可以不同，所有有可能<strong>某个 Sentinel 判断主观下线时，另一个 Sentinel 认为在线状态</strong>。</p><h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>当 Sentinel 判断主服务器为主观下线时，还会向其他 Sentinel 询问，得到足量数据已下线判断后，就会判定服务器为客观下线，并执行故障转移。</p><h3 id="发送-sentinel-is-master-down-by-addr-命令"><a href="#发送-sentinel-is-master-down-by-addr-命令" class="headerlink" title="发送 sentinel is-master-down-by-addr 命令"></a>发送 sentinel is-master-down-by-addr 命令</h3><p>Sentinel 使用：<code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current. epoch&gt; &lt;runid&gt;</code>命令询问其他 Sentinel 是否同意主服务器下线。这些参数分别是 Sentinel 的 ip，端口，配置纪元和运行 id。</p><h3 id="接收-sentinel-is-master-down-by-addr-命令"><a href="#接收-sentinel-is-master-down-by-addr-命令" class="headerlink" title="接收 sentinel is-master-down-by-addr 命令"></a>接收 sentinel is-master-down-by-addr 命令</h3><p>其他接收并返回三个参数的 Multi Bulk 回复：</p><ol><li><down_state>：是对主服务器的检查结果，1 表示已下线；0 表示未下线。</down_state></li><li><leader_runid>：如果是 *，表示该命令用于检测服务器状态；如果是 Sentinel 的运行 id 用于选举领头 Sentinel。</leader_runid></li><li><leader_epoch>：选举计数器，用于选举领头 sentinel。</leader_epoch></li></ol><h3 id="接收-sentinel-is-master-down-by-addr-命令的回复"><a href="#接收-sentinel-is-master-down-by-addr-命令的回复" class="headerlink" title="接收 sentinel is-master-down-by-addr 命令的回复"></a>接收 sentinel is-master-down-by-addr 命令的回复</h3><p>统计其他 Sentinel 同意主服务器已下线数量，当数量超过配置值（quorum 参数）时，sentinel 会将主服务器实例的 flags 属性的<code>SRI_O_DOWN</code>属性打开，表示已进入客观下线状态。</p><pre><code class="line-numbers language-c">typedef struct sentinelRedisInstance {    //判断这个实例为客观下线所需的支持投票数量    int quorum;    ...} sentinelRedisInstance;</code></pre><h2 id="选举领头-Sentinel"><a href="#选举领头-Sentinel" class="headerlink" title="选举领头 Sentinel"></a>选举领头 Sentinel</h2><p>当主服务器被判断为客观下线时，sentinel 会协商选举领头 sentinel，并由领头 sentinel 对下线主服务器执行故障转移操作。</p><p>当<code>SENTINEL is-master-down-by-addr</code>命令已经确认主服务器客观下线时，Sentinel 还会<strong>再发送</strong>带有选举性质的该命令，并且带上自己的运行 ID。如果接收命令的 Sentinel 还没设置局部领头时，就会将这个运行 ID 作为自己的 <strong>Multi Bulk 回复参数</strong>。根据回复参数来判断多少 sentinel 将自己设置为局部领头。可能根据网络延迟，有的 Sentinel 命令比其他 Sentinel 都先到达，并且胜出（必须有<strong>半数以上</strong>的票），那么就由它负责故障转移。一次选举没有产生，一段时间后再次选举，直到选出。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>故障转移包括 3 步：</p><ol><li>在已下线的主服务器属下从服务器里选出一个将其转为主服务器。</li><li>让其他从服务器都复制新主服务器。</li><li>当原来的主服务器再次上线时，让他成为新主服务器的从服务器。</li></ol><h3 id="选出新主服务器"><a href="#选出新主服务器" class="headerlink" title="选出新主服务器"></a>选出新主服务器</h3><p>如何选新的主服务器？Sentinel 会将所有从服务器放入列表，<strong>一项一项</strong>过滤：</p><ul><li>删除处于下线或断线状态的从服务器。</li><li>删除最近 5 秒没有回复过领头<code>sentinel INFO</code>命令的从服务器。</li><li>删除与已下线服务器段开时间超过<code>down-after-milliseconds*10</code>毫秒的从服务器。</li></ul><p>然后根据<strong>优先级排序</strong>，相同则选<strong>偏移量最大</strong>的，相同则选运行 ID 最小的。</p><p>选出来之后，对这个从服务器发送<code>SLAVEOF no one</code>命令，然后以<strong>每秒一次</strong>的频率向它发送<code>INFO</code>命令，观察返回的 role 属性如果变成 master，就表示顺利升级为主服务器了。</p><h3 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h3><p>向所有其他从服务器发送<code>SLAVEOF</code>命令，让他们都去复制新的主服务器。</p><h3 id="将旧的主服务器变为从服务器"><a href="#将旧的主服务器变为从服务器" class="headerlink" title="将旧的主服务器变为从服务器"></a>将旧的主服务器变为从服务器</h3><p>当原来的主服务器上线时，Sentinel 就会向它发送<code>SLAVEOF</code>命令，让他成为新主服务器的从服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 复制</title>
      <link href="/database/redis/redis-duo-ji-ku-de-shi-xian/redis-fu-zhi/"/>
      <url>/database/redis/redis-duo-ji-ku-de-shi-xian/redis-fu-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-复制"><a href="#【Redis】-复制" class="headerlink" title="【Redis】 复制"></a>【Redis】 复制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 复制date: 2023-07-09 08:44tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 复制</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Redis 中，可通过 SLAVEOF 命令或配置文件中设置 slaveof 选项，让一个服务器去复制另一个服务器，被复制的为主服务器，对其复制的称为从服务器。</p><ul><li>Redis 2.8以前的复制功能不能高效地处理断线后重复制情况，但Redis 2.8新添加的部分重同步功能可以解决这个问题。</li><li>部分重同步通过<strong>复制偏移量</strong>、<strong>复制积压缓冲区</strong>、<strong>服务器运行ID</strong>三个部分来实现。</li><li>在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。</li><li>主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器<strong>发送命令</strong>来进行<strong>心跳检测</strong>，以及命令丢失检测。</li></ul><h2 id="旧版本复制功能的实现"><a href="#旧版本复制功能的实现" class="headerlink" title="旧版本复制功能的实现"></a>旧版本复制功能的实现</h2><p>Redis 在 2.8 以前使用旧版本复制，在短线重连后的从服务器会遇上低效的情况。</p><p>Redis 的复制功能分为<strong>同步</strong>和<strong>命令传播</strong>俩操作：</p><ul><li>同步用于把从服务器的数据库状态<strong>更新至主服务器的数据库状态</strong>。</li><li>命令传播是在主服务器的<strong>数据库状态被修改</strong>时，导致主从数据库状态不一致时，让主从回到一致的过程。</li></ul><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>从服务器对主服务器的同步（下文以主从代替），需要向主服务器发送 SYNC 命令，具体步骤：</p><ol><li>从向主发送 SYNC 命令。</li><li>主接收并<strong>执行 BGSAVE</strong>，后台生成 RDB 文件，并用一个<strong>缓冲区记录</strong>现在开始执行的所有写命令。</li><li>BGSAVE 执行完毕时，主将 RDB 文件发给从，从接收并载入，更新数据库状态。</li><li>主将其记录在<strong>缓冲区的所有写命令</strong>发给从，从执行写命令。</li></ol><p><img src="/attachment/2bb57d5d270d7e17ac7a35fa1924a2e0.png"></p><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>当主发生写操作时，主从同步需要通过命令传播，具体步骤：</p><ol><li>主将写命令发送给从。</li><li>从接收并执行相同的写命令。</li></ol><h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>旧版复制的缺陷主要体现在断线重连上，主因为网络原因中断复制，但从通过自动重连连上主，并继续复制主的时候。此时，从发送 SYNC 命令，希望将<strong>断线期间</strong>由于写操作对主的数据库状态修改同步，但 SYNC 每次都会<strong>重新生成 RDB 文件</strong>，将<strong>所有的</strong>数据库状态都写到 RDB，这就造成了资源的<strong>大量浪费</strong>。SYNC 命令对性能的损耗比较高主要表现在：</p><ol><li>主执行 BGSAVE 生成 RDB 文件会消耗 <strong>CPU、内存和磁盘 I/O 资源</strong>。</li><li>主需要发送 RDB，消耗<strong>网络资源</strong>。</li><li>从接收并载入 RDB，载入期间是<strong>阻塞的无法处理命令</strong>。</li></ol><p>因此，必须是真正有必要才调用 SYNC 命令。</p><h2 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h2><p>Redis 从 2.8 开始使用 PSYNC 代替 SYNC 命令来执行同步操作。</p><p>PSYNC 有完整重同步和部分重同步的两种模式：</p><ul><li>完整重同步用于初次复制的情况，与 SYNC 命令一样。</li><li>部分重同步用于处理断线重连后的情况，重连后，主服务器将<strong>断线期间执行的写命令</strong>发送给从服务器，从只需接收并执行这些命令。</li></ul><p>部分重同步的执行过程：</p><ol><li>从向主发送 PSYNC 命令，请求同步数据。</li><li>主判断后，确认需要执行部分重同步时，返回给从 <strong>+COUNTINUE</strong>。</li><li>主将断线期间的写命令发送给从。</li></ol><p><img src="/attachment/c57a4d6a1035fee5e32c39ee2187c526.png"></p><h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><p>部分重同步基于三个部分实现：</p><ul><li>主从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区</li><li>服务器运行 ID</li></ul><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>主从都会维护一个复制偏移量，记录<strong>存储数据的字节数</strong>，当主服务器向从服务器传播 N 个字节数据时，主的复制偏移量会加 N，从接收到之后也会加 N。通过偏移量<strong>判断数据库状态是否一致</strong>。但有一个问题，就是从服务器重连后，需要执行部分还是完整重同步，这时候就需要复制积压缓冲区来帮忙判断。</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>复制积压缓冲区由主服务器维护，是固定长度的<strong>先进先出队列</strong>，默认 1M。当入队元素大于队列长度时，最先入队的元素会被弹出。主服务器在命令传播时，不仅将写命令发给从，还会将<strong>写命令入队至积压缓冲区</strong>。</p><p><img src="/attachment/becbcb51d25af6d8d15e01339dfe0337.png"></p><p>复制积压缓冲区会保存最近写的命令，并为队列中的<strong>每个字节记录复制偏移量</strong>。</p><p><img src="/attachment/9f9135e665a0ef4f512140b992649edf.png"></p><p>当从服务器重连后，发送 PSYNC 并将自己的复制偏移量也发送给主服务器，主服务器拿着复制偏移量去复制积压缓冲区找，如果<strong>存在</strong>则进行部分重同步并给从服务器<strong>发送 + CONTINUE</strong> 回复，否则进行完整重同步。</p><p>复制积压缓冲区大小应该根据实际场景的两个因素进行调整：</p><ul><li>断线重连平均时间</li><li>主服务器平均每秒产生写命令的数据量</li></ul><p>一般得将这两个指标相乘后再乘以 2，作为复制积压缓冲区的大小，应对大多数断线情况。</p><h4 id="服务器运行-ID"><a href="#服务器运行-ID" class="headerlink" title="服务器运行 ID"></a>服务器运行 ID</h4><p>服务器运行 ID 决定断线后执行哪种同步方式，主从都有运行 ID，是自动生成的 40 个随机十六进制字符。主从第一次复制时，从服务器会保存主服务器的 ID，断线后也会向主服务器发送这个 ID，如果<strong>不同则进行完整重同步</strong>（之前的主服务器由于某些原因连接断开，重新选举的情况）；相同则部分重同步。</p><h3 id="PSYNC-命令的实现"><a href="#PSYNC-命令的实现" class="headerlink" title="PSYNC 命令的实现"></a>PSYNC 命令的实现</h3><p>PSYNC 命令调用方法有两种：</p><ul><li>从服务器第一次复制时，会发送<code>**PSYNC ? -1**</code>命令，请求完整重同步。</li><li>已经复制过的情况，向主服务器发送<code>**PSYNC &lt;runid&gt; &lt;offset&gt;**</code>命令，一个是主服务器运行 ID，一个是积压缓冲区的偏移量。</li></ul><p>主服务器接收后有 3 种返回值：</p><ul><li><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>：表示执行<strong>完整重同步</strong>，从服务器会将这两个变量保存。</li><li><code>+CONTINUE</code>：执行<strong>部分重同步</strong>，从服务器等待缺失数据的发送。</li><li><code>-ERR</code>：主服务器版本低于 2.8，执行<strong>完整重同步</strong>操作。</li></ul><p><img src="/attachment/97e186a84ca1ce2df124c486b806b6d9.png"></p><h2 id="一次完整的主从复制过程"><a href="#一次完整的主从复制过程" class="headerlink" title="一次完整的主从复制过程"></a>一次完整的主从复制过程</h2><p>一次完整的复制过程可以分为设置主服务器的地址和端口、建立套接字连接、发送 PING 命令、身份验证、发送端口信息、同步、命令传播。</p><h3 id="设置主服务器的地址和端口"><a href="#设置主服务器的地址和端口" class="headerlink" title="设置主服务器的地址和端口"></a>设置主服务器的地址和端口</h3><p>当客户端向服务器发送 SLAVEOF 命令时，从服务器会将主服务器的 ip 和端口都保存后发送 OK。这是一个<strong>异步命令</strong>，所以复制工作在回复 OK 后再执行。</p><h3 id="建立套接字连接"><a href="#建立套接字连接" class="headerlink" title="建立套接字连接"></a>建立套接字连接</h3><p>从服务器此时创建连接主服务器的套接字，如果套接字能成功连接，从服务器会给它关联一个处理复制工作的<strong>文件事件处理器</strong>（负责接收 RDB，传播的命令等）。主从成功连接后，主服务器会创建从服务器的客户端状态。</p><h3 id="发送-PING-命令"><a href="#发送-PING-命令" class="headerlink" title="发送 PING 命令"></a>发送 PING 命令</h3><p>从服务器在套接字连接后做的第一个工作就是发送 PING 命令，检查套接字<strong>读写状态是否正常</strong>；主服务器<strong>能否正常处理命令请求</strong>。而主服务器会根据网络状态、能够处理给出对应回复。一旦回复超时或返回错误，从服务器就会断开并重连主服务器。</p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>检查从服务器是否设置 masterauth，如果设置则进行身份验证。</p><h3 id="发送端口信息"><a href="#发送端口信息" class="headerlink" title="发送端口信息"></a>发送端口信息</h3><p>身份验证后，从服务器向主服务器发送自己监听的端口号，主服务器保存这个端口号。</p><h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>从服务器发送 PSYNC 命令，主从互相成为对方的客户端，都能够执行命令并回复，执行同步操作，看是完整重同步还是部分重同步。</p><h3 id="命令传播-1"><a href="#命令传播-1" class="headerlink" title="命令传播"></a>命令传播</h3><p>完成同步后，进入该阶段，主服务器将写命令发送给从服务器，从服务器接收并执行。</p><h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>在命令传播阶段，从服务器默认 <strong>1 秒一次</strong>发送<code>REPLCONF ACK &lt;replication_offset&gt;</code>命令给主服务器，replication_offset 是复制偏移量。这么做有 3 个作用：</p><ul><li>检测主从网络状态</li><li>辅助实现 min-slave 选项</li><li>检测命令丢失</li></ul><h3 id="检测主从网络状态"><a href="#检测主从网络状态" class="headerlink" title="检测主从网络状态"></a>检测主从网络状态</h3><p>下面分别说这三个作用。检测网络连接很好理解，如果主服务器超过一秒没受到从服务器的<code>REPLCONF ACK</code>则表示连接有问题。</p><h3 id="辅助实现-min-slave-选项"><a href="#辅助实现-min-slave-选项" class="headerlink" title="辅助实现 min-slave 选项"></a>辅助实现 min-slave 选项</h3><p>Redis 的<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>可<strong>防止主服务器在不安全的情况下执行写命令</strong>。如果设置如下：</p><pre><code>min-slaves-to-write 3 min-slaves-max-lag 10</code></pre><p>表示从服务器数量少于 3 或 3 个从服务器延迟大于等于 10s 时，主服务器拒绝写命令。</p><h3 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h3><p>通过发送的偏移量，主服务器会判断命令是否有丢失，如果丢失，就从积压缓冲区里找到并<strong>补发</strong>。</p><p>注：Redis2.8 之前版本并<strong>不会注意</strong>到丢失数据，所以保持主从数据一致性最好使用以上版本。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 服务器</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-fu-wu-qi/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-服务器"><a href="#【Redis】-服务器" class="headerlink" title="【Redis】 服务器"></a>【Redis】 服务器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 服务器date: 2023-07-09 08:42tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 服务器</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>简而言之，这章就是在解释客户端<strong>输入 Redis 指令到返回结果的执行过程</strong>。</p><ul><li>一个命令请求从发送到完成主要包括以下步骤：<ol><li>客户端将命令请求发送给服务器；</li><li>服务器读取命令请求，并分析出命令参数；</li><li>命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；</li><li>服务器将命令回复返回给客户端。</li></ol></li><li>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括<ol><li>更新服务器状态信息，</li><li>处理服务器接收的SIGTERM信号，</li><li>管理客户端资源和数据库状态，</li><li>检查并执行持久化操作等等。</li></ol></li><li>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：<ol><li>初始化服务器状态；</li><li>载入服务器配置；</li><li>初始化服务器数据结构；</li><li>还原数据库状态；</li><li>执行事件循环。</li></ol></li></ul><h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><p>首先是 Redis 服务器初始化操作，服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p><ol><li>初始化服务器状态。</li><li>载入服务器配置。</li><li>初始化服务器数据结构。</li><li>还原数据库状态。</li><li>执行事件循环。</li></ol><h3 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h3><p>主要是对 redisServer 结构体的初始化，包括设置服务器运行 ID，运行频率，设置配置文件路径，设置持久化条件，命令表创建等。</p><h3 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h3><p>根据用户设定的配置，对 redisServer 相关变量的值进行修改，比如端口号，数据库数量，RDB 的压缩是否开启等等。其他属性还是沿用默认值。</p><h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>服务器必须先载入用户配置，才能对其他数据结构进行准确初始化。其他数据结构包括客户端链表，db 数组，订阅信息，Lua 脚本执行环境，慢查询日志相关属性等等。</p><h3 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h3><p>载入 RDB 或 AOF 文件的数据恢复过程。</p><h3 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h3><p>至此，服务器可接收客户端请求并发送信息。</p><h2 id="命令执行过程"><a href="#命令执行过程" class="headerlink" title="命令执行过程"></a>命令执行过程</h2><p>以<code>SET key value</code>为例，命令的执行过程是：</p><ol><li>客户端发送命令。</li><li>服务器接收并处理请求，对数据库操作，回复 OK。</li><li>服务器将命令回复给客户端。</li><li>客户端接收命令并打印结果。</li></ol><p>下面将按照步骤拆解为发送，读取查找，执行预备操作，调用实现函数，执行后续工作，回复，打印操作讲解。</p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>客户端接收命令请求时，会将命令根据协议转为固定格式再发送给服务器。</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>当套接字因客户端的写入变得可读时，服务器会先读取协议格式内容并保存到输入缓冲区。命令分析，提取参数及个数，存入 argv 和 argc 属性。最后调用命令执行器。</p><h3 id="命令执行器-查找命令的实现"><a href="#命令执行器-查找命令的实现" class="headerlink" title="命令执行器 - 查找命令的实现"></a>命令执行器 - 查找命令的实现</h3><p>命令表是一个<strong>字典</strong>，键是命令名字，值是 redisCommand 结构。几个重要属性如下：</p><ul><li>name：命令名称。</li><li>proc：指向命令实现函数。</li><li>arity：命令参数个数，包括命令名称。</li><li>sflags：命令属性。</li></ul><p>查找命令表的过程就是找到 redisCommand，把指针指向它：</p><p><img src="/attachment/42f69c7f6daaba30ba8312e02846c4a4.png"></p><h3 id="命令执行器-执行预备操作"><a href="#命令执行器-执行预备操作" class="headerlink" title="命令执行器 - 执行预备操作"></a>命令执行器 - 执行预备操作</h3><p>在命令真正执行前需要有预备操作保证命令可以被正确，顺利地执行。这个环节相当于一层过滤，比如检查命令是否正确，参数是否正确，身份验证是否通过，内存是否够用等等。保证配置生效，准确执行。</p><h3 id="命令执行器-调用命令的实现函数"><a href="#命令执行器-调用命令的实现函数" class="headerlink" title="命令执行器 - 调用命令的实现函数"></a>命令执行器 - 调用命令的实现函数</h3><p>执行过程就是调用之前找到并指向的执行函数。通过 client-&gt;cmd-&gt;proc(client); 调用。然后将回复保存在客户端状态的输出缓冲区中，关联该套接字的命令回复处理器。</p><h3 id="命令执行器-执行后续工作"><a href="#命令执行器-执行后续工作" class="headerlink" title="命令执行器 - 执行后续工作"></a>命令执行器 - 执行后续工作</h3><p>有一些善后工作还将继续，比如慢查询日志记录，执行时长记录，AOF 持久化，主服务器将命令传给从服务器。当这些都处理完后，服务器就继续从文件时间处理器中取出并执行下一个命令请求。</p><h3 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h3><p>当客户端套接字变为可写状态，服务器执行命令回复处理器，将输出缓冲区的回复发送给客户端。</p><h3 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h3><p>将回复转为人类可读的格式，打印给用户看。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 客户端</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-ke-hu-duan/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-客户端"><a href="#【Redis】-客户端" class="headerlink" title="【Redis】 客户端"></a>【Redis】 客户端</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 客户端date: 2023-07-09 08:41tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 客户端</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 服务器的状态结构 clients 属性是<strong>链表</strong>，记录了所有与服务器相连的客户端结构，对客户端执行批量操作或查找操作，都可以通过 clients 链表完成：</p><pre><code class="line-numbers language-c">struct redisServer{    //一个链表，保存了所有客户端状态    list *clents    ...};</code></pre><p><img src="/attachment/920db7202bdda200313f8d5588a4bc22.png"></p><ul><li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li><li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li><li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li><li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li><li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li><li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li><li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li><li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li><li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li></ul><h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><p>客户端的属性主要分为通用和特定的，这里主要介绍通用的。简单来说有套接字描述符，标志，输入缓冲区，命令与参数，输出缓冲区，时间等。</p><pre><code class="line-numbers language-c">typedef struct redisClient{    //套接字描述符    int fd;    //标志    int flags;    //输入缓冲区    sds querybuf;    //单个命令拆分的数组    robj **argv;    //argv数组的长度    int argc;    //命令函数    struct redisCommand *cmd;    //固定大小输出缓冲区，默认16K    char buf[REDIS_REPLY_CHUNK_BYTES];    //buf已使用字节数    int bufpos;    //大小可变输出缓冲区    list *reply    //创建客户端的时间    time_t ctime;    //与服务器互动的最后时间    time_t lastinteraction;    //软性限制时间    time_t obuf_soft_limit_reached_time;    ...}redis client;</code></pre><h3 id="套接字描述符-fd"><a href="#套接字描述符-fd" class="headerlink" title="套接字描述符 fd"></a>套接字描述符 fd</h3><p>根据客户端类型不同：</p><ul><li>fd 为 - 1 表示伪客户端。</li><li>fd 为大于 - 1 的整数时表示普通客户端。</li></ul><p>伪客户端就是用于处理的命令请求来源于 AOF 或 Lua 脚本，不需要套接字连接，也就不需要套接字记录符。普通客户端就是所有来源于网络需要套接字连接的客户端。</p><h3 id="标志-flags"><a href="#标志-flags" class="headerlink" title="标志 flags"></a>标志 flags</h3><p>标志 flags 记录了客户端的角色。有主从标志，Lua 伪客户端标志，执行 MONITOR 标志… 标志可以以二进制来拼接：<code>flags:&lt;flag1&gt;|&lt;flag2&gt;|&lt;flag3&gt;...</code></p><h3 id="输入缓冲区-querybuf"><a href="#输入缓冲区-querybuf" class="headerlink" title="输入缓冲区 querybuf"></a>输入缓冲区 querybuf</h3><p>输入缓冲区存储客户端输入的指令，大小根据输入内容动态缩小扩大，最大不可超过 1G，否则导致服务器关闭该客户端。</p><h3 id="命令与参数-argv，argc）"><a href="#命令与参数-argv，argc）" class="headerlink" title="命令与参数 (argv，argc）"></a>命令与参数 (argv，argc）</h3><p>客户端输入的命令会先存放到数组 argv 中，其数据结构是这样的：</p><p><img src="/attachment/5a39935614975c0d34860507a262718a.png"></p><p>当客户端输入命令后，服务器根据 argv[0] 的值再命令表中查找（命令不区分大小写）对应命令的函数并给 cmd 赋值，cmd 就是对应的命令函数相关的操作信息。</p><h3 id="输出缓冲区（buf，bufpos，reply）"><a href="#输出缓冲区（buf，bufpos，reply）" class="headerlink" title="输出缓冲区（buf，bufpos，reply）"></a>输出缓冲区（buf，bufpos，reply）</h3><p>输出缓冲区有两个，一个大小固定，一个大小可变。大小固定的存储长度小的回复，比如 OK，错误返回等。大小可变缓冲区保存长度较大的回复，比如长列表，大集合。</p><p>大小可变缓冲区由 reply 链表实现，利用链表结构存储若干和字符串对象，使得长度不会受到限制。数据结构如下：</p><h3 id="时间（ctime，lastinteraction，obuf-soft-limit-reached-time）"><a href="#时间（ctime，lastinteraction，obuf-soft-limit-reached-time）" class="headerlink" title="时间（ctime，lastinteraction，obuf_soft_limit_reached_time）"></a>时间（ctime，lastinteraction，obuf_soft_limit_reached_time）</h3><p>服务器使用两种模式来限制客户端输出缓冲区的大小:</p><ul><li>硬性限制 (hard limit): 如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制 (softlimit): 软性限制比硬性限制小，服务器会根据输出缓冲区大小介于软硬性限制之间的时间决定是否关闭客户端 。</li></ul><h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><p>由于客户端有不同类型，所以创建和关闭的方式也不相同。</p><h3 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h3><p>客户端连接时调用 connect 函数，服务器就会调用连接事件处理器，为客户端创建状态，并创建新的客户端到 client 链表末尾。</p><h3 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h3><p>普通客户端可因其中一个原因关闭：</p><ul><li>客户端进程退出或者被杀死</li><li>客户端向服务器发送了带有不符合协议格式的命令请求</li><li>客户端成为了 CLIENT KILL 命令的目标</li><li>用户为服务器设置了 timeout 配置选项且当客户端的空转时间超过 timeout 时。不过 timeout 选项有客户端是主服务器，从服务器，正在被 BLPOP 等命令阻塞，正在执行 SUBSCRIBE、PSUBSCRIBE 等订阅命令，那么即使客户端的空转时间超过了 timeout 选项的值，客户端也不会被服务器关闭。</li><li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小 (默认为 1GB)</li><li>输出缓冲区的大小超过了硬性限制所设置的大小</li><li>输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制的时间超过指定时间。</li></ul><h3 id="Lua-脚本的伪客户端"><a href="#Lua-脚本的伪客户端" class="headerlink" title="Lua 脚本的伪客户端"></a>Lua 脚本的伪客户端</h3><p>服务器初始化时创建，随服务器结束关闭。</p><h3 id="AOF-文件的伪客户端"><a href="#AOF-文件的伪客户端" class="headerlink" title="AOF 文件的伪客户端"></a>AOF 文件的伪客户端</h3><p>载入 AOF 文件时创建，载入结束关闭。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 事件</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-shi-jian/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-事件"><a href="#【Redis】-事件" class="headerlink" title="【Redis】 事件"></a>【Redis】 事件</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 事件date: 2023-07-09 08:40tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 事件</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 服务器是一个<strong>事件驱动程序</strong>，主要有两种：</p><ul><li>文件事件：Redis 服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象。服务器与客户端通信会产生相应文件事件，服务器通过监听这些事件来完成一系列网络通信操作。</li><li>时间事件：Redis 服务器有一些需要在给定时间内执行的操作，而时间事件就是对这类定时操作的抽象。</li></ul><p>简单来说，文件事件就是<strong>套接字操作相关的事件</strong>；时间事件就是<strong>定时操作相关事件</strong>。</p><p><img src="/attachment/ac6460a0bd5d531922041e16fc619677.png"></p><p><img src="/attachment/66b550d03e4a8e2eeae8eedf70775185.png"></p><ul><li>Redis服务器是一个事件驱动程序，服务器处理的事件分为<strong>时间事件</strong>和<strong>文件事件</strong>两类。</li><li>文件事件处理器是<strong>基于Reactor模式</strong>实现的<strong>网络通信程序</strong>。</li><li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li><li>文件事件分为<strong>AE_READABLE事件（读事件）</strong>和<strong>AE_WRITABLE事件</strong>（写事件）两类。</li><li>时间事件分为<strong>定时事件</strong>和<strong>周期性事件</strong>：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li><li>服务器在一般情况下只执行<strong>serverCron函数</strong>一个时间事件，并且这个事件是周期性事件。</li><li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li><li>时间事件的实际处理时间通常会比设定的到达时间晚一些。</li></ul><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis 基于 Reactor 模式开发的网络事件处理器，就是文件事件处理器。大致是使用 I/O 多路复用程序<strong>同时监听多个套接字</strong>，根据套接字目前执行的任务为套接字<strong>关联不同的事件处理器</strong>；当被监听的套接字准备好<strong>应答，读取，写入，关闭</strong>等操作时。与之对应的文件事件就会产生，文件事件处理器就开始发挥作用了，调用事先关联好的事件处理器来处理事件。</p><p><img src="/attachment/2c4a583abe3309497b26cf6efba54179.png"></p><p>利用多路复用，虽然以单线程的方式运行，但文件事件处理器实现了高性能的网络通信模型，又能很好的与 Redis 服务器中其他模块对接，保持了设计的<strong>简单性</strong>。</p><h3 id="文件事件处理器的组成"><a href="#文件事件处理器的组成" class="headerlink" title="文件事件处理器的组成"></a>文件事件处理器的组成</h3><p>由套接字，I/O 多路复用程序，文件事件分派器，事件处理器组成。</p><p>I/O 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。I/O 多路复用程序总是将所有产生事件的<strong>套接字放入到一个队列</strong>中，以有序，同步，<strong>一次一个套接字</strong>向文件事件分派器传送的姿态来运行。只有当上一个套接字产生事件被事件处理器执行完了，才会继续传送下一个套接字。</p><p><img src="/attachment/3d386afeb9761489c690a472c9b354df.png"></p><h4 id="I-x2F-O-多路复用的实现"><a href="#I-x2F-O-多路复用的实现" class="headerlink" title="I/O 多路复用的实现"></a>I/O 多路复用的实现</h4><p>Redis 为所有多路复用的函数库进行包装，每个多路复用函数库在其中都对应一个单独文件：<code>ae_select.c</code>,<code>ae_epoll.c</code>,<code>ae_kqueue.c</code>。为每个多路复用函数都实现了相同的 API，所以多路复用程序的底层实现是可以互换的。Redis 在多路复用程序源码中用宏定义了相应规则，使得程序在编译时自动选择系统中性能最高的 I/O 多路复用函数库。</p><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><p>多路复用程序可监听的套接字事件可分为<code>ae.h/AE_READABLE</code>事件和<code>ae.h/AE_WRITABLE</code>事件。</p><ul><li>当套接字变得<strong>可读</strong>时（客户端对套接字执行 write，close，accept 后），套接字产生 AE_READABLE 事件。</li><li>当套接字变得<strong>可写</strong>时（客户端对套接字执行 read 操作后），套接字产生 AE_WRITABLE 事件。</li></ul><p>I/O 多路复用程序允许服务器同时监听者两个事件，如果某个套接字同时产生了两种事件，文件事件分派其会优先处理 AE_READABLE，再处理 AE_WRITABLE</p><h4 id="文件事件处理器的事件处理器"><a href="#文件事件处理器的事件处理器" class="headerlink" title="文件事件处理器的事件处理器"></a>文件事件处理器的事件处理器</h4><p>根据客户端的需要，事件处理器分为连接应答处理器，命令请求处理器，命令回复处理器，复制处理器。这里只介绍前三者。</p><ol><li>连接应答处理器</li></ol><p><code>networking.c/acceptTcpHandler</code>函数是 Redis 的连接应答处理器，用于连接服务器监听套接字的客户端进行应答。</p><p>Redis 服务器初始化时，程序就将连接应答处理器和服务器监听套接字的 <strong>AE_READABLE 事件关联</strong>，当客户端调用<code>sys/socket.h/connect</code>函数时连接服务器监听套接字时，套接字就会产生 AE_READABLE 事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p><p>简单来说就是客户端<strong>连接被监听的套接字</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>连接应答处理器就会执行</strong>。</p><ol start="2"><li>命令请求处理器</li></ol><p><code>networking.c/readQueryFromClient</code>函数是 Redis 命令请求处理器，主要负责从套接字中读入客户端发送的命令请求内容。</p><p>当客户端成功连接到服务器后，服务器会将 <strong>AE_READABLE 事件</strong>和命令请求处理器关联。当客户端向服务器发送命令请求时，套接字产生 AE_READABLE 事件，引发命令请求处理器执行，执行相应套接字的读入操作。</p><p>简单来说就是客户端<strong>发送命令请求</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>命令请求处理器就会执行</strong>。</p><ol start="3"><li>命令回复处理器</li></ol><p><code>networking.c/sendReplyToClient</code>函数是 Redis 的命令回复处理器，负责将服务器执行命令后得到的命令回复通过套接字返回给客户端。</p><p>当需要回复命令结果时，服务器会将客户端套接字的 <strong>AE_WRITEBLE 事件</strong>和命令回复处理器关联，当客户端准备好接收回复时就会产生 AE_WRITABLE 事件，引发命令回复处理器执行。执行结束，服务器会解除命令回复处理器与客户端的套接字 AE_WRITABLE 事件之间的关联。</p><p>简单来说就是服务器<strong>发送命令回复</strong>时，套接字<strong>产生并触发写事件</strong>，<strong>命令回复处理器就会执行</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一次完整的基于文件事件的服务器与客户端交互，相关处理器的处理过程：</p><ol><li>客户端发起连接，产生读事件，触发连接应答处理器执行。创建套接字，客户端状态并将该套接字的读事件与命令请求处理器关联。</li><li>客户端发送命令，产生读事件，触发命令请求处理器。读取执行命令，得到回复并将该套接字的写事件与命令回复处理器关联。</li><li>客户端读取命令回复，产生写事件，触发命令回复处理器。将回复写入套接字，解除读事件与命令回复处理器的关联。</li></ol><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>时间事件可分为<strong>定时事件</strong>和<strong>周期性事件</strong>：</p><ul><li>定时事件: 只在指定事件到达一次。如 xx 时间后执行一次。</li><li>周期性事件: 每隔一段时间执行一次。如每隔 xx 秒执行一次。</li></ul><p>注：Redis 一般只用周期性事件。</p><h3 id="时间事件的组成"><a href="#时间事件的组成" class="headerlink" title="时间事件的组成"></a>时间事件的组成</h3><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一 ID (标识号)。 ID 号按<strong>从小到大</strong>的顺序递增，新事件的 ID 号比旧事件大。</li><li>when：毫秒精度的 UNIX 时间戳，时间事件的到达 (arrive) 时间。</li><li>timeProc：时间事件处理器函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>事件处理器返回<code>ae.h/AE_NOMORE</code>, 为定时事件：该事件在达到一次之后被删除，之后不再到达。</li><li>事件处理器返回非<code>AE_NOMORE</code>的整数值，为周期性时间。当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的 when 属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，遍历整个链表，找到已到达的时间事件，调用相应的事件处理器。新的事件总是插入到链表的表头。</p><p><img src="/attachment/3cb8b55e4a5b27f9cddb7b200a0782ee.png"></p><p>因为事件 ID 只能增大，所以新插入的 id 总是最大的。</p><h3 id="serverCron-函数"><a href="#serverCron-函数" class="headerlink" title="serverCron 函数"></a>serverCron 函数</h3><p>很多情况下，Redis 需要定期进行资源检查，状态同步等操作，就需要定期操作，而定期操作都是由 serverCron 函数负责的，也是时间事件的应用实例。默认每隔 100ms 执行，具体工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。口清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行 AOF 或 RDB 持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>下面简单从几个方面出发，介绍 serverCron 的本职工作。</p><h4 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h4><p>Redis 不少功能依赖于系统当前时间，每次获取系统时间都会进行系统调用，为减少系统调用次数，服务器使用了 unixtime 和 mstime 作为当前时间的缓存。</p><pre><code class="line-numbers language-c">struct redisServer{    //保存了秒级精度的系统当前UNIX时间戳    time_t unixtime;    //保存了毫秒级的系统当前UNIC时间戳    long long mstime;    ...}</code></pre><p>由于 serverCron 默认 100 毫秒更新一次 unixtime 和 mstime，导致其精度不高，只使用于精度要求不高的场景：</p><ul><li>服务器打印日志，更新服务器的 LRU 时钟，决定执行持久化，计算上限时间等。</li><li>设置过期时间，添加慢查询日志需要高高进度，服务器还是会进行系统调用。</li></ul><h4 id="更新-LRU-时钟"><a href="#更新-LRU-时钟" class="headerlink" title="更新 LRU 时钟"></a>更新 LRU 时钟</h4><p>每个 Redis 对象也会有 lru 属性，记录上一次被命令访问的时间。如果要计算一个键的空转时长，就要通过 lrulock 记录的时间减去对象的 lru 属性记录时间。</p><pre><code class="line-numbers language-c">struct redisServer{    //默认每10秒更新一次的时钟缓存，    //用于计算键的空转时长    unsigned lrulock:22;    ...}typedef struct redisObject{    //对象最后一个被命令访问的时间    unsigned lru:22;    ...}</code></pre><h4 id="更新服务器每秒执行命令数"><a href="#更新服务器每秒执行命令数" class="headerlink" title="更新服务器每秒执行命令数"></a>更新服务器每秒执行命令数</h4><p>抽样计算函数以 100 毫秒一次，估算最近一秒钟的处理请求数。每次都会根据 4 个变量（上次抽样时间、当前时间、上次抽样已执行命令数、当前已执行命令数）来计算调用之间平均每毫秒处理几个命令，乘以 1000 就是 1 秒内处理命令的估计值。这个估计值会被放入 redisServer 的 ops_sec_samples 数组中。当我们需要知道秒内的指令数时，就会计算这个数组的平均数，因此结果是一个估算值。</p><h4 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h4><pre><code class="line-numbers language-c">struct redisServer{    //已使用内存峰值    size_t stat_peak_memory;    ...}</code></pre><p>stat_peak_memory 记录内存峰值，每次 serverCron 函数执行就会判断是否需要刷新内存峰值，如果当前使用的多就刷新。</p><h4 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h4><p>serverCron 每次执行都会调用 clientsCron 函数对客户端进行检查：如果已经超时则关闭；如果输入缓冲区大小超过一定长度则重新创建默认大小的输入缓冲区。</p><h4 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h4><p>serverCron 每次执行都会调用 databaseCron 函数，会对服务器的一部分数据库检查，删除过期键；对字典收缩。</p><p><strong>执行被延迟的 BGREWRITEAOF</strong></p><pre><code class="line-numbers language-c">struct redisServer{    //AOF延迟标志位，如果为1，则有AOF操作被延迟    int aof_rewrite_shceduled;    ...}</code></pre><p>由<code>aof_rewrite_shceduled</code>标志位决定，如果处于 BGSAVE 命令执行期间，BGREWRITEAOF 会被延迟到 BGSAVE 执行后执行。</p><h4 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h4><pre><code class="line-numbers language-c">struct redisServer{    //执行BGSAVE命令的子进程，没有为-1    pid_t rdb_child_pid;    //执行BGREWRITEAOF命令的子进程，没有为-1    pid_t aof_child_pid;    ...}</code></pre><p><code>rdb_child_pid</code>和<code>aof_child_pid</code>只要<strong>一个不为 - 1</strong>，则检查子进程是否有信号发来。如果有信号到达则进行后续操作，比如新 <strong>RDB 文件的替换，重写的 AOF 文件替换</strong>等。</p><p>如果<code>rdb_child_pid</code>和<code>aof_child_pid</code><strong>都为 - 1</strong>，则进行检查：</p><ul><li>是否有 BGREWRITEAOF 被延迟，有的话就进行 BGREWRITEAOF 操作。</li><li>自动保存条件是否满足，满足且未执行其他持久化操作则执行 BGSAVE。</li><li>AOF 重写条件是否满足，满足且未执行其他持久化操作则开始一次新的 BGREWRITEAOF 操作。</li></ul><p><img src="/attachment/98f02e914df90aa1426ac1c59bd447a4.png"></p><h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>当服务器同时存在时间事件和文件事件，调度时该如何选择，花费多久？</p><p>事件的调度由<code>ae.c/aeProcessEvents</code>函数负责。对于每一次事件循环，主要过程是：</p><ol><li>拿到最近的时间事件并计算还有多少毫秒。</li><li>创建时间任务结构；阻塞等待文件时间产生，最大阻塞时间<strong>由最近时间事件到达毫秒数决定</strong>。</li><li>先处理已产生的<strong>文件事件</strong>再处理到达的<strong>时间事件</strong>。</li></ol><p>执行原则 / 设计利弊：</p><ol><li>aeApiPoll 函数（redis 封装的多路复用函数）的最大阻塞时间由到达时间<strong>最接近当前时间的时间事件</strong>决定，这个方法既可以避免服务器对时间事件进行频繁的轮询 (忙等待)，也可以确保 aeApiPoll 函数<strong>不会阻塞过长时间</strong>。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。</li><li>对文件事件和时间事件的处理都是<strong>同步、有序、原子地执行</strong>的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器, 还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 AOF 持久化</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-aof-chi-jiu-hua/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-aof-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-AOF-持久化"><a href="#【Redis】-AOF-持久化" class="headerlink" title="【Redis】 AOF 持久化"></a>【Redis】 AOF 持久化</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 AOF 持久化date: 2023-07-09 08:39tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 AOF 持久化</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态。服务器启动时，可通过载入和执行 AOF 文件中保存的命令来还原服务器关闭前的数据库状态。</p><p><img src="/attachment/e07cc22d8e9bfa9cd0d5fce9b2a29b1c.png"></p><ul><li>AOF文件通过保存所有<strong>修改数据库的写命令</strong>请求来记录服务器的数据库状态。</li><li>AOF文件中的所有命令都以<strong>Redis命令请求协议</strong>的格式保存。</li><li>命令请求会先保存到<strong>AOF缓冲区</strong>里面，之后再定期写入并同步到AOF文件。</li><li>appendfsy nc选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。</li><li>服务器只要<strong>载入并重新执行保存在AOF文件中的命令</strong>，就可以还原数据库本来的状态。</li><li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库<strong>状态一样</strong>，但<strong>体积更小</strong>。</li><li>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</li><li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个<strong>AOF重写缓冲区</strong>，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF</li></ul><p>文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p><h2 id="AOF-持久化的实现"><a href="#AOF-持久化的实现" class="headerlink" title="AOF 持久化的实现"></a>AOF 持久化的实现</h2><p>AOF 持久化可分为命令追加，文件写入，文件同步三个步骤。</p><h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>开启 AOF 持久化后，服务器执行完一个写命令后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的 <strong>aof_buf 缓冲区末尾</strong>：</p><pre><code class="line-numbers language-c">struct redisServer{    //AOF缓冲区    sds aof_buf;    ...};</code></pre><h3 id="AOF-文件的写入与同步"><a href="#AOF-文件的写入与同步" class="headerlink" title="AOF 文件的写入与同步"></a>AOF 文件的写入与同步</h3><p>Redis 服务器进程就是一个<strong>事件循环</strong>，负责接收客户端命令请求及命令回复，时间事件负责执行向<code>serverCron</code>函数这样需要定时运行的函数。服务器每结束一个时间循环前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否有必要<strong>将 aof 缓冲区中的内容写入和保存至 AOF 文件</strong>里。这个判断的依据就是根据配置文件的 appendfsync 值决定：</p><ul><li>always：将 aof_buf 缓冲区的所有内容<strong>写入并同步</strong>到 AOF 文件。</li><li>everysec：将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间<strong>超过一秒</strong>，就再次对 AOF 文件进行同步，并由一个线程专门负责。</li><li>no：将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，但并<strong>不对 AOF 文件进行同步</strong>，何时同步<strong>由操作系统决定</strong>。</li></ul><p>为什么有写入和同步的区分？写入≠同步</p><p>为提高写效率，操作系统一般将写入数据<strong>暂时保存在内存缓冲区</strong>，等缓冲区<strong>填满或超过</strong>指定时间后才会真正地将<strong>数据同步到磁盘里</strong>。操作系统提供了 fsync 和 fdatasync 两同步函数，可<strong>强制操作系统同步数据</strong>，保证数据安全性。</p><p>也就是说，每一次的事件循环，aof_buf 中的指令<strong>都会被写入操作系统的缓冲区</strong>，根据 appendfsync 配置，当操作系统缓冲区满足一定条件后，就被<strong>真实地写入</strong>磁盘内。</p><h2 id="AOF-文件的载入与数据还原"><a href="#AOF-文件的载入与数据还原" class="headerlink" title="AOF 文件的载入与数据还原"></a>AOF 文件的载入与数据还原</h2><p>步骤如下：</p><ol><li>创建一个没有网络连接的伪客户端。由于 Redis 命令只能在客户端上下文中执行，并且 AOF 文件在本地而不是网络。</li><li>解析 AOF 文件并取出一条写命令。</li><li>使用伪客户端执行被读出的写命令</li><li>持续执行 2 和 3，直到所有写命令都已经执行完毕</li></ol><p><img src="/attachment/c50d73913c36b39f22d6dc108c5da992.png"></p><h3 id="AOF-创建和重写时对过期键的处理套路"><a href="#AOF-创建和重写时对过期键的处理套路" class="headerlink" title="AOF 创建和重写时对过期键的处理套路"></a>AOF 创建和重写时对过期键的处理套路</h3><p>如果数据库中的某个键已经过期且没有被删除，AOF 文件不会因为这个对过期键产生影响。当过期间被惰性删除或定期删除后，AOF 文件<strong>追加一条 DEL 命令</strong>来显式删除。</p><p>AOF 重写时，程序会对数据库的键检查，已过期的<strong>不会保存</strong>到 AOF 文件中。</p><h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>因为 AOF 持久化会将所有的写命令都记录，所以会有冗余情况，比如频繁地创建删除键值对，或者对同一个键的值频繁更新，都会导致文件的内容越来越多。所以需要一种<strong>瘦身的机制</strong>确保 AOF 里存的都是必不可少的精华。</p><p>Redis 提供 AOF 文件重写功能，让服务器创建一个新的 AOF 文件，替代现有的 AOF 文件，减少冗余命令。</p><h3 id="AOF-文件重写的实现"><a href="#AOF-文件重写的实现" class="headerlink" title="AOF 文件重写的实现"></a>AOF 文件重写的实现</h3><p>在新的 AOF 文件的重写过程中，不会读取旧 AOF 文件，而是通过<strong>读取数据库状态</strong>来实现的。首先从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前记录的多条命令。</p><p>注：在重写时会先检查键所包含的元素数量，因为多元素的键在命令转换时可能会导致客户端输入缓冲区溢出。因此读取配置中对应的常量，默认超过 64 个就用多条指令记录。</p><h3 id="AOF-后台重写过程"><a href="#AOF-后台重写过程" class="headerlink" title="AOF 后台重写过程"></a>AOF 后台重写过程</h3><p>AOF 重写的过程中会有大量的写入操作，为了避免 Redis 服务器长时间的阻塞，重写工作将被放到<strong>子进程中进行</strong>。这样的好处是：</p><ul><li>父进程仍然可继续处理请求。</li><li>子进程有自己的数据副本，而非子线程，可以避免一些线程安全性问题的出现。</li></ul><p>子进程在执行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，导致<strong>当前数据库状态与重写后的 AOF 文件保存状态不一致</strong>。为解决这个问题，设置了 <strong>AOF 重写缓冲区</strong>。</p><p>当重写子进程创建后，Redis 服务器执行完写命令就会将其写入 AOF 缓冲区和 AOF 重写缓冲区，子进程执行重写期间，服务器进程要执行 3 个工作：</p><ol><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到 AOF 缓冲区。</li><li>将执行后的写命令追加到 AOF 重写缓冲区。</li></ol><p><img src="/attachment/875dc96dab16f0743e27de35f672b65c.png"></p><p>当子进程完成重写后，会向父进程<strong>发送一个信号</strong>，父进程接收并调用信号处理函数，将重写缓冲区的所有内容写到新 AOF 文件中，原子地覆盖现有的 AOF 文件。因此整个 AOF 文件重写的过程中，只有<strong>信号处理函数执行时，才会阻塞</strong>，将性能损耗降到最低。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 RDB 持久化</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-rdb-chi-jiu-hua/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-rdb-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-RDB-持久化"><a href="#【Redis】-RDB-持久化" class="headerlink" title="【Redis】 RDB 持久化"></a>【Redis】 RDB 持久化</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 RDB 持久化date: 2023-07-09 08:38tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 RDB 持久化</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于 Redis 是内存数据库，数据状态都存储于内存，如果不想办法将存储在内存中的数据库状态保存到磁盘里，那么一旦服务器进程退出，服务器中的数据库状态也会消失。</p><p>为解决这个问题，Redis 提供了持久化的功能，可将内存中的数据库保存到磁盘，防止意外丢失。RDS 持久化（默认持久化策略）就是将某一时间点上的状态保存到一个 RDB 文件里。RDB 文件是经过<strong>压缩的二进制文件</strong>，可通过该文件还原成数据库状态。</p><p><img src="/attachment/397e2f468246a0464cd81462262cf7e2.png"></p><p><img src="/attachment/f8bdc604be32622fd208ac3ae22fcd1c.png"></p><ul><li>RDB文件用于保存和还原Redis服务器所有数据库中的<strong>所有键值对数据</strong>。</li><li><strong>SAVE命令</strong>由服务器进程直接执行保存操作，所以该命令会<strong>阻塞</strong>服务器。</li><li><strong>BGSAVE命令</strong>由子进程执行保存操作，所以该命令<strong>不会阻塞</strong>服务器。</li><li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li><li>RDB文件是一个经过<strong>压缩的二进制文件</strong>，由多个部分组成。</li><li>对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。</li></ul><h2 id="RDB-文件的创建与载入"><a href="#RDB-文件的创建与载入" class="headerlink" title="RDB 文件的创建与载入"></a>RDB 文件的创建与载入</h2><p>有两个命令可用于生成 RDB 文件（SAVE 和 BGSAVE）。他们之间的区别是：SAVE 会<strong>阻塞</strong> Redis 服务器进程，直到 RDB 文件创建完毕为止，阻塞期间，服务器不能处理任何命令请求。而 BGSAVE 会 <strong>fork 出一个子进程</strong>，由子进程负责创建 RDB 文件，<strong>父进程继续处理命令请求</strong>。当子进程完成之后，向父进程<strong>发送信号</strong>。</p><p>创建就是执行 SAVE/BGSAVE 底层调用 rdbSave 函数的过程，载入就是服务启动时读取 RDB 文件底层调用 rdbLoad 函数的过程。</p><h3 id="RDB-创建与载入时对过期键的处理套路"><a href="#RDB-创建与载入时对过期键的处理套路" class="headerlink" title="RDB 创建与载入时对过期键的处理套路"></a>RDB 创建与载入时对过期键的处理套路</h3><p>执行<code>SAVE</code>或<code>BGSAVE</code>时，创建一个新的 RDB 文件，程序回对数据库中键检查，已过期的就不会包含到 RDB 文件中。</p><p>在启动时，RDB 文件载入：</p><ul><li>如果服务器以主服务模式运行，程序对文件保存的键检查，未过期的载入到数据库，过期则<strong>忽略</strong>。</li><li>如果服务器以从服务模式运行，无论是否过期，<strong>都会载入</strong>到数据库。因为主服务器在数据同步时，会将从服务器的数据库清空，一般不会有影响。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>在一定间隔时间做一次备份，所以如果 redis 挂了，就会<strong>丢失最后一次快照后的所有修改</strong>。</li><li>fork 的时候，内存中的数据被克隆一份，大致 <strong>2 倍的膨胀性</strong>需要考虑内存空间。</li></ul><h3 id="BGSAVE-执行时的服务器状态"><a href="#BGSAVE-执行时的服务器状态" class="headerlink" title="BGSAVE 执行时的服务器状态"></a>BGSAVE 执行时的服务器状态</h3><p>BGSAVE 命令执行期间，对 SAVE，BGSAVE，BGREWRITEAOF（AOF 持久化命令）三个命令的处理方式如下：</p><p>由于 SAVE，BGSAVE 底层都是调用 rdbSave 来持久化文件的，而且父子进程同时执行两个 rdbSave 调用会<strong>产生竞态条件</strong>，所以这两个指令会被服务器拒绝。BGREWRITEAOF 会被延迟到 BGSAVE 执行结束后执行。<br>如果 BGREWRITEAOF 正在执行，服务器会拒绝 BGSAVE 命令。由于 BGREWRITEAOF 和 BGSAVE 都会产生子进程且有大量的磁盘写入，出于性能考虑不会同时执行。</p><p>简单来说，就是 BGSAVE 执行期间，<strong>拒绝 SAVE，BGSAVE</strong>；<strong>延迟执行 BGREWRITEAOF</strong>。BGREWRITEAOF 执行期间，<strong>拒绝 BGSAVE</strong>。</p><h3 id="RDB-与-AOF-共存的载入情况"><a href="#RDB-与-AOF-共存的载入情况" class="headerlink" title="RDB 与 AOF 共存的载入情况"></a>RDB 与 AOF 共存的载入情况</h3><p>RDB 文件的载入是在服务器启动时执行，Redis 并没有专门提供载入 Redis 的命令。由于 AOF 文件的更新频率更高，因此开启 AOF 持久化功能后，启动时<strong>优先加载 AOF</strong> 还原数据，只有在 AOF 处于关闭状态，才使用 RDB 文件恢复数据。</p><h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>服务器允许用户通过配置文件设置隔一定时间自动执行 BGSAVE。可通过 save 选项设多个保存条件，默认的配置如下：</p><pre><code class="line-numbers language-c">save 900 1save 300 10save 60 10000</code></pre><p>只要满足任意条件，900s 内对数据库进行 1 次修改或 300s 内…BGSAVE 就会被执行。</p><p>那么，服务器是如何根据 save 选项来自动执行 BGSAVE 的？<br>从实现角度考虑，我们需要<strong>记录配置</strong>、<strong>评判依据</strong>和<strong>依据更新驱动</strong>。记录配置由 saveparams 实现；评判依据是 dirty 计数器和 lastsave 属性；依据更新驱动就是 serverCron 对评判依据的动态更新。<br>save 配置都会在 redisServer 的 saveparam 数组中体现：</p><pre><code class="line-numbers language-c">struct redisServer{    //记录了保存条件的数组    struct saveparam *saveparams;    ...};struct saveparam{    //秒数    time_t seconds;    //修改数    int changes;};</code></pre><h3 id="dirty-计数器和-lastsave-属性"><a href="#dirty-计数器和-lastsave-属性" class="headerlink" title="dirty 计数器和 lastsave 属性"></a>dirty 计数器和 lastsave 属性</h3><p>这两个属性由 redisServer 持有：</p><ul><li>dirty 计数器记录距离上次成功执行 SAVE 或 BGSAVE 后数据库被修改了几次。</li><li>lastsave 是一个 UNIX 时间戳，记录上次成功执行 SAVE 或 BGSAVE 的时间。</li></ul><pre><code class="line-numbers language-c">struct redisServer{    //修改计数器    long long dirty;    //上一次执行保存的时间    time_t lastsave;    //...};</code></pre><h3 id="检查条件是否满足"><a href="#检查条件是否满足" class="headerlink" title="检查条件是否满足"></a>检查条件是否满足</h3><p>Redis 的周期性操作函数 serverCron 每隔 100 毫秒会执行一次，其中一项工作就是检查 save 选项设置的保存条件是否满足要求，满足则执行 BGSAVE。</p><h2 id="RDB-文件结构"><a href="#RDB-文件结构" class="headerlink" title="RDB 文件结构"></a>RDB 文件结构</h2><p><img src="/attachment/32420f4dff71b35fb14eaa0b1152e957.png"></p><p>REDIS：长度 5 字节，保存 “REDIS”5 个字符（为书写方便，其实是 5 个单独字符），通过这个判断该文件是否为 RDB 文件。</p><p>db_version：长度 4 字节，是字符串表示的整数记录 RDB 的版本号。</p><p>database：包含 0 个或多个数据库及各数据库中键值对数据。表示那些数据库是有数据的。</p><p>EOF：常量长度 1 字节，标志 RDB 文件正文的结束。读取时遇到该值，表示键值对的载入已经结束了。</p><p>check_sum：是一个 8 字节的无符号整数，保存一个同过前几位变量计算出来的校验和。每次加载都会进行计算校验，通过这个来判断文件是否损坏。</p><h3 id="database-部分"><a href="#database-部分" class="headerlink" title="database 部分"></a>database 部分</h3><p>每个非空数据库在 RDB 文件中都可表示为 SELECTDB，db_number，key_value_pairs 三部分</p><ul><li>selectdb：1 字节，标志位，标志着下一位存储的是数据库号码。</li><li>db_number：是一个数据库号码。</li><li>key_value_pairs：保存了数据库中所有键值对数据，如果有过期时间，则过期时间也会保存。</li></ul><h3 id="key-value-pairs-部分"><a href="#key-value-pairs-部分" class="headerlink" title="key_value_pairs 部分"></a>key_value_pairs 部分</h3><p>不带过期时间的键值对在 RDB 文件由 TYPE，key，value 组成，带过期时间则含有 EXPIRETIME_MS，ms：</p><p><img src="/attachment/114b672e75807c382972efb0754fc551.png"></p><p>EXPIRETIME_MS：标志位，长度为 1 字节，告知程序下一个读入的是以毫秒为单位的过期时间。<br>ms：是 8 字节长的带符号整数，记录 UNIX 时间戳，即过期时间。<br>type：记录 value 的类型，长度 1 字节，这个常量其实就是 Redis 对象类型和底层编码的组装：</p><ul><li>REDIS RDBTYPE_STRING</li><li>REDIS_ RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_HASH_ZIPLIST</li></ul><p>服务器会根据 TYPE 来决定如何读入和解释 value 的数据。</p><p>key 就不用做过多解释~</p><h3 id="value-的编码"><a href="#value-的编码" class="headerlink" title="value 的编码"></a>value 的编码</h3><p>根据 TYPE 的不同，value 的存储结构也大不相同。这里不详细展开，只需要知道，对于字符串对象，如果大于 20 字节，就会用 LZF 算法压缩。除字符串对象和整数集合，其他存储方式的开头都是节点数量，告诉程序应读入多少节点 / 键值对。</p><h2 id="分析-RDB-文件"><a href="#分析-RDB-文件" class="headerlink" title="分析 RDB 文件"></a>分析 RDB 文件</h2><p>Redis 自带 RDB 文件检查工具 redis-check-dump。可以帮助在系统故障后分析快照文件，也就是 RDB 文件。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 数据库</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-shu-ju-ku/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-数据库"><a href="#【Redis】-数据库" class="headerlink" title="【Redis】 数据库"></a>【Redis】 数据库</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 数据库date: 2023-07-09 08:37tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 数据库</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从 Redis 服务端的实现角度介绍，包括 db 存储，切换，键的存储及过期相关处理。</p><p><img src="/attachment/79a3ab862efb1ae17d0de6cb9b5cd3b0.png"></p><ul><li>Redis服务器的所有数据库都保存<strong>在redisServer.db数组</strong>中，而数据库的数量则由redisServer.dbnum属性保存。</li><li>客户端通过<strong>修改目标数据库指针</strong>，让它指向redisServer.db数组中的不同元素来<strong>切换不同的数据库</strong>。</li><li>数据库主要<strong>由dict和expires两个字典构成</strong>，其中<strong>dict字典</strong>负责保存<strong>键值对</strong>，而<strong>expires字典</strong>则负责<strong>保存键的过期时间</strong>。</li><li>因为数据库由字典构成，所以对数据库的操作都是建立在<strong>字典</strong>操作之上的。</li><li>数据库的<strong>键</strong>总是一个<strong>字符串对象</strong>，而<strong>值</strong>则可以是任意一种<strong>Redis对象类型</strong>，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。</li><li>expires字典的<strong>键</strong>指向<strong>数据库中的某个键</strong>，而<strong>值</strong>则记录了数据库键的<strong>过期时间</strong>，过期时间是一个以毫秒为单位的UNIX时间戳。</li><li>Redis使用<strong>惰性删除</strong>和<strong>定期删除</strong>两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li><li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li><li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li><li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li><li>当<strong>主服务器</strong>删除一个过期键之后，它会向所有从服务器发送一条<strong>DEL命令</strong>，显式地删除过期键。</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li><li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li></ul><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis 把所有库信息都保存在<code>redis.h/redisServer</code>结构的 db 数组中，数组类型是<code>redis.h/redisDB</code>，dbnum 决定着应该创建多少数据库中的 db，clients 维护着所有连接 Redis 的客户端：</p><pre><code class="line-numbers language-c">struct redisServer{    //服务器的数据库数量    int dbnum;    //一个数组，保存着服务器中的所有数据库    redisDb *db;    //客户端状态链表    list *clients;    //...}</code></pre><p>服务器数据库实例如图所示：</p><p><img src="/attachment/10b9c2751bf7753dacf1c337cd976540.png"></p><p>当切换库时，其实就是 redisClient.db 对 redisServer.db 数组的目标数据库指针的移动。下面展示了从 0 号库切为 1 号库的过程。通过<strong>指针的切换</strong>，实现对库的共享：</p><p><img src="/attachment/6a1916a768e8655f62460751cbf89d61.png"></p><h2 id="数据库的键空间"><a href="#数据库的键空间" class="headerlink" title="数据库的键空间"></a>数据库的键空间</h2><p>redis 将所有 key 进行统一管理，按照所属的库划分，放在 redisDb 的字典中（按照上面画的数据结构，redis 每一个库都对应一个 redisDb）。redisDb 结构的 dict 字典保存了该数据库中的所有键值对，也称为<strong>键空间</strong>。键空间的数据结构如下：</p><pre><code class="line-numbers language-c">typedef struct redisDb{    //数据库键空间，保存着数据库中的所有键值对    dict *dict;    ...}</code></pre><p>键空间的键就是数据库的键，每个键都是一个字符串对象，键空间的值就是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象</p><p><img src="/attachment/a1fe0204bfaf1c1acbbabb057e5e5237.png"></p><p>当执行一些插入指令时，就是对 dict 中 key 的新增；同理，删除键后，dict 中的键值对对象都会被删除。</p><h3 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h3><p>对键的读写时，服务器会做相应的善后操作，比如更新缓存的命中率，更新 LRU（最后一次使用）时间，对已过期的键先进行删除操作，修改时对客户端 watch 的键进行 dirty 标记，更新 dirty 键计数器的值，当开启通知功能后，键修改时需要按配置发送相应通知。</p><h2 id="键过期时间相关操作"><a href="#键过期时间相关操作" class="headerlink" title="键过期时间相关操作"></a>键过期时间相关操作</h2><p>通过<code>EXPIRE</code>或<code>PEXPIRE</code>，客户端可以以<strong>秒或毫秒</strong>为精度设置过期时间（Time To Live，TTL）。通过<code>EXPIREAT</code>或<code>PEXPIREAT</code>，客户端可以设置<strong>时间戳</strong>作为过期时间。</p><p>使用<code>TTL</code>或<code>PTTL</code>也可查看某个键的剩余生存时间，还有多久过期：</p><pre><code class="line-numbers language-shell">redis&gt; SET key valueOK redis&gt; EXPIRE key 500(integer) 1 redis&gt; TTL key(integer) 498</code></pre><p>Redis 是如何保存过期时间的，又是如何删除过期键的将在下面论述。</p><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>Redis 提供了 4 个命令设置过期时间：</p><ul><li><code>EXPIRE&lt;key&gt; &lt;ttl&gt;</code>：将 key 的生存时间设为 ttl 秒。</li><li><code>PEXPIRE&lt;key&gt; &lt;ttl&gt;</code>：将 key 的生存时间设为 ttl 毫秒。</li><li><code>EXPIREAT&lt;key&gt; &lt;timestamp&gt;</code>：将 key 的过期时间设置为 timestamp 秒数时间戳。</li><li><code>PEXPIREAT&lt;key&gt; &lt;timestamp&gt;</code>：将 key 的过期时间设置为 timestamp 毫秒数时间戳。</li></ul><p>其实几个命令底层都是经过换算后，用 <strong>PEXPIREAT</strong> 实现的。</p><p>实现转换关系图：</p><p><img src="/attachment/1fdeafced406a5ded853f062281ad621.png"></p><h3 id="存储过期时间"><a href="#存储过期时间" class="headerlink" title="存储过期时间"></a>存储过期时间</h3><p>redisDb 中有一个 expires 的字典数据结构保存所有键的过期时间，也称为过期字典。过期字典的值是一个 <strong>long long</strong> 类型的整数，保存了键所指向的数据库键的过期时间（毫秒精度的 Unix 时间戳）。</p><pre><code class="line-numbers language-c">typedef struct redisDb{    //过期字典，保存着键的过期时间    dict *expires;    ...} redisDb;</code></pre><p>图中键空间和过期的键其实复用了一个键对象，这里方便展示就拆开来，假设我们给键 alphabet 和 book 都设置了过期时间：</p><h3 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h3><p>PERSIST 命令可以<strong>移除一个键的过期时间</strong>，在过期字段中查找给定键，并<strong>解除</strong>键和值在过期字典中的关联。</p><pre><code class="line-numbers language-bash">redis&gt; SET key valueOK redis&gt; EXPIRE key 500(integer) 1 redis&gt; TTL key(integer) 498 redis&gt; PERSIST message(integer) 1 redis&gt; TTL key(integer) -1</code></pre><h3 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h3><p>TTL 以秒为单位返回剩余时间，PTTL 以毫秒返回键的剩余时间。二者的计算都是通过计算键的过期时间与当前时间之差来实现的。</p><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>如果一个键过期了，那么在什么时候被删除？列举几个常见淘汰策略：</p><ol><li>定时删除：设置键的过期时间时，创建定时器，过期时，以定时器立刻执行键的删除。</li><li>惰性删除：不着急删除过期键，每次获取时都会进行过期校验。</li><li>定期删除：隔一段时间，程序就对数据库检查，删除过期键。</li></ol><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>定时删除策略<strong>对内存友好</strong>，但<strong>对 CPU 不友好</strong>。过期键比较多时，删除会占用资源，特别是和删除当前任务无关的过期键，影响性能。Redis 定时器需要创建时间事件，时间事件底层由无需链表实现，查找复杂度为 O(N)，如果需要高效处理必然要创建大量的定时器，并不现实。</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除<strong>对 CPU 友好</strong>，但<strong>对内存不友好</strong>。不需要把时间浪费在非相关键的删除上。当键非常多时，会导致内存泄漏，因为只有用到时才会判断，删除。</p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>定期删除是一种折衷的方式，隔一段时间执行一次，并<strong>限制</strong>删除操作<strong>执行的时长和频率</strong>减少对 CPU 的占用；定期删除还能<strong>减少庞大的过期键对内存的占用</strong>。如何确定时长和频率是难点，过长或过少，会退变为定时删除和惰性删除。</p><h3 id="Redis-的过期键删除策略"><a href="#Redis-的过期键删除策略" class="headerlink" title="Redis 的过期键删除策略"></a>Redis 的过期键删除策略</h3><p>Redis 使用了<strong>惰性删除和定期删除</strong>两种策略配合，服务器可以合理地在使用 CPU 时间和避免内存浪费之间权衡。</p><ul><li>惰性删除策略的实现</li></ul><p>该策略由<code>db.c/expireIfNeeded</code>函数实现，如同指令过滤器，在执行读写键指令时都会调用该函数检查，如果过期则删除。</p><ul><li>定期删除策略的实现</li></ul><p>该策略由<code>redis.c/activeExpireCycle</code>函数实现，当服务器周期性调用<code>redis.c/serverCron</code>函数时，<code>activeExpireCycle</code>函数就会被调用，规定时间内，多次遍历服务器的各个数据库，从 expires 字典中随机检查一部分键的过期时间，并删除过期键。<code>activeExpireCycle</code>函数的主要工作可以拆分为：</p><ol><li>每次运行，都从一定数量的数据库中取出一定数量的<strong>随机键</strong>检查并删除过期键。</li><li>全局遍历记录检查进度，有<strong>记忆</strong>功能，全局变量存储的是几号库。</li><li>当所有数据库都被检查一遍后，<strong>重置</strong>全局变量，进行新一轮检查。</li></ol><h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>Redis 发布订阅功能可以让客户端获取数据库中键的变化及命令的执行情况。关注某个键执行了什么命令的通知称为键空间通知。关注某个命令被什么键执行的通知称为事件通知。</p><p>主要就是围绕通知功能，简单看下发送通知及其实现。</p><h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>该功能由<code>notify.c/notifyKeyspaceEvent</code>函数实现：</p><p>通过几个入参：要发送的通知类型，时间名称，产生时间的键，产生时间的数据库号。来构造事件通知内容和接收频道名，Redis 许多指令的执行函数都会调用这个函数，传递该命令引发的事件相关信息。</p><h4 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h4><ol><li>通过服务器配置的值判断，如果给定通知类型不是服务器允许的就直接返回。</li><li>如果是服务器允许发送的，检测是否允许发送键空间通知，允许则构建发送事件并通知。</li><li>检测是否允许发送键事件通知，如果允许则构建并发送通知。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 对象</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-dui-xiang/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-对象"><a href="#【Redis】-对象" class="headerlink" title="【Redis】 对象"></a>【Redis】 对象</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 对象date: 2023-07-09 08:35tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 对象</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis <strong>没有直接使用</strong>前文的数据结构来实现键值对数据库，而是基于这些数据结构构建了一个对象系统，通过对象组织数据结构，包括字<strong>符串对象，列表对象，哈希对象，集合对象</strong>和<strong>有序集合对象这</strong> 5 种对象。</p><p>使用对象的一个好处是可以针对不同的使用场景，为对象<strong>设置多种不同的数据结构实现</strong>，从而优化对象在不同场景下的使用效率。</p><p>Redis 使用对象来表示数据库的键和值。每个对象都是一个 redisObject 结构，是一个按照位段存储的结构，节约内存：</p><pre><code class="line-numbers language-c">typedef struct redisObject{    //类型    unsigned type :4;    //编码    unsigned encoding:4;    //指向底层实现数据结构的指针    void *ptr;    ...} robj;</code></pre><ul><li>Redis数据库中的每个键值对的键和值都是一个对象。</li><li>Redis共有<strong>字符串</strong>、<strong>列表</strong>、<strong>哈希</strong>、<strong>集合</strong>、<strong>有序集合</strong>五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li><li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</li><li>Redis的对象系统带有<strong>引用计数</strong>实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</li><li>Redis会共享值为0到9999的字符串对象。</li><li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的<strong>空转时间</strong>。</li></ul><h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><p>Redis 使用对象来表示数据库的键和值。每个对象都是一个 redisObject 结构，是一个按照位段存储的结构，节约内存：</p><pre><code class="line-numbers language-c">typedef struct redisObject{    //类型    unsigned type :4;    //编码    unsigned encoding:4;    //指向底层实现数据结构的指针    void *ptr;    ...} robj;</code></pre><p>其中，type 是类型常量，记录对象的类型：</p><table><thead><tr><th>类型常量</th><th>对象的名字</th></tr></thead><tbody><tr><td>REDIS_ String</td><td>字符串对象</td></tr><tr><td>REDIS_ List</td><td>列表对象</td></tr><tr><td>REDIS_ HASH</td><td>哈希对象</td></tr><tr><td>REDIS_ SET</td><td>集合对象</td></tr><tr><td>REDIS_ ZSET</td><td>有序集合对象</td></tr></tbody></table><p>encoding 记录对象使用的编码，即对象底层使用的具体数据结构：</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td>REDIS_ ENCODING_ INT</td><td>long类型的整数</td></tr><tr><td>REDIS ENCODING EMBSTR</td><td>embstr编码的简单动态字符串</td></tr><tr><td>REDIS_ ENCODING RAW</td><td>简单动态字符串</td></tr><tr><td>REDIS_ ENCODING_ HT</td><td>字典</td></tr><tr><td>REDIS_ ENCODING LINKEDLIST</td><td>双端链表</td></tr><tr><td>REDIS ENCODING ZIPLIST</td><td>压缩列表</td></tr><tr><td>REDIS_ ENCODING_ INTSET</td><td>整数集合</td></tr><tr><td>REDIS ENCODING SKIPLIST</td><td>一秒乎 跳跃表和字典</td></tr></tbody></table><p>Redis 对象采用 <strong>encoding 属性来设置编码</strong>，从而<strong>决定底层数据结构</strong>，而不是为特定类型的对象关联一种固定编码。这种方式极大地提高了灵活性和效率。</p><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串对象可以是 <strong>int，raw</strong> 或 <strong>embstr</strong>。</p><ul><li>如果字符串对象保存的是<strong>整数值</strong>，且这个数值<strong>可用 long</strong> 表示，底层就会以**<code>REDIS_ENCODING_INT</code>**编码来实现。</li><li>如果字符串对象是一个字符串值，且这个字符串长度 <strong>&gt;39 字节</strong>，字符串将使用一个 SDS 保存，底层编码为**<code>REDIS_ENCODING_RAW</code>**。</li><li>如果字符串对象保存的是字符串，且这个字符串长度 <strong>&lt;=39 字节</strong>，底层编码就是**<code>REDIS_ENCODING_EMBSTR</code>**，使用 embstr 编码的方式保存字符串。</li></ul><p><img src="/attachment/1501888fa3da916f257d8d3a1a0378f0.png"></p><h3 id="embstr-编码"><a href="#embstr-编码" class="headerlink" title="embstr 编码"></a>embstr 编码</h3><p>专门用于保存短字符串的一种优化编码方式，与 raw 的效果相同，都使用 redisObject 和 sdshdr 结构来表示字符串对象，但是 raw 会调用两次内存分配函数<strong>分别创建</strong> redisObject 和 sdshdr 结构。embstr 编码则通过调用<strong>一次内存分配</strong>函数来分配一块连续空间，空间依次包括 redisObject 和 sdshdr 俩结构。</p><p>使用 embstr 编码保存短字符串的<strong>优点</strong>：</p><ul><li>内存分配次数由两次降为 <strong>1 次</strong>。</li><li>释放 embstr 字符串对象只需调用 <strong>1 次</strong>内存释放函数。</li><li>embstr 字符串放在一块连续的内存中，能更好地<strong>利用缓存</strong>带来的优势.</li></ul><p>注：<strong>浮点数</strong>的存储，在 Redis 底层也会以<strong>字符串的形式</strong>保存。在有需要时，程序会将字符串对象中的字符串值<strong>转为浮点数值</strong>执行运算操作，然后再将结果<strong>转为字符串值</strong>保存。</p><h3 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h3><p><code>int-&gt;raw</code>：对 int 编码的字符串对象执行后，保存的不再是整数值，而是字符串值时。比如整数追加字符串。</p><p><code>embstr-&gt;raw</code>：Redis 没有为 embstr 编写修改程序，所以是<strong>只读的</strong>，当 embstr 编码的字符串修改后，就变成 raw 编码的字符串对象。</p><h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码是 ziplist 或 linkedlist。</p><p>当列表可以同时满足以下两个条件时，列表对象使用 ziplist 编码：</p><ul><li>列表对象保存的所有字符串元素的长度都 <strong>&lt;64 字节</strong></li><li>列表对象保存的元素数量 <strong>&lt;512 个</strong></li></ul><p>否则使用 linkedlist 编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用 ziplist 编码，执行<code>RPUSH elements "a" "b" 1</code>，后的数据结构：</p><p><img src="/attachment/dac49f238294e9fdd4ae2950a7b5a5a1.png"></p><p><img src="/attachment/b05e06b6cae83ee7373296c304cae12c.png"></p><p>注：SDS 对象都<strong>以 StringObject 代替</strong>。</p><h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是 ziplist 或 hashtable。</p><ul><li>ziplist 的数据结构：每当有新的键值对插入哈希对象时，Redis 会先将保存键的压缩列表节点推入表尾，再将保存值的压缩列表节点推入表尾。</li><li>hashtable 的数据结构：字典的每个键都是一个字符串对象，保存键；字典的每个值都是字符串对象，保存值</li></ul><p>当哈希对象可以同时满足下两个条件时，使用 <strong>ziplist 编码</strong>：</p><ul><li>哈希对象保存的所有键值对的值和键<strong>都 &lt; 64 字节</strong></li><li>哈希对象保存的键值对数量 <strong>&lt;512 个</strong></li></ul><p>否则使用 hashtable 编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用 ziplist 编码，执行<code>HSET student name "madongmei" age 25 career "pick up trash"</code>后的数据结构：</p><p><img src="/attachment/1fd09df94f60829def8f69bba77e198a.png"></p><p><img src="/attachment/fd033b73980ede2dca6483ef6d04610b.png"></p><p>使用 hashtable 编码，执行<code>HSET student name "madongmei" age 25 career "pick up trash"</code>后的数据结构：</p><p><img src="/attachment/2223ec3fe2fc79ba2f7f2757a0682b11.png"></p><h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是 intset 或 hashtable。</p><p>如果以 hashtable 编码作为<strong>集合对象</strong>底层实现，那么字典的每个键都是一个<strong>字符串对象</strong>，值都是 <strong>null</strong>。</p><p>当集合对象同时满足以下两个条件时，使用 intset 编码：</p><ul><li>集合对象保存的所有元素<strong>都是整数值</strong></li><li>集合对象保存的元素数量 <strong>&lt;=512 个</strong></li></ul><p>否则使用 hashtable 编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用 intset 编码，执行<code>SADDnumbers 1 3 5</code>后的数据结构：</p><p><img src="/attachment/3d79a1bd1ad2b7ee7c2fa9cbf2ebfbc0.png"></p><p><img src="/attachment/ca813997ce4625f4814eba4f7683c33a.png"></p><h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是 ziplist 或 skiplist。</p><p>使用 ziplist 编码时，每个元素使用<strong>两个紧挨在一起的压缩列表节点</strong>来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。</p><p><img src="/attachment/7bc280445e09c4a2545ddffece3505f9.png"></p><p><img src="/attachment/c288d2c4f0955eb4c8810448de6966dd.png"></p><p>如果是 skiplist 编码，使用 zset 结构：</p><pre><code class="line-numbers language-c">typedef struct zset{    zskiplist *zsl;    dict *dict;} zset;</code></pre><p>dict 字典为有序集合创建了一个从<strong>成员到分值的映射</strong>，字典中的每个键值对都保存了一个集合元素：键保存元素，值保存分值。通过字典以 <strong>O(1) 查找给定成员的分值</strong>。有序集合元素<strong>都是字符串对象</strong>，分值都是 <strong>double 类型浮点数</strong>。zset 的跳跃表和字典通过指针来<strong>共享相同元素</strong>的成员和分值，<strong>不会浪费</strong>额外内存。</p><p><img src="/attachment/73d576f6cd54160b9e8e4c125d84b776.png"></p><p>当有序集合对象同时满足以下两条件时，对象使用 ziplist 编码：</p><ul><li>有序集合保存的元素数量 <strong>&lt;128 个</strong></li><li>有序集合保存的所有元素成员的长度<strong>都 &lt; 64 字节</strong></li></ul><p>否则使用 skiplist 编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>Redis 中用于操作键的命令可分为两种类型。一种是可对<strong>任何类型执行</strong>的，如 del，expire，rename 等。另一种命令只能对<strong>特定类型的键执行</strong>，如 set，get，hdel，hset，rpush 等。如果对特定类型使用其他类型的命令，那么就会报错。</p><h3 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h3><p>为了确保只有制定类型的键可以执行某些特定命令，在执行前，Redis 会先通过 RedisObject 的 <strong>type 属性检查</strong>输入键的类型是否正确。</p><h3 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h3><p>Redis 除了根据值对象判断键是否能够执行制定命令外，还会根据<strong>值对象的编码方式</strong>，选择正确的命令实现代码来执行。比如基于编码的多态，列表对象的编码可能是 ziplist 或 linkedlist，所以需要<strong>多态命令执行</strong>对应编码的 API。基于类型的多态是<strong>一个命令可以同时处理多种不同类型的键</strong>。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>由于 C 语言没有内存回收机制，Redis 在对象系统中构建了<strong>引用计数器技术</strong>实现内存回收机制。每个对象的引用计数器信息由 redisObject 的 refcount 来记录。当对象的引用计数值<strong>为 0</strong> 时，所占用的内存<strong>会被释放</strong>。</p><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>引用计数器还有共享对象的作用。如果两个不同键的值都一样（必须是整数值的字符串对象），则将数据库键的值指针<strong>指向一个现有的值对象</strong>，然后将被共享对象的引用计数加一。如果不是整数值的对象，则需要耗费大量的时间<strong>验证共享对象和目标对象是否相同</strong>，复杂度较高，消耗 CPU 时间，所以 Redis <strong>不会共享包含字符串的对象</strong>。</p><p>Redis 在初始化服务时，会创建很多字符串对象，包含 0~9999 的整数（和 Integer 的常量池有点像），当需要时，就能直接复用。</p><p><img src="/attachment/9e8e46c883f3f61361adfaed3956397a.png"></p><h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>redisObject 还包含了 lru 属性，记录对象最后一个被命令程序访问的时间。<code>object idletime</code>命令可打印键的空转时长，就是<strong>当前时间减去 lru 时间</strong>计算得到的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 压缩列表</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-ya-suo-lie-biao/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-ya-suo-lie-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-压缩列表"><a href="#【Redis】-压缩列表" class="headerlink" title="【Redis】 压缩列表"></a>【Redis】 压缩列表</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 压缩列表date: 2023-07-09 08:34tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 压缩列表</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>压缩列表是<strong>列表键</strong>和<strong>哈希键</strong>底层实现之一。当一个列表键只包含少量列表项，且每个列表项要么是小整数，要么是长度比较短的字符串，Redis 就使用压缩列表来做列表键的底层实现。</p><p><strong>list</strong></p><p><img src="/attachment/3eea00ed5e6077b39e2e90392a72ddc6.png"></p><p><strong>entry</strong></p><p><img src="/attachment/580fba21935d385bf637c6f27d289871.png"></p><ul><li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li><li>压缩列表被用作列表键和哈希键的底层实现之一。</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</li></ul><h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p>为节约内存而开发的，由一系列<strong>特殊编码</strong>的<strong>连续内存块</strong>组成的<strong>顺序型</strong>数据结构。</p><p>结构比较简单，属性如下：</p><ul><li>zlbytes：记录整个压缩列表占用<strong>内存字节数</strong>，进行内存重分配或计算 zlend 时使用。</li><li>zltail：记录压缩列表尾节点<strong>距离压缩列表起始地址</strong>多少字节。</li><li>zllen：节点数量。小于 65535 时，表示<strong>节点数量</strong>；大于时，需要<strong>遍历</strong>才能计算得出。</li><li>entryx：列表节点。</li><li>zlend：特殊值 0xFF 用于<strong>标记压缩列表的末端</strong>。</li></ul><p><img src="/attachment/3eea00ed5e6077b39e2e90392a72ddc6.png"></p><h2 id="压缩列表节点的组成"><a href="#压缩列表节点的组成" class="headerlink" title="压缩列表节点的组成"></a>压缩列表节点的组成</h2><p><img src="/attachment/580fba21935d385bf637c6f27d289871.png"></p><p>每个压缩列表节点可以是一个<strong>字节数组</strong>，也可以是一个<strong>整数</strong>。由<code>previous_entry_length，encoding，content</code>组成。</p><p><strong>previous_entry_length</strong></p><p>单位是字节，记录压缩列表<strong>前一个节点的长度</strong>。该属性长度为 <strong>1 字节或 5 字节</strong>，前<strong>两位</strong>表示该属性长度为 2 位还是 10 位。</p><ul><li>前一个节点的长度 &lt; 254 字节时，该属性只有 <strong>2 位</strong>，且前一节点的长度就保存在这两位。如 0x05，表示前一个字节长度为 5 字节。</li><li>前一个节点的长度 &gt;=254 字节时，该属性有 <strong>10 位</strong>，且前两位表示这是一个 5 字节的长度，后 8 位表示前一个节点的长度。如 0xFE0000，表示前一个字节长度为 0x00002766，换算为 10 进制就是我们熟悉的数字。</li></ul><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>encoding 记录了节点的 content 属性所保存<strong>数据类型</strong>和<strong>长度</strong>。<strong>高两位</strong>表示存储的是字节数组还是整数。</p><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>存储节点的值。</p><h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>当<strong>多个连续</strong>的长度<strong>介于 250 字节到 253 字节</strong>之间的节点，插入新的头节点（长度大于等于 245 字节），后面节点的 previous_entry_length 就要新增 4 字节的空间（1 字节变成 5 字节），需要进行<strong>内存重分配</strong>，由于前一个节点的变更，每个节点的 previous_entry_length 属性<strong>也需要记录之前的长度而发生相应的变更</strong>，所以会出现连锁更新。除了新增节点，删除节点也可能会遇到这种情况。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行 <strong>N 次空间重分配操作</strong>，每次<strong>重分配的的最坏时间复杂度</strong>为 $O(N)$ ，所以连锁更新的<strong>最坏时间复杂度为</strong> $O(N^2)$</p><p>虽然代价很高，但是出现的<strong>几率比较低</strong>，而且只要更新节点的数量不多，就不会对性能产生影响。因此 ziplistPush 命令的<strong>平均复杂度为</strong> $O(N)$ 。</p><h2 id="压缩列表的时间复杂度"><a href="#压缩列表的时间复杂度" class="headerlink" title="压缩列表的时间复杂度"></a>压缩列表的时间复杂度</h2><table><thead><tr><th>操作 时间复杂度</th><th></th></tr></thead><tbody><tr><td>将新节点插入</td><td>“平均O(N),最坏O(N2)”</td></tr><tr><td>返回给定索引节点</td><td>O(N)</td></tr><tr><td>查找并返回合定值的节点</td><td>“如果是字节数组和整数,检查节点的复杂度为0(N),查找列表的复杂度为O(N2)”</td></tr><tr><td>删除给定节点</td><td>“平均O(N),最坏O(N2)”</td></tr><tr><td>返回节点数量</td><td>“节点数小于65535时为O(1),大于65535时为O(N)”</td></tr></tbody></table><h2 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h2><table><thead><tr><th>函数</th><th>作用</th><th>算法复杂度</th></tr></thead><tbody><tr><td>ziplistNew</td><td>创建一个新的压缩列表</td><td>O(1)</td></tr><tr><td>ziplistPush</td><td>“创建一个包含给定值的新节点,并将这 个新节点添加到压缩列表的表头或者表尾”</td><td>“平均0(N),最坏0(N)”</td></tr><tr><td>ziplistInsert</td><td>将包含给定值的新节点插人到给定节点 之后</td><td>“平均O(N),最坏O(v)”</td></tr><tr><td>ziplistIndex</td><td>返回压缩列表给定索引上的节点</td><td>O(N)</td></tr><tr><td>ziplistFind</td><td>在压缩列表中查找并返回包含了给定值 的节点</td><td>“因为节点的值可能是一个字节数组, 所以检查节点值和给定值是否相同的复 杂度为O(N,而查找整个列表的复杂度 则为0(N)”</td></tr><tr><td>ziplistNext</td><td>返回给定节点的下一个节点</td><td>O(1)</td></tr><tr><td>ziplistPrev</td><td>返回给定节点的前一个节点</td><td>O(1)</td></tr><tr><td>ziplistGet</td><td>获取给定节点所保存的值</td><td>O(1)</td></tr><tr><td>ziplistDelete</td><td>从压缩列表中删除给定的节点</td><td>“平均O(N),最坏O(N)”</td></tr><tr><td>ziplistDeleteRange</td><td>删除压缩列表在给定索引上的连续多个 节点</td><td>“平均O(N),最坏O(v)”</td></tr><tr><td>ziplistBlobLen</td><td>返回压缩列表目前占用的内存字节数</td><td>O(1)</td></tr><tr><td>ziplistLen</td><td>返回压缩列表目前包含的节点数量</td><td>“节点数量小于65535时为0(1),大于 65 535  时为O(N)”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 整数集合</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-zheng-shu-ji-he/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-zheng-shu-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-整数集合"><a href="#【Redis】-整数集合" class="headerlink" title="【Redis】 整数集合"></a>【Redis】 整数集合</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 整数集合date: 2023-07-09 08:33tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 整数集合</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当一个集合只包含整数元素，并且元素不多时，Redis 就会使用整数集合作为集合键的底层实现。</p><p><img src="/attachment/f45179f0b5157cc2a2793a276a7877b8.png"></p><ul><li>整数集合是集合键的底层实现之一。</li><li>整数集合的底层实现为<strong>数组</strong>，这个数组以<strong>有序</strong>、<strong>无重复</strong>的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。</li><li><strong>升级操作</strong>为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。</li><li>整数集合只支持升级操作，不支持降级操作。</li></ul><h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合是 Redis 中用于保存整数值的集合<strong>抽象数据结构</strong>，可以保证集合<strong>有序不重复</strong>。每个<code>intset.h/intset</code>结构来表示一个整数集合：</p><pre><code class="line-numbers language-c">typedef struct intset{    //编码方式    uint32_t encoding;    //集合包含的元素数量    uint32_t length;    //保存元素的数组    int8_t contents[];} intset;</code></pre><p>length 属性记录了整数集合包含的元素数量，contents 是整数集合的底层实现。contents 存储元素的真实类型<strong>取决于 encoding</strong>，比如<code>encoding==INT_ENC_INT16</code>时，contents 数组中每个向都是 int16_t 类型的整数。可以为<code>int16_t</code>,<code>int32_t</code>或<code>int64_t</code>。</p><p><img src="/attachment/f45179f0b5157cc2a2793a276a7877b8.png"></p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>当我们要将一个新元素添加至集合时，并且新元素的类型<strong>比现有集合类型都长</strong>时，整数集合就要升级。</p><p>步骤：</p><ol><li>根据新元素类型，<strong>扩展</strong>数组空间，为新元素分配空间。</li><li>将底层数组现有所有元素<strong>都转为新元素相同类型</strong>，并将类型转换后的元素放到正确位置。</li><li>将新元素<strong>添加</strong>到底层数组。</li></ol><p>由于每次向整数集合添加新元素都<strong>可能会引起升级</strong>，而每次升级都需要对底层数组中已有元素进行类型转换，所以添加的**时间复杂度为 O(N)**。</p><h3 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h3><p>有两个好处，可以提升整数集合的<strong>灵活性</strong>，也能尽可能地<strong>节约内存</strong>。<br>C 语言是静态类型语言，一般数组中的元素类型都相同，使用升级可以<strong>不用担心类型兼容</strong>问题，提升灵活性。元素统一以最大类型存储，而不是都用<code>int64_t</code>，可节约内存。</p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合<strong>不支持降低</strong>，一旦升级就不能降级。</p><h2 id="整数集合的时间复杂度"><a href="#整数集合的时间复杂度" class="headerlink" title="整数集合的时间复杂度"></a>整数集合的时间复杂度</h2><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>给定元素添加到/移出集合</td><td>O(N)</td></tr><tr><td>判断给定元素是否在集合</td><td>“由于有序,可用二分查找,复杂度为O(logN)”</td></tr><tr><td>取出给定索引元素</td><td>0(1)</td></tr></tbody></table><h2 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h2><table><thead><tr><th>函 数</th><th>作 用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>intsetNew</td><td>创建 一个新的压缩列表</td><td>O(1)</td></tr><tr><td>intsetAdd</td><td>将给定元素添加到整数集合里面</td><td>O(N)</td></tr><tr><td>intsetRemove</td><td>从整数集合中移除给定元素</td><td>O(N)</td></tr><tr><td>intsetFind</td><td>检查给定值是否存在于集合</td><td>“因为底层数组有序,查找可以通过二分查找 法来进行,所以复杂度为 0(logN)”</td></tr><tr><td>intsetRandom</td><td>从整数集合中随机返回一个元素</td><td>O(1)</td></tr><tr><td>intsetGet</td><td>取出底层数组在给定索引上的元素</td><td>O(1)</td></tr><tr><td>intsetLen</td><td>返回整数集合包含的元素个数</td><td>0(1)</td></tr><tr><td>intsetBlobLen</td><td>返回整数集合占用的内存字节数</td><td>O(1)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 跳跃表</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-tiao-yue-biao/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-tiao-yue-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-跳跃表"><a href="#【Redis】-跳跃表" class="headerlink" title="【Redis】 跳跃表"></a>【Redis】 跳跃表</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 跳跃表date: 2023-07-09 08:32tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 跳跃表</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>跳跃表是一种<strong>有序</strong>的数据结构，通过在每个节点<strong>维持多个指向其他节点的指针</strong>，达到快速访问节点的目的。</p><p>如果一个有序集合中包含的元素数量比较多，又或者有序集合中元素的成员是较长的字符串，Redis 就会使用跳跃表来作为有序集合键的底层实现。Redis 只有在两个地方用到了跳跃表，一个是实现<strong>有序集合键</strong>，另一个是在<strong>集群节点中</strong>作为内部数据结构。</p><p><img src="/attachment/23fabcfdd5dbe94a3432865cdd9f5c0a.png"></p><ul><li>跳跃表是有序集合的底层实现之一。</li><li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是1至32之间的随机数。</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li></ul><h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><p>Redis 的跳跃表由<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个数据结构定义。</p><pre><code class="line-numbers language-c">typedef struct zskiplist{    //表头节点和表尾节点    structz zskiplistNode *header,* tail;    //表中节点的数量    unsigned long length;    //表中层数最大的节点的层数    int level;} zskiplist;</code></pre><p>跳跃表由 zskiplist 组织，通过多个跳跃表节点 zskiplistNode 组成一个跳跃表。值得注意的是，记录 level 时，表头节点的层高不会记录在内。</p><p><img src="/attachment/23fabcfdd5dbe94a3432865cdd9f5c0a.png"></p><h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><pre><code class="line-numbers language-c">typedef strct zskiplistNode{    //后退指针    struct zskiplistNode *backward;    //分值    double score;    //成员对象    robj *obj;    //层    struct zskiplistlevel{        //前进指针        struct zskiplistNode *forward;        //跨度        unsigned int span;    }level[];} zskiplistNode;</code></pre><h2 id="跳跃表的时间复杂度"><a href="#跳跃表的时间复杂度" class="headerlink" title="跳跃表的时间复杂度"></a>跳跃表的时间复杂度</h2><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>插入新节点和分值</td><td>“平均O(logN),最坏O(N),N为跳跃表长度”</td></tr><tr><td>删除给定成员和分值</td><td>“平均O(logN), 最坏O(N),N为跳跃表长度”</td></tr><tr><td>返回给定成员和分值节点的排位</td><td>“平均O(logN), 最坏O(N),N为跳跃表长度”</td></tr><tr><td>释放给定跳跃表</td><td>“O(N),N为跳跃表的长度”</td></tr><tr><td>删除给定排位范围内节点</td><td>“O(N),N为被删除节点数”</td></tr><tr><td>“给定分值范围,返回是否有节点”</td><td>O(1)</td></tr><tr><td>“给定分值范围,返回第一个符合节点”</td><td>“平均O(logN), 最坏O(N),N为跳跃表长度”</td></tr></tbody></table><h2 id="跳跃表-API"><a href="#跳跃表-API" class="headerlink" title="跳跃表 API"></a>跳跃表 API</h2><table><thead><tr><th>函 数</th><th>作 用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>zslCreate</td><td>创建-一个新的跳跃表</td><td>O(1)</td></tr><tr><td>zslFree</td><td>“释放给定跳跃表,以及表中包含的所有节点”</td><td>“0(N),N为跳跃表的长度”</td></tr><tr><td>zslInsert</td><td>将包含给定成员和分值的新节点添加到跳跃表中</td><td>“平均O(logN),最坏o(M), N为跳跃表长度”</td></tr><tr><td>zslDelete</td><td>删除跳跃表中包含给定成员和分值的节点</td><td>“平均 O(logN),最坏o(N, N为跳跃表长度”</td></tr><tr><td>zslGetRank</td><td>返回包含给定成员和分值的节点在 跳跃表中的排位</td><td>“平均 O(logN),最坏O(N),N为跳跃表长度”</td></tr><tr><td>zslGetElementByRank</td><td>返回跳跃表在给定排位上的节点</td><td>“平均O(logM), 最坏O(N), N为跳跃表长度”</td></tr><tr><td>zslIsInRange</td><td>“给定一个分值范围(range), 比如0 到15, 20到28,诸如此类,如果跳跃表中有至少一个节点的分值在这个范围之内,那么返回1,否则返回0”</td><td>“通过跳跃表的表头节点和表尾节点, 这个检测可以用0(1)复杂度完成”</td></tr><tr><td>zslFirstInRange</td><td>“给定一个分值范围,返回跳跃表中第一个符合这个范围的节点”</td><td>“平均O(logN), 最坏O(M)。N为跳跃表长度”</td></tr><tr><td>zslLastInRange</td><td>“给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点”</td><td>“平均O(logN),最坏0(N)。N为跳跃表长度”</td></tr><tr><td>zslDeleteRangeByScore</td><td>“给定一个分值范围,删除跳跃表中 所有在这个范围之内的节点”</td><td>“O(N),N为被删除节点数量”</td></tr><tr><td>zslDeleteRangeByRank</td><td>“给定一个排位范围,删除跳跃表中 所有在这个范围之内的节点”</td><td>“O(N),N为被删除节点数量”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 字典</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-zi-dian/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-zi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-字典"><a href="#【Redis】-字典" class="headerlink" title="【Redis】 字典"></a>【Redis】 字典</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 字典date: 2023-07-09 08:31tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 字典</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>字典又称<strong>符号表</strong>，<strong>关联数组</strong>或<strong>映射</strong>，用于保存键值对的抽象数据结构。当一个哈希键包含的键值对比较多时，或者键值对中的元素都是比较长的字符串时，Redis 就会使用字典作为哈希键的底层实现。</p><p><img src="/attachment/1586b7cef27e4e6d8d296f5c2e0991b4.png"></p><p>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</p><ul><li>Redis中的字典使用<strong>哈希表</strong>作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</li><li>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</li><li>哈希表使用<strong>链地址法</strong>来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</li><li>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。</li></ul><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis 的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有<strong>多个哈希表节点</strong>，每个哈希表节点保存了字典中的<strong>一个键值对</strong>。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>使用<code>dict.h/dictht</code>结构定义：</p><pre><code class="line-numbers language-c">typedef struct dictht{    //哈希表数组    dictEntry **table;    //哈希表大小    unsigned long size;    //哈希表大小掩码，用于计算索引值    //总是等于size-1    unsigned long sizemask;    //该哈希表已有节点的数量    unsigned long used;}dictht;</code></pre><p>数组中的每个元素都是指向<code>dict.h/dictht</code>的结构，dictEntry 就是一个键值对。</p><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><p>哈希表节点使用 dictEntry 实现，每个 dictEntry 都存储着一个键值对：</p><pre><code class="line-numbers language-c">typedef struct dictEntry{    //键    void *key;    //值    union{        void *val;        uint64_t u64;        int64_t s64;    } v;    //指向下个哈希表节点，形成链表    struct dictEntry *next;} dictEntry;</code></pre><p>键值对的值可以是一个指针，或一个<code>uint64_t</code>整数，或一个<code>int64_t</code>整数。next 是<strong>指向另一个哈希节点的指针</strong>，可将多个<strong>哈希值相同的键值对连接在一起</strong>，以此来解决冲突。</p><p><img src="/attachment/7cb821b75c9e66e619910c5b95838a00.png"></p><p>如图，表示的是两个哈希值相同的节点，通过指针连接在一起。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Redis 中的字典由<code>dict.h/dict</code>实现，由这个数据结构将字典组织在一起。</p><pre><code class="line-numbers language-c">typedef struct dict{    //类型特定函数    dictType *type;    //私有数据    void *privdata;    //哈希表    dictht ht[2];    //rehash索引    //当rehash不在进行时，值为-1    int rehashidx;} dict;</code></pre><p>type 和 privdata 属性是<strong>针对不同类型</strong>的键值对，为丰富键值对的使用场景而设置的。</p><ul><li>type 属性是一个指向 dictType 的结构指针，每个 dictType 结构保存了一簇用于<strong>操作特定类型键值对的函数</strong>，Redis 为用途不同的字典设置不同类型特定函数。</li></ul><pre><code class="line-numbers language-c">typedef struct dictType{    //计算哈希值的函数    unsigned int (*hashFunction)(const void *key);    //复制键的函数    void *(*keyDup)(void *privdata,const void *key)    ...}</code></pre><ul><li>privdata 属性保存了需要传给那些类型特定函数的可选参数。</li><li>ht 属性是包含<strong>两个项</strong>的数组，每项都是一个哈希表，ht[0] 平时使用，而 ht[1] 仅在 rehash 时使用。</li><li>rehashidx 记录了 rehash 的进度，初始为 - 1。</li></ul><p><img src="/attachment/1586b7cef27e4e6d8d296f5c2e0991b4.png"></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>Redis 计算哈希值方法： <code>hash=dict-&gt;type-&gt;hashFunction(key);</code><br>计算索引值的方法：<code>index=hash &amp; dict-&gt;ht[x].sizemask;</code></p><p>当字典被用作数据库的底层实现或哈希键的底层实现时，Redis 使用 <strong>MurmurHash2 算法</strong>来计算键的哈希值。优点在于即使输入的键是有规律的，算法仍然能给出<strong>很好的随机分布性</strong>，并且计算<strong>速度飞快</strong>。</p><h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>当有两个或以上的键被分配到哈希表的<strong>同个索引</strong>，那么就发生了冲突。Redis 使用链地址法来解决冲突，被分配到索引的多个节点<strong>使用链表连接</strong>。为了提高速度，每次都是将新节点添加到链表的<strong>表头</strong>位置。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>为了让哈希表的负载因子维持在一个<strong>合理的范围内</strong>，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行响应的扩容或缩容。扩容和缩容通过执行 rehash 来完成，Redis 中<strong>重新散列的步骤</strong>如下：</p><ol><li>为字典 ht[1] 哈希表<strong>分配空间</strong>，大小取决于要执行的操作与 ht[0] <strong>当前键值对的数量</strong>。</li><li>将保存在 ht[0] 中的所有键值对存放到 ht[1] 指定的位置</li><li>当 ht[0] 的所有键值对都迁移完毕后，<strong>释放 ht[0]<strong>，并</strong>指向</strong> ht[1]，并在 ht[1] 上创建一个空的哈希表，为下次 rehash 准备。</li></ol><h3 id="扩容与缩容场景"><a href="#扩容与缩容场景" class="headerlink" title="扩容与缩容场景"></a>扩容与缩容场景</h3><p>扩容操作场景：</p><ul><li>服务器目前没有在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子 &gt;=1</strong>。</li><li>服务器正在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子 &gt;=5</strong>。</li></ul><p>负载因子 = 哈希表已存储节点数 / 哈希表大小<br><code>load_factor=ht[0].used/ht[0].size</code></p><p>为什么根据**<code>BGSAVE</code><strong>命令或</strong><code>BGREWRITEAOF</code><strong>命令来判断是否扩展？<br>因为执行这些命令时，Redis 需要创建当前服务器进程的</strong>子进程<strong>，大多数操作系统采用</strong>写时复制技术**来优化子进程使用效率，此时提高负载因子，可以尽量避免子进程对哈希表扩展，避免不必要的内存写入操作，节约内存。</p><p>缩容操作场景：<strong>负载因子 &lt; 0.1</strong> 时，<strong>自动</strong>对哈希表执行收缩操作。</p><h2 id="渐进式-rehash-的过程"><a href="#渐进式-rehash-的过程" class="headerlink" title="渐进式 rehash 的过程"></a>渐进式 rehash 的过程</h2><p>rehash 时会将 ht[0] 中所有的键值对 rehash 到 ht[1]，如果键值对很多并且一次性操作的话，容易导致服务器在<strong>一段时间内停止服务</strong>。为避免这种情况，Redis 采用渐进式 rehash，将 ht[0] 中的键值对分多次，<strong>慢慢的 rehash</strong> 到 ht[1] 之中。</p><p>步骤：</p><ol><li>为 ht[1] 分配空间，让字典同时持有两个哈希表。</li><li>在字典中维持一个<strong>索引计数器变量 rehashidx</strong>，将其设置为 0，表示 rehash 正式开始。</li><li>在 rehash 进行期间，每次对字典进行<strong>添加，删除，查找或更新</strong>操作时，程序除了执行指定的操作外，还会将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 **rehash 到 ht[1]**，当 rehash 工作完成后，将 rehashidx++。</li><li>某个时刻，ht[0] 中的所有键值对都被 rehash 至 ht[1]，此时设置 rehashidx=-1 时，表示 rehash 操作已经完成。</li></ol><p>这种方式的 rehash 的好处在于采用了分而治之的方式，将 rehash 键值对所需的<strong>计算工作均摊到对字典的每个操作中</strong>，从而避免集中式 rehash 带来庞大计算量。</p><p>在 rehash 的期间，字典<strong>同时使用</strong> ht[0]，ht[1] 两个哈希表。对哈希表的操作会在两个表上进行，比如查找键时，<strong>先在 ht[0] 里面查找</strong>，如果为空，就<strong>继续到 ht[1] 里查找</strong>。在此期间，新增的键值对<strong>都会被添加到 ht[1]</strong> 中，ht[0] <strong>不承担任何添加</strong>操作，保证 ht[0] 中的键值对只能是<strong>越来越少</strong>。</p><h2 id="字典时间复杂度"><a href="#字典时间复杂度" class="headerlink" title="字典时间复杂度"></a>字典时间复杂度</h2><p>字典相关操作及时间复杂度：</p><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>添加键值对</td><td>O(1)</td></tr><tr><td>返回给定键的值</td><td>O(1)</td></tr><tr><td>删除给定键的值</td><td>“O(N),N为链表长度”</td></tr><tr><td>释放字典</td><td>“O(N),N为字典包含的键值对数”</td></tr></tbody></table><h2 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h2><table><thead><tr><th>函 数</th><th>作 用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>dictCreate</td><td>创建一个新的字典</td><td>O(1)</td></tr><tr><td>dictAdd</td><td>将给定的键值对添加到字典里面</td><td>O(1)</td></tr><tr><td>dictReplace</td><td>“将给定的键值对添加到字典里面,如果键已经 存在于字典,那么用新值取代原有的值”</td><td>0(1)</td></tr><tr><td>dictFetchValue</td><td>返回给定键的值</td><td>O(1)</td></tr><tr><td>dictGetRandomKey</td><td>从字典中随机返回一个键值对</td><td>0(1)</td></tr><tr><td>dictDelete</td><td>从字典中删除给定键所对应的键值对</td><td>0(1)</td></tr><tr><td>dictRelease</td><td>“释放给定字典,以及字典中包含的所有键值对”</td><td>“O(N), N为字典包含的键值对数量”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 链表</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-lian-biao/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-链表"><a href="#【Redis】-链表" class="headerlink" title="【Redis】 链表"></a>【Redis】 链表</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 链表date: 2023-07-09 08:30tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 链表</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当一个列表键包含了数量比较多的元素，或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。</p><p><img src="/attachment/79eb0908ba542e2b75dfdde93b6d7a14.png"></p><ul><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ul><h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><pre><code class="line-numbers language-c">typedef struct listNode{    //前置节点    struct listNode *prev;    //后置节点    struct listNode *next;    //节点的值    void *value;}listNode;</code></pre><p>节点由前驱后继组成，多个节点组成的链表为双端链表。</p><p>使用<code>adlist.h/list</code>来持有，操作链表：</p><pre><code class="line-numbers language-c">typedef struct list{    //表头节点    listNode *head;    //表尾节点    listNode *tail;    //链表所包含的节点数量    unsigned long len;    //节点值复制函数    void *(*dup)(void *ptr);    //节点值释放函数    void (*free)(void *ptr);    //节点值对比函数    int (*match)(void *ptr,void *key);}list;</code></pre><p>整个链表串起来后，如下图：</p><p><img src="/attachment/79eb0908ba542e2b75dfdde93b6d7a14.png"></p><p>Redis 的链表特性可以总结如下：</p><p><strong>双端</strong>：链表节点带有 prev 和 next 指针，获取前置和后置节点的复杂度都是 O(1)。<br><strong>无环</strong>：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点。 带表头指针和表尾指针 带链表长度计数器 。<br><strong>头尾指针</strong>：将程序获取头尾节点的复杂度降为 O(1)。<br><strong>长度计数器</strong>：将程序获取表长的复杂度降为 O(1)。<br><strong>多态</strong>：链表节点使用 void * 指针来保存节点值，并且可以通过 list 结构的<code>dup、free、match</code>为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</p><h2 id="链表时间复杂度"><a href="#链表时间复杂度" class="headerlink" title="链表时间复杂度"></a>链表时间复杂度</h2><p>链表相关操作及时间复杂度：</p><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>返回链表长度/头尾节点/给定节点的前驱后继</td><td>O(1)</td></tr><tr><td>插入新节点到表尾/表头</td><td>O(1)</td></tr><tr><td>删除/查找给定节点</td><td>“0(N),N为链表长度”</td></tr><tr><td>拷贝/释放一个链表</td><td>“0(N),N为链表长度”</td></tr></tbody></table><h2 id="链表-API"><a href="#链表-API" class="headerlink" title="链表 API"></a>链表 API</h2><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>listSetDupMethod</td><td>“将给定的函数设置为链表的节点值复制函数,复制函数可以通过链表的dup 属性直接获得”</td><td>0(1)</td></tr><tr><td>listGetDupMethod</td><td>“返回链表当前正在使用的节点值复制函数”</td><td>0(1)</td></tr><tr><td>listSetFreeMethod</td><td>“将给定的函数设置为链表的节点值释放函数,释放函数可以通过链表的 free 属性直接获得”</td><td>0(1)</td></tr><tr><td>listGetFree</td><td>“返回链表当前正在使用的节点值释放函数”</td><td>0(1)</td></tr><tr><td>listSetMatchMethod</td><td>“将给定的函数设置为链表的节点值对比函数,对比函数可以通过链表的match 属性直接获得”</td><td>O(1)</td></tr><tr><td>listGetMatchMethod</td><td>“返回链表当前正在使用的节点值对比函数”</td><td>0(1)</td></tr><tr><td>listLength</td><td>“返回链表的长度(包含了多少个节点),链表长度可以通过链表的 len 属性直接获得”</td><td>0(1)</td></tr><tr><td>listFirst</td><td>“返回链表的表头节点,表头节点可以通过链表的 head 属性直接获得”</td><td>O(1)</td></tr><tr><td>listLast</td><td>“返回链表的表尾节点,表尾节点可以通过链表的 tail 属性直接获得”</td><td>O(1)</td></tr><tr><td>listPrevNode</td><td>“返回给定节点的前置节点,前置节点可以通过节点的prev 属性直接获得”</td><td>0(1)</td></tr><tr><td>listNextNode</td><td>“返回给定节点的后置节点,后置节点可以通过节点的next 属性直接获得”</td><td>0(1)</td></tr><tr><td>listNodeValue</td><td>“返回给定节点目前正在保存的值,节点值可以通过节点的value 属性直接获得”</td><td>O(1)</td></tr><tr><td>listCreate</td><td>“创建一个不包含任何节点的新链表”</td><td>O(1)</td></tr><tr><td>listAddNodeHead</td><td>将一个包含给定值的新节点添加到给定链表 的表头</td><td>O(1)</td></tr><tr><td>listAddNodeTail</td><td>将一个包含给定值的新节点添加到给定链表 的表尾</td><td>0(1)</td></tr><tr><td>listInsertNode</td><td>将一个包含给定值的新节点添加到给定节点 的之前或者之后</td><td>0(1)</td></tr><tr><td>listSearchKey</td><td>查找并返回链表中包含给定值的节点</td><td>“O(N),N为链表长度”</td></tr><tr><td>listIndex</td><td>返回链表在给定索引上的节点</td><td>“O(M),N为链表长度”</td></tr><tr><td>listDelNode</td><td>从链表中删除给定节点</td><td>“O(M),N为链表长度”</td></tr><tr><td>listRotate</td><td>“将链表的表尾节点弹出,然后将被弹出的节 点插人到链表的表头,成为新的表头节点”</td><td>O(1)</td></tr><tr><td>listDup</td><td>复制一个给定链表的副本</td><td>“O(N),N为链表长度”</td></tr><tr><td>listRelease</td><td>“释放给定链表,以及链表中的所有节点”</td><td>“O(M),N为链表长度”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 简单动态字符串</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-jian-dan-dong-tai-zi-fu-chuan/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-jian-dan-dong-tai-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-简单动态字符串"><a href="#【Redis】-简单动态字符串" class="headerlink" title="【Redis】 简单动态字符串"></a>【Redis】 简单动态字符串</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 简单动态字符串date: 2023-07-09 08:28tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 简单动态字符串</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 中，涉及可以被修改的字符串值时，都用<strong>简单动态字符串</strong>（simple dynamic string，SDS）来实现。比如包含字符串值的键值对在底层的实现。C 字符串（C 语言中传统字符串，以空字符串结尾的字符数组）则用于<strong>无须对字符串进行修改</strong>的地方，比如日志打印。</p><p>SDS 还被用作缓冲区，比如 AOF 模块中的 AOF 缓冲区，客户端状态中的输入缓冲区。</p><p><img src="/attachment/48f6554b6d64116a146df63a9cd88017.png"></p><p>Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。</p><p>比起C字符串，SDS具有以下<strong>优点</strong>：</p><ol><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出。</li><li>减少修改字符串长度时所需的内存重分配次数。</li><li>二进制安全。</li><li>兼容部分C字符串函数。</li></ol><h2 id="SDS-定义"><a href="#SDS-定义" class="headerlink" title="SDS 定义"></a>SDS 定义</h2><pre><code class="line-numbers language-c">struct sdshdr{    //buf已使用的字节数    int len;    //buf未使用的字节数    int free;    //字节数组，用于保存字符串    char buf[];}</code></pre><p>buf 遵循 C 字符串以空字符串结尾的惯例，保存空字符串的 1 字节空间不计算在 SDS 的 len 属性里面，并为空字符分配<strong>额外 1 字节</strong>空间，对用户来说是透明的。</p><p><img src="/attachment/48f6554b6d64116a146df63a9cd88017.png"></p><p>如中展示了 SDS 的数据结构，5 字节未使用空间，已使用 5 字节，buf 存储了字符串值，最后一个字节保存了空字符<code>'\0'</code>。这里要注意的是，free 和 len 的计算不涉及空字符。</p><h2 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h2><ol><li>SDS 有<strong>常数级的时间复杂度</strong>获取字符串长度。<br> 由于 C 字符串不会记录自身长度，因此只能遍历，直到遇到结尾的空字符为止, 时间复杂度为 O(N)。而 SDS 对于字符串长度的记录都是在其 API 中执行的，所以时间复杂度为 **O(1)**。</li><li>SDS <strong>杜绝缓冲区溢出。</strong><br> 由于 C 字符串未记录自身长度，容易导致缓冲区溢出。在执行字符串拼接时，如果没有足够的空间，并且相邻内存地址被其他字符串占用时，字符串的<strong>数据将溢出</strong>，且容易<strong>意外修改相邻的字符串内容</strong>。相比而言，SDS 会将这种情况扼杀在摇篮之中，SDS API 先判断<strong>空间是否满足</strong>，如果不满足则将空间<strong>扩展至执行修改所需的大小</strong>。</li><li>SDS 拥有<strong>内存分配策略</strong>，详见 1.3。</li><li>SDS API 都是<strong>二进制安全</strong>的。<br>C 字符串的字符<strong>必须符合某种编码</strong>，并且中间<strong>不能</strong>有空字符，否则读取时会被误以为是字符串结尾。种种局限使得 C 字符串只能存文本，不能存图片，音频，视频，压缩文件等二进制数据。 为确保 Redis 对不同使用场景的支持，SDS API 都是二进制安全的，也就是所有 SDS API 都会以<strong>二进制的方式</strong>存取 buf 中的数据，数据的写入和读出都是一个样的。由于 SDS 读取时并不是依靠空字符来判断结束的，而是 <strong>len 属性</strong>，所以是二进制安全的。</li><li><strong>兼容部分 C 字符串函数</strong>。<br> SDS 虽然都是二进制安全的，但也<strong>遵循以空字符结尾</strong>的习惯。SDS API 总会在 buf 数组分配空间时多分配一个字节用于容纳空字符，这是为了保存文本的 SDS <strong>重用一部分</strong> &lt;string.h&gt; 库函数，避免代码重复。</li></ol><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>由于 C 字符并<strong>不记录</strong>自身长度，并且需要一个字符空间保存空字符串，因此每次增长或缩短字符串时，就要对其进行一次<strong>内存重分配</strong>操作。增长字符串时要看空间是否够用，否则会有<strong>缓冲区溢出</strong>；缩短字符串要释放不用的空间，否则会有<strong>内存泄漏</strong>。</p><p>Redis 经常被用于速度要求严苛，数据被频繁修改的场合，每次修改字符串都要重新分配内存，就会占用很多时间。为避免这个问题，redis 采用了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略。</p><h3 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h3><p>空间预分配用于优化 SDS 字符串<strong>增长操作</strong>。在扩展 SDS 空间前，SDS API 会先检查未使用空间够不够，如果不够，则进行空间预分配。此时，程序不仅会为 SDS 分配修改所必须要的空间，还为其分配额外未使用的空间。</p><ul><li>修改后的 SDS&lt;1MB，程序分配和 len 属性<strong>同样大小</strong>的未使用空间，此时 SDS 的 len 与 free 大小相等。比如修改后实际存储字符串的空间变为 13 字节，那么 len=13，free=13，buf 数组整体的长度 = 13+13+1（额外 1 字节保存空字符）。</li><li>修改后 SDS&gt;=1MB。程序会分配 <strong>1MB</strong> 的未使用空间。比如修改后实际存储字符串的空间变为 2MB，那么 len=2M，free=1MB，buf 数组整体的长度 = 2MB+1MB+1byte。</li></ul><p>通过空间的预分配，将<strong>连续增长 N 次字符串需要的内存分配次数</strong>从一定需要 N 次变为<strong>最多 N 次</strong>。因而可以减少连续执行字符串增长操作所需的内存重分配的次数。</p><h3 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h3><p>惰性空间的释放用于优化 SDS 字符串<strong>缩短操作</strong>。当 SDS API 需要缩短保存的字符串时，程序并不立即回收这部分内存，而是使用 free 属性将字节的数量记录，等待使用。与此同时，SDS 提供了相关 API，在有需要时，<strong>真正释放</strong>未使用空间，不需要担心惰性空间造成的内存浪费。</p><p>C 字符串与 SDS 的区别简单来说：</p><table><thead><tr><th>C字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>“API是不安全的,可能会造成缓冲区溢出”</td><td>API是安全的,不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度N次必然需要执行N次重分配</td><td>修改字符串长度N次最多需要执行N次重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本或二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h2 id="SDS-时间复杂度"><a href="#SDS-时间复杂度" class="headerlink" title="SDS 时间复杂度"></a>SDS 时间复杂度</h2><p>SDS 相关操作及时间复杂度：</p><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>创建/释放/拷贝一个的SDS</td><td>“O(N),N为C字符串长度”</td></tr><tr><td>清空SDS内容</td><td>“情性空闫释放,O(1)”</td></tr><tr><td>给定C字符率拼接到SDS尾部</td><td>“O(N),N为被拼接字符串长度”</td></tr></tbody></table><h2 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h2><table><thead><tr><th>函 数</th><th>作 用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>sdsnew</td><td>创建一个包含给定C字符串的 SDS</td><td>“O(N),N为给定C字符串的长度”</td></tr><tr><td>sdsempty</td><td>创建一个不包含任何内容的空 SDS</td><td>O(1)</td></tr><tr><td>sdsfree</td><td>释放给定的 SDS</td><td>“O(M),N为被释放SDS的长度”</td></tr><tr><td>sdslen</td><td>返回SDS的已使用空间字节数</td><td>“这个值可以通过读取 SDS 的len属性来 直接获得,复杂度为 0(1)”</td></tr><tr><td>sdsavail</td><td>返回SDS 的未使用空间字节数</td><td>“这个值可以通过读取 SDS 的free属性 来直接获得,复杂度为 0(1)”</td></tr><tr><td>sdsdup</td><td>创建一个给定 SDS的副本( copy )</td><td>“O(M),N为给定 SDS的长度”</td></tr><tr><td>sdsclear</td><td>清空SDS保存的字符串内容</td><td>“因为惰性空间释放策略,复杂度为O(1)”</td></tr><tr><td>sdscat</td><td>将给定C字符串拼接到SDS字符串的末尾</td><td>“O(M),N为被拼接C字符串的长度”</td></tr><tr><td>sdscatsds</td><td>将给定SDS字符串拼接到另一个SDS字符串 的末尾</td><td>“O(N),N为被拼接SDS字符串的长度”</td></tr><tr><td>sdscpy</td><td>“将给定的C字符串复制到 SDS里面,覆盖 SDS原有的字符串”</td><td>“O(M),N为被复制C字符串的长度”</td></tr><tr><td>sdsgrowzero</td><td>用空字符将SDS扩展至给定长度</td><td>“O(N),N为扩展新增的字节数”</td></tr><tr><td>sdsrange</td><td>“保留SDS给定区间内的数据,不在区间内的 数据会被覆盖或清除”</td><td>“O(N),N为被保留数据的字节数”</td></tr><tr><td>sdstrim</td><td>“接受一个SDS和一个C字符串作为参数,从 SDS中移除所有在C字符串中出现过的字符”</td><td>“O(N),N为给定C字符串的长度”</td></tr><tr><td>sdscmp</td><td>对比两个SDS字符串是否相同</td><td>“O(M),N为两个SDS 中较短的那个 SDS 的长度”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 多机库的实现</title>
      <link href="/database/redis/redis-duo-ji-ku-de-shi-xian/redis-duo-ji-ku-de-shi-xian/"/>
      <url>/database/redis/redis-duo-ji-ku-de-shi-xian/redis-duo-ji-ku-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-多机库的实现"><a href="#【Redis】-多机库的实现" class="headerlink" title="【Redis】 多机库的实现"></a>【Redis】 多机库的实现</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 多机库的实现date: 2023-07-09 07:59tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 多机库的实现</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/850d61c882123d73b0f6f251e3ef9025.png"></p><ul><li>复制（同步，命令传播，SYNC，PSYNC 实现，心跳检测）</li><li>Sentinel 机制（启动并初始化，获取主从信息，发送 / 接收频道消息，下线检测，故障转移）</li><li>cluster 集群（节点数据结构，槽指派，命令执行，重新分片，ASK 错误，故障转移，消息）</li></ul><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>undefined</p><p>undefined</p><h2 id="Sentinel-机制"><a href="#Sentinel-机制" class="headerlink" title="Sentinel 机制"></a>Sentinel 机制</h2><p>undefined</p><p>undefined</p><h2 id="cluster-集群"><a href="#cluster-集群" class="headerlink" title="cluster 集群"></a>cluster 集群</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 单机库的实现</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-dan-ji-ku-de-shi-xian/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-dan-ji-ku-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-单机库的实现"><a href="#【Redis】-单机库的实现" class="headerlink" title="【Redis】 单机库的实现"></a>【Redis】 单机库的实现</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 单机库的实现date: 2023-07-08 23:28tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 单机库的实现</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/0f7624ac6815ad0d822a4e791f52731e.png"></p><ul><li>数据库（数据库实现，键空间实现，过期键操作，删除策略，通知）</li><li>RDB 持久化（载入与创建，间隔性保存原理，文件结构）</li><li>AOF 持久化（实现，载入与数据还原，AOF 重写）</li><li>事件（文件事件，I/O 多路复用的实现，时间事件，serverCron 函数，调度与执行）</li><li>客户端（属性，创建与关闭）</li><li>服务器（初始化过程，命令执行过程）</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>undefined</p><p>undefined</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>undefined</p><p>undefined</p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>undefined</p><p>undefined</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>undefined</p><p>undefined</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>undefined</p><p>undefined</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 Redis 数据结构与对象</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-shu-ju-jie-gou-yu-dui-xiang/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-shu-ju-jie-gou-yu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-Redis-数据结构与对象"><a href="#【Redis】-Redis-数据结构与对象" class="headerlink" title="【Redis】 Redis 数据结构与对象"></a>【Redis】 Redis 数据结构与对象</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 Redis 数据结构与对象date: 2023-07-08 20:57tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 Redis 数据结构与对象</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/b6b17135ab87241a042e726ff6ea516d.png"></p><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>undefined</p><p>undefined</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>undefined</p><p>undefined</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>undefined</p><p>undefined</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>undefined</p><p>undefined</p><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>undefined</p><p>undefined</p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>undefined</p><p>undefined</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 阻塞队列DelayedWorkQueue</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-zu-sai-dui-lie-delayedworkqueue/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-zu-sai-dui-lie-delayedworkqueue/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-阻塞队列DelayedWorkQueue"><a href="#【Java-多线程并发】-阻塞队列DelayedWorkQueue" class="headerlink" title="【Java 多线程并发】 阻塞队列DelayedWorkQueue"></a>【Java 多线程并发】 阻塞队列DelayedWorkQueue</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 阻塞队列DelayedWorkQueuedate: 2023-07-05 12:58tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 阻塞队列DelayedWorkQueue</code></pre><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线程池运行时，会不断从任务队列中获取任务，然后执行任务。如果我们想实现延时或者定时执行任务，重要一点就是任务队列会根据任务延时时间的不同进行排序，延时时间越短的就排在队列的前面，先被获取执行。</p><p>队列是先进先出的数据结构，就是先进入队列的数据，先被获取。但是有一种特殊的队列叫做优先级队列，它会对插入的数据进行优先级排序，保证优先级越高的数据首先被获取，与数据的插入顺序无关。</p><p>实现优先级队列高效常用的一种方式就是使用堆。</p><h2 id="ScheduledThreadPoolExecutor线程池"><a href="#ScheduledThreadPoolExecutor线程池" class="headerlink" title="ScheduledThreadPoolExecutor线程池"></a>ScheduledThreadPoolExecutor线程池</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以其内部的数据结构和ThreadPoolExecutor基本一样，并在其基础上增加了按时间调度执行任务的功能，分为延迟执行任务和周期性执行任务。</p><p>ScheduledThreadPoolExecutor的构造函数只能传3个参数corePoolSize、ThreadFactory、RejectedExecutionHandler，默认maximumPoolSize为Integer.MAX_VALUE。</p><p>工作队列是高度定制化的延迟阻塞队列DelayedWorkQueue，其实现原理和DelayQueue基本一样，核心数据结构是二叉最小堆的优先队列，队列满时会自动扩容，所以offer操作永远不会阻塞，maximumPoolSize也就用不上了，所以线程池中永远会保持至多有corePoolSize个工作线程正在运行。</p><pre><code class="line-numbers language-java">public ScheduledThreadPoolExecutor(int corePoolSize,                                   ThreadFactory threadFactory,                                   RejectedExecutionHandler handler) {    // 调用父类ThreadPoolExecutor的构造方法来创建定时任务线程池    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue(), threadFactory, handler); // 传入DelayedWorkQueue阻塞队列}</code></pre><h2 id="DelayedWorkQueue延迟阻塞队列"><a href="#DelayedWorkQueue延迟阻塞队列" class="headerlink" title="DelayedWorkQueue延迟阻塞队列"></a>DelayedWorkQueue延迟阻塞队列</h2><p><img src="/attachment/0ae74fa0f8f40eb7a116ad968d9b0900.png"></p><p>DelayedWorkQueue 也是一种设计为定时任务的延迟队列，它的实现和DelayQueue一样，不过是将优先级队列和DelayQueue的实现过程迁移到本身方法体中，从而可以在该过程当中灵活的加入定时任务特有的方法调用。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，是因为 ScheduleThreadPoolExecutor 要求的工作队列有些特殊。</p><p>DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面（注意：<mark style="background: #FFB8EBA6;">这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的</mark>）。</p><p>堆结构如下图：</p><p><img src="/attachment/63d9e47e647b424426dc32422e56110e.png"></p><p>可见，DelayedWorkQueue是一个基于最小堆结构的队列。堆结构可以使用数组表示，可以转换成如下的数组：</p><p><img src="/attachment/b7819846345fdfc2a1d37a3309bbeb6c.png"></p><p>在这种结构中，可以发现有如下特性： 假设“第一个元素” 在数组中的索引为 0 的话，则父结点和子结点的位置关系如下：</p><ul><li>索引为  的左孩子的索引是 (2 * i + 1)；</li><li>索引为  的右孩子的索引是 (2 * i + 2)；</li><li>索引为  的父结点的索引是 floor((i−1)/2)；</li></ul><p>为什么要使用DelayedWorkQueue呢？</p><ul><li>定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。</li><li>DelayedWorkQueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code class="line-numbers language-java">static class DelayedWorkQueue extends AbstractQueue&lt;Runnable&gt;        implements BlockingQueue&lt;Runnable&gt; {         /*         * A DelayedWorkQueue is based on a heap-based data structure         * like those in DelayQueue and PriorityQueue, except that         * every ScheduledFutureTask also records its index into the         * heap array. This eliminates the need to find a task upon         * cancellation, greatly speeding up removal (down from O(n)         * to O(log n)), and reducing garbage retention that would         * otherwise occur by waiting for the element to rise to top         * before clearing. But because the queue may also hold         * RunnableScheduledFutures that are not ScheduledFutureTasks,         * we are not guaranteed to have such indices available, in         * which case we fall back to linear search. (We expect that         * most tasks will not be decorated, and that the faster cases         * will be much more common.)         *         * All heap operations must record index changes -- mainly         * within siftUp and siftDown. Upon removal, a task's         * heapIndex is set to -1. Note that ScheduledFutureTasks can         * appear at most once in the queue (this need not be true for         * other kinds of tasks or work queues), so are uniquely         * identified by heapIndex.         */          /* 借助Google翻译：        DelayedWorkQueue基于堆的数据结构，如DelayQueue和PriorityQueue中的数据结构，除了每个        ScheduledFutureTask还将其索引记录到堆数组中。这消除了在取消时找到任务的需要，大大加快了移除（从        O（n）到O（log n）），并减少了垃圾保留，否则通过等待元素在清除之前升至顶部而发生垃圾保留。但是因为        队列也可能包含不是ScheduledFutureTasks的RunnableScheduledFutures，所以我们不能保证有这样的索引可        用，在这种情况下我们会回到线性搜索。 （我们希望大多数任务都不会被装饰，而且更快的情况会更常见。）        所有堆操作都必须记录索引更改 - 主要在siftUp和siftDown中。删除后，任务的heapIndex设置为-1。请注        意，ScheduledFutureTasks最多可以出现在队列中一次（对于其他类型的任务或工作队列，这不一定是这样），        因此由heapIndex唯一标识。*/</code></pre><p>DelayedWorkQueue 的类继承关系如下：</p><p>undefined</p><p>其包含的方法定义如下：</p><p><img src="/attachment/69de2bd87a9433f04b6ffb92e364c3bf.png"></p><h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><pre><code class="line-numbers language-java">// 初始时，数组长度大小。private static final int INITIAL_CAPACITY = 16;        // 使用数组来储存队列中的元素,根据初始容量创建RunnableScheduledFuture类型的数组private RunnableScheduledFuture&lt;?&gt;[] queue =  new RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];        // 使用ReentrantLock来保证多线程并发安全问题。private final ReentrantLock lock = new ReentrantLock();        // 队列中储存元素的大小private int size = 0;        // 特指队列头任务所在leader线程。也就是等待要去执行队列头任务的线程private Thread leader = null;        // 当队列头的任务延时时间到了，或者新线程可能需要成为leader，用来唤醒等待线程private final Condition available = lock.newCondition();</code></pre><p>DelayedWorkQueue是用数组来储存队列中的元素，数组类型为RunnableScheduledFuture，其实就类似于Runnable，只不过加了一些定时任务的属性，核心数据结构是二叉最小堆的优先队列，队列满时会自动扩容。</p><p>数组类型是一个接口，本质的实现还是Runnable：</p><pre><code class="line-numbers language-java">public interface RunnableScheduledFuture&lt;V&gt; extends RunnableFuture&lt;V&gt;, ScheduledFuture&lt;V&gt; {    // 该任务是否是周期性的    boolean isPeriodic();}</code></pre><p>对于多线程的网络模型来说：所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>DelayedWorkQueue 是 ScheduledThreadPoolExecutor 的静态类部类，默认只有一个无参构造方法。</p><pre><code class="line-numbers language-java">static class DelayedWorkQueue extends AbstractQueue&lt;Runnable&gt;        implements BlockingQueue&lt;Runnable&gt; {    // ...}</code></pre><h3 id="入队方法"><a href="#入队方法" class="headerlink" title="入队方法"></a>入队方法</h3><pre><code class="line-numbers language-java">public void put(Runnable e) {    offer(e);}        public boolean add(Runnable e) {                return offer(e);}   // timeout和unit两个参数并没有用public boolean offer(Runnable e, long timeout, TimeUnit unit) {                return offer(e);}</code></pre><p>DelayedWorkQueue 提供了三个插入元素方法：</p><ul><li>put(e)</li><li>add(e)</li><li>offer(e, t, u)</li></ul><p>通过源码我们发现与普通阻塞队列相比，这三个添加方法都是调用 offer 方法。那是因为它没有队列已满的条件，也就是说可以不断地向 DelayedWorkQueue 添加元素，当元素个数超过数组长度时，会进行数组扩容。</p><h4 id="offer添加元素"><a href="#offer添加元素" class="headerlink" title="offer添加元素"></a>offer添加元素</h4><p>ScheduledThreadPoolExecutor提交任务时调用的是DelayedWorkQueue.add，而add、put等一些对外提供的添加元素的方法都调用了offer。</p><pre><code class="line-numbers language-java">public boolean offer(Runnable x) {                if (x == null)                        throw new NullPointerException();       // 将要加入队列的任务转换为RunnableScheduledFuture类型，因为存储任务的堆数组就是这个类型    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;) x;    // 使用lock保证并发操作安全    final ReentrantLock lock = this.lock;    // 加锁    lock.lock();                try {            // 获取当前队列中有多少个元素                    int i = size;                        // 如果要超过数组长度，就要进行数组扩容        if (i &gt;= queue.length)                                // 数组扩容            grow();                        // 将队列中元素个数加一        size = i + 1;                        // 如果是第一个元素，那么就不需要排序，直接赋值就行了        if (i == 0) {            queue[0] = e;            setIndex(e, 0);        } else {                                // 调用siftUp方法，使插入的元素变得有序。            siftUp(i, e);        }                        // 表示新插入的元素是队列头，那么就要唤醒正在等待获取任务的线程来获取这个队列头中的任务        if (queue[0] == e) {            // 准备设置新的队列头            leader = null;                                // 唤醒正在等待获取任务的线程            available.signal();        }    } finally {        // 释放锁        lock.unlock();    }          // 成功入队则返回true          return true;}</code></pre><p>其基本流程如下：</p><ol><li>其作为生产者的入口，首先获取锁。</li><li>判断队列是否要满了（size &gt;= queue.length），满了就扩容grow()。</li><li>队列未满，size+1。</li><li>判断添加的元素是否是队列中的第一个元素，是则不需要堆化。</li><li>添加的元素不是队列中第一个元素，则需要堆化siftUp。</li><li>如果堆顶元素刚好是此时被添加的元素，则唤醒take线程来消费队列中的任务。</li><li>最终释放锁。</li></ol><p><strong>offer基本流程图如下：</strong></p><p><img src="/attachment/62140b4230c55ae3520ed701cc1becb8.png"></p><h4 id="扩容grow"><a href="#扩容grow" class="headerlink" title="扩容grow()"></a>扩容grow()</h4><p>可以看到，当队列满时，不会阻塞等待，而是继续扩容。新容量newCapacity在旧容量oldCapacity的基础上扩容50%（oldCapacity &gt;&gt; 1相当于oldCapacity /2）。最后Arrays.copyOf（将旧数组拷贝到一块新的数组空间中），Arrays.copyOf的作用就是先根据newCapacity创建一个新的空数组，然后将旧数组的数据复制到新数组中。</p><pre><code class="line-numbers language-java">private void grow() {                int oldCapacity = queue.length;                // 每次扩容增加原来数组的一半数量。    // grow 50%    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);     if (newCapacity &lt; 0) // overflow        newCapacity = Integer.MAX_VALUE;                // 使用Arrays.copyOf来复制一个新数组    queue = Arrays.copyOf(queue, newCapacity);}</code></pre><h4 id="向上堆化siftUp"><a href="#向上堆化siftUp" class="headerlink" title="向上堆化siftUp"></a>向上堆化siftUp</h4><p>新添加的元素先会加到堆底，然后一步步和上面的父亲节点比较，若小于父亲节点则和父亲节点互换位置，循环比较直至大于父亲节点才结束循环。通过循环，来查找元素key应该插入在堆二叉树哪个节点位置，并交互父节点的位置。</p><pre><code class="line-numbers language-java">private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) {                // 当k==0时，就到了堆二叉树的根节点了，跳出循环    while (k &gt; 0) {                        // 父节点位置坐标, 相当于(k - 1) / 2        int parent = (k - 1) &gt;&gt;&gt; 1;                        // 获取父节点位置元素        RunnableScheduledFuture&lt;?&gt; e = queue[parent];                        // 如果key元素大于父节点位置元素，满足条件，那么跳出循环        // 因为是从小到大排序的。        if (key.compareTo(e) &gt;= 0)                                break;                        // 否则就将父节点元素存放到k位置        queue[k] = e;                        // 这个只有当元素是ScheduledFutureTask对象实例才有用，用来快速取消任务。        setIndex(e, k);                        // 重新赋值k，寻找元素key应该插入到堆二叉树的那个节点        k = parent;    }                // 循环结束，k就是元素key应该插入的节点位置    queue[k] = key;    // 将key插入到k位置    setIndex(key, k);}</code></pre><p>代码很好理解，就是循环的根据key节点与它的父节点来判断，如果key节点的执行时间早于父节点，则将两个节点交换，使执行时间靠前的节点排列在队列的前面。</p><p>可见，每次新增节点时，只是根据父节点来判断，而不会影响兄弟节点。</p><h3 id="出队方法"><a href="#出队方法" class="headerlink" title="出队方法"></a>出队方法</h3><p>DelayedWorkQueue 提供了以下几个出队方法</p><ul><li>take()，等待获取队列头元素</li><li>poll() ，立即获取队列头元素</li><li>poll(long timeout, TimeUnit unit) ，超时等待获取队列头元素</li></ul><h4 id="take-消费元素"><a href="#take-消费元素" class="headerlink" title="take() 消费元素"></a>take() 消费元素</h4><p>Worker工作线程启动后就会循环消费工作队列中的元素，因为ScheduledThreadPoolExecutor的keepAliveTime=0，所以消费任务其只调用了DelayedWorkQueue.take。take()方法的基本流程如下：</p><ol><li>首先获取可中断锁，判断堆顶元素是否是空，空的则阻塞等待available.await()。</li><li>堆顶元素不为空，则获取其延迟执行时间delay，delay &lt;= 0说明到了执行时间，出队列finishPoll()。</li><li>delay &gt; 0还没到执行时间，判断leader线程是否为空，不为空则说明有其他take线程也在等待，当前take线程将无限期阻塞等待。</li><li>leader线程为空，当前take线程设置为leader，并阻塞等待delay时长。</li><li>当前leader线程等待delay时长自动唤醒或者被其他take线程唤醒，则最终将leader设置为null。</li><li>再循环一次判断delay &lt;= 0出队列。</li><li>跳出循环后判断leader为空并且堆顶元素不为空，则唤醒其他take线程，最后是否锁。</li></ol><pre><code class="line-numbers language-java">public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException {                final ReentrantLock lock = this.lock;    lock.lockInterruptibly();                try {          // 自旋，只有任务到了要执行的时间才将任务出队返回                      for (;;) {            RunnableScheduledFuture&lt;?&gt; first = queue[0];                                // 如果没有任务，就让线程在available条件下等待。            if (first == null)                available.await();                                else {                                        // 获取任务的剩余延时时间                long delay = first.getDelay(NANOSECONDS);                                        // 如果延时时间到了，就返回这个任务，用来执行。                if (delay &lt;= 0)                                                return finishPoll(first);                                        // 如果任务还没有到时间，则将first设置为null，当线程等待时，不持有first的引用                first = null; // don't retain ref while waiting                                         // 如果前面有线程在等待，当前线程直接进入等待状态                if (leader != null)                    // 条件锁                    available.await();                      // 如果前面没有有线程在等待                else {                                                // 记录一下当前等待队列头任务的线程                    Thread thisThread = Thread.currentThread();                       // 将当前线程作为leader                    leader = thisThread;                                                try {                                                        // 当任务的延时时间到了时，能够自动超时唤醒。                        available.awaitNanos(delay);                    } finally {                                                                    // 唤醒后再次获得锁后把leader再置空                             if (leader == thisThread)                            leader = null;                    }                }            }        }    } finally {          // 唤醒等待任务的线程                      if (leader == null &amp;&amp; queue[0] != null)                                available.signal();        ock.unlock();    }}</code></pre><p><strong>take基本流程图如下：</strong></p><p><img src="/attachment/4ec69962afbe8dc1945545829fc776da.png"></p><p>take线程阻塞等待：</p><p>可以看出这个生产者take线程会在两种情况下阻塞等待：</p><ul><li>堆顶元素为空。</li><li>堆顶元素的delay &gt; 0 。</li></ul><p><strong>take方法是什么时候调用的呢？</strong></p><p>在ThreadPoolExecutor中，getTask方法，工作线程会循环地从workQueue中取任务。但定时任务却不同，因为如果一旦getTask方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在take方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p><p><strong>leader线程</strong></p><p>再来说一下leader的作用，这里的leader是为了减少不必要的定时等待。leader线程的设计，是Leader-Follower模式的变种，旨在于为了不必要的时间等待。当一个take线程变成leader线程（可以最先拿到队列中弹出任务去执行的线程）时，只需要等待下一次的延迟时间，而不是leader线程的其他take线程则需要等leader线程拿到队列中任务后，才唤醒其他take线程，其他的take线程唤醒后再去争抢锁，谁抢到锁了，谁就是新的leader线程。</p><p>举例来说，如果没有leader，那么在执行take时，所有的线程都要执行available.awaitNanos(delay)，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。多个线程执行该段代码是没有作用的，因为只能有一个线程会从take中返回queue[0]（因为有lock），其他线程这时再返回for循环执行时取的queue[0]，已经不是之前的queue[0]了，然后又要继续阻塞。</p><p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在finally中调用了signal()来唤醒一个线程，而不是signalAll()）。也就是说我们保证只会有一个线程在等待队列中的任务出队即可，其他的线程直接全部阻塞，当第一个线程成功获取到队列中的任务后再去唤醒其他的线程，来成为新的leader线程。</p><h4 id="finishPoll-出队列"><a href="#finishPoll-出队列" class="headerlink" title="finishPoll() 出队列"></a>finishPoll() 出队列</h4><p>堆顶元素delay&lt;=0，执行时间到，出队列就是一个向下堆化的过程siftDown。</p><pre><code class="line-numbers language-java">// 移除队列头元素private RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) {                // 将队列中元素个数减一    int s = --size;                // 获取队列末尾元素x    RunnableScheduledFuture&lt;?&gt; x = queue[s];                // 原队列末尾元素设置为null    queue[s] = null;                if (s != 0)                        // 因为移除了队列头元素，所以进行重新排序。        siftDown(0, x);    setIndex(f, -1);                return f;}</code></pre><p>堆的删除方法主要分为三步：</p><ol><li>先将队列中元素个数减一；</li><li>将原队列末尾元素设置成为队列头元素，再将队列末尾元素设置为null；</li><li>调用setDown(O,x)方法，保证按照元素的优先级排序。</li></ol><h4 id="向下堆化siftDown"><a href="#向下堆化siftDown" class="headerlink" title="向下堆化siftDown"></a>向下堆化siftDown</h4><p>由于堆顶元素出队列后，就破坏了堆的结构，需要组织整理下，将堆尾元素移到堆顶，然后向下堆化：</p><ol><li>从堆顶开始，父亲节点与左右子节点中较小的孩子节点比较（左孩子不一定小于右孩子）。</li><li>父亲节点小于等于较小孩子节点，则结束循环，不需要交换位置。</li><li>若父亲节点大于较小孩子节点，则交换位置。</li><li>继续向下循环判断父亲节点和孩子节点的关系，直到父亲节点小于等于较小孩子节点才结束循环。</li></ol><pre><code class="line-numbers language-java">private void siftDown(int k, RunnableScheduledFuture&lt;?&gt; key) {         // 无符号右移，相当于size/2    int half = size &gt;&gt;&gt; 1;                // 通过循环，保证父节点的值不能大于子节点。    while (k &lt; half) {                        // 左子节点, 相当于 (k * 2) + 1        int child = (k &lt;&lt; 1) + 1;                        // 左子节点位置元素        RunnableScheduledFuture&lt;?&gt; c = queue[child];                        // 右子节点, 相当于 (k * 2) + 2        int right = child + 1;                        // 如果左子节点元素值大于右子节点元素值，那么右子节点才是较小值的子节点。        // 就要将c与child值重新赋值        if (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; 0)            c = queue[child = right];                        // 如果父节点元素值小于较小的子节点元素值，那么就跳出循环        if (key.compareTo(c) &lt;= 0)                                break;                        // 否则，父节点元素就要和子节点进行交换        queue[k] = c;        setIndex(c, k);        k = child;    }                queue[k] = key;    setIndex(key, k);}</code></pre><p>siftDown方法执行时包含两种情况，一种是没有子节点，一种是有子节点（根据half判断）。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>立即获取队列头元素，当队列头任务是null，或者任务延时时间没有到，表示这个任务还不能返回，因此直接返回null。否则调用finishPoll方法，移除队列头元素并返回。</p><pre><code class="line-numbers language-java">public RunnableScheduledFuture&lt;?&gt; poll() {                final ReentrantLock lock = this.lock;    lock.lock();                try {        RunnableScheduledFuture&lt;?&gt; first = queue[0];                        // 队列头任务是null，或者任务延时时间没有到，都返回null        if (first == null || first.getDelay(NANOSECONDS) &gt; 0)                                return null;                        else            // 移除队列头元素            return finishPoll(first);    } finally {        lock.unlock();    }}</code></pre><h4 id="poll-long-timeout-TimeUnit-unit"><a href="#poll-long-timeout-TimeUnit-unit" class="headerlink" title="poll(long timeout, TimeUnit unit)"></a>poll(long timeout, TimeUnit unit)</h4><p>超时等待获取队列头元素，与take方法相比较，就要考虑设置的超时时间，如果超时时间到了，还没有获取到有用任务，那么就返回null。其他的与take方法中逻辑一样。</p><pre><code class="line-numbers language-java">public RunnableScheduledFuture&lt;?&gt; poll(long timeout, TimeUnit unit)                throws InterruptedException {                long nanos = unit.toNanos(timeout);                final ReentrantLock lock = this.lock;    lock.lockInterruptibly();                try {                        for (;;) {            RunnableScheduledFuture&lt;?&gt; first = queue[0];                                // 如果没有任务。            if (first == null) {                                        // 超时时间已到，那么就直接返回null                if (nanos &lt;= 0)                                                return null;                                        else                    // 否则就让线程在available条件下等待nanos时间                    nanos = available.awaitNanos(nanos);            } else {                                        // 获取任务的剩余延时时间                long delay = first.getDelay(NANOSECONDS);                                        // 如果延时时间到了，就返回这个任务，用来执行。                if (delay &lt;= 0)                                                return finishPoll(first);                                        // 如果超时时间已到，那么就直接返回null                if (nanos &lt;= 0)                                                return null;                                        // 将first设置为null，当线程等待时，不持有first的引用                first = null; // don't retain ref while waiting                // 如果超时时间小于任务的剩余延时时间，那么就有可能获取不到任务。                // 在这里让线程等待超时时间nanos                if (nanos &lt; delay || leader != null)                    nanos = available.awaitNanos(nanos);                                        else {                    Thread thisThread = Thread.currentThread();                    leader = thisThread;                                                try {                                                        // 当任务的延时时间到了时，能够自动超时唤醒。                        long timeLeft = available.awaitNanos(delay);                                                        // 计算剩余的超时时间                        nanos -= delay - timeLeft;                    } finally {                                                        if (leader == thisThread)                            leader = null;                    }                }            }        }    } finally {                        if (leader == null &amp;&amp; queue[0] != null)                                // 唤醒等待任务的线程            available.signal();        lock.unlock();    }}</code></pre><h4 id="remove-删除指定元素"><a href="#remove-删除指定元素" class="headerlink" title="remove() 删除指定元素"></a>remove() 删除指定元素</h4><p>删除指定元素一般用于取消任务时，任务还在阻塞队列中，则需要将其删除。当删除的元素不是堆尾元素时，需要做堆化处理。</p><pre><code class="line-numbers language-java">public boolean remove(Object x) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        int i = indexOf(x);        if (i &lt; 0)            return false;        //维护heapIndex        setIndex(queue[i], -1);        int s = --size;        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];        queue[s] = null;        if (s != i) {            //删除的不是堆尾元素，则需要堆化处理            //先向下堆化            siftDown(i, replacement);            if (queue[i] == replacement)                //若向下堆化后，i位置的元素还是replacement，说明四无需向下堆化的，                //则需要向上堆化                siftUp(i, replacement);        }        return true;    } finally {        lock.unlock();    }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用优先级队列DelayedWorkQueue，保证添加到队列中的任务，会按照任务的延时时间进行排序，延时时间少的任务首先被获取。</p><ol><li>DelayedWorkQueue的数据结构是基于堆实现的；</li><li>DelayedWorkQueue采用数组实现堆，根节点出队，用最后叶子节点替换，然后下推至满足堆成立条件；最后叶子节点入队，然后向上推至满足堆成立条件；</li><li>DelayedWorkQueue添加元素满了之后会自动扩容原来容量的1/2，即永远不会阻塞，最大扩容可达Integer.MAX_VALUE，所以线程池中至多有corePoolSize个工作线程正在运行；</li><li>DelayedWorkQueue 消费元素take，在堆顶元素为空和delay &gt;0 时，阻塞等待；</li><li>DelayedWorkQueue 是一个生产永远不会阻塞，消费可以阻塞的生产者消费者模式；</li><li>DelayedWorkQueue 有一个leader线程的变量，是Leader-Follower模式的变种。当一个take线程变成leader线程时，只需要等待下一次的延迟时间，而不是leader线程的其他take线程则需要等leader线程出队列了才唤醒其他take线程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 ThreadPoolExecutor</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-threadpoolexecutor/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-threadpoolexecutor/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-ThreadPoolExecutor"><a href="#【Java-多线程并发】-ThreadPoolExecutor" class="headerlink" title="【Java 多线程并发】 ThreadPoolExecutor"></a>【Java 多线程并发】 ThreadPoolExecutor</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 ThreadPoolExecutordate: 2023-07-05 12:34tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 ThreadPoolExecutor</code></pre><h2 id="线程池框架"><a href="#线程池框架" class="headerlink" title="线程池框架"></a>线程池框架</h2><p><img src="/attachment/3a3a8b64afcb7c3711a9811a92048421.png"></p><h3 id="第一层结构"><a href="#第一层结构" class="headerlink" title="第一层结构"></a>第一层结构</h3><ol><li>sun.nio.ch.AsynchronousChannelGroupImpl(Iocp)  异步channel –AIO相关实现</li><li>java.util.concurrent.CompletableFuture.ThreadPerTaskExecutor   （启动一个线程执行）</li><li>sun.net.httpserver.ServerImpl.DefaultExecutor   （more执行器，直接执行）</li><li>com.sun.jmx.remote.internal.ClientNotifForwarder.LinearExecutor  （线性执行器）</li><li>java.util.concurrent.ExecutorService （核心执行器服务）</li></ol><h3 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h3><ol><li>java.util.concurrent.Executor （执行器，执行方法）</li><li>java.util.concurrent.ExecutorService （执行服务） 包含服务的生命周期</li><li>java.util.concurrent.ScheduledExecutorService （调度相关的服务）</li></ol><h3 id="核心实现类"><a href="#核心实现类" class="headerlink" title="核心实现类"></a>核心实现类</h3><ol><li>java.util.concurrent.ThreadPoolExecutor  （普通的的线程池实现类）</li><li>java.util.concurrent.ScheduledThreadPoolExecutor （调度的核心实现类）</li></ol><h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><ol><li>java.util.concurrent.Executors</li></ol><h3 id="完成服务"><a href="#完成服务" class="headerlink" title="完成服务"></a>完成服务</h3><p>java.util.concurrent.CompletionService<br>java.util.concurrent.ExecutorCompletionService</p><p>核心的话，我们的Java自带的线程池就是由两种类型（那些Executors提供的固定类型只是对这两种类型改了一些参数而已）：</p><ol><li>普通线程池 ThreadPoolExecutor</li><li>定时线程池 ScheduledThreadPoolExecutor</li></ol><p>下面我们就先来分析普通线程池 ThreadPoolExecutor 的源码。</p><h2 id="二、ThreadPoolExecutor的成员属性和内部类"><a href="#二、ThreadPoolExecutor的成员属性和内部类" class="headerlink" title="二、ThreadPoolExecutor的成员属性和内部类"></a>二、ThreadPoolExecutor的成员属性和内部类</h2><h3 id="主要成员属性以及工具方法"><a href="#主要成员属性以及工具方法" class="headerlink" title="主要成员属性以及工具方法"></a>主要成员属性以及工具方法</h3><pre><code class="line-numbers language-java">public class ThreadPoolExecutor extends AbstractExecutorService {    // 线程池的状态和线程数量都是通过一个原子类型AtomicInteger的变量ctl来表示的，创建线程池的时候就会将ctl初始化为RUNNING状态和0个工作线程    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));    // 表示低29位的值，用于表示线程池中工作线程的数量    private static final int COUNT_BITS = Integer.SIZE - 3; // =29    // 用于表示线程池中工作线程的数量的最大值，等于2^29-1    private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1; // =000 11111...    // 线程池的五种状态，高3位表示    下面的状态值依次增高，是根据他们状态流程的顺序依次增高的    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS; // 111 00000...    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS; // 000 00000...    private static final int STOP       =  1 &lt;&lt; COUNT_BITS; // 001 00000...    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS; // 010 00000...    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS; // 011 00000...     // 传入ctl，计算返回线程池的状态    // 通过与运算，将高3位的值保留，低29位的值置为0    private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }    // 传入ctl，计算返回线程池中工作线程的数量    // 通过与运算，将高3位的值置为0，低29位的值保留    private static int workerCountOf(int c)  { return c &amp; CAPACITY; }    // 计算ctl的值，等于运行状态“加上”线程数量    // 通过或运算，将高3位和低29位的值都保留，合并为ctl并返回    private static int ctlOf(int rs, int wc) { return rs | wc; }      // runStateLessThan方法用于判断线程池的状态是否小于某个状态    private static boolean runStateLessThan(int c, int s) {        return c &lt; s;    }    // runStateAtLeast方法用于判断线程池的状态是否大于等于某个状态    private static boolean runStateAtLeast(int c, int s) {        return c &gt;= s;    }    // isRunning方法用于判断线程池的状态是否是RUNNING状态    private static boolean isRunning(int c) {        return c &lt; SHUTDOWN;    }    // 该方法用于增加工作线程的数量，如果增加成功则返回true，否则返回false    private boolean compareAndIncrementWorkerCount(int expect) {        return ctl.compareAndSet(expect, expect + 1);    }    // 该方法用于减少工作线程的数量，如果减少成功则返回true，否则返回false    private boolean compareAndDecrementWorkerCount(int expect) {        return ctl.compareAndSet(expect, expect - 1);    }    // 该方法用于设置线程池的状态，如果设置成功则返回true，否则返回false    private void decrementWorkerCount() {        do {} while (! compareAndDecrementWorkerCount(ctl.get()));    }    // 用于保存工作线程的集合    private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();    // 线程池的状态锁，对线程池状态（比如线程池大小、runState等）的改变都要使用这个锁    private final ReentrantLock mainLock = new ReentrantLock();    // 线程池的条件锁，用mainLock创建的，在线程池的状态发生改变时，会使用这个条件锁来通知所有等待的线程    private final Condition termination = mainLock.newCondition();      // 核心参数：任务阻塞队列    private final BlockingQueue&lt;Runnable&gt; workQueue;    // 核心参数：线程池的线程工厂，用于创建线程    private volatile ThreadFactory threadFactory;    // 核心参数：拒绝策略，用于在线程池已经关闭或者线程数已经达到最大值的情况下，对新任务的处理策略    private volatile RejectedExecutionHandler handler;    // 核心参数：当线程数大于核心线程数时，多余的空闲线程存活的最长时间    private volatile long keepAliveTime;    // 是否允许核心线程空闲退出，默认值为false    private volatile boolean allowCoreThreadTimeOut;    // 核心参数：线程池的核心线程数    private volatile int corePoolSize;    // 核心参数：线程池的最大线程数    private volatile int maximumPoolSize;     // 这是一个动态的变量。    // largestPoolSize表示线程池中曾经出现过的最大线程数，即在线程池的整个生命周期中，曾经有多少个线程同时处于活动状态。所以说largestPoolSize是小于等于maximumPoolSize的。    // 它的值可以通过ThreadPoolExecutor的getLargestPoolSize()方法获取。    private int largestPoolSize;    // 表示已经完成的任务数量    private long completedTaskCount;    // 默认的拒绝策略，默认的拒绝策略就是直接抛出异常。如果构造方法中没有转入指定的拒绝策略，就会将defaultHandler赋值给handler    private static final RejectedExecutionHandler defaultHandler =        new AbortPolicy();    ...}</code></pre><h3 id="五种内部类"><a href="#五种内部类" class="headerlink" title="五种内部类"></a>五种内部类</h3><p><img src="/attachment/90d933193620279960d9809e3355779f.png"></p><p>ThreadPoolExecutor中有五个内部类，总的来说其实就两类：1、拒绝策略（Policy）  2、工作线程类（Worker）</p><h4 id="拒绝策略内部类（Policy）"><a href="#拒绝策略内部类（Policy）" class="headerlink" title="拒绝策略内部类（Policy）"></a>拒绝策略内部类（Policy）</h4><p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢？这里的拒绝策略，就是解决这个问题的。</p><p>拒绝策略表示当任务队列满了且线程数也达到最大了，这时候再新加任务，线程池已经无法承受了，这些新来的任务应该按什么逻辑来处理。</p><h4 id="工作线程内部类（Worker）"><a href="#工作线程内部类（Worker）" class="headerlink" title="工作线程内部类（Worker）"></a>工作线程内部类（Worker）</h4><p>Worker类，每一个Worker类就会绑定一个线程（Worker类有一个成员属性持有一个线程对象），可以将Worker理解为线程池中执行任务的线程。但是实际上它并不仅仅是一个线程，Worker里面还会有一些统计信息，存储一些相关的数据。</p><h2 id="源码原理解析（执行普通任务）"><a href="#源码原理解析（执行普通任务）" class="headerlink" title="源码原理解析（执行普通任务）"></a>源码原理解析（执行普通任务）</h2><p>下面我们以执行普通任务为例，讲解ThreadPoolExecutor的源码。</p><h3 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h3><p>之前我们学过线程是有自己的生命周期的，其实线程池也是存在生命周期的。在我们讲线程池体系结构的时候，讲了一些方法，比如shutDown()/shutDownNow()，它们都是与线程池的生命周期相关联的。</p><p>我们先来看一下线程池ThreadPoolExecutor中定义的生命周期中的状态及相关方法：</p><pre><code class="line-numbers language-java">// 线程池的状态和线程数量都是通过一个原子类型AtomicInteger的变量ctl来表示的，创建线程池的时候就会将ctl初始化为RUNNING状态和0个工作线程private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// 表示低29位的值，用于表示线程池中工作线程的数量private static final int COUNT_BITS = Integer.SIZE - 3; // =29// 用于表示线程池中工作线程的数量的最大值，等于2^29-1private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1; // =000 11111...// 线程池的五种状态，高3位表示    下面的状态值依次增高，是根据他们状态流程的顺序依次增高的private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS; // 111 00000...private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS; // 000 00000...private static final int STOP       =  1 &lt;&lt; COUNT_BITS; // 001 00000...private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS; // 010 00000...private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS; // 011 00000...// 传入ctl，计算返回线程池的状态// 通过与运算，将高3位的值保留，低29位的值置为0private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }// 传入ctl，计算返回线程池中工作线程的数量// 通过与运算，将高3位的值置为0，低29位的值保留private static int workerCountOf(int c)  { return c &amp; CAPACITY; }// 计算ctl的值，等于运行状态“加上”线程数量// 通过或运算，将高3位和低29位的值都保留，合并为ctl并返回private static int ctlOf(int rs, int wc) { return rs | wc; }  // runStateLessThan方法用于判断线程池的状态是否小于某个状态private static boolean runStateLessThan(int c, int s) {    return c &lt; s;}// runStateAtLeast方法用于判断线程池的状态是否大于等于某个状态private static boolean runStateAtLeast(int c, int s) {    return c &gt;= s;}// isRunning方法用于判断线程池的状态是否是RUNNING状态private static boolean isRunning(int c) {    return c &lt; SHUTDOWN;}</code></pre><p>从上面这段代码，我们可以得出：</p><p>（1）线程池的状态和工作线程的数量共同保存在控制变量ctl中，类似于AQS中的state变量，不过这里是直接使用的AtomicInteger，这里换成unsafe+volatile也是可以的；<br>（2）ctl的高三位保存运行状态，低29位保存工作线程的数量，也就是说线程的数量最多只能有(2^29-1)个，也就是上面的CAPACITY；关于ctl的详细讲解见：【线程池】线程池的ctl属性详解<br>（3）线程池的状态一共有五种，分别是RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED；<br>（4）RUNNING，表示可接受新任务，且可执行队列中的任务；<br>（5）SHUTDOWN，表示不接受新任务，但可执行队列中的任务；<br>（6）STOP，表示不接受新任务，且不再执行队列中的任务，且中断正在执行的任务；<br>（7）TIDYING，所有任务已经中止，且工作线程数量为0，最后变迁到这个状态的线程将要执行terminated()钩子方法，只会有一个线程执行这个方法；<br>（8）TERMINATED，中止状态，已经执行完terminated()钩子方法；</p><p>下面我们再通过流程图来看看这些状态之间是怎么流转的：</p><p><img src="/attachment/811d683d178ab50a736d06873e600e5e.png"></p><p>（1）新建线程池时，它的初始状态为RUNNING，这个在上面定义ctl的时候可以看到；<br>（2）RUNNING-&gt;SHUTDOWN，执行shutdown()方法时；<br>（3）RUNNING-&gt;STOP，执行shutdownNow()方法时；<br>（4）SHUTDOWN-&gt;STOP，执行shutdownNow()方法时；<br>（5）STOP-&gt;TIDYING，执行了shutdown()或者shutdownNow()后，所有任务已中止，且工作线程数量为0时，此时会执行terminated()方法；<br>（6）TIDYING-&gt;TERMINATED，执行完terminated()方法后；</p><p>下面让我们一起来看看源码中是怎么控制线程池状态的。</p><h4 id="（1）RUNNING初始化状态"><a href="#（1）RUNNING初始化状态" class="headerlink" title="（1）RUNNING初始化状态"></a>（1）RUNNING初始化状态</h4><p>RUNNING，比较简单，创建线程池的时候就会初始化ctl，而ctl初始化为RUNNING状态，所以线程池的初始状态就为RUNNING状态。</p><pre><code class="line-numbers language-java">// 初始状态为RUNNINGprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code></pre><h4 id="（2）SHUTDOWN-方法"><a href="#（2）SHUTDOWN-方法" class="headerlink" title="（2）SHUTDOWN()方法"></a>（2）SHUTDOWN()方法</h4><p>执行shutdown()方法时把状态修改为SHUTDOWN，这里肯定会成功，因为advanceRunState()方法中是个自旋，不成功不会退出。</p><pre><code class="line-numbers language-java">public void shutdown() {    // 获取线程池锁    final ReentrantLock mainLock = this.mainLock;    // 加锁，修改线程池状态    mainLock.lock();    try {          // 检查是否有权限关闭线程池        checkShutdownAccess();        // 修改状态为SHUTDOWN，自旋操作，只有状态修改成功才会返回        advanceRunState(SHUTDOWN);        // 标记空闲线程为中断状态        interruptIdleWorkers();        onShutdown();    } finally {        mainLock.unlock();    }    tryTerminate();} private void advanceRunState(int targetState) {    // 自旋修改线程池状态    for (;;) {        // 获取ctl        int c = ctl.get();        // 如果状态大于SHUTDOWN（因为只有RUNNING状态才能转化为SHUTDOWN状态，而只有RUNNING状态是小于SHUTDOWN状态的），        // 或者修改为SHUTDOWN成功了，才会break跳出自旋        if (runStateAtLeast(c, targetState) ||            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))            break;    }}</code></pre><h4 id="（3）STOP"><a href="#（3）STOP" class="headerlink" title="（3）STOP"></a>（3）STOP</h4><p>执行shutdownNow()方法时，会把线程池状态修改为STOP状态，同时标记所有线程为中断状态。</p><pre><code class="line-numbers language-java">public List&lt;Runnable&gt; shutdownNow() {    List&lt;Runnable&gt; tasks;    // 获取线程池的锁    final ReentrantLock mainLock = this.mainLock;    // 加锁，进行状态修改操作    mainLock.lock();    try {        // 检查是否有权限关闭线程池        checkShutdownAccess();        // 修改为STOP状态        advanceRunState(STOP);        // 标记所有线程为中断状态        interruptWorkers();        // 将队列中的任务全部移除，并返回        tasks = drainQueue();    } finally {        // 解锁        mainLock.unlock();    }    // 尝试终止线程池    tryTerminate();    // 返回队列中的任务    return tasks;}</code></pre><p>至于线程是否响应中断其实是在队列的take()或poll()方法中响应的，最后会到AQS中，它们检测到线程中断了会抛出一个InterruptedException异常，然后getTask()中捕获这个异常，并且在下一次的自旋时退出当前线程并减少工作线程的数量。</p><pre><code class="line-numbers language-java">private Runnable getTask() {    boolean timedOut = false; // Did the last poll() time out?    for (;;) {        int c = ctl.get();        int rs = runStateOf(c);        // 如果状态为STOP了，这里会直接退出循环，且减少工作线程数量        // 退出循环了也就相当于这个线程的生命周期结束了        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {            decrementWorkerCount();            return null;        }        int wc = workerCountOf(c);        // Are workers subject to culling?        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {            if (compareAndDecrementWorkerCount(c))                return null;            continue;        }        try {            // 真正响应中断是在poll()方法或者take()方法中            Runnable r = timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();            if (r != null)                return r;            timedOut = true;        } catch (InterruptedException retry) {            // 这里捕获中断异常            timedOut = false;        }    }}</code></pre><p>这里有一个问题，就是已经通过getTask()取出来且返回的任务怎么办？</p><p>实际上它们会正常执行完毕，这个知识点涉及到runWorker()这个方法，我们在后面会分析这个方法。</p><h4 id="（4）TIDYING"><a href="#（4）TIDYING" class="headerlink" title="（4）TIDYING"></a>（4）TIDYING</h4><p>当执行shutdown()或shutdownNow()之后，如果所有任务已中止，且工作线程数量为0，就会进入这个状态。</p><pre><code class="line-numbers language-java">final void tryTerminate() {    // 自旋修改状态    for (;;) {        int c = ctl.get();        // 下面几种情况不会执行后续代码        // 1. 运行中        // 2. 状态的值比TIDYING还大，也就是TERMINATED        // 3. SHUTDOWN状态且任务队列不为空        if (isRunning(c) ||            runStateAtLeast(c, TIDYING) ||            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))            return;        // 工作线程数量不为0，也不会执行后续代码        if (workerCountOf(c) != 0) {            // 尝试中断空闲的线程            interruptIdleWorkers(ONLY_ONE);            return;        }                // 获取线程池的锁        final ReentrantLock mainLock = this.mainLock;        // 加锁        mainLock.lock();        try {            // CAS修改状态为TIDYING状态            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {                try {                    // 更新成功，执行terminated钩子方法                    terminated();                // 确保terminated钩子方法执行完毕后，再次修改状态为TERMINATED（最终的终止状态），线程池彻底关闭                } finally {                    // 强制更新状态为TERMINATED，这里不需要CAS了                    ctl.set(ctlOf(TERMINATED, 0));                    // 通知所有等待线程                    termination.signalAll();                }                return;            }        } finally {            // 解锁            mainLock.unlock();        }        // else retry on failed CAS    }}</code></pre><p>实际更新状态为TIDYING和TERMINATED状态的代码都在tryTerminate()方法中，实际上tryTerminated()方法在很多地方都有调用，比如shutdown()、shutdownNow()、线程退出时，所以说几乎每个线程最后消亡的时候都会调用tryTerminate()方法，但最后只会有一个线程真正执行到修改状态为TIDYING的地方。</p><p>修改状态为TIDYING后执行terminated()方法，最后修改状态为TERMINATED，标志着线程池真正消亡了。</p><h4 id="（5）TERMINATED"><a href="#（5）TERMINATED" class="headerlink" title="（5）TERMINATED"></a>（5）TERMINATED</h4><p>见上面TIDYING中分析。</p><h3 id="线程池执行原理"><a href="#线程池执行原理" class="headerlink" title="线程池执行原理"></a>线程池执行原理</h3><p>本章节我们讲的是普通线程池，以固定线程池为例，下面就是线程池提交任务的基本用法。我们可以使用Executors框架来直接创建线程池，但是本质它还是通过ThreadPoolExecutor的构造方法创建的线程池。</p><pre><code class="line-numbers language-java">// 固定线程池ExecutorService executorService = Executors.newFixedThreadPool(2);// 提交单个任务，无返回值executorService.execute(new Runnable() {    public void run() {    }});// 提交单个任务，有返回值，返回FutureexecutorService.submit(new Callable&lt;String&gt;() {    public String call() throws Exception {        return "abc";    }});</code></pre><h4 id="初始化构造器"><a href="#初始化构造器" class="headerlink" title="初始化构造器"></a>初始化构造器</h4><p>ThreadPoolExecutor的多个构造方法，都是调用的下面这个构造方法来实现的。</p><pre><code class="line-numbers language-java">/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 * 所有的构造方法最终都会调用这个构造方法，都是基于这个方法实现的 */public ThreadPoolExecutor(  int corePoolSize, // 线程池的核心线程数量                            int maximumPoolSize, // 线程池的最大线程数                            long keepAliveTime, // 当线程数大于核心线程数时，多余的空闲线程存活的最长时间                            TimeUnit unit, // 存活时间的时间单位                            BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列，用来储存等待执行任务的队列                            ThreadFactory threadFactory, // 线程工厂，用来创建线程，一般默认即可                            RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务                        ) {    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();     if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();     this.acc = System.getSecurityManager() == null ?            null :            AccessController.getContext();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}</code></pre><p>下面我们通过这个构造方法创建一个线程池，它的核心数量为5，最大数量为10，空闲时间为1秒，队列长度为5，拒绝策略打印一句话。如果使用它运行20个任务，会是什么结果呢？</p><pre><code class="line-numbers language-java">public class ThreadPoolTest01 {    public static void main(String[] args) {        // 通过构造方法新建一个线程池        // 核心数量为5，最大数量为10，空闲时间为1秒，队列长度为5，拒绝策略打印一句话        ExecutorService threadPool = new ThreadPoolExecutor(5, 10,                1, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5),                Executors.defaultThreadFactory(),                 new RejectedExecutionHandler() { // 自定义拒绝策略                    @Override                    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {                        System.out.println(currentThreadName() + ", discard task");                    }                }        );        // 循环提交20个任务，注意观察num        for (int i = 0; i &lt; 20; i++) {            int num = i;            threadPool.execute(()-&gt;{                try {                    // 打印执行任务的线程信息 和 num的大小  以及执行的时间                    System.out.println(currentThreadName() + ", "+ num + " running, " + System.currentTimeMillis());                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            });        }    }        // 打印当前线程的名字    private static String currentThreadName() {        return Thread.currentThread().getName();    }}</code></pre><p>我们一起来看看一次运行的结果：</p><pre><code class="line-numbers language-java">pool-1-thread-1, 0 running, 1572678434411pool-1-thread-3, 2 running, 1572678434411pool-1-thread-2, 1 running, 1572678434411pool-1-thread-4, 3 running, 1572678434411pool-1-thread-5, 4 running, 1572678434411pool-1-thread-6, 10 running, 1572678434412pool-1-thread-7, 11 running, 1572678434412pool-1-thread-8, 12 running, 1572678434412main, discard taskmain, discard taskmain, discard taskmain, discard taskmain, discard taskpool-1-thread-9, 13 running, 1572678434412pool-1-thread-10, 14 running, 1572678434412pool-1-thread-3, 5 running, 1572678436411pool-1-thread-1, 6 running, 1572678436411pool-1-thread-6, 7 running, 1572678436412pool-1-thread-2, 8 running, 1572678436412pool-1-thread-7, 9 running, 1572678436412</code></pre><p>注意，观察num值的打印信息，先是打印了0<del>4，再打印了10</del>14，最后打印了5~9，竟然不是按顺序打印的，为什么呢？</p><p>下面我们基于上面这段代码示例，一步一步debug进去查看ThreadPoolExecutor中地相关源码。</p><h3 id="execute-方法——提交任务"><a href="#execute-方法——提交任务" class="headerlink" title="execute()方法——提交任务"></a>execute()方法——提交任务</h3><p>execute()方法是线程池提交任务的方法之一，也是最核心的方法。该方法是在Executor线程池顶层接口中定义的，用于提交Runnable无返回值任务到线程池中执行，该方法也没有返回值。该方法在ThreadPoolExecutor中实现。</p><p>java.util.concurrent.ThreadPoolExecutor#execute</p><pre><code class="line-numbers language-java">// 提交任务，任务并非立即执行，所以翻译成执行任务似乎不太合适，其实是将任务提交到任务队列中，然后线程池再从任务队列中取出任务执行public void execute(Runnable command) {    // 任务不能为空    if (command == null)        throw new NullPointerException();            // 获取ctl（高3位存储状态，低29位存储工作线程的数量）    int c = ctl.get();    // 1. 如果工作线程数量小于核心数量    if (workerCountOf(c) &lt; corePoolSize) {        // 就添加一个工作线程（核心）  并将该任务作为该工作线程的第一个任务，创建线程完成后直接返回        if (addWorker(command, true))            return;        // 如果创建工作线程失败，则重新获取下ctl        c = ctl.get();    }    // 2. 如果达到了核心数量且线程池是运行状态，则将任务加入队列（workQueue是构造方法的核心参数之一）    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {        // 再次获取ctl        int recheck = ctl.get();        // 再次检查线程池状态，如果不是运行状态，就移除任务并执行拒绝策略        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        // 容错检查工作线程数量是否为0，如果为0就创建一个，此时就不用为工作线程绑定任务了，因为任务已经加入到队列中了        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    }    // 3. 任务入队列失败（例如队列满了），尝试创建非核心工作线程，将该任务和非核心工作线程绑定在一起    else if (!addWorker(command, false))        // 非核心工作线程创建失败，执行拒绝策略        reject(command);}</code></pre><p>提交任务的过程大致如下：</p><p>（1）工作线程数量小于核心数量，创建核心线程，并将任务交给该核心线程去执行；<br>（2）达到核心数量，将任务加入任务队列；<br>（3）任务队列满了，创建非核心线程，并将任务交给该非核心线程去执行；<br>（4）线程数达到最大数量，队列也满了，则执行拒绝策略；</p><p>其实，就是三道坎——核心数量、任务队列、最大数量，这样就比较好记了。</p><p>流程图大致如下：</p><p><img src="/attachment/7ea619a1fe986911bb127e2c8bce75a4.png"></p><p>任务流转的过程我们知道了，但是任务是在哪里执行的呢？继续往下看。</p><h3 id="addWorker-方法——添加工作线程并启动"><a href="#addWorker-方法——添加工作线程并启动" class="headerlink" title="addWorker()方法——添加工作线程并启动"></a>addWorker()方法——添加工作线程并启动</h3><h4 id="retry-标记"><a href="#retry-标记" class="headerlink" title="retry:标记"></a>retry:标记</h4><p>讲解这个方法之前先了解下 retry: 因为源码中有这个retry标记</p><p>先看一个简单的例子</p><pre><code class="line-numbers language-java">public void testRetry() {    int i = 0;    retry:  //①    while (true) {        i++;        System.out.println("i=" + i);        int j = 0;               // retry:   //②        for (; ; ) {            j++;            System.out.println("j=" + j);            if (j == 2) {                break retry;            }        }    }}</code></pre><p>首先需要说明的是，retry：可以理解为java中的一种特殊的标记，其中retry可以换成任何合法的命名。</p><p>a:、b:、A13: 等等都是可以的。该标记其实就是”:”，符号前面是自己定义的任意合法名字。</p><h4 id="打开①，关闭②-打印结果"><a href="#打开①，关闭②-打印结果" class="headerlink" title="打开①，关闭②  打印结果"></a>打开①，关闭②  打印结果</h4><pre><code class="line-numbers language-text">i=1j=1j=2</code></pre><p>这里有一点需要注意，这里和C语言的goto不一样，如果break到了循环外面（就是说再也没有循环套在retry外面了），那么这个程序就永远不会再进入到这个循环了，而C语言的goto只是重新调整了程序的执行位置，程序会接着按照代码向下执行，进入循环。如果是用的continue retry就还可以再进入循环。</p><h4 id="打开②，关闭①，打印结果"><a href="#打开②，关闭①，打印结果" class="headerlink" title="打开②，关闭①，打印结果"></a>打开②，关闭①，打印结果</h4><pre><code class="line-numbers language-text">....j=1j=2i=132348j=1j=2i=132349j=1j=2i=132350j=1j=2...一直循环打印</code></pre><p>retry相当于一个标记，只用在循环里面，很像goto语句，break到retry字符处。如果retry没有在循环（for，while）里面，在执行到retry时，就会跳出整个循环。如果retry在循环里面，可以理解为跳到了关键字处执行，不管几层循环。continue理解也是一样。</p><p>注意：retry：需要放在for，whlie，do…while的前面声明，变量只跟在break和continue后面。</p><h4 id="addWorker-方法源码"><a href="#addWorker-方法源码" class="headerlink" title="addWorker()方法源码"></a>addWorker()方法源码</h4><p>如果工作线程数小于核心线程数的话，会调用 addWorker，顾名思义，这个方法主要用来创建一个工作线程，并启动之，其中会做线程池状态、工作线程数量等各种检测。</p><p>源码很长，但其实就做了两件事：</p><ol><li>使用循环 CAS 操作来将线程数加 1；</li><li>新建一个线程并启用。</li></ol><p>java.util.concurrent.ThreadPoolExecutor#addWorker</p><pre><code class="line-numbers language-java">// 该方法用于创建新的工作线程添加到线程池中，如果添加成功则启动线程// 参数firstTask是一个Runnable对象，表示要给该线程的第一个任务// 参数core表示创建的是否是核心线程// 返回值表示是否成功创建并启动了工作线程private boolean addWorker(Runnable firstTask, boolean core) {    // 判断有没有资格创建新的工作线程    // 主要是一些状态/数量的检查等等    retry:    for (;;) {        // 获取ctl        int c = ctl.get();        // 获取当前线程池运行状态        int rs = runStateOf(c);        // 线程池状态检查        if (rs &gt;= SHUTDOWN &amp;&amp; // 大于等于SHUTDOWN说明线程池不是RUNNING状态            ! (rs == SHUTDOWN &amp;&amp;               firstTask == null &amp;&amp;               ! workQueue.isEmpty()))            // 两种情况会直接返回false  1.如果非运行状态  2.不是【线程池是停止状态并且传入的任务是null并且workQueue不等于空】这种情况               return false;        // 工作线程数量检查        for (;;) {            // 获取当前线程数            int wc = workerCountOf(c);            if (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                // 判断是否饱和容量了，如果已经达到最大线程数则不能再新建线程，直接返回false                return false;            // 完成了上面的判断后，说明现在线程池可以创建新线程，则将线程数量加1，因为后面要创建线程了，并跳出循环            if (compareAndIncrementWorkerCount(c))                // 因为外面的retry:已经不在循环内了，跳到retry:位置后也不会再进入到该循环了，其实就相当于跳出这两层循环并且不再进入这两层循环，执行后续的流程                break retry;            // 如果上面的compareAndIncrementWorkerCount(c)方法返回false，则说明有其他线程在操作线程池的线程数量，所以需要重新获取ctl            c = ctl.get();  // Re-read ctl            // 如果当前的运行状态已经和最开始获取的状态不一样了            if (runStateOf(c) != rs)                // 回到retry:，但是因为这里用的是continue，所以程序往后执行还是会再次进入到该循环继续执行上面的判断                continue retry;            // else CAS failed due to workerCount change; retry inner loop        }    }        // 如果上面的条件满足，则会把工作线程数量加1，然后执行下面创建线程的动作    // 标记是否启动了工作线程    boolean workerStarted = false;    // 标记是否成功添加了工作线程    boolean workerAdded = false;    // 要创建的Worker对象    Worker w = null;    try {        // 创建工作线程        // 增加一个worker   这个firstTask就是一个线程（任务线程，每一个Worker都和一个任务线程绑定），Runable,具体可以看这Worker源码        w = new Worker(firstTask);        // 这个是绑定在Worker上的工作线程，并不是任务线程，工作线程是用来执行任务的，        final Thread t = w.thread;        // 判断t是否为null        if (t != null) {            // 获取线程池的锁            final ReentrantLock mainLock = this.mainLock;            // 在读取线程池状态的时候就应该上锁，防止有并发操作破坏程序的一致性，上下不一致            mainLock.lock();            try {                // 锁定后并重新检查线程池的状态，查看是否存在线程工厂的失败或者锁定前的关闭                // 获取线程池运行状态                int rs = runStateOf(ctl.get());                if (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) {                                        if (t.isAlive()) // precheck that t is startable                        throw new IllegalThreadStateException();                                        // 添加到工作线程队列。 workers是线程池中存放工作线程的集合                    // 增加work  每一个线程池都持有一个workers集合，里面存储着线程池的所有worker，也就是所有线程                    workers.add(w);                    // 还在池子中的线程数量（只能在mainLock中使用）                    int s = workers.size();                    // 不能超过线程池的最大线程数量                    if (s &gt; largestPoolSize)                        largestPoolSize = s;                                        // 标记线程添加成功                    workerAdded = true;                }            } finally {                // 解锁                mainLock.unlock();            }            if (workerAdded) {                // 线程添加成功之后启动线程                // 启动绑定在worker上的线程。启动了之后该工作线程就会开始从任务队列中拿任务去执行了                t.start();                // 标记工作线程启动成功                workerStarted = true;            }        }    } finally {        // 线程启动失败，执行失败方法（线程数量减1，执行tryTerminate()方法等）        if (! workerStarted)            addWorkerFailed(w);    }    // 返回新创建的工作线程是否启动成功    return workerStarted;}</code></pre><p>这里其实还没到任务执行的地方，上面我们可以看到线程是包含在Worker这个类中的，我们可以推测出其实执行任务的操作是在内部类Worker中完成的。</p><p>通过源码，可以总结出创建 Worker 失败的原因：</p><ol><li>在添加时线程池被停止了</li><li>添加核心线程池时，超过核心线程池数量</li><li>添加非核心线程池时，超过最大线程池数量</li><li>Worker 对象初始化未完成时就被使用，即 thread 对象还未完全创建</li><li>当前线程正在被运行（防止出现重复运行，抛出异常）</li><li>线程创建过多，导致 OOM</li></ol><p>addWorker 方法中，如果添加 Worker 并且启动线程失败，则会做失败后的处理：</p><pre><code class="line-numbers language-java">private void addWorkerFailed(Worker w) {    final ReentrantLock mainLock = this.mainLock;    // 加锁    mainLock.lock();    try {        // 移除添加失败的worker        if (w != null)            workers.remove(w);        // 减少worker数量        decrementWorkerCount();        // 尝试终止线程池        tryTerminate();    } finally {        // 解锁        mainLock.unlock();}</code></pre><p>这个方法主要做三件事</p><ol><li>如果 worker 已经构造好了，则从 workers 集合中移除这个 worker</li><li>原子递减核心线程数（因为在 addWorker 方法中先做了原子增加）</li><li>尝试结束线程池</li></ol><p>线程池添加线程流程图：</p><p><img src="/attachment/0aac77bcd4500a53fc647eb7ad3ead09.png"></p><h3 id="runWorker-方法——工作线程执行任务"><a href="#runWorker-方法——工作线程执行任务" class="headerlink" title="runWorker()方法——工作线程执行任务"></a>runWorker()方法——工作线程执行任务</h3><p>其实真正执行任务的操作，是在runWorker()方法中完成的。该方法是ThreadPoolExecutor中的核心方法之一，但是调用该方法确实通过内部类Worker实现的。</p><p>上面在addWorker()方法的源码中，ThreadPoolExecutor线程池调用了绑定在Worker对象上的t工作线程的start()方法，也就相当于启动了Worker工作线程。Worker实现了Runnable方法，所以它其中存在run()方法，当启动了工作线程之后，就会自动执行run()方法，而run()方法其实调用的就是ThreadPoolExecutor的runWorker()方法，该方法就会让工作线程持续地去队列中拿任务执行。</p><p>至于ThreadPoolExecutor如何执行任务和对其源码的分析，详见：Worker源码分析。这里就不再赘述了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面对线程池的重要方法地分析，我们了解了线程池中普通任务执行的流程。</p><p>（1）execute()，提交任务的方法，根据核心数量、任务队列大小、最大数量，分成四种情况判断任务应该往哪去；<br>（2）addWorker()，添加工作线程的方法，通过Worker内部类封装一个Thread实例维护工作线程的执行；<br>（3）runWorker()，真正执行任务的地方，先执行第一个任务，再源源不断从任务队列中取任务来执行；<br>（4）getTask()，真正从队列取任务的地方，默认情况下，根据工作线程数量与核心数量的关系判断使用队列的poll()还是take()方法，keepAliveTime参数也是在这里使用的。</p><p>线程池运作的总流程图：</p><p><img src="/attachment/4dd670944be61db1565aa4abce0d284d.png"></p><ol><li>如果当前运行的线程数（当前池大小）poolSize 小于 corePoolSize ，则创建新线程执行任务</li><li>如果当前运行的线程数（当前池大小）poolSize 大于 corePoolSize ，且等待队列未满，则进入等待队列</li><li>如果当前运行的线程数（当前池大小）poolSize 大于 corePoolSize 且小于 maximumPoolSize ，且等待队列已满，则创建新线程执行任务</li><li>如果当前运行的线程数（当前池大小）poolSize 大于 corePoolSize 且大于 maximumPoolSize ，且等待队列已满，则调用拒绝策略来处理该任务，拒绝策略会调用RejectedExecutionHandler.rejectedExecution()方法。</li><li>线程池里的每个线程执行完任务后不会立刻退出，而是会去检查下等待队列里是否还有线程任务需要执行</li><li>如果在 keepAliveTime 里等不到新的任务了，那么线程就会退出，默认只有超过核心数的线程空闲时间超过keepAliveTime才会被销毁。但是也可以通过allowCoreThreadTimeOut(true)来设置，核心数以内的线程空闲超过keepAliveTime后也会关闭</li></ol><p>下面这个流程图我感觉可能更能直观的看出ThreadPoolExecutor每一部分的分工：</p><p><img src="/attachment/78b8baed732c374fa02947be12e1b48e.png"></p><p>下面这个流程我我感觉能更直观展现每一个方法的调用流程：</p><p><img src="/attachment/acde874562d22960472845e3802d7daf.png"></p><p>至此，我们再看最开始给出的那个使用例子带来的问题：</p><p>观察num值的打印信息，先是打印了0<del>4，再打印了10</del>14，最后打印了5~9，竟然不是按顺序打印的，为什么呢？</p><p>线程池的参数：核心数量5个，最大数量10个，任务队列5个。</p><p>答：执行前5个任务执行时，正好还不到核心数量，所以新建核心线程并执行了他们；<br>执行中间的5个任务时，已达到核心数量，所以他们先入队列；<br>执行后面5个任务时，已达核心数量且队列已满，所以新建非核心线程并执行了他们；<br>再执行最后5个任务时，线程池已达到满负荷状态，所以执行了拒绝策略。<br>最后再来一个ThreadPoolExecutor运行机制图示：</p><p><img src="/attachment/95780f86cb7181c72fb780bd07a0cd91.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>线程池的本质就是一种池化的思想，复用线程，减少线程的创建和销毁的开销。常量池和连接池也都是这样的思想。</li><li>线程池的设计思路是生产者和消费者模型，通过队列进行解耦，而使用阻塞队列则是为了并发安全和不必要的自旋。其实消息队列也是生产者和消费者模型，因为消息队列和阻塞队列都是队列。</li><li>线程池如果用不好可能会死锁，即尽量不要在线程池内部使用 execute 方法提交任务，因为可能会出现循环等待的情况。而且线程池使用 submit() 方法要注意选择合适的拒绝策略，因为 submit() 会将任务包装成 FutureTask 对象，如果任务被拒绝，即没有调用 run() 方法，那么调用 get() 方法的线程会被阻塞住。</li></ol><h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="核心线程和非核心线程有什么区别？"><a href="#核心线程和非核心线程有什么区别？" class="headerlink" title="核心线程和非核心线程有什么区别？"></a>核心线程和非核心线程有什么区别？</h3><p>答：实际上并没有什么区别，主要是根据corePoolSize来判断任务该去哪里，两者在执行任务的过程中并没有任何区别。有可能新建的时候是核心线程，而keepAliveTime时间到了结束了的也可能是刚开始创建的核心线程。</p><h3 id="Worker继承自AQS有何意义？"><a href="#Worker继承自AQS有何意义？" class="headerlink" title="Worker继承自AQS有何意义？"></a>Worker继承自AQS有何意义？</h3><p>前面我们看了Worker内部类的定义，它继承自AQS，天生自带锁的特性，那么，它的锁是用来干什么的呢？跟任务的执行有关系吗？</p><p>答：既然是跟锁（同步）有关，说明Worker类跨线程使用了，此时我们查看它的lock()方法发现只在runWorker()方法中使用了，但是其tryLock()却是在interruptIdleWorkers()方法中使用的。</p><pre><code class="line-numbers language-java">private void interruptIdleWorkers(boolean onlyOne) {    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        for (Worker w : workers) {            Thread t = w.thread;            if (!t.isInterrupted() &amp;&amp; w.tryLock()) {                try {                    t.interrupt();                } catch (SecurityException ignore) {                } finally {                    w.unlock();                }            }            if (onlyOne)                break;        }    } finally {        mainLock.unlock();    }}</code></pre><p>interruptIdleWorkers()方法的意思是中断空闲线程的意思，它只会中断BlockingQueue的poll()或take()方法，而不会中断正在执行的任务。</p><p>一般来说，interruptIdleWorkers()方法的调用不是在本工作线程，而是在主线程中调用的，还记得shutdown()和shutdownNow()方法吗？</p><p>观察两个方法中中断线程的方法，shutdown()中就是调用了interruptIdleWorkers()方法来中断线程地，而且interruptIdleWorkers()方法中就用到了tryLock()，只有获取到锁了才能中断线程，如果没有获取到锁则不中断。而调用tryLock()后没获取到锁只有一种原因，那就是lock()所在的地方runWorker()方法中，有任务正在执行。这样shutdown()方法就实现了只中断空闲线程，不会中断正在执行任务的线程。</p><p>而shutdownNow()中中断线程则很暴力，并没有tryLock()，而是直接中断了线程，所以调用shutdownNow()可能会中断正在执行的任务。</p><p>所以，Worker继承自AQS实际是要使用其锁的能力，<mark style="background: #FFF3A3A6;">这个锁主要是用来控制调用shutdown()时不要中断正在执行任务的线程</mark>。</p><p>那么为什么Worker使用AQS实现锁，而不直接用ReentrantLock呢？我们可以看到Worker的tryAcquire 方法，它是不允许重入的，而 ReentrantLock是允许重入的。所以这是为了实现不可重入的特性去反应线程现在的执行状态。</p><h3 id="execute-和-submit-的区别"><a href="#execute-和-submit-的区别" class="headerlink" title="execute() 和 submit() 的区别"></a>execute() 和 submit() 的区别</h3><p>很多同学应该关注到了。线程池的执行任务有两种方法，一种是 submit、一种是 execute； 这两个方法是有区别的。</p><p>execute：</p><ol><li>execute 只可以接收一个 Runnable 的参数</li><li>execute 如果出现异常会抛出</li><li>execute 没有返回值</li></ol><p>submit：</p><ol><li>submit 可以接收 Runable 和 Callable 这两种类型的参数，</li><li>对于 submit 方法，如果传入一个 Callable，可以得到一个 Future 的返回值</li><li>submit 方法调用不会抛异常，除非调用 Future.get()才会在调用get()方法时抛出异常。</li></ol><h3 id="RPC框架中异步调用是怎么实现的？"><a href="#RPC框架中异步调用是怎么实现的？" class="headerlink" title="RPC框架中异步调用是怎么实现的？"></a>RPC框架中异步调用是怎么实现的？</h3><p>答：RPC框架常用的调用方式有同步调用、异步调用，其实它们本质上都是异步调用，它们就是用FutureTask的方式来实现的。</p><p>一般地，通过一个线程（我们叫作远程线程）去调用远程接口，如果是同步调用，则直接让调用者线程阻塞着等待远程线程调用的结果，待结果返回了再返回；如果是异步调用，则先返回一个未来可以获取到远程结果的东西FutureXxx，当然，如果这个FutureXxx在远程结果返回之前调用了get()方法一样会阻塞着调用者线程。</p><p>有兴趣的同学可以先去预习一下dubbo的异步调用（它是把Future扔到RpcContext中的）。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程池的ctl属性</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-xian-cheng-chi-de-ctl-shu-xing/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-xian-cheng-chi-de-ctl-shu-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程池的ctl属性"><a href="#【Java-多线程并发】-线程池的ctl属性" class="headerlink" title="【Java 多线程并发】 线程池的ctl属性"></a>【Java 多线程并发】 线程池的ctl属性</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程池的ctl属性date: 2023-07-05 12:27tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 线程池的ctl属性</code></pre><h2 id="ctl介绍"><a href="#ctl介绍" class="headerlink" title="ctl介绍"></a>ctl介绍</h2><p>ThreadPoolExecutor中有一个<mark style="background: #FFB8EBA6;">控制状态的属性</mark>叫ctl，它是一个AtomicInteger类型的变量，它包含两个概念：</p><ul><li>workerCount：表明当前有效的线程数</li><li>runState：表明当前线程池的状态，是否处于Running，Shutdown，Stop，Tidying，Terminate五种状态。</li></ul><p>为了把这两种状态放到一个int值（共32位）中保存，代码中限定了workerCount的值是2^29-1，因为还有五种状态需要表示，至少需要<mark style="background: #FFB8EBA6;">3位才能表示五种状态</mark>（3位二进制数最大能到6），所以会有29位来表示workerCount，而剩下的3位来表示当前线程池的状态。</p><p><img src="/attachment/b8ccb40882f8742abcf1019a7ad9ca7d.png"></p><p>从上面的代码中可以看出COUNT_BITS这个属性就是Integer.SIZE-3，也就是29。说明线程数所占位数为29位，而CAPACITY得到的就是1向左无符号移29位-1，得到的就是低28位全是1的536870911。而看到上图下面的五个状态，分别是-1，0，1，2，3向左无符号移29位。</p><p><img src="/attachment/208f7c1ea5614e6bd3c44137e540c48f.png"></p><p>位数计算</p><ol><li>从上图可以看到workerCountOf这个函数传入ctl之后，是通过ctl &amp; CAPACITY操作来获取当前运行线程总数的。也就是RunningState | WorkCount &amp; CAPACITY，算出来的就是低28位的值。因为CAPACITY得到的就是高3位（29-31位）位0，低28位（0-28位）都是1，所以得到的就是ctl中低28位的值。</li><li>而runStateOf这个方法的话，算的就是RunningState | WorkCount &amp; <del>CAPACITY，高3位的值，因为</del>CAPACITY是CAPACITY的取反，所以得到的就是高3位（29-31位）为1，低28位（0-28位）为0，所以通过&amp;运算后，所得到的值就是高3为的值。</li><li>从而理解了ctl中是高3位作为状态值，低28位作为线程的线程数量来进行存储的原因。</li></ol><h2 id="线程池ctl源码"><a href="#线程池ctl源码" class="headerlink" title="线程池ctl源码"></a>线程池ctl源码</h2><p>打开ThreadPoolExecutor的源码（我裁剪掉了一部分），一开始就会发现：</p><pre><code class="line-numbers language-java">public class ThreadPoolExecutor extends AbstractExecutorService {        /** 我以一个字节8位来简化解释线程池对运行状态和当前有效线程个数的原子管理方案             * 线程池当中，用一个ctl原子变量包装了高3位的运行状态和低5位的线程个数         *         *   运行状态:  线程池初始化后，就处于该状态：此时，线程池可以接受新任务并且处理任务         *   关闭状态:  调用shutdown()方法时，就处于该状态：此时，shutdown()方法之后不能再提交新任务，线程池会把shutdown()方法之前提交的任务按照线程池工作原理的步骤都处理完毕。（请参考我的博客：线程池工作原理）         *   停止状态:  调用shutdownNow()方法时，就处于该状态：此时，shutdownNow()方法之后不能再提交新任务，线程池不处理已经提交到任务队列中的任务，线程池尝试中断正在执行的工作线程         *   整理状态:  线程池内部自己使用的状态：当线程池queue任务队列为空，hashset&lt;worker&gt;为空时，就是该状态，该状态是由关闭状态/停止状态转变而来的。当处于整理状态时，线程池会调用terminated()钩子方法         *   终结状态:  当钩子方法terminated()执行完毕之后，线程池由整理状态转变为终结状态。钩子方法是线程池自动调用的。         *         *   在线程池终结状态之前，可以调用awaitTermination()阻塞方法，使当前主线程阻塞，直至线程状态转变为终结状态         */          /**     * The main pool control state, ctl, is an atomic integer packing     * two conceptual fields     *   workerCount, indicating the effective number of threads     *   runState,    indicating whether running, shutting down etc      *      * The runState provides the main lifecycle control, taking on values:      *      *   RUNNING: Accept new tasks and process queued tasks      *   SHUTDOWN: Don't accept new tasks, but process queued tasks      *   STOP: Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks      *   TIDYING: All tasks have terminated, workers is zero,the thread transitioning to state TIDYING      *   TERMINATED: terminated() has completed        *        * RUNNING -&gt; SHUTDOWN On invocation of shutdown(), perhaps implicitly in finalize()        * (RUNNING or SHUTDOWN) -&gt; STOP On invocation of shutdownNow()        * SHUTDOWN -&gt; TIDYING when both queue and pool are empty，will run the terminated() method        * STOP -&gt; TIDYING When pool is empty        * TIDYING -&gt; TERMINATED when the terminated() hook method has completed        *         * Threads waiting in awaitTermination() will return when the state reaches TERMINATED.         */        private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));        private static final int COUNT_BITS = Integer.SIZE - 3;        private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;            // runState is stored in the high-order bits        private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;        private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;        private static final int STOP       =  1 &lt;&lt; COUNT_BITS;        private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;        private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;            // Packing and unpacking ctl        private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }        private static int workerCountOf(int c)  { return c &amp; CAPACITY; }        private static int ctlOf(int rs, int wc) { return rs | wc; }            .......    }</code></pre><h2 id="线程池ctl分析"><a href="#线程池ctl分析" class="headerlink" title="线程池ctl分析"></a>线程池ctl分析</h2><p>负数的表示方法：补码表示法（原码的反码+1），</p><p>我以8字节举例（同理适应于32位或64位机器）</p><p>上源码：我以8字节举例（同理适应于32位或64位机器）</p><pre><code class="line-numbers language-java">private static final int COUNT_BITS = Integer.SIZE - 3;            //8-3=5 活跃线程支持5位来表示个数private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1; //1左移5位-1（1*2的5次方-1），也就是31个线程（低5位）   也就是00000001左移5位是00100000，然后再减00000001得到最终结果00011111将低5位标识线程数的部分保留 // runState is stored in the high-order bitsprivate static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;       // -1即11111111 左移5位后为11100000 表示运行状态（高3位）private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;    //  0即00000000 左移5位后为00000000 表示关闭状态（高3位）private static final int STOP       =  1 &lt;&lt; COUNT_BITS;           //  1即00000001 左移5位后为00100000 表示停止状态（高3位）private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;         //  2即00000010 左移5位后为01000000 表示关闭状态（高3位）private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;   //  3即00000011 左移5位后为01100000 表示关闭状态（高3位）</code></pre><p>不难发现，高3位很好的表示5种状态 000 SHUTDOWN，001 STOP，010 TIDYING，011 TERMINATED，111 RUNNING</p><h3 id="private-static-int-ctlOf-int-rs-int-wc-return-rs-wc"><a href="#private-static-int-ctlOf-int-rs-int-wc-return-rs-wc" class="headerlink" title="private static int ctlOf(int rs, int wc) { return rs | wc; }"></a>private static int ctlOf(int rs, int wc) { return rs | wc; }</h3><p>假如：当前线程池是运行状态 rs = -1 并且有效线程是3个（ws），那么ctlOf(rs,wc)方法的逻辑是什么意思呢？rs | wc 的翻译如下：</p><p>11100000 （运行状态）<br>或             （0|1为1，1|1为1，0|0为0，也就是说，或的位运算，有1就为真）<br>00000011（线程个数）<br>的值为：11100011 表示ctl当前的值：有3个线程，线程池处于运行状态<br>该方法用于初始化ctl</p><h3 id="private-final-AtomicInteger-ctl-x3D-new-AtomicInteger-ctlOf-RUNNING-0"><a href="#private-final-AtomicInteger-ctl-x3D-new-AtomicInteger-ctlOf-RUNNING-0" class="headerlink" title="private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));"></a>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</h3><p>由以上的ctlOf()举例分析，知晓了，初始化的ctl值为11100000，高3位表示线程池目前处于运行状态，低5位表示线程0个</p><h3 id="private-static-int-runStateOf-int-c-return-c-amp-CAPACITY"><a href="#private-static-int-runStateOf-int-c-return-c-amp-CAPACITY" class="headerlink" title="private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }"></a>private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }</h3><p>这里的c是ctl.get()得到的原子值（AtomicInteger原子类中的volatile变量），也可以理解为当前ctl的值，这个值的高3位表示线程池的运行状态，低5位表示当前的线程个数。</p><p>c &amp; ~CAPACITY 翻译如下：</p><p>假如c的值当前就是上面的举例：11100011 表示有3个线程，线程池处于运行状态</p><p>~CAPACITY 的运算即为：00011111求反，得值为11100000<br>c &amp; ~CAPACITY<br>11100011（高3位表示运行状态）<br>与            （0&amp;1为0，1&amp;1为1，0&amp;0为0，也就是说，与的位运算，有0必为假）<br>11100000</p><p>得值为：11100000 会发现，runStateOf()方法的目的就是高3位原是什么样，现运算后还是什么样，剔除掉了低5位的影响，我们通过runStateOf()方法拿到了纯的当前状态的值xxx00000 xxx刚好是：当初规定好的高3位表示当前的线程池状态</p><h3 id="private-static-int-workerCountOf-int-c-return-c-amp-CAPACITY"><a href="#private-static-int-workerCountOf-int-c-return-c-amp-CAPACITY" class="headerlink" title="private static int workerCountOf(int c)  { return c &amp; CAPACITY; }"></a>private static int workerCountOf(int c)  { return c &amp; CAPACITY; }</h3><p>有了以上 c &amp; ~CAPACITY 翻译后，这里就较好理解，下面翻译下 c &amp; CAPACITY</p><p>假如c的值当前就是上面的举例：11100011 表示有3个线程，线程池处于运行状态</p><p>c &amp; CAPACITY<br>11100011（高3位表示运行状态）<br>与            （0&amp;1为0，1&amp;1为1，0&amp;0为0，也就是说，与的位运算，有0必为假）<br>00011111</p><h2 id="线程池ctl如何管理池状态和线程数"><a href="#线程池ctl如何管理池状态和线程数" class="headerlink" title="线程池ctl如何管理池状态和线程数"></a>线程池ctl如何管理池状态和线程数</h2><p>翻看ThreadPoolExecutor的源码会发现：</p><p>ctl的初始化：</p><pre><code class="line-numbers language-java">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static int ctlOf(int rs, int wc) { return rs | wc; }</code></pre><p>ctl在线程池运行期间，有大量的方法都调用了：</p><pre><code class="line-numbers language-java">ctl.compareAndSet(expect, update); //这个操作是原子操作，表示设置当前ctl的值。</code></pre><p>可参考AtomicInteger原子类的compareAndSet()方法</p><pre><code class="line-numbers language-java">public final boolean compareAndSet(int expect, int update)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程池的内部类Worker</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-xian-cheng-chi-de-nei-bu-lei-worker/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-xian-cheng-chi-de-nei-bu-lei-worker/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程池的内部类Worker"><a href="#【Java-多线程并发】-线程池的内部类Worker" class="headerlink" title="【Java 多线程并发】 线程池的内部类Worker"></a>【Java 多线程并发】 线程池的内部类Worker</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程池的内部类Workerdate: 2023-07-05 12:15tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 线程池的内部类Worker</code></pre><h2 id="【Java-多线程并发】-线程池的内部类Worker-1"><a href="#【Java-多线程并发】-线程池的内部类Worker-1" class="headerlink" title="【Java 多线程并发】 线程池的内部类Worker"></a>【Java 多线程并发】 线程池的内部类Worker</h2><p>Worker是ThreadPoolExecutor中的内部类，它其实就可以<mark style="background: #FFB8EBA6;">相当于线程池中存储的线程</mark>，用它来执行提交给线程池的任务，但是这个worker并不是一个单纯的线程，而是它的属性中持有一个线程，它还有其他的属性，用来做一些数据统计以及实现一些执行任务相关的功能。</p><h2 id="Worker类对象的类图"><a href="#Worker类对象的类图" class="headerlink" title="Worker类对象的类图"></a>Worker类对象的类图</h2><p><img src="/attachment/bd07504845a005a26b47fd5dd17930e2.png"></p><h2 id="Worker类对象的解释"><a href="#Worker类对象的解释" class="headerlink" title="Worker类对象的解释"></a>Worker类对象的解释</h2><p>线程池中的线程，都会被封装成一个Worker类对象，ThreadPoolExecutor维护的其实就是一组Worker对象，其中用集合workers存储这些Worker对象；</p><p>Worker类中有两个属性，一个是firstTask，用来保存传入线程池中的任务，一个是thread，是在构造Worker对象的时候，利用ThreadFactory来创建的线程，用来处理任务的线程；</p><p>Worker继承AQS，使用AQS实现独占锁，并且是不可重入的，构造Worker对象的时候，会把锁资源状态设置成-1，因为新增的线程，还没有处理过任务，是不允许被中断的</p><p><strong>Worker使用AQS来实现的不可重入锁，固定state只有1个。以下为它的AQS实现：</strong></p><pre><code class="line-numbers language-java">private final class Worker        extends AbstractQueuedSynchronizer        implements Runnable{    ....        protected boolean isHeldExclusively() {        return getState() != 0;    }        protected boolean tryAcquire(int unused) {        if (compareAndSetState(0, 1)) {            setExclusiveOwnerThread(Thread.currentThread());            return true;        }        return false;    }        protected boolean tryRelease(int unused) {        setExclusiveOwnerThread(null);        setState(0);        return true;    }        public void lock()        { acquire(1); }    public boolean tryLock()  { return tryAcquire(1); }    public void unlock()      { release(1); }    public boolean isLocked() { return isHeldExclusively(); }    ....}</code></pre><p>也就是说Worker对象本身就有lock()、unlock()、tryLock()、isLocked()等方法可以调用，用来给Worker对象加锁。</p><p>lock 方法一旦获取了独占锁，表示当前线程正在执行任务中；那么它会有以下几个作用</p><ul><li>如果正在执行任务，则不应该中断线程；</li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li><li>线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers 方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态</li><li>之所以设置为不可重入，是因为我们不希望任务在调用像 setCorePoolSize 这样的线程池控制方法时重新获取锁，这样会中断正在运行的线程</li></ul><h3 id="Worker继承自AQS有何意义？"><a href="#Worker继承自AQS有何意义？" class="headerlink" title="Worker继承自AQS有何意义？"></a>Worker继承自AQS有何意义？</h3><p>前面我们看了Worker内部类的定义，它继承自AQS，天生自带锁的特性，那么，它的锁是用来干什么的呢？跟任务的执行有关系吗？</p><p>答：既然是跟锁（同步）有关，说明Worker类跨线程使用了，此时我们查看它的lock()方法发现只在runWorker()方法中使用了，但是其tryLock()却是在interruptIdleWorkers()方法中使用的。</p><pre><code class="line-numbers language-java">private void interruptIdleWorkers(boolean onlyOne) {    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        for (Worker w : workers) {            Thread t = w.thread;            if (!t.isInterrupted() &amp;&amp; w.tryLock()) {                try {                    t.interrupt();                } catch (SecurityException ignore) {                } finally {                    w.unlock();                }            }            if (onlyOne)                break;        }    } finally {        mainLock.unlock();    }}</code></pre><p>interruptIdleWorkers()方法的意思是中断空闲线程的意思，它只会中断BlockingQueue的poll()或take()方法，而不会中断正在执行的任务。</p><p>一般来说，interruptIdleWorkers()方法的调用不是在本工作线程，而是在主线程中调用的，还记得shutdown()和shutdownNow()方法吗？</p><p>观察两个方法中中断线程的方法，shutdown()中就是调用了interruptIdleWorkers()方法来中断线程地，而且interruptIdleWorkers()方法中就用到了tryLock()，只有获取到锁了才能中断线程，如果没有获取到锁则不中断。而调用tryLock()后没获取到锁只有一种原因，那就是lock()所在的地方runWorker()方法中，有任务正在执行。这样shutdown()方法就实现了只中断空闲线程，不会中断正在执行任务的线程。</p><p>而shutdownNow()中中断线程则很暴力，并没有tryLock()，而是直接中断了线程，所以调用shutdownNow()可能会中断正在执行的任务。</p><p>所以，Worker继承自AQS实际是要使用其锁的能力，<mark style="background: #FFB8EBA6;">这个锁主要是用来控制调用shutdown()时不要中断正在执行任务的线程。</mark></p><p>那么为什么Worker使用AQS实现锁，而不直接用ReentrantLock呢？我们可以看到<mark style="background: #FFB8EBA6;">Worker的tryAcquire 方法，它是不允许重入的</mark>，而 ReentrantLock是允许重入的。所以这是为了实现不可重入的特性去反应线程现在的执行状态。</p><h2 id="Worker的主要代码"><a href="#Worker的主要代码" class="headerlink" title="Worker的主要代码"></a>Worker的主要代码</h2><pre><code class="line-numbers language-java">private final class Workerextends AbstractQueuedSynchronizerimplements Runnable{    /**     * This class will never be serialized, but we provide a     * serialVersionUID to suppress a javac warning.     */    private static final long serialVersionUID = 6138294804551838833L;        /** 这个就是worker持有的线程，也就是线程池中的线程 */        final Thread thread;        /** 这个就是提交给线程池的任务 */        Runnable firstTask;        /** 每一个线程执行的任务数量的计数器 */      volatile long completedTasks;        /**     * 我们在调用addWorker方法的时候就会调用这个构造方法，有可能是创建新线程并执行任务，那么firstTask就是传给线程池要执行的任务，如果只是了     * 单纯的想创建一个线程，只需要传入null就可以     */    Worker(Runnable firstTask) {        setState(-1); // inhibit interrupts until runWorker        this.firstTask = firstTask;            // 这个是通过线程工厂类创建一个线程，也就是给线程池创建一个线程        this.thread = getThreadFactory().newThread(this);     }        /** Delegates main run loop to outer runWorker  */    public void run() {        runWorker(this);    }        省略上面已经讲过的利用AQS实现锁的部分......}</code></pre><p>以上就是Worker内部类的源码，所以Worker内部类的实现很简单，没有多少代码，它调用的很多方法其实仍然是ThreadPoolExecutor中的方法。</p><p>总体来看，worker其实就是一个Runable，其也是需要构造成一个Thread对象，然后调用Thread.start()方法运行的。<mark style="background: #FFB8EBA6;">只不过在worker的run方法中是定义了一个runWoker的方法。这个方法的主要内容从 for 循环不停的从task队列中获取对应的runable的task，然后同步调用这个task的run()方法。</mark>其实就是在某个线程中，不停的拿队列中的任务进行执行。</p><h3 id="运行worker"><a href="#运行worker" class="headerlink" title="运行worker"></a>运行worker</h3><p>可以看到构造方法内，有一个Thread对象，其使用了ThreadFactory构造了一个新的线程，并且线程的runable是worker本身。</p><pre><code class="line-numbers language-java">this.thread = getThreadFactory().newThread(this);</code></pre><p>所以需要执行worker的时候，只需要调用worker中的thread的start()方法即可，并且可以调用thread的方法来控制worker的状态，例如interrupt等。</p><p>只有运行启动了的线程，才能够去执行线程池中的任务。因为线程去获取任务执行的逻辑是定义在Worker的runWorker()方法中的，而runWorker()方法放在了Worker的run()方法中，想要执行run()方法，就需要去调用Worker类中thread对象的start()方法。所以当向线程池中成功添加worker线程后，需要将该worker线程启动才能正常使用该线程去执行任务。</p><h3 id="worker和ThreadPool的关系"><a href="#worker和ThreadPool的关系" class="headerlink" title="worker和ThreadPool的关系"></a>worker和ThreadPool的关系</h3><p>在ThreadPool中是有一个worker集合的。通过这个集合，我们可以知道有多少worker线程在进行工作等，每一个worker都是各自进行工作，工作的内容就是不停的获取task，然后执行task即可。</p><h2 id="Worker源码分析"><a href="#Worker源码分析" class="headerlink" title="Worker源码分析"></a>Worker源码分析</h2><p>下面我们对Worker的一些关键方法源码进行分析，来帮助我们理解Worker的运作原理。下面就是工作线程执行任务时用到的核心方法分析。</p><h3 id="Worker实现接口Runnable，执行run方法"><a href="#Worker实现接口Runnable，执行run方法" class="headerlink" title="Worker实现接口Runnable，执行run方法"></a>Worker实现接口Runnable，执行run方法</h3><p>Worker的run()方法中，实际上执行的是runWorker()方法。该方法实际上就是让线程去线程池中拿任务来执行。</p><p>runWorker()方法是线程池真正执行任务的地方。</p><p>这里要注意，run()方法是Worker类的方法，但是其调用的runWorker()方法是ThreadPoolExecutor中的方法。</p><p>java.util.concurrent.ThreadPoolExecutor#runWorker</p><pre><code class="line-numbers language-java">// 向线程池中添加线程成功，并且启动也成功，则会执行Worker对象的run方法，进入runWorker方法逻辑final void runWorker(ThreadPoolExecutor.Worker w) {    // 获取当前线程，其实这个当前线程，就是worker对象持有的线程，从线程池中拿到的任务就是由这个线程执行的    Thread wt = Thread.currentThread();    // 在构造Worker对象的时候，会把一个任务添加进Worker对象    // 因此需要把其作为新增线程的第一个任务来执行    Runnable task = w.firstTask;    // 上面已经将该任务拿出来准备进行执行了（将firstTask取出赋值给task），则需要将该worker对象即线程池中的线程对象持有的任务清空    w.firstTask = null;    // 将AQS锁资源的状态由-1变成0，运行该线程进行中断 因为在创建的时候将state设为-1了，现在开始执行任务了，也就需要加锁了，所以要把state再重新变为0，这样在后面执行任务的时候才能用来加锁，保证任务在执行过程中不会出现并发异常    // 解锁    w.unlock();    // 用来判断执行任务的过程中，是否出现了异常    boolean completedAbruptly = true;    try {        // 线程池中的线程循环处理线程池中的任务，直到线程池中的所有任务都被处理完后则跳出循环        while (task != null || (task = getTask()) != null) {  // 这一步的getTask()就说明Worker一直在轮询的从队列中获取任务，getTask()方法将从队列获取到的任务返回，赋值给task            // 给该worker加锁，一个线程只处理一个任务。注意加锁是给worker线程加锁，不是给任务线程加锁，因为worker线程之前一直在轮询地在队列中取任务，但是当执行任务的时候，为了避免执行任务出现异常，就对其加锁            w.lock();            // 线程池是否是STOP状态            // 如果是，则确保当前线程是中断状态            // 如果不是，则确保当前线程不是中断状态            if ((runStateAtLeast(ctl.get(), STOP) ||                    (Thread.interrupted() &amp;&amp;                            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                    !wt.isInterrupted())                // 注意这里中断的是当前线程，也就是worker对象持有的线程                wt.interrupt();                        try {                // 扩展使用，在执行任务的run方法之前执行                beforeExecute(wt, task);                // 记录执行任务过程中，出现的异常                Throwable thrown = null;                try {                    // 执行任务的run方法   当前线程环境就是worker对象持有的线程，所以本质就是woker对象在执行task任务的run()方法                    task.run();                } catch (RuntimeException x) {                    thrown = x; throw x;                } catch (Error x) {                    thrown = x; throw x;                } catch (Throwable x) {                    thrown = x; throw new Error(x);                } finally {                    // 扩展使用，在执行任务的run方法之后执行                    afterExecute(task, thrown);                }            } finally {                // 执行完任务后，就将任务对象清空                task = null;                w.completedTasks++; // 该worker已经完成的任务数+1                w.unlock();  // 将worker线程地锁释放            }        }        // 正常执行完任务        completedAbruptly = false;    } finally {        // 线程池中所有的任务都处理完后，或者执行任务的过程中出现了异常，就会执行该方法        processWorkerExit(w, completedAbruptly);    }} </code></pre><p>这个方法主要做几件事</p><ol><li>如果 task 不为空，则开始执行 task</li><li>如果 task 为空，则通过 getTask()再去取任务，并赋值给 task，如果取到的 Runnable 不为空，则执行该任务</li><li>执行完毕后，通过 while 循环继续 getTask()取任务</li><li>如果 getTask()取到的任务依然是空，那么整个 runWorker()方法执行完毕</li></ol><p>这个方法比较简单，如果忽略状态检测和锁的内容，本质就是如果有第一个任务，就先执行之，之后再从任务队列中取任务来执行，获取任务是通过getTask()来进行的。</p><p><strong>Worker执行任务流程图：</strong></p><p><img src="/attachment/f81240ae5b0e08f5daf71c4aaae5c594.png"></p><h3 id="核心方法-getTask"><a href="#核心方法-getTask" class="headerlink" title="核心方法 getTask()"></a>核心方法 getTask()</h3><p>这个方法用来向队列中轮询地尝试获取任务。该方法也是ThreadPoolExecutor中的方法。</p><p>这里重要的地方是第二个 if 判断，目的是控制线程池的有效线程数量。</p><p>由上文中的分析可以知道，在执行 execute 方法时，如果当前线程池的线程数量超过了 corePoolSize 且小于maximumPoolSize，并且 workQueue 已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是 timedOut 为 true 的情况，说明 workQueue 已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于 corePoolSize 数量的线程销毁掉，保持线程数量在 corePoolSize 即可。</p><p><strong>什么时候会销毁？</strong></p><p>当然是 runWorker()方法执行完之后，也就是 Worker 中的 run 方法执行完，由 JVM 自动回收。</p><pre><code class="line-numbers language-java">// 返回任务Runnableprivate Runnable getTask() {    // timedOut表示 记录上一次从队列中获取任务是否超时    boolean timedOut = false; // Did the last poll() time out?    // 自旋    for (;;) {        // 这一部分是判断线程池状态        // 获取线程池的状态和线程池中线程数量组成的整形字段，32位        // 高3位代表线程池的状态，低29位代表线程池中线程的数量        int c = ctl.get();        // 获取高3位的值，即线程池的状态        int rs = runStateOf(c);        // 如果线程池状态不是Running状态，并且 线程也不是SHUTDOWN状态 或者任务队列已空        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {            // 则将线程池中的线程数量减1  就是说该线程已经不是运行状态了，所以要这个worker线程也没有用了，直接将该worker去掉。这个是原子操作            decrementWorkerCount();            //返回一个空任务，因为：            // 1：如果任务队列已空，则想返回任务也没有            // 2:如果线程池处于STOP或者之上的状态，则线程池不允许再处理任务            return null;        }        // 这一部分是判断线程池有效线程数量        // 获取低29位的值，即线程池中线程的数量        int wc = workerCountOf(c);        // timed是否需要进行超时控制        // allowCoreThreadTimeOut默认false        // 当线程池中线程的数量没有达到核心线程数量时，获取任务的时候允许超时  如果将allowCoreThreadTimeOut设为true，那也不允许超时        // 当线程池中线程的数量超过核心线程数量时，获取任务的时候不允许超时           boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 这个很好理解         // wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；        // timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时        // 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；        // 如果减1失败，则continue返回重试        // 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {            if (compareAndDecrementWorkerCount(c))                return null;            continue;        }         // 如果上面都没问题，就可以获取任务了        try {            // 获取任务            // 如果timed = true ，说明需要做超时控制，则根据keepAliveTime设置的时间内，阻塞等待从队列中获取任务            // 如果timed = false，说明不需要做超时控制，则阻塞，直到从队列中获取到任务为止            Runnable r = timed ?                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                    workQueue.take();            // 如果获取到任务，则把任务返回            if (r != null)                return r;            // 执行到这里，说明在允许的时间内，没有获取到任务            timedOut = true;        } catch (InterruptedException retry) {            // 获取任务没有超时，但是出现异常了，将timedOut设置为false            timedOut = false;        }    }}</code></pre><p>注意，这里取任务会根据工作线程的数量判断是使用BlockingQueue的poll(timeout, unit)方法还是take()方法。</p><p>poll(timeout, unit)方法会在超时时返回null，如果timeout&lt;=0，队列为空时直接返回null。<br>take()方法会一直阻塞直到取到任务或抛出中断异常。<br>所以，如果keepAliveTime设置为0，当任务队列为空时，非核心线程取不出来任务，会立即结束其生命周期。<br>默认情况下，是不允许核心线程超时的，但是可以通过下面这个方法设置使核心线程也可超时：</p><pre><code class="line-numbers language-java">public void allowCoreThreadTimeOut(boolean value) {    if (value &amp;&amp; keepAliveTime &lt;= 0)        throw new IllegalArgumentException("Core threads must have nonzero keep alive times");    if (value != allowCoreThreadTimeOut) {        allowCoreThreadTimeOut = value;        if (value)            // 中断空闲的线程            interruptIdleWorkers();    }}</code></pre><p>getTask()方法返回 null 时，在 runWorker()方法中会跳出 while 循环，然后会执行processWorkerExit 方法。</p><h3 id="核心方法-processWorkerExit"><a href="#核心方法-processWorkerExit" class="headerlink" title="核心方法 processWorkerExit()"></a>核心方法 processWorkerExit()</h3><p>runWorker 的 while 循环执行完毕以后，在 finally 中会调用 processWorkerExit()方法，来销毁工作线程。该方法就是判断当前线程是需要将其删除还是继续执行任务。该方法也是ThreadPoolExecutor中的方法。</p><p>但这个方法只有在一定情况下才会起作用，如果已经从队列中取不出任务来了，或者在worker执行任务过程中出现了错误，这个方法就起到了作用，如果正常的话这个方法就没啥用。</p><pre><code class="line-numbers language-java">private void processWorkerExit(ThreadPoolExecutor.Worker w, boolean completedAbruptly) {    // 如果 completedAbruptly = true ，则线程执行任务的时候出现了异常，需要从线程池中减少一个线程    // 如果 completedAbruptly = false，则执行getTask方法的时候已经减1，这里无需在进行减1操作    if (completedAbruptly)        decrementWorkerCount();        // 获取线程池的锁，因为后面是线程池的操作，为了并发安全，需要对线程池加锁    final ReentrantLock mainLock = this.mainLock;    // 线程池加锁    mainLock.lock();    try {        // 统计该线程池完成的任务数        completedTaskCount += w.completedTasks;        // 从线程池中移除一个工作线程    works是线程池持有的一个集合          workers.remove(w); // 将没用的worker去掉，也就是当前传入的worker    } finally {        // 线程池解锁        mainLock.unlock();    }    // 根据线程池的状态，决定是否结束该线程池    tryTerminate(); // 钩子方法     // 判断线程池是否需要增加线程    // 获取线程池的状态    int c = ctl.get();    // -当线程池是RUNNING或SHUTDOWN状态时    // --如果worker是异常结束（即completedAbruptly为false），那么会直接addWorker；    // ---如果allowCoreThreadTimeOut = true，并且等待队列有任务，至少保留一个worker；    // ---如果allowCoreThreadTimeOut = false，活跃线程数不少于corePoolSize    if (runStateLessThan(c, STOP)) { // 线程池状态小于STOP，就说明当前线程池是RUNNING或SHUTDOWN状态        // 如果worker是异常结束的，不进入下面的分支，直接去addWorker        if (!completedAbruptly) {            // 根据allowCoreThreadTimeOut的值，来设置线程池中最少的活跃线程数是0还是corePoolSize            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;            // 如果等待队列中有任务，要至少保留一个worker            if (min == 0 &amp;&amp; ! workQueue.isEmpty())                // 至少保留一个worker                min = 1;            // 如果活跃线程数大于等于min，直接返回，不需要再调用addWorker来增加线程池中的线程了            if (workerCountOf(c) &gt;= min)                return; // replacement not needed        }        // 增加线程池中的worker        addWorker(null, false);    }}</code></pre><h3 id="worker的异常处理"><a href="#worker的异常处理" class="headerlink" title="worker的异常处理"></a>worker的异常处理</h3><pre><code class="line-numbers language-java">try {    while (task != null || (task = getTask()) != null) {        w.lock();        // If pool is stopping, ensure thread is interrupted;        // if not, ensure thread is not interrupted.  This        // requires a recheck in second case to deal with        // shutdownNow race while clearing interrupt        if ((runStateAtLeast(ctl.get(), STOP) ||             (Thread.interrupted() &amp;&amp;              runStateAtLeast(ctl.get(), STOP))) &amp;&amp;            !wt.isInterrupted())            wt.interrupt();        try {            beforeExecute(wt, task);            Throwable thrown = null;            try {                task.run();            } catch (RuntimeException x) {                thrown = x; throw x;            } catch (Error x) {                thrown = x; throw x;            } catch (Throwable x) {                thrown = x; throw new Error(x);            } finally {                afterExecute(task, thrown);            }        } finally {            task = null;            w.completedTasks++;            w.unlock();        }    }    completedAbruptly = false;} finally {    processWorkerExit(w, completedAbruptly);}</code></pre><p>通过源代码可以看出，对应的Exception都是保存在thrown中，在finally中交给了afterExecute进行了处理。</p><p>所以可以自己实现对应的afterExecute来进行处理系统内部发生的异常问题。</p><h2 id="Worker工作线程的生命周期"><a href="#Worker工作线程的生命周期" class="headerlink" title="Worker工作线程的生命周期"></a>Worker工作线程的生命周期</h2><p><img src="/attachment/9fbfe29dd019fd8d1ddaba93ad8fb669.png"></p><p> <strong>Worker执行任务的模型如下图所示：</strong></p><p><img src="/attachment/a1c7216d056195156c93b0766c64e109.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Schedule 定时任务</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-schedule-ding-shi-ren-wu/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-schedule-ding-shi-ren-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Schedule-定时任务"><a href="#【Java-多线程并发】-Schedule-定时任务" class="headerlink" title="【Java 多线程并发】 Schedule 定时任务"></a>【Java 多线程并发】 Schedule 定时任务</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Schedule 定时任务date: 2023-07-05 12:01tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 Schedule 定时任务</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在实现定时调度功能的时候，我们往往会借助于第三方类库来完成，比如：quartz、Spring Schedule等等。JDK从1.3版本开始，就提供了基于Timer的定时调度功能。在Timer中，任务的执行是串行的。这种特性在保证了线程安全的情况下，往往带来了一些严重的副作用，比如任务间相互影响、任务执行效率低下等问题。为了解决Timer的这些问题，JDK从1.5版本开始，提供了基于ScheduledExecutorService的定时调度功能。</p><p>虽然Java的定时调度可以通过Timer&amp;TimerTask来实现。但是由于其实现的方式为单线程，因此从JDK1.3发布之后就一直存在一些问题，大致如下：</p><ul><li>多个任务之间会相互影响</li><li>多个任务的执行是串行的，性能较低</li></ul><p>ScheduledExecutorService在设计之初就是为了解决Timer&amp;TimerTask的这些问题。因为天生就是基于多线程机制，所以任务之间不会相互影响（只要线程数足够。当线程数不足时，有些任务会复用同一个线程）。</p><p>除此之外，因为其内部使用的延迟队列，本身就是基于等待/唤醒机制实现的，所以CPU并不会一直繁忙。同时，多线程带来的CPU资源复用也能极大地提升性能。</p><h3 id="ScheduledExecutorService-和-Timer-的区别"><a href="#ScheduledExecutorService-和-Timer-的区别" class="headerlink" title="ScheduledExecutorService 和 Timer 的区别"></a>ScheduledExecutorService 和 Timer 的区别</h3><ul><li>Timer 对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；</li><li>Timer 内部只有一个执行线程，因此长时间运行的任务会延迟其他任务，而且如果有多个任务的话就会顺序执行，这样我们的延迟时间和循环时间就会出现问题。 ScheduledThreadPoolExecutor 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程。所以在多线程环境下对延迟任务和循环任务要求严格的时候，就需要考虑使用ScheduledExecutorService了;</li><li>在TimerTask 中抛出的运行时异常会杀死一个线程，从而导致 Timer 死机，即计划任务将不再运行。ScheduledThreadExecutor 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 afterExecute 方法ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。</li></ul><p>综上，在 JDK1.5 之后，你没有理由再使用 Timer 进行任务调度了。当然，在实际项目中基本也不会用到ScheduledThreadPoolExecutor，所以对这部分大家只需要简单了解一下它的思想。</p><p>备注： Quartz 是一个由 Java 编写的任务调度库，由 OpenSymphony 组织开源出来。在实际项目开发中使用 Quartz 的还是居多，比较推荐使用 Quartz。因为 Quartz 理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等等。</p><h2 id="什么是ScheduledExecutorService？"><a href="#什么是ScheduledExecutorService？" class="headerlink" title="什么是ScheduledExecutorService？"></a>什么是ScheduledExecutorService？</h2><p>ScheduledExecutorService接口是<mark style="background: #FFB8EBA6;">基于ExecutorService</mark>的功能实现的延迟和周期执行任务的功能。每个任务以及每个任务的每个周期都会提交到线程池中由线程去执行，所以任务在不同周期内执行它的线程可能是不同的。ScheduledExecutorService接口的默认实现类是ScheduledThreadPoolExecutor。在周期执行的任务中，如果任务执行时间大于周期时间，则会以任务时间优先，等任务执行完毕后才会进入下一次周期</p><p>ScheduledExecutorService接口中定义了一些方法：</p><pre><code class="line-numbers language-java">public interface ScheduledExecutorService extends ExecutorService {    // 在指定延时后执行一次    public ScheduledFuture&lt;?&gt; schedule(Runnable command,                                       long delay, TimeUnit unit);     // 在指定延时后执行一次    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,                                           long delay, TimeUnit unit);                                               // 在指定延时后开始执行，并在之后以指定时间间隔重复执行（间隔不包含任务执行的时间）    // 相当于之后的延时以任务开始计算    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,                                                  long initialDelay,                                                  long period,                                                  TimeUnit unit);     // 在指定延时后开始执行，并在之后以指定延时重复执行（间隔包含任务执行的时间）    // 相当于之后的延时以任务结束计算    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                     long initialDelay,                                                     long delay,                                                     TimeUnit unit);}</code></pre><h2 id="ScheduledThreadPoolExecutor中的方法"><a href="#ScheduledThreadPoolExecutor中的方法" class="headerlink" title="ScheduledThreadPoolExecutor中的方法"></a>ScheduledThreadPoolExecutor中的方法</h2><p>之前我们讲的ThreadPoolExecutor是java的普通线程池。而ScheduledThreadPoolExecutor是java提供的定时任务线程池。</p><p>因为ScheduledThreadPoolExecutor类继承了ThreadPoolExecutor类，所以有很多方法都是来自ThreadPoolExecutor类，其本身是支持线程池的所有功能，它自己还额外提供了一些关于延迟执行和定时任务的方法。我们常用的有如下几种：</p><pre><code class="line-numbers language-java">/** * 带延迟时间的调度，只执行一次 * 调度之后可通过Future.get()阻塞直至任务执行完毕 */1. public ScheduledFuture&lt;?&gt; schedule(Runnable command,                                      long delay, TimeUnit unit);/** * 带延迟时间的调度，只执行一次 * 调度之后可通过Future.get()阻塞直至任务执行完毕，并且可以获取执行结果 */2. public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,                                          long delay, TimeUnit unit);/** * 带延迟时间的调度，循环执行，固定频率 */3. public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,                                                 long initialDelay,                                                 long period,                                                 TimeUnit unit);/** * 带延迟时间的调度，循环执行，固定延迟 */4. public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                    long initialDelay,                                                    long delay,                                                    TimeUnit unit); </code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code class="line-numbers language-java">ScheduledThreadPoolExecutor(int corePoolSize)ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)</code></pre><ul><li>corePoolSize：线程池核心线程数</li><li>threadFactory：线程工厂</li><li>handler：任务拒绝策略</li></ul><p>构造一个Schedule线程池，最大线程数为Integer的最大值，线程的空闲时间为0，队列采用的是DelayedWorkQueue。</p><h3 id="schedule方法"><a href="#schedule方法" class="headerlink" title="schedule方法"></a>schedule方法</h3><pre><code class="line-numbers language-java">// 延迟执行无返回值单个任务，该方法返回ScheduledFuture，就可以理解普通线程池中返回的FutureScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)// 延迟执行有返回值单个任务，该方法返回ScheduledFuture&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></pre><ul><li>command：要延迟执行的任务（Runnable / Callable）</li><li>delay：延时的时间</li><li>unit：时间单位</li></ul><p>延时delay时长执行Runnable或者Callable任务，只会执行一次。执行Runnable任务时是没有结果返回的，那为什么还会返回ScheduledFuture，因为我们可以通过Future做一些取消任务等操作。该方法会使任务在delay时间之后去执行。</p><p>调度之后还可以通过Future.get()阻塞直至任务执行完毕。</p><h3 id="scheduleAtFixedRate方法"><a href="#scheduleAtFixedRate方法" class="headerlink" title="scheduleAtFixedRate方法"></a>scheduleAtFixedRate方法</h3><pre><code class="line-numbers language-java">ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></pre><ul><li>command：Runnable任务</li><li>initialDelay：任务首次执行前的延迟时间</li><li>period：周期时间</li><li>unit：时间单位</li></ul><p>固定周期性执行任务，当任务的执行时长大于周期，那么下一个周期任务将在上一个执行完毕之后马上执行。</p><p><strong>作用：</strong> 指定的延迟时间（ initialDelay）调度第一次，后续以 period为一个时间周期进行调度，该方法并不 care 每次任务执行的耗时，如果某次耗时超过调度周期（period），则下一次调度从上一次任务结束时开始，然后接着按照period的间隔严格执行任务。</p><p>也就是说这个方法会严格按照周期间隔去执行，并不会管任务的执行时间。</p><p>任务的第一次会在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。意思是下一次执行任务的时间与任务执行过程花费的时间无关，只与period有关！</p><p>如果此任务的任何一个执行要花费比其周期更长的时间，则将推迟后续执行，但不会同时执行。</p><p>如果任务的任何一个执行遇到异常，则后续执行都会被取消。否则，只能通过执行程序的取消或终止方法来终止该任务。</p><h3 id="scheduleWithFixedDelay方法"><a href="#scheduleWithFixedDelay方法" class="headerlink" title="scheduleWithFixedDelay方法"></a>scheduleWithFixedDelay方法</h3><pre><code class="line-numbers language-java">ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></pre><ul><li>command：Runnable任务</li><li>initialDelay：任务首次执行前的延迟时间</li><li>delay：延时时间</li><li>unit：时间单位</li></ul><p>固定延时执行任务，也是周期性任务，和scheduleAtFixedRate不同的是：scheduleAtFixedRate当任务执行时间小于周期时间时，此时周期时间到了的时候会进入下一周期，这一点和scheduleWithFixedDelay是没有区别的；但是如果任务执行时间大于周期时间时，scheduleAtFixedRate的任务结束后会立即进入下一周期；而scheduleWithFixedDelay是无论你任务时间是否超过，都将会在你任务执行完毕后延迟固定时间（delay），才会进入下一周期。</p><p><strong>作用</strong>：在指定的延迟时间（ delay）调度第一次，后续以 period 为一个时间周期进行调度，该方法非常 care 上一次任务执行的耗时，如果某次耗时超过调度周期（period），则下一次调度时间为 上一次任务结束时间 + 调度周期时间</p><p>也就是说使用scheduleWithFixedDelay可以实现在每一次执行终止和下一次执行开始之间都存在给定的延迟（delay）。</p><h3 id="setContinueExistingPeriodicTasksAfterShutdownPolicy方法"><a href="#setContinueExistingPeriodicTasksAfterShutdownPolicy方法" class="headerlink" title="setContinueExistingPeriodicTasksAfterShutdownPolicy方法"></a>setContinueExistingPeriodicTasksAfterShutdownPolicy方法</h3><pre><code class="line-numbers language-java">void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)</code></pre><p> 默认为false。在线程池执行shutdown方法后是否继续执行scheduleAtFixedRate方法和scheduleWithFixedDelay方法提交的任务</p><h3 id="setExecuteExistingDelayedTasksAfterShutdownPolicy方法"><a href="#setExecuteExistingDelayedTasksAfterShutdownPolicy方法" class="headerlink" title="setExecuteExistingDelayedTasksAfterShutdownPolicy方法"></a>setExecuteExistingDelayedTasksAfterShutdownPolicy方法</h3><pre><code class="line-numbers language-java">void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)</code></pre><p> 默认为true，在线程池执行shutdown方法后，需要等待当前正在等待的任务的和正在运行的任务被执行完，然后进程被销毁。为false时，表示放弃等待的任务，正在运行的任务一旦完成，则进程被销毁。</p><h3 id="scheduleAtFixedRate和scheduleWithFixedDelay的区别"><a href="#scheduleAtFixedRate和scheduleWithFixedDelay的区别" class="headerlink" title="scheduleAtFixedRate和scheduleWithFixedDelay的区别"></a>scheduleAtFixedRate和scheduleWithFixedDelay的区别</h3><p>直白地讲，scheduleAtFixedRate()为固定频率，scheduleWithFixedDelay()为固定延迟。固定频率是相对于任务执行的开始时间，而固定延迟是相对于任务执行的结束时间，这就是他们最根本的区别！</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="schedule练习1"><a href="#schedule练习1" class="headerlink" title="schedule练习1"></a>schedule练习1</h3><pre><code class="line-numbers language-java">import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit; public class ScheduledExecutorServiceExample {    public static void main(String[] args) {        // 创建定时任务线程池,核心线程数为2        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);        // 2秒后执行Runnable任务        scheduledThreadPoolExecutor.schedule(() -&gt; {            System.out.println("This is runable1 task");        }, 2, TimeUnit.SECONDS);        // 再提交一个2秒后才执行的Runnable任务        // 既然Runnable无法返回结果,为什么还要有Future呢,因为我们可以通过Future进行取消任务等操作        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.schedule(() -&gt; {            System.out.println("This is runable2 task");        }, 2, TimeUnit.SECONDS);        // 取消任务        runnableFuture.cancel(true);        // 休眠3秒,确保上面的任务都被执行完        mySleep(3);        System.out.println("========================");    }     private static void mySleep(int seconds){        try {            TimeUnit.SECONDS.sleep(seconds);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行结果：</strong></p><pre><code class="line-numbers language-console">This is runable1 task========================</code></pre><h3 id="schedule练习2"><a href="#schedule练习2" class="headerlink" title="schedule练习2"></a>schedule练习2</h3><pre><code class="line-numbers language-java">@Test public void test_schedule4Runnable() throws Exception {    // 创建定时任务线程池    ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();    // 延迟执行任务    ScheduledFuture future = service.schedule(() -&gt; {        try {            Thread.sleep(3000L);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("task finish time: " + format(System.currentTimeMillis()));    }, 1000, TimeUnit.MILLISECONDS);    System.out.println("schedule finish time: " + format(System.currentTimeMillis()));    // 通过get方法阻塞当前线程，直到任务执行完毕    System.out.println("Runnable future's result is: " + future.get() +                       ", and time is: " + format(System.currentTimeMillis()));}</code></pre><p>上述代码达到的效果应该是这样的：延迟执行时间为1秒，任务执行3秒，任务只执行一次，同时通过Future.get()阻塞直至任务执行完毕。</p><p>我们运行看到的效果的确和我们猜想的一样，如下图所示。</p><p><img src="/attachment/7273a2feead5dcb70704b043b7e231ea.png"></p><p>在schedule Runnable的基础上，我们将Runnable改为Callable来看一下。</p><pre><code class="line-numbers language-java">@Test public void test_schedule4Callable() throws Exception {    // 创建定时任务线程池    ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();    // 提交一个带返回值的Callable任务，延迟1秒执行    ScheduledFuture&lt;String&gt; future = service.schedule(() -&gt; {        try {            Thread.sleep(3000L);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("task finish time: " + format(System.currentTimeMillis()));        return "success";    }, 1000, TimeUnit.MILLISECONDS);    System.out.println("schedule finish time: " + format(System.currentTimeMillis()));    // 通过future.get()方法获取任务执行结果，如果任务还没执行完，则会阻塞等待    System.out.println("Callable future's result is: " + future.get() +            ", and time is: " + format(System.currentTimeMillis()));}</code></pre><p>运行看到的结果和Runnable基本相同，唯一的区别在于future.get()能拿到Callable返回的真实结果。</p><p><img src="/attachment/77dc7be74d95175ed0b84379f410d585.png"></p><h3 id="scheduleAtFixedRate练习1"><a href="#scheduleAtFixedRate练习1" class="headerlink" title="scheduleAtFixedRate练习1"></a>scheduleAtFixedRate练习1</h3><p>周期性执行某个任务，执行到一定时间后取消任务</p><pre><code class="line-numbers language-java">import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ScheduledExecutorServiceExample2 {    public static void main(String[] args) {        // 创建定时任务线程池        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);        // 提交延迟1秒执行,周期为2秒的runnable任务,虽然Runnable没有返回结果,但是可以通过runnableFuture取消任务        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; {            System.out.println("This is runable task running "+Thread.currentThread().getName());        }, 1,2, TimeUnit.SECONDS);        // 休眠8秒        mySleep(8);        // 取消该循坏任务        runnableFuture.cancel(true);    }        private static void mySleep(int seconds){        try {            TimeUnit.SECONDS.sleep(seconds);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行结果：</strong></p><p>可以看出每个周期执行的任务并不是同一个线程，周期时间到的时候只是将任务扔到线程池的任务队列中由空闲线程获取它的执行权。</p><pre><code class="line-numbers language-console">This is runable task running pool-1-thread-1This is runable task running pool-1-thread-1This is runable task running pool-1-thread-1This is runable task running pool-1-thread-2</code></pre><h3 id="scheduleAtFixedRate练习2"><a href="#scheduleAtFixedRate练习2" class="headerlink" title="scheduleAtFixedRate练习2"></a>scheduleAtFixedRate练习2</h3><p>超时的周期性任务</p><pre><code class="line-numbers language-java">import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicLong;public class ScheduledExecutorServiceExample3 {    public static void main(String[] args) {        // 创建定时任务线程池        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);        // 创建一个原子计数器        AtomicLong atomicLong = new AtomicLong(0L);        // 提交初始延迟1秒执行,固定周期为2秒的Runnable任务        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; {            // 记录当前时间            Long current = System.currentTimeMillis();            // 判断是否为第一次运行            if (atomicLong.get()==0) {                atomicLong.set(current);                System.out.printf("first running [%d]\n",atomicLong.get());            } else {                // 记录与上次的间隔时间                System.out.printf("running time:[%d]\n",current-atomicLong.get());            }            // 将当前时间保存            atomicLong.set(current);            // 模拟超过固定周期时间，故意让任务晚结束，导致超过本轮周期时长了            mySleep(5);        }, 1,2, TimeUnit.SECONDS);    }    private static void mySleep(int seconds){        try {            TimeUnit.SECONDS.sleep(seconds);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行结果：</strong></p><p>可以看出，超出周期时间时，任务完成后立即就进入了下一周期</p><pre><code class="line-numbers language-console">first running [1597659726690]running time:[5042]running time:[5001]running time:[5000]running time:[5001]</code></pre><h3 id="scheduleWithFixedDelay练习"><a href="#scheduleWithFixedDelay练习" class="headerlink" title="scheduleWithFixedDelay练习"></a>scheduleWithFixedDelay练习</h3><pre><code class="line-numbers language-java">import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicLong; public class ScheduledExecutorServiceExample4 {    public static void main(String[] args) {        // 创建定时任务线程池        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);        // 创建原子计数器        AtomicLong atomicLong = new AtomicLong(0L);        // 提交初始延迟1秒执行,延迟为2秒的runnable任务        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; {            // 记录当前时间            Long current = System.currentTimeMillis();            // 判断是否为第一次运行            if (atomicLong.get() == 0){                atomicLong.set(current);                System.out.printf("first running [%d]\n",atomicLong.get());            }else{                //记录与上次的间隔时间                System.out.printf("running time:[%d]\n",current-atomicLong.get());            }            // 将当前时间保存            atomicLong.set(current);            // 模拟超过固定周期时间   使其运行时间超过周期时间            mySleep(5);        }, 1,2, TimeUnit.SECONDS);    }    private static void mySleep(int seconds){        try {            TimeUnit.SECONDS.sleep(seconds);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行结果：</strong></p><p>可以看出来，无论你的任务执行多久，在任务执行完毕之后都会延迟一个调度周期时间才进入下一周期。</p><pre><code class="line-numbers language-console">first running [1597659862349]running time:[7047]running time:[7002]running time:[7023]running time:[7002]running time:[7003]</code></pre><h3 id="setContinueExistingPeriodicTasksAfterShutdownPolicy练习"><a href="#setContinueExistingPeriodicTasksAfterShutdownPolicy练习" class="headerlink" title="setContinueExistingPeriodicTasksAfterShutdownPolicy练习"></a>setContinueExistingPeriodicTasksAfterShutdownPolicy练习</h3><pre><code class="line-numbers language-java">import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ScheduledExecutorServiceExample5 {    public static void main(String[] args) {        // 创建定时任务线程池        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);        // 提交固定周期任务        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; {            System.out.println("This is runable task running "+Thread.currentThread().getName());        }, 1,2, TimeUnit.SECONDS);        // 默认情况关闭线程池后是不允许继续执行固定周期任务的，所有输出false        System.out.println(scheduledThreadPoolExecutor.getContinueExistingPeriodicTasksAfterShutdownPolicy());        // 设置为true        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);        // 休眠1200毫秒，确保任务被执行        mySleep(1200);        // 关闭线程池        scheduledThreadPoolExecutor.shutdown();        // 休眠2000毫秒后查看线程池状态        mySleep(2000);        // 线程池的状态        System.out.println("isShutdown:"+scheduledThreadPoolExecutor.isShutdown());        System.out.println("isTerminating:"+scheduledThreadPoolExecutor.isTerminating());        System.out.println("isTerminated:"+scheduledThreadPoolExecutor.isTerminated());    }        private static void mySleep(int milliSeconds){        try {            TimeUnit.MILLISECONDS.sleep(milliSeconds);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行结果：</strong></p><p>可以看出来，设置为true之后，即使线程池关闭了，定时任务仍然在执行</p><pre><code class="line-numbers language-console">falseThis is runable task running pool-1-thread-1This is runable task running pool-1-thread-1isShutdown:trueisTerminating:trueisTerminated:falseThis is runable task running pool-1-thread-1This is runable task running pool-1-thread-1</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Executors框架创建线程池</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-executors-kuang-jia-chuang-jian-xian-cheng-chi/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-executors-kuang-jia-chuang-jian-xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Executors框架创建线程池"><a href="#【Java-多线程并发】-Executors框架创建线程池" class="headerlink" title="【Java 多线程并发】 Executors框架创建线程池"></a>【Java 多线程并发】 Executors框架创建线程池</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Executors框架创建线程池date: 2023-07-05 11:44tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 Executors框架创建线程池</code></pre><h2 id="【Java-多线程并发】-Executors框架创建线程池-1"><a href="#【Java-多线程并发】-Executors框架创建线程池-1" class="headerlink" title="【Java 多线程并发】 Executors框架创建线程池"></a>【Java 多线程并发】 Executors框架创建线程池</h2><p>以下是使用 Executors框架去创建的线程池，是Java内置的线程池，已经设好了相应的参数。</p><p>用法：ExecutorService executorService = Executors.newFixedThreadPool(2);</p><p>通过Executor框架对线程池的构建，都是基于 ThreadpoolExecutor 构造方法来构建的。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。整个线程池的线程数量并不固定，会随着需要来进行调整变化。该线程池使用同步队列 SynchronousQueue，该队列没有容量。</p><h3 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h3><p>（1）线程池中数量<mark style="background: #FFB8EBA6;">没有核心线程</mark>，并且非核心线程数量不固定，没有上限，可达到最大值（Interger. MAX_VALUE）。<br>（2）线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟，线程空闲时间超过60秒就会被回收）<br>（3）当线程池中，没有可用线程，会重新创建一个线程（会维持至少有一个空闲线程在线程池中）<br>（4）使用的是<mark style="background: #FFB8EBA6;">SynchronousQueue队列</mark>，只能存储一个任务<br>（5）60秒后将空闲线程关闭后，<mark style="background: #FFB8EBA6;">当线程池内线程为0时会自动关闭线程池</mark><br>（6）<mark style="background: #FFB8EBA6;">初始化线程大小为0</mark></p><h3 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h3><p>（1）Executors.newCachedThreadPool();<br>（2）Executors.newCachedThreadPool(ThreadFactory threadFactory);</p><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><pre><code class="line-numbers language-java">public static ExecutorService newCachedThreadPool() {    /*     * 0：表示核心线程数为0     * Integer.MAX_VALUE：表示最大线程数为Integer.MAX_VALUE     * 60L：表示线程空闲时间为60秒，当线程数量超过核心线程数时，超过的空闲线程如果空闲时间超过60秒就会被回收，因为这个线程池的核心线程数量设置的为0，所以这个线程池中所有的线程只要是空闲时间超过了60s，都会被回收     * TimeUnit.SECONDS：表示秒为时间单位     * new SynchronousQueue&lt;Runnable&gt;()：表示线程池中使用的阻塞队列为同步队列      */    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());} public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {    /*     * 0：表示核心线程数为0     * Integer.MAX_VALUE：表示最大线程数为Integer.MAX_VALUE     * 60L：表示线程空闲时间为60秒     * TimeUnit.SECONDS：表示秒为时间单位     * new SynchronousQueue&lt;Runnable&gt;()：表示线程池中使用的阻塞队列为同步队列     * threadFactory：表示线程工厂     */    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;(),                                  threadFactory);}</code></pre><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><ol><li>没有核心线程，直接向 SynchronousQueue 中提交任务。SynchronousQueue内部没有容器，该队列不会保留任务，任务达到后直接创建线程。</li><li>如果有空闲线程，就去取出任务执行；如果没有空闲线程，就新建一个</li><li>执行完任务的线程有 60 秒生存时间，如果在这个时间内可以接到新任务，就可以继续活下去，否则就被回收</li></ol><h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><ul><li>只适合短暂的任务，如果是非常耗时的任务不建议使用，因为每次提交一个任务都会开启一个线程，线程过多可能导致OMM</li><li>用来创建一个可以无限扩大的线程池，适用于服务器负载较轻，执行很多短期异步任务。</li></ul><h2 id="newFixedThreadPool（fixed：固定的）"><a href="#newFixedThreadPool（fixed：固定的）" class="headerlink" title="newFixedThreadPool（fixed：固定的）"></a>newFixedThreadPool（fixed：固定的）</h2><h3 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h3><p>创建一个<mark style="background: #FFB8EBA6;">可重用固定线程数</mark>的线程池，以无界队列方式来运行这些线程，该线程池的线程数在创建时就被固定了，不可以扩大。在任意时间点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在线程关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在，即使线程一直处在空闲状态且队列为空，也不会被回收，直到调用shutdown。该线程池使用无界队列 LinkedBlockingQueue，该队列的最大容量为 Integer.MAX_VALUE，可以认为是无界的。因为不可以扩大线程数，所以也就不存在回收线程。</p><h3 id="特征：-1"><a href="#特征：-1" class="headerlink" title="特征："></a>特征：</h3><p>（1）FixedThreadPool 的<mark style="background: #FFB8EBA6;">核心线程数和最大线程数都是指定值</mark>，也就是说当线程池中的线程数超过核心线程数后，任务都会被放到阻塞队列中。该线程池的核心线程数量和最大线程数量是一样的，即全部都为核心线程。<br>（2）FixedThreadPool选用的阻塞队列是 <mark style="background: #FFB8EBA6;">LinkedBlockingQueue</mark>，使用的是默认容量 <mark style="background: #FFB8EBA6;">Integer.MAX_VALUE</mark>， 相当于没有上限<br>（3）线程池中的线程处于一定的量，可以很好的控制线程的并发量<br>（4）线程可以重复被使用，在线程被显示关闭之前，都将一直存在<br>（5）初始化时该线程池中的线程数就定了，是固定的，不可以扩大<br>（6）当线程处于空闲，且任务队列为空时，线程池也不会关闭</p><h3 id="创建方式：-1"><a href="#创建方式：-1" class="headerlink" title="创建方式："></a>创建方式：</h3><p>（1）Executors.newFixedThreadPool(int nThreads)；//nThreads为线程的数量<br>（2）Executors.newFixedThreadPool(int nThreads，ThreadFactory threadFactory)；//nThreads为线程的数量，threadFactory创建线程的工厂方式</p><h3 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h3><pre><code class="line-numbers language-java">// 该线程池的最大线程数量和核心线程数量是一样的public static ExecutorService newFixedThreadPool(int nThreads) {        /**         * nThreads:表示线程池中核心线程数量         * nThreads:表示线程池中最大线程数量         * 0L:表示线程池中空闲线程的存活时间，0表示当线程数量超过线程池的核心线程数后，超过的线程如果空闲时间超过0就会被回收，这也就说明该线程池的线程数量是不会超过nThreads的，超过的空闲线程就会被回收。但是如果没有超过核心线程数量，空闲线程就可以一直存活，除非显式地关闭线程         * TimeUnit.MILLISECONDS:表示空闲线程的存活时间的单位         * new LinkedBlockingQueue&lt;Runnable&gt;():表示线程池中的任务队列使用的是无界队列LinkedBlockingQueue         */        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;());} // 默认情况下该线程池地最大线程数量和核心线程数量都是1，说明该线程池中只有一个线程在工作public static ExecutorService newSingleThreadExecutor() {        /**         * 1:表示线程池中核心线程数量         * 1:表示线程池中最大线程数量         * 0L:表示线程池中空闲线程的存活时间，0表示当线程数量超过线程池的核心线程数后，超过的线程如果空闲时间超过0就会被回收，这也就说明该线程池的线程数量是不会超过nThreads的，超过的空闲线程就会被回收。但是如果没有超过核心线程数量，空闲线程就可以一直存活，除非显式地关闭线程         * TimeUnit.MILLISECONDS:表示空闲线程的存活时间的单位         * new LinkedBlockingQueue&lt;Runnable&gt;():表示线程池中的任务队列使用的是无界队列LinkedBlockingQueue         */        return new FinalizableDelegatedExecutorService            (new ThreadPoolExecutor(1, 1,                                    0L, TimeUnit.MILLISECONDS,                                    new LinkedBlockingQueue&lt;Runnable&gt;()));}</code></pre><h3 id="执行流程：-1"><a href="#执行流程：-1" class="headerlink" title="执行流程："></a>执行流程：</h3><ol><li>线程数少于核心线程数，也就是设置的线程数时，新建线程执行任务</li><li>线程数等于核心线程数后，将任务加入阻塞队列</li><li>由于队列容量非常大，可以一直添加</li><li>执行完任务的线程反复去队列中取任务执行</li></ol><h3 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h3><p>主要适用于固定大小的线程池，因为它是无界的阻塞队列，那么线程池中的线程不会扩大，适用与可以预测线程数的场景中，或者服务器的负载很高，为了资源的合理利用，需要对线程数量进行严格控制的场景中。</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><h3 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h3><p>创建一个使用单个 worker 线程的 线程池，即该线程池只会有一个线程处于活动状态，所以任务只能一个一个被执行。以<mark style="background: #FFB8EBA6;">无界队列</mark>方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。该线程池使用无界队列 LinkedBlockingQueue，该队列的最大容量为 Integer.MAX_VALUE，可以认为是无界的。</p><h3 id="特征：-2"><a href="#特征：-2" class="headerlink" title="特征："></a>特征：</h3><p>（1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行<br>（2）该线程池是一个单线程化的线程池，它只会用<mark style="background: #FFB8EBA6;">唯一的工作线程来执行任务</mark>，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行<br>（3）SingleThreadExecutor选用的阻塞队列是 LinkedBlockingQueue，使用的是默认容量 Integer.MAX_VALUE， 相当于没有上限<br>（4）newSingleThreadExecutor返回的是一个经过代理的ExecutorService，不能转换为ThreadPoolExecutor，这也就意味着它只有一些ExecutorService的基本方法<br>（5）SingleThreadExecutor与单独new出来的Thread区别在于，单独new出来的Thread任务结束之后线程也就会随着结束，而且不可以submit提交任务到队列</p><h3 id="创建方式：-2"><a href="#创建方式：-2" class="headerlink" title="创建方式："></a>创建方式：</h3><p>（1）Executors.newSingleThreadExecutor() ；<br>（2）Executors.newSingleThreadExecutor(ThreadFactory threadFactory)；// threadFactory创建线程的工厂方式</p><h3 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h3><pre><code class="line-numbers language-java">public static ExecutorService newSingleThreadExecutor() {    /**     * 1（corePoolSize）：表示线程池中的核心线程数量     * 1：表示线程池的最大线程数量     * 0L（keepAliveTime）：表示线程池中超过corePoolSize数目的空闲线程最大存活时间，该线程池是值得核心线程数量为1，所以只要是线程池中的线程数量超过1，该空闲线程就会被回收     * TimeUnit.MILLISECONDS：参数keepAliveTime的时间单位     * new LinkedBlockingQueue&lt;Runnable&gt;()：一个阻塞队列，用来存储等待执行的任务     */    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));} public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {    /**     * 1（corePoolSize）：表示线程池中的核心线程数量     * 1：表示线程池的最大线程数量     * 0L（keepAliveTime）：表示线程池中超过corePoolSize数目的空闲线程最大存活时间，该线程池是值得核心线程数量为1，所以只要是线程池中的线程数量超过1，该空闲线程就会被回收     * TimeUnit.MILLISECONDS：参数keepAliveTime的时间单位     * new LinkedBlockingQueue&lt;Runnable&gt;()：一个阻塞队列，用来存储等待执行的任务     * threadFactory：线程工厂，用来创建线程     */    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;(),                                threadFactory));}</code></pre><h3 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h3><p>适用于需要保证任务被按顺序执行，并且在任何时候都不会出现多个线程的情况。</p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><p>创建一个线程池，它可以实现在给定延迟后运行命令或者定期地执行。该线程池使用延迟阻塞队列 DelayedWorkQueue。</p><h3 id="特征：-3"><a href="#特征：-3" class="headerlink" title="特征："></a>特征：</h3><p>（1）线程池中具有指定数量的线程，即便是空线程也将保留<br>（2）可定时或者延迟执行线程活动</p><h3 id="创建方式：-3"><a href="#创建方式：-3" class="headerlink" title="创建方式："></a>创建方式：</h3><p>（1）Executors.newScheduledThreadPool(int corePoolSize)；// corePoolSize线程的个数<br>（2）newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)；// corePoolSize线程的个数，threadFactory创建线程的工厂</p><h3 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h3><pre><code class="line-numbers language-java">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {    // corePoolSize：表示线程池中的核心线程数    return new ScheduledThreadPoolExecutor(corePoolSize);} public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) {    // corePoolSize：表示线程池中的核心线程数    // threadFactory：线程工厂，用于创建线程    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);}</code></pre><h2 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h2><h3 id="作用：-3"><a href="#作用：-3" class="headerlink" title="作用："></a>作用：</h3><p>创建一个单线程执行程序，它可实现在给定延迟后运行命令或者定期地执行。该线程池使用延迟阻塞队列 DelayedWorkQueue。</p><h3 id="特征：-4"><a href="#特征：-4" class="headerlink" title="特征："></a>特征：</h3><p>（1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行<br>（2）可定时或者延迟执行线程活动</p><h3 id="创建方式：-4"><a href="#创建方式：-4" class="headerlink" title="创建方式："></a>创建方式：</h3><p>（1）Executors.newSingleThreadScheduledExecutor() ；<br>（2）Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory) ；//threadFactory创建线程的工厂</p><h3 id="源码：-4"><a href="#源码：-4" class="headerlink" title="源码："></a>源码：</h3><pre><code class="line-numbers language-java">public static ScheduledExecutorService newSingleThreadScheduledExecutor() {    return new DelegatedScheduledExecutorService        (new ScheduledThreadPoolExecutor(1));} public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {    return new DelegatedScheduledExecutorService        (new ScheduledThreadPoolExecutor(1, threadFactory));}</code></pre><h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><h3 id="特征：-5"><a href="#特征：-5" class="headerlink" title="特征："></a>特征：</h3><p>（1）该方法会根据你的CPU核数来创建线程个数，也可指定线程数<br>（2）newWorkStealingPool其内部使用的是ForkJoinPool，在任务全部执行完之后该线程池会自动关闭</p><h3 id="适用场景：-3"><a href="#适用场景：-3" class="headerlink" title="适用场景："></a>适用场景：</h3><p>创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行，适用于大耗时的操作，可以并行来执行</p><h2 id="为什么不推荐使用内置线程池？"><a href="#为什么不推荐使用内置线程池？" class="headerlink" title="为什么不推荐使用内置线程池？"></a>为什么不推荐使用内置线程池？</h2><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><h3 id="为什么呢？"><a href="#为什么呢？" class="headerlink" title="为什么呢？"></a>为什么呢？</h3><ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</li></ul><p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><h3 id="Executors-返回线程池对象的弊端如下-后文会详细介绍到-："><a href="#Executors-返回线程池对象的弊端如下-后文会详细介绍到-：" class="headerlink" title="Executors 返回线程池对象的弊端如下(后文会详细介绍到)："></a>Executors 返回线程池对象的弊端如下(后文会详细介绍到)：</h3><ul><li>FixedThreadPool 和 SingleThreadExecutor：使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li><li>ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。</li></ul><p>所以不建议用下面这些方法创建线程池，还是直接使用ThreadPoolExecutor的构造方法，自己制定相应的参数来创建。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Java线程池的核心参数</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-java-xian-cheng-chi-de-he-xin-can-shu/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-java-xian-cheng-chi-de-he-xin-can-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Java线程池的核心参数"><a href="#【Java-多线程并发】-Java线程池的核心参数" class="headerlink" title="【Java 多线程并发】 Java线程池的核心参数"></a>【Java 多线程并发】 Java线程池的核心参数</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Java线程池的核心参数date: 2023-07-05 10:33tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 Java线程池的核心参数</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ThreadPoolExecutor的构造方法是创建线程池的入口，虽然比较简单，但是信息量很大，由此也能引发一系列的问题，构造方法中有很多核心参数，这也是面试中经常被问到的问题。</p><p>Executors创建线程池也是基于ThreadPoolExecutor的构造方法实现的。定时任务线程池还基于ScheduledThreadPoolExecutor的构造方法，但归根结底还是基于ThreadPoolExecutor，所以下面我们对线程池核心参数的讲解都是基于ThreadPoolExecutor来分析的。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ThreadPoolExecutor有四个构造方法，其中前三个最终都是调用最后一个，它有7个参数，分别为corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。</p><pre><code class="line-numbers language-java">// 构造方法有不同的参数版本，以满足不同的需求public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue) {    // 使用默认线程工厂和默认拒绝策略  Executors.defaultThreadFactory()和defaultHandler    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), defaultHandler);}  public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory) {    // 使用默认拒绝策略                             this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         threadFactory, defaultHandler);}  public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          RejectedExecutionHandler handler) {    // 使用默认线程工厂                            this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), handler);}  /** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 * 所有的构造方法最终都会调用这个构造方法，都是基于这个方法实现的 */public ThreadPoolExecutor(  int corePoolSize, // 线程池的核心线程数量                            int maximumPoolSize, // 线程池的最大线程数                            long keepAliveTime, // 当线程数大于核心线程数时，多余的空闲线程存活的最长时间                            TimeUnit unit, // 存活时间的时间单位                            BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列，用来储存等待执行任务的队列                            ThreadFactory threadFactory, // 线程工厂，用来创建线程，一般默认即可                            RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务                        ) {    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.acc = System.getSecurityManager() == null ?            null :            AccessController.getContext();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}</code></pre><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li>corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li>maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue：新任务来的时候会先判断当前运行（正在执行任务的线程）的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p>ThreadPoolExecutor其他常见参数 :</p><ul><li>keepAliveTime：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li><li>unit: keepAliveTime 参数的时间单位。</li><li>threadFactory：executor（线程池）创建新线程的时候会用到。</li><li>handler：饱和策略。关于饱和策略下面单独介绍一下。</li></ul><p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：</p><p><img src="/attachment/5e7e6976f5895ecfa45428c2206ba93c.png"></p><h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><p><strong>参数说明</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池维护线程的最少数量。线程池至少会保持改数量的线程存在，即使没有任务可以处理。（注意：这里说的至少是指线程达到这个数量后，即使有空闲的线程也不会释放，而不是说线程池创建好之后就会初始化这么多线程）</td></tr><tr><td>maximumPoolSize</td><td>线程池维护线程的最大数量。线程池最多可创建的线程数，即使队列中的任务满了线程数量也不会超过 maximumPoolSize</td></tr><tr><td>keepAliveTime</td><td>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于 corePoolSize 时，超过 corePoolSize 的线程如果空闲时间超过 keepAliveTime，线程将被终止</td></tr><tr><td>unit</td><td>线程池维护线程所允许的空闲时间的单位，和 keepAliveTime 配合使用</td></tr><tr><td>workQueue</td><td>线程池所使用的缓冲队列。ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue，PriorityBlockingQueue</td></tr><tr><td>handler</td><td>线程池对拒绝任务的处理策略。AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy，自定义</td></tr></tbody></table><h3 id="corePoolSize-线程池核心线程大小"><a href="#corePoolSize-线程池核心线程大小" class="headerlink" title="corePoolSize 线程池核心线程大小"></a>corePoolSize 线程池核心线程大小</h3><p>线程池中会维护一个最小的线程数量，即使这些线程处于空闲状态，它们也不会被销毁，除非设置了allowCoreThreadTimeOut为true。所以默认情况下核心线程数量只会增多，不会减少，因为核心线程是不会被销毁的，除非显式的将线程销毁。</p><ul><li>当正在运行的线程数小于核心线程数时，来一个任务就创建一个核心线程；</li><li>当正在运行的线程数大于或等于核心线程数时，任务来了先不创建线程而是丢到任务队列中。</li></ul><h3 id="maximumPoolSize-线程池最大线程数量"><a href="#maximumPoolSize-线程池最大线程数量" class="headerlink" title="maximumPoolSize 线程池最大线程数量"></a>maximumPoolSize 线程池最大线程数量</h3><p>当正在运行的线程大于等于核心线程数的时，一个任务被提交到线程池后会被加入到任务队列中，在队列中等待核心线程将其取出并执行处理。但是如果任务提交的速度大于核心线程处理任务的速度，有界的任务队列就会被填满，<mark style="background: #BBFABBA6;">当任务队列满了时，再来一个任务才会创建一个非核心线程</mark>，但线程池中核心线程数量 + 非核心线程数量 不能超过最大线程数。这个最大线程数量即由maximunPoolSize来指定。如果是无界的任务队列这个参数就没用了</p><h3 id="keepAliveTime-空闲线程存活时间"><a href="#keepAliveTime-空闲线程存活时间" class="headerlink" title="keepAliveTime 空闲线程存活时间"></a>keepAliveTime 空闲线程存活时间</h3><p>一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定。内部主要是通过阻塞队列带超时的poll(timeout, unit)方法实现的。</p><p>默认情况下，此参数仅当正在运行的线程数大于核心线程数时才有效，即只针对非核心线程。</p><p>但是，如果allowCoreThreadTimeOut被设置成了true，针对核心线程也有效。</p><h3 id="unit-空间线程存活时间单位"><a href="#unit-空间线程存活时间单位" class="headerlink" title="unit 空间线程存活时间单位"></a>unit 空间线程存活时间单位</h3><p>keepAliveTime的计量单位。可选的单位有Days、HOURS、MINUTES、MILLISECONDS、MICROSECONDS、NANOSECONDS。</p><h3 id="workQueue-工作队列"><a href="#workQueue-工作队列" class="headerlink" title="workQueue 工作队列"></a>workQueue 工作队列</h3><p>当正在运行的线程数大于或等于核心线程数时，任务来了是先进入任务队列中的。</p><p>这个队列必须是阻塞队列，所以像ConcurrentLinkedQueue这种就不能作为参数，因为它虽然是并发安全的队列，但是它不是阻塞队列，因为它并没有实现BlockingQueue接口。</p><p>当任务进入到工作队列后，在任务调度时再从队列中取出任务。线程池中比较常用的四种工作队列（阻塞队列）：</p><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p><h4 id="LinkedBlockingQuene"><a href="#LinkedBlockingQuene" class="headerlink" title="LinkedBlockingQuene"></a>LinkedBlockingQuene</h4><p>基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</p><h4 id="SynchronousQuene"><a href="#SynchronousQuene" class="headerlink" title="SynchronousQuene"></a>SynchronousQuene</h4><p>一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务（不会将该任务暂时寄存在队列中等待），如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p><p>SynchronousQuene同步队列没有任何内部容量，甚至连一个队列的容量都没有。</p><p>感觉ArrayBlockingQueue就像一个隧道，而SynchronousQueue就像一个门框（门框上不可以站人），进出队列就是穿门而过。</p><p>Executors提供的newCachedThreadPool线程池就是用了SynchronousQueue做任务队列，而它的核心线程数为0，最大线程数为无限大。</p><pre><code class="line-numbers language-java">public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}</code></pre><p>因为核心线程数为0，所以任务来时，只能新建线程池（如果没有空闲的线程），因为SynchronousQueue队列没有容量，不能存放任务，有了工作线程之后通过SynchronousQueue队列获取任务（让任务穿门而过，前一个任务不被线程领取，后边的任务不能过门）</p><p>所以这个线程池不能用于执行耗时的任务，因为他的最大线程数为无限大，很可能会建很多的线程。</p><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>具有优先级的无界阻塞队列，优先级通过参数Comparator实现。比较器（Comparable、Comparator）</p><h3 id="threadFactory-线程工厂"><a href="#threadFactory-线程工厂" class="headerlink" title="threadFactory 线程工厂"></a>threadFactory 线程工厂</h3><p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程（守护线程）、查看创建线程数、给线程设置是否是后台运行、设置线程优先级等等。</p><p>默认使用的是Executors工具类中的DefaultThreadFactory类，这个类有个缺点，创建的线程的名称是自动生成的，无法自定义以区分不同的线程池，且它们都是非守护线程。</p><p>源码:</p><pre><code class="line-numbers language-java">static class DefaultThreadFactory implements ThreadFactory {    private static final AtomicInteger poolNumber = new AtomicInteger(1);    private final ThreadGroup group;    private final AtomicInteger threadNumber = new AtomicInteger(1);    private final String namePrefix;    DefaultThreadFactory() {        SecurityManager s = System.getSecurityManager();        group = (s != null) ? s.getThreadGroup() :                              Thread.currentThread().getThreadGroup();        namePrefix = "pool-" +                      poolNumber.getAndIncrement() +                     "-thread-";    }    public Thread newThread(Runnable r) {        Thread t = new Thread(group, r,                              namePrefix + threadNumber.getAndIncrement(),                              0);        if (t.isDaemon())            t.setDaemon(false);        if (t.getPriority() != Thread.NORM_PRIORITY)            t.setPriority(Thread.NORM_PRIORITY);        return t;    }}</code></pre><h3 id="handler-拒绝策略"><a href="#handler-拒绝策略" class="headerlink" title="handler 拒绝策略"></a>handler 拒绝策略</h3><table><thead><tr><th>RejectedExecutionHandler</th><th>特性及效果</th></tr></thead><tbody><tr><td>AbortPolicy</td><td>线程池默认的策略，如果元素添加到线程池失败，会抛出 RejectedExecutionException 异常</td></tr><tr><td>DiscardPolicy</td><td>如果添加失败，则放弃，并且不会抛出任何异常</td></tr><tr><td>DiscardOldestPolicy</td><td>如果添加到线程池失败，会将队列中最早添加的元素移除，再尝试添加，如果失败则按该策略不断重试</td></tr><tr><td>CallerRunsPolicy</td><td>如果添加失败，那么主线程会自己调用执行器中的 execute 方法来执行改任务</td></tr><tr><td>自定义</td><td>如果觉得以上几种策略都不合适，那么可以自定义符合场景的拒绝策略。需要实现 RejectedExecutionHandler 接口，并将自己的逻辑写在 rejectedExecution 方法内。</td></tr></tbody></table><p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢？这里的拒绝策略，就是解决这个问题的。</p><p>拒绝策略表示当任务队列满了且线程数也达到最大了，这时候再新加任务，线程池已经无法承受了，这些新来的任务应该按什么逻辑来处理。</p><p>常用的拒绝策略有丢弃当前任务、丢弃最老的任务、抛出异常、调用者自己处理等待。</p><p>默认的拒绝策略是抛出异常（AbortPolicy），即线程池无法承载了，调用者再往里面添加任务会抛出异常。</p><p>默认的拒绝策略虽然比较简单粗暴，但是相对于丢弃任务策略明显要好很多，最起码调用者自己可以捕获这个异常再进行二次处理。</p><p>jdk中提供了四种拒绝策略（policy：政策，策略）：</p><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><p>该策略是线程池的默认策略。使用该策略时，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。</p><pre><code class="line-numbers language-java">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {    //不做任何处理，直接抛出异常    throw new RejectedExecutionException("Task " + r.toString() +                                         " rejected from " +                                         e.toString());}</code></pre><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><p>这个策略和AbortPolicy的slient版本，如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常。</p><pre><code class="line-numbers language-java">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {    //就是一个空的方法}</code></pre><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><p>该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</p><pre><code class="line-numbers language-java">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {    if (!e.isShutdown()) {        //移除队头元素        e.getQueue().poll();        //再尝试入队        e.execute(r);    }}</code></pre><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p>使用此策略，如果添加到线程池失败，那么主线程（调用线程池执行任务的线程）会自己去执行该任务，不会等待线程池中的线程去执行。就像是个急脾气的人，我等不到别人来做这件事就干脆自己干。</p><pre><code class="line-numbers language-java">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {    if (!e.isShutdown()) {        //直接执行run方法        r.run();    }}</code></pre><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>如果以上策略都不符合业务场景，那么可以自己定义一个拒绝策略，只要实现RejectedExecutionHandler接口，并且实现rejectedExecution方法就可以了。具体的逻辑就在rejectedExecution方法里去定义就OK了。</p><pre><code class="line-numbers language-java">public class MyRejectPolicy implements RejectedExecutionHandler{    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {        //Sender是我的Runnable类，里面有message字段        if (r instanceof Sender) {            Sender sender = (Sender) r;            //直接打印            System.out.println(sender.getMessage());        }    }}</code></pre><h2 id="执行拒绝策略"><a href="#执行拒绝策略" class="headerlink" title="执行拒绝策略"></a>执行拒绝策略</h2><p>以ThreadPoolExecutor为例，它是通过自己的reject()方法来执行拒绝策略的。</p><pre><code class="line-numbers language-java">// 要针对任务command执行拒绝策略final void reject(Runnable command) {    // handler就是核心参数中传入的拒绝策略    // 如果创建线程池时没有向构造方法中传入拒绝策略，那么默认的拒绝策略就是抛出异常    handler.rejectedExecution(command, this);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程池</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-xian-cheng-chi/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程池"><a href="#【Java-多线程并发】-线程池" class="headerlink" title="【Java 多线程并发】 线程池"></a>【Java 多线程并发】 线程池</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程池date: 2023-07-05 10:30tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 线程池</code></pre><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>顾名思义，线程池就是<mark style="background: #FFB8EBA6;">管理一系列线程的资源池</mark>。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><p>在 Java 中，如果每个请求到达就创建一个新线程，创建和销毁线程花费的时间和消耗的系统 资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。 如果在一个 JVM里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。</p><p>为了解决这个问题，就有了线程池的概念，线程池的核心逻辑是提前创建好若干个线程放在一个容器中。如果有任务需要处理，则将任务直接分配给线程池中的线程来执行就行，任务处理完以后这个线程不会被销毁，而是等待后续分配任务。同时通过线程池来重复管理线程还可以避免创建大量线程增加开销。</p><p><img src="/attachment/176893d8945ca5ebf0aa5792bf4849b9.png"></p><h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。合理的设置线程池大小可以避免因为线程数超过硬件资源瓶颈带来的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Future机制</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-future-ji-zhi/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-future-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Future机制"><a href="#【Java-多线程并发】-Future机制" class="headerlink" title="【Java 多线程并发】 Future机制"></a>【Java 多线程并发】 Future机制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Future机制date: 2023-07-05 09:54tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 Future机制</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>核心思想</strong></p><p>一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去控制方法f的计算过程。</p><p><strong>方法</strong></p><ul><li>get方法：获取计算结果（如果还没计算完，也是必须等待的）</li><li>cancel方法：还没计算完，可以取消计算过程</li><li>isDone方法：判断是否计算完</li><li>isCancelled方法：判断计算是否被取消</li></ul><p><strong>FutureTask</strong></p><p>FutureTask是Future的具体实现。FutureTask实现了RunnableFuture接口。RunnableFuture接口又同时继承了Future 和 Runnable 接口。<br>FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。</p><p>state字段</p><ul><li>volatile修饰的state字段；表示FutureTask当前所处的状态。</li></ul><pre><code class="line-numbers language-java">/**     * Possible state transitions:     * NEW -&gt; COMPLETING -&gt; NORMAL（创建到正常运行结束的状态变化轨迹）     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL（创建到异常运行结束的状态变化轨迹）     * NEW -&gt; CANCELLED  （创建到取消的状态变化轨迹）     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED（创建到中断结束的状态变化轨迹）     */    private volatile int state;     // NEW 新建状态，表示这个 FutureTask还没有开始运行    private static final int NEW          = 0;       // COMPLETING 完成状态， 表示 FutureTask 任务已经计算完毕了       // 但是还有一些后续操作，例如唤醒等待线程操作，还没有完成。    private static final int COMPLETING   = 1;       // FutureTask 任务完结，正常完成，没有发生异常    private static final int NORMAL       = 2;       // FutureTask 任务完结，因为发生异常。    private static final int EXCEPTIONAL  = 3;       // FutureTask 任务完结，因为取消任务    private static final int CANCELLED    = 4;       // FutureTask 任务完结，也是取消任务，不过发起了中断运行任务线程的中断请求    private static final int INTERRUPTING = 5;       // FutureTask 任务完结，也是取消任务，已经完成了中断运行任务线程的中断请求    private static final int INTERRUPTED  = 6;</code></pre><p><strong>CompletableFuture</strong></p><p>Future 不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。</p><ul><li>观察者模式</li><li>提供了更为好用和强大的 Future 特性</li><li>函数式编程</li><li>异步任务编排组合</li></ul><p><img src="/attachment/c5b2007f356169eb2402602bcec20625.png"></p><p><strong>CompletableFuture常用方法</strong></p><ul><li>获取结果<ul><li>public T get()</li><li>public T get(long timeout,TimeUnit unit)</li><li>public T join() —&gt;和get一样的作用，只是不需要抛出异常</li><li>public T getNow(T valuelfAbsent) —&gt;计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞</li></ul></li><li>主动触发计算<ul><li>public boolean complete(T value) —-&gt;是否打断get方法立即返回括号值</li></ul></li><li>接受任务的处理结果，并消费处理，无返回结果<ul><li>thenAccept</li></ul></li><li>对比补充<ul><li>thenRun(Runnable runnable) :任务A执行完执行B，并且不需要A的结果</li><li>thenAccept(Consumer action): 任务A执行完执行B，B需要A的结果，但是任务B没有返回值</li><li>thenApply(Function fn): 任务A执行完执行B，B需要A的结果，同时任务B有返回值</li></ul></li><li>谁快用谁<ul><li>applyToEither</li></ul></li><li>对计算结果进行合并<ul><li>两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理</li><li>先完成的先等着，等待其他分支任务</li></ul></li></ul><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>先上一个场景：假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。</p><p>实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。</p><p>但是，子线程执行的结果是要返回厨具的，而run方法是没有返回值的。所以，这才是难点，需要好好考虑一下。</p><h3 id="模拟代码1："><a href="#模拟代码1：" class="headerlink" title="模拟代码1："></a>模拟代码1：</h3><pre><code class="line-numbers language-java">package test;public class CommonCook {    public static void main(String[] args) throws InterruptedException {        long startTime = System.currentTimeMillis();        // 第一步 网购厨具        OnlineShopping thread = new OnlineShopping();        thread.start();        thread.join();  // 保证厨具送到         // 第二步 去超市购买食材        Thread.sleep(2000);  // 模拟购买食材时间        Shicai shicai = new Shicai();        System.out.println("第二步：食材到位");         // 第三步 用厨具烹饪食材        System.out.println("第三步：开始展现厨艺");        cook(thread.chuju, shicai);                System.out.println("总共用时" + (System.currentTimeMillis() - startTime) + "ms");    }        // 网购厨具线程    static class OnlineShopping extends Thread {                private Chuju chuju;        @Override        public void run() {            System.out.println("第一步：下单");            System.out.println("第一步：等待送货");            try {                Thread.sleep(5000);  // 模拟送货时间            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println("第一步：快递送到");            chuju = new Chuju();        }            }    //  用厨具烹饪食材    static void cook(Chuju chuju, Shicai shicai) {}        // 厨具类    static class Chuju {}        // 食材类    static class Shicai {}}</code></pre><p>运行结果：</p><ul><li>第一步：下单</li><li>第一步：等待送货</li><li>第一步：快递送到</li><li>第二步：食材到位</li><li>第三步：开始展现厨艺</li></ul><p>总共用时7013ms</p><p>可以看到，多线程已经失去了意义。在厨具送到期间，我们不能干任何事。对应代码，就是调用join方法阻塞主线程。</p><p>有人问了，不阻塞主线程行不行？？？</p><p>不行！！！</p><p>从代码来看的话，run方法不执行完，属性chuju就没有被赋值，还是null，后面执行就会出现空指针异常。换句话说，没有厨具，怎么做饭。</p><p>Java现在的多线程机制，核心方法run是没有返回值的；如果要保存run方法里面的计算结果，必须等待run方法计算完，无论计算过程多么耗时。</p><p>面对这种尴尬的处境，程序员就会想：在子线程run方法计算的期间，能不能在主线程里面继续异步执行？？？</p><p>Where there is a will，there is a way！！！</p><p>这种想法的核心就是Future模式，下面先应用一下Java自己实现的Future模式。</p><h3 id="模拟代码2："><a href="#模拟代码2：" class="headerlink" title="模拟代码2："></a>模拟代码2：</h3><pre><code class="line-numbers language-java">package test;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class FutureCook {    public static void main(String[] args) throws InterruptedException, ExecutionException {        long startTime = System.currentTimeMillis();        // 第一步 网购厨具        Callable&lt;Chuju&gt; onlineShopping = new Callable&lt;Chuju&gt;() {            @Override            public Chuju call() throws Exception {                System.out.println("第一步：下单");                System.out.println("第一步：等待送货");                Thread.sleep(5000);  // 模拟送货时间                System.out.println("第一步：快递送到");                return new Chuju();            }                    };        FutureTask&lt;Chuju&gt; task = new FutureTask&lt;Chuju&gt;(onlineShopping);        new Thread(task).start();        // 第二步 去超市购买食材        Thread.sleep(2000);  // 模拟购买食材时间        Shicai shicai = new Shicai();        System.out.println("第二步：食材到位");        // 第三步 用厨具烹饪食材        if (!task.isDone()) {  // 联系快递员，询问是否到货            System.out.println("第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）");        }        Chuju chuju = task.get();        System.out.println("第三步：厨具到位，开始展现厨艺");        cook(chuju, shicai);                System.out.println("总共用时" + (System.currentTimeMillis() - startTime) + "ms");    }        //  用厨具烹饪食材    static void cook(Chuju chuju, Shicai shicai) {}        // 厨具类    static class Chuju {}        // 食材类    static class Shicai {}}</code></pre><p>运行结果：</p><p>第一步：下单<br>第一步：等待送货<br>第二步：食材到位<br>第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）<br>第一步：快递送到<br>第三步：厨具到位，开始展现厨艺</p><p>总共用时5005ms</p><p>可以看见，在快递员送厨具的期间，我们没有闲着，可以去买食材；而且我们知道厨具到没到，甚至可以在厨具没到的时候，取消订单不要了。</p><p>好神奇，有没有。</p><p>当然你可能会说模拟代码1中，只要join在cook(thread.chuju, shicai);就可以了，但是用future应该来说从编程角度更加自然。</p><p>比如模拟二的逻辑：</p><pre><code class="line-numbers language-java">if (!task.isDone()) { // 联系快递员，询问是否到货System.out.println("第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）");}Chuju chuju = task.get();</code></pre><p>等价于模拟一：</p><pre><code class="line-numbers language-java">thread.start();// 第二步 去超市购买食材Thread.sleep(2000); // 模拟购买食材时间Shicai shicai = new Shicai();System.out.println("第二步：食材到位");thread.join(); // 保证厨具送到 ---------------join应该在购买食材开始后，而不是之前</code></pre><p>用join这种写法也可以达到future的效果，但是使用Future不仅仅是更自然，而且确实是增加了灵活性，比如任务完成与否的判断，任务的取消等。这些是join不能做到的。</p><p>下面具体分析一下第二段代码：</p><p>1）把耗时的网购厨具逻辑，封装到了一个Callable的call方法里面。</p><pre><code class="line-numbers language-java">public interface Callable&lt;V&gt; {    /**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */    V call() throws Exception;}</code></pre><p>Callable接口可以看作是Runnable接口的补充，call方法带有返回值，并且可以抛出异常。</p><p>2）把Callable实例当作参数，生成一个FutureTask的对象，然后把这个对象当作一个Runnable，作为参数另起线程。</p><p>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</p><p>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</p><pre><code class="line-numbers language-java">public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><p>这个继承体系中的核心接口是Future。Future的核心思想是：一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去控制方法f的计算过程。</p><p>这里的控制包括：</p><p>get方法：获取计算结果（如果还没计算完，也是必须等待的）<br>cancel方法：还没计算完，可以取消计算过程<br>isDone方法：判断是否计算完<br>isCancelled方法：判断计算是否被取消</p><p>这些接口的设计很完美，FutureTask的实现注定不会简单，后面再说。</p><p>3）在第三步里面，调用了isDone方法查看状态，然后直接调用task.get方法获取厨具，不过这时还没送到，所以还是会等待3秒。对比第一段代码的执行结果，这里我们节省了2秒。这是因为在快递员送货期间，我们去超市购买食材，这两件事在同一时间段内异步执行。</p><h2 id="为什么出现Future机制"><a href="#为什么出现Future机制" class="headerlink" title="为什么出现Future机制"></a>为什么出现Future机制</h2><p>常见的两种创建线程的方式。一种是直接继承Thread，另外一种就是实现Runnable接口。</p><p>这两种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p><p>从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p>Future模式的核心思想是能够让主线程将原来需要同步等待的这段时间用来做其他的事情。（因为可以异步获得执行结果，所以不用一直同步等待去获得执行结果）</p><p><img src="/attachment/c2c554b65b2f796c180d0b705a278591.png"></p><p>上图简单描述了不使用Future和使用Future的区别，不使用Future模式，主线程在invoke完一些耗时逻辑之后需要等待，这个耗时逻辑在实际应用中可能是一次RPC调用，可能是一个本地IO操作等。B图表达的是使用Future模式之后，我们主线程在invoke之后可以立即返回，去做其他的事情，回头再来看看刚才提交的invoke有没有结果。</p><h3 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h3><p>Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><pre><code class="line-numbers language-java">// V 代表了Future执行的任务返回值的类型public interface Future&lt;V&gt; {    // 取消任务执行    // 成功取消返回 true，否则返回 false    boolean cancel(boolean mayInterruptIfRunning);    // 判断任务是否被取消    boolean isCancelled();    // 判断任务是否已经执行完成    boolean isDone();    // 获取任务执行结果    V get() throws InterruptedException, ExecutionException;    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutExceptio}</code></pre><p>简单理解就是：我有一个任务，提交给了 Future 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 Future 那里直接取出任务执行结果。</p><h2 id="Future的相关类图"><a href="#Future的相关类图" class="headerlink" title="Future的相关类图"></a>Future的相关类图</h2><h3 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h3><p>首先，我们需要清楚，Futrue是个接口。Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p><img src="/attachment/b66232f729a217a8539994376b42dc53.png"></p><p>口定义行为，我们通过上图可以看到实现Future接口的子类会具有哪些行为：</p><ul><li>我们可以取消这个执行逻辑，如果这个逻辑已经正在执行，提供可选的参数来控制是否取消已经正在执行的逻辑。</li><li>我们可以判断执行逻辑是否已经被取消。</li><li>我们可以判断执行逻辑是否已经执行完成。</li><li>我们可以获取执行逻辑的执行结果。</li><li>我们可以允许在一定时间内去等待获取执行结果，如果超过这个时间，抛TimeoutException。</li></ul><h3 id="FutureTask-类"><a href="#FutureTask-类" class="headerlink" title="FutureTask 类"></a>FutureTask 类</h3><p>类图如下：</p><p><img src="/attachment/2c14b6b8976535d5ac251993e91d3055.png"></p><p>FutureTask是Future的具体实现。FutureTask实现了RunnableFuture接口。RunnableFuture接口又同时继承了Future 和 Runnable 接口。所以FutureTask既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><h2 id="FutureTask源码分析"><a href="#FutureTask源码分析" class="headerlink" title="FutureTask源码分析"></a>FutureTask源码分析</h2><h3 id="state字段"><a href="#state字段" class="headerlink" title="state字段"></a>state字段</h3><p>volatile修饰的state字段；表示FutureTask当前所处的状态。可能的转换过程见注释。</p><pre><code class="line-numbers language-java">/**     * Possible state transitions:     * NEW -&gt; COMPLETING -&gt; NORMAL（创建到正常运行结束的状态变化轨迹）     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL（创建到异常运行结束的状态变化轨迹）     * NEW -&gt; CANCELLED  （创建到取消的状态变化轨迹）     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED（创建到中断结束的状态变化轨迹）     */    private volatile int state;     // NEW 新建状态，表示这个 FutureTask还没有开始运行    private static final int NEW          = 0;       // COMPLETING 完成状态， 表示 FutureTask 任务已经计算完毕了       // 但是还有一些后续操作，例如唤醒等待线程操作，还没有完成。    private static final int COMPLETING   = 1;       // FutureTask 任务完结，正常完成，没有发生异常    private static final int NORMAL       = 2;       // FutureTask 任务完结，因为发生异常。    private static final int EXCEPTIONAL  = 3;       // FutureTask 任务完结，因为取消任务    private static final int CANCELLED    = 4;       // FutureTask 任务完结，也是取消任务，不过发起了中断运行任务线程的中断请求    private static final int INTERRUPTING = 5;       // FutureTask 任务完结，也是取消任务，已经完成了中断运行任务线程的中断请求    private static final int INTERRUPTED  = 6;</code></pre><h3 id="其他变量"><a href="#其他变量" class="headerlink" title="其他变量"></a>其他变量</h3><pre><code class="line-numbers language-java">/** 任务 */    private Callable&lt;V&gt; callable;    /** 储存结果*/    private Object outcome; // non-volatile, protected by state reads/writes    /** 执行任务的线程*/    private volatile Thread runner;    /** get方法阻塞的线程队列 */    private volatile WaitNode waiters;    //FutureTask的内部类，get方法的等待队列    static final class WaitNode {        volatile Thread thread;        volatile WaitNode next;        WaitNode() { thread = Thread.currentThread(); }    }</code></pre><h3 id="CAS工具初始化"><a href="#CAS工具初始化" class="headerlink" title="CAS工具初始化"></a>CAS工具初始化</h3><pre><code class="line-numbers language-java">     // Unsafe mechanics    private static final sun.misc.Unsafe UNSAFE;    private static final long stateOffset;    private static final long runnerOffset;    private static final long waitersOffset;    static {        try {            UNSAFE = sun.misc.Unsafe.getUnsafe();            Class&lt;?&gt; k = FutureTask.class;            stateOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("state"));            runnerOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("runner"));            waitersOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("waiters"));        } catch (Exception e) {            throw new Error(e);        }    }</code></pre><p>这段代码是为了后面使用CAS而准备的。可以这么理解：</p><p>一个java对象可以看成是一段内存，各个字段都得按照一定的顺序放在这段内存里，同时考虑到对齐要求，可能这些字段不是连续放置的，用这个UNSAFE.objectFieldOffset（）方法能准确地告诉你某个字段相对于对象的起始内存地址的字节偏移量，因为是相对偏移量，所以它其实跟某个具体对象又没什么太大关系，跟class的定义和虚拟机的内存模型的实现细节更相关。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>FutureTask有两个构造函数：</p><pre><code class="line-numbers language-java">public FutureTask(Callable&lt;V&gt; callable) {    if (callable == null)        throw new NullPointerException();    this.callable = callable;    this.state = NEW;       // ensure visibility of callable}    public FutureTask(Runnable runnable, V result) {    this.callable = Executors.callable(runnable, result);    this.state = NEW;       // ensure visibility of callable}</code></pre><p>这两个构造函数区别在于，如果使用第一个构造函数最后获取线程实行结果就是callable的执行的返回结果；而如果使用第二个构造函数那么最后获取线程实行结果就是参数中的result，接下来让我们看一下FutureTask的run方法。</p><p>同时两个构造函数都把当前状态设置为NEW。</p><h3 id="jdk1-8和之前版本的区别"><a href="#jdk1-8和之前版本的区别" class="headerlink" title="jdk1.8和之前版本的区别"></a>jdk1.8和之前版本的区别</h3><p>1.8:</p><p>get方法的逻辑很简单，如果call方法的执行过程已完成，就把结果给出去；如果未完成，就将当前线程挂起等待。awaitDone方法里面死循环的逻辑，推演几遍就能弄懂；它里面挂起线程的主要创新是定义了WaitNode类，来将多个等待线程组织成队列，这是与JDK6的实现最大的不同。</p><p>1.6：</p><p>JDK6的FutureTask的基本操作都是通过自己的内部类Sync来实现的，而Sync继承自AbstractQueuedSynchronizer这个出镜率极高的并发工具类</p><p>也就是说<mark style="background: #FFB8EBA6;">1.8自己定义了一个WaitNode类，来将多个等待线程组织成队列，在以前使用AQS来实现的</mark></p><p>这个get方法里面处理等待线程队列的方式是调用了acquireSharedInterruptibly方法</p><h2 id="Callable-和-Future-有什么关系？"><a href="#Callable-和-Future-有什么关系？" class="headerlink" title="Callable 和 Future 有什么关系？"></a>Callable 和 Future 有什么关系？</h2><p>我们可以通过 FutureTask 来理解 Callable 和 Future 之间的关系。</p><p>FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask 。</p><pre><code class="line-numbers language-java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);Future&lt;?&gt; submit(Runnable task);</code></pre><p>FutureTask 不光实现了 Future接口，还实现了Runnable 接口，因此可以作为任务直接被线程执行。</p><p><img src="/attachment/3d3c57f763724719950edfcac4916b13.png"></p><p>FutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象。</p><pre><code class="line-numbers language-java">public FutureTask(Callable&lt;V&gt; callable) {    if (callable == null)        throw new NullPointerException();    this.callable = callable;    this.state = NEW;}public FutureTask(Runnable runnable, V result) {    // 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象    this.callable = Executors.callable(runnable, result);    this.state = NEW;}</code></pre><p>FutureTask相当于对Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。</p><h2 id="CompletableFuture-类"><a href="#CompletableFuture-类" class="headerlink" title="CompletableFuture 类"></a>CompletableFuture 类</h2><p>Future 在实际使用过程中存在一些局限性，比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。</p><p>Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><p>下面我们来简单看看 CompletableFuture 类的定义。</p><pre><code class="line-numbers language-java">public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {}</code></pre><p>可以看到，CompletableFuture 同时实现了 Future 和 CompletionStage 接口。</p><p><img src="/attachment/2153a37f89c6c893af88403a2e25de0f.png"></p><p>CompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p><p>CompletionStage 接口中的方法比较多，CompletableFuture 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p><p><img src="/attachment/50e0a799c992f84724e04f98e453688c.png"></p><h3 id="CompletableFuture对Future的改进"><a href="#CompletableFuture对Future的改进" class="headerlink" title="CompletableFuture对Future的改进"></a>CompletableFuture对Future的改进</h3><h4 id="CompletableFuture为什么会出现"><a href="#CompletableFuture为什么会出现" class="headerlink" title="CompletableFuture为什么会出现"></a>CompletableFuture为什么会出现</h4><ol><li>get()方法在Future计算完成之前会一直处在<mark style="background: #FFB8EBA6;">阻塞</mark>状态下，<mark style="background: #BBFABBA6;">阻塞的方式和异步编程的设计理念相违背</mark>。</li><li>isDene()方法容易耗费cpu资源（cpu空转），</li><li>对于真正的异步处理我们希望是可以通过传入<mark style="background: #FFB8EBA6;">回调函数</mark>，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</li></ol><p>jdk8设计出CompletableFuture，CompletableFuture提供了一种<mark style="background: #FFB8EBA6;">观察者模式</mark>类似的机制，可以让任务执行完成后通知监听的一方。</p><h4 id="CompletableFuture和CompletionStage介绍"><a href="#CompletableFuture和CompletionStage介绍" class="headerlink" title="CompletableFuture和CompletionStage介绍"></a>CompletableFuture和CompletionStage介绍</h4><p>类架构说明：</p><p><img src="/attachment/c5b2007f356169eb2402602bcec20625.png"></p><ul><li>接口CompletionStage<ul><li>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。</li><li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li></ul></li><li>类CompletableFuture<ul><li>提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture的方法</li><li>它可能代表一个明确完成的Future，也可能代表一个完成阶段（CompletionStage），它支持在计算完成以后触发一些函数或执行某些动作</li></ul></li></ul><h4 id="核心的四个静态方法，来创建一个异步任务"><a href="#核心的四个静态方法，来创建一个异步任务" class="headerlink" title="核心的四个静态方法，来创建一个异步任务"></a>核心的四个静态方法，来创建一个异步任务</h4><p>四个静态构造方法</p><p><img src="/attachment/b858e4dffdcef27b0c3535c59972c76c.png"></p><p>对于上述Executor参数说明：若没有指定，则使用默认的ForkJoinPoolcommonPool（）作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</p><pre><code class="line-numbers language-java">/** * @author Guanghao Wei * @create 2023-04-10 12:16 */public class CompletableFutureBuildDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException {        ExecutorService executorService = Executors.newFixedThreadPool(3);        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; {            System.out.println(Thread.currentThread().getName());            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }        },executorService);        System.out.println(completableFuture.get()); //null        CompletableFuture&lt;String&gt; objectCompletableFuture = CompletableFuture.supplyAsync(()-&gt;{            System.out.println(Thread.currentThread().getName());            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            return "hello supplyAsync";        },executorService);        System.out.println(objectCompletableFuture.get());//hello supplyAsync        executorService.shutdown();    }}</code></pre><p>CompletableFuture减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><pre><code class="line-numbers language-java">/** * @author Guanghao Wei * @create 2023-04-10 12:28 */public class CompletableFutureUseDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException {        ExecutorService executorService = Executors.newFixedThreadPool(3);        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {            System.out.println(Thread.currentThread().getName() + "---come in");            int result = ThreadLocalRandom.current().nextInt(10);            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            if (result &gt; 5) { //模拟产生异常情况                int i = 10 / 0;            }            System.out.println("----------1秒钟后出结果" + result);            return result;        }, executorService).whenComplete((v, e) -&gt; {            if (e == null) {                System.out.println("计算完成 更新系统" + v);            }        }).exceptionally(e -&gt; {            e.printStackTrace();            System.out.println("异常情况：" + e.getCause() + " " + e.getMessage());            return null;        });        System.out.println(Thread.currentThread().getName() + "先去完成其他任务");        executorService.shutdown();    }}/** * 无异常情况 * pool-1-thread-1---come in * main先去完成其他任务 * ----------1秒钟后出结果9 * 计算完成 更新系统9 *//** * 有异常情况 *pool-1-thread-1---come in * main先去完成其他任务 * java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero * 异常情况：java.lang.ArithmeticException: / by zero java.lang.ArithmeticException: / by zero */</code></pre><p>CompletableFuture优点：</p><ul><li>异步任务结束时，会<mark style="background: #FFB8EBA6;">自动回调</mark>某个对象的方法</li><li>主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以<mark style="background: #FFB8EBA6;">顺序执行</mark></li><li>异步任务出错时，会<mark style="background: #FFB8EBA6;">自动回调</mark>某个对象的方法</li></ul><h3 id="CompletableFuture常用方法"><a href="#CompletableFuture常用方法" class="headerlink" title="CompletableFuture常用方法"></a>CompletableFuture常用方法</h3><h4 id="获得结果和触发计算"><a href="#获得结果和触发计算" class="headerlink" title="获得结果和触发计算"></a>获得结果和触发计算</h4><ul><li>获取结果<ul><li>public T get()</li><li>public T get(long timeout,TimeUnit unit)</li><li>public T join() —&gt;和get一样的作用，只是不需要抛出异常</li><li>public T getNow(T valuelfAbsent) —&gt;计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞</li></ul></li><li>主动触发计算<ul><li>public boolean complete(T value) —-&gt;是否打断get方法立即返回括号值</li></ul></li></ul><h4 id="对计算结果进行处理"><a href="#对计算结果进行处理" class="headerlink" title="对计算结果进行处理"></a>对计算结果进行处理</h4><ul><li>thenApply —&gt;计算结果存在依赖关系，这两个线程串行化—-&gt;由于存在依赖关系（当前步错，不走下一步），当前步骤有异常的话就叫停</li><li>handle —&gt;计算结果存在依赖关系，这两个线程串行化—-&gt;有异常也可以往下走一步</li></ul><pre><code class="line-numbers language-java">/** * @author Guanghao Wei * @create 2023-04-10 13:43 */public class CompletableFutureApiDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {        ExecutorService threadPool = Executors.newFixedThreadPool(3);        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            return 1;        }, threadPool).thenApply(f -&gt; {            System.out.println("222");            return f + 2;        }).handle((f, e) -&gt; {            System.out.println("3333");            int i=10/0;            return f + 2;//             thenApply(f -&gt; {//            System.out.println("3333");//            return f + 2;        }).whenComplete((v, e) -&gt; {            if (e == null) {                System.out.println("----计算结果" + v);            }        }).exceptionally(e -&gt; {            e.printStackTrace();            System.out.println(e.getCause());            return null;        });        System.out.println(Thread.currentThread().getName() + "------主线程先去做其他事情");    }}</code></pre><h4 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h4><ul><li>接受任务的处理结果，并消费处理，无返回结果<ul><li>thenAccept</li></ul></li></ul><pre><code class="line-numbers language-java">/** * @author Guanghao Wei * @create 2023-04-10 13:59 */public class CompletableFutureApi2Demo {    public static void main(String[] args) {        ExecutorService threadPool = Executors.newFixedThreadPool(3);        CompletableFuture.supplyAsync(() -&gt; {            return 1;        }, threadPool).thenApply(f -&gt; {            return f + 2;        }).thenApply(f -&gt; {            return f + 2;        }).thenAccept(r -&gt; {            System.out.println(r);//5        });    }}</code></pre><ul><li>对比补充<ul><li>thenRun(Runnable runnable) :任务A执行完执行B，并且不需要A的结果</li><li>thenAccept(Consumer action): 任务A执行完执行B，B需要A的结果，但是任务B没有返回值</li><li>thenApply(Function fn): 任务A执行完执行B，B需要A的结果，同时任务B有返回值</li></ul></li></ul><pre><code class="line-numbers language-java">/** * @author Guanghao Wei * @create 2023-04-10 13:59 */public class CompletableFutureApi2Demo {    public static void main(String[] args) {        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenRun(() -&gt; {}).join());//null        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenAccept(r -&gt; System.out.println(r)).join());//result null        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenApply(f -&gt; f + 2).join());//result2    }}</code></pre><h4 id="对计算速度进行选用"><a href="#对计算速度进行选用" class="headerlink" title="对计算速度进行选用"></a>对计算速度进行选用</h4><ul><li>谁快用谁<ul><li>applyToEither</li></ul></li></ul><pre><code class="line-numbers language-java">/** * @author Guanghao Wei * @create 2023-04-10 14:11 * 可以合并写在一起，不必拆分 */public class CompletableFutureApiDemo {    public static void main(String[] args) {        ExecutorService threadPool = Executors.newFixedThreadPool(3);        CompletableFuture&lt;String&gt; playA = CompletableFuture.supplyAsync(() -&gt; {            try {                System.out.println("A come in");                TimeUnit.SECONDS.sleep(2);            } catch (InterruptedException e) {                e.printStackTrace();            }            return "playA";        }, threadPool);        CompletableFuture&lt;String&gt; playB = CompletableFuture.supplyAsync(() -&gt; {            try {                System.out.println("B come in");                TimeUnit.SECONDS.sleep(3);            } catch (InterruptedException e) {                e.printStackTrace();            }            return "playB";        }, threadPool);        CompletableFuture&lt;String&gt; result = playA.applyToEither(playB, f -&gt; {            return f + " is winner";        });        /**         * A come in         * B come in         * main-----------winner:playA is winner         */        System.out.println(Thread.currentThread().getName() + "-----------winner:" + result.join());    }}</code></pre><h4 id="对计算结果进行合并"><a href="#对计算结果进行合并" class="headerlink" title="对计算结果进行合并"></a>对计算结果进行合并</h4><ul><li>两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理</li><li>先完成的先等着，等待其他分支任务</li></ul><pre><code class="line-numbers language-java">/** * @author Guanghao Wei * @create 2023-04-10 14:28 * 可以合并写在一起，不必拆分 */public class CompletableFutureApi3Demo {    public static void main(String[] args) {        CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; {            System.out.println(Thread.currentThread().getName() + " 启动");            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            return 10;        });        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; {            System.out.println(Thread.currentThread().getName() + " 启动");            try {                TimeUnit.SECONDS.sleep(2);            } catch (InterruptedException e) {                e.printStackTrace();            }            return 20;        });        CompletableFuture&lt;Integer&gt; finalResult = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; {            System.out.println("----------开始两个结果合并");            return x + y;        });        System.out.println(finalResult.join());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程中断</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-zhong-duan/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-zhong-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程中断"><a href="#【Java-多线程并发】-线程中断" class="headerlink" title="【Java 多线程并发】 线程中断"></a>【Java 多线程并发】 线程中断</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程中断date: 2023-07-04 23:52tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 线程中断</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>线程中断</strong></p><p>Java中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。<br>通过 Thread#interrupt() 给线程该线程一个标志位</p><p><strong>线程阻塞</strong></p><p>Java 中提供了一个较为底层的并发工具类：LockSupport，该类中的核心方法有两个：park(Object blocker) 以及 unpark(Thread thred)，前者表示阻塞指定线程，后者表示唤醒指定的线程。</p><p><strong>中断方法</strong></p><ul><li>interrupt()是一个动词，表示中断线程。<ul><li>本质调用<code>native void interrupt0()</code>方法，interrupt的功能都是在这个native方法中实现的</li></ul></li><li>interrupted()是一个形容词，用于检查线程的中断位并修改中断位，<ul><li>本质调用的是native方法isInterrupted，是通过这个native方法实现的功能</li></ul></li><li>isInterrupted()方法只是简单的检查，interrupted()在检查的同时还会对中断位进行操作。<ul><li>本质调用的是native方法isInterrupted</li></ul></li></ul><p><strong>原理</strong></p><ul><li>Thread对象的native实现里有一个成员代表线程的中断状态</li><li>Thread对象的native实现里有一个成员代表线程是否可以阻塞的许可permit</li></ul><h2 id="Java线程中断与阻塞的区别"><a href="#Java线程中断与阻塞的区别" class="headerlink" title="Java线程中断与阻塞的区别"></a>Java线程中断与阻塞的区别</h2><p>对于很多刚接触编程的人来说，对于线程中断和线程阻塞两个概念，经常性是混淆起来用，单纯地认为线程中断与线程阻塞的概念是一致的，都是指线程运行状态的停止。其实这个观点是错误的，两者之前有很大的区别，本文就再最开始先着重介绍下两者之间的区别。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>在一个线程正常结束之前，如果被强制终止，那么就有可能造成一些比较严重的后果，设想一下如果现在有一个线程持有同步锁，然后在没有释放锁资源的情况下被强制休眠，那么这就造成了其他线程无法访问同步代码块。因此我们可以看到在 Java 中类似 Thread#stop() 方法被标为 @Deprecated。</p><p>针对上述情况，我们不能直接将线程给终止掉，但有时又必须将让线程停止运行某些代码，那么此时我们必须有一种机制让线程知道它该停止了。Java 为我们提供了一个比较优雅的做法，即可以通过 Thread#interrupt() 给线程该线程一个标志位，让该线程自己决定该怎么办。</p><p>接下来就用代码来演示下 interrupt() 的作用：</p><pre><code class="line-numbers language-java">public class InterruptDemo {    static class MyThread implements Runnable {        @Override        public void run() {            for (int i= 0; !Thread.currentThread().isInterrupted() &amp;&amp; i &lt; 200000; i++) {                System.out.println(Thread.currentThread().getName() + "：i = " + i);            }        }    }    public static void main(String[] args) throws InterruptedException {        Thread myThread = new Thread(new MyThread());        myThread.start();        // 让线程运行一段时间        Thread.sleep(5);        myThread.interrupt();        // 等待 myThread 运行停止        myThread.join();        System.out.println("end");    }}</code></pre><p>以上代码的运行结果如下：</p><p><img src="/attachment/02b5abb54834391a17715530b43fb102.png"></p><p>可以看到，当前线程并没有按 for 循环中的结束量 20000 去跑，而是在被中断后，停止了当前了 for 循环。所以我们可以利用 interrupt 配置线程使用，使得线程在一定的位置停止下来。</p><p>不过到这里可能会让人产生一些疑惑，因为在这里看起来，当前线程像是被阻塞掉了，其实并不是的，我们可以利用下面这段代码来演示下：</p><pre><code class="line-numbers language-java">public class InterruptDemo {    static class MyThread implements Runnable {        @Override        public void run() {            for (int i= 0; i &lt; 200000; i++) {                System.out.println(Thread.currentThread().getName() + "：i = " + i);            }        }    }    public static void main(String[] args) throws InterruptedException {        Thread myThread = new Thread(new MyThread());        myThread.start();        // 让线程运行一段时间        Thread.sleep(5);        myThread.interrupt();        // 等待 myThread 运行停止        myThread.join();        System.out.println("end");    }}</code></pre><p>上面这段代码的运行结果如下：</p><p><img src="/attachment/6f052822e5d2fb06e290533cf0f2aa71.png"></p><p>可见，线程一直打印到 20000，执行完毕后推出线程，并没有像我们预料中在某处中断。所以我们可以得出结论：单纯用 interrupt() 中断线程方法并不能停止当前正在运行的线程，需要配合其他方法才能正确停止线程。</p><p>了解完中断的基本概念后，线程的中断还有需要其他需要注意的点：</p><ul><li>设置线程中断后，线程内调用 wait()、join()、slepp() 方法中的一种，都会抛出 InterruptedException 异常，且中断标志位被清除，重新设置为 false；</li><li>当线程被阻塞，比如调用了上述三个方法之一，那么此时调用它的 interrupt() 方法，也会产生一个 InterruptedException 异常。因为没有占有 CPU 的线程是无法给自己设置中断状态位置的；</li><li>尝试获取一个内部锁的操作（进入一个 synchronized 块）是不能被中断的，但是 ReentrantLock 支持可中断的获取模式：tryLock(long time, TimeUnit unit)；</li><li>当代码调用中需要抛出一个 InterruptedException，捕获之后，要么继续往上抛，要么重置中断状态，这是最安全的做法。</li></ul><h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><p>上面讲完了线程中断，它其实只是一个标志位，并不能让线程真正的停止下来，那么接下来就来介绍如何真正让线程停止下来。</p><p>对于这个问题，Java 中提供了一个较为底层的并发工具类：LockSupport，该类中的核心方法有两个：park(Object blocker) 以及 unpark(Thread thred)，前者表示阻塞指定线程，后者表示唤醒指定的线程。</p><pre><code class="line-numbers language-java">// java.util.concurrent.locks.LockSupportpublic static void park(Object blocker) {    Thread t = Thread.currentThread();    setBlocker(t, blocker);    UNSAFE.park(false, 0L);    setBlocker(t, null);} public static void unpark(Thread thread) {    if (thread != null)        UNSAFE.unpark(thread);}</code></pre><p>该方法在 Java 的语言层面上比较简单，最终也是去调用 UNSAFE 中的 native 方法。真正涉及到底层的东西需要去理解 JVM 的源码，这里就不做太多的介绍。不过我们可以用一个简单的例子来演示下这两个方法：</p><pre><code class="line-numbers language-java">public class LockSupportDemo {    static class MyThread implements Runnable {        @Override        public void run() {            System.out.println(Thread.currentThread().getName() + "开始执行");            LockSupport.park();            System.out.println(Thread.currentThread().getName() + "执行结束");        }    }    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new MyThread(), "线程：MyThread");        thread.start();        Thread.sleep(100);        System.out.println(Thread.currentThread().getName() + "主线程执行中");        LockSupport.unpark(thread);        System.out.println(Thread.currentThread().getName() + "主线程执行结束");    }}</code></pre><p>上述代码的执行结果为：</p><pre><code class="line-numbers language-console">线程：MyThread开始执行main主线程执行中线程：MyThread执行结束main主线程执行结束</code></pre><p>可以看到，myThread 线程在开始执行后停止了下来，等到主线程重新调用 LockSupport.unpark(thread) 后才重新开始执行。</p><h2 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h2><p>下面我们进入本文的正题，开始向西讲解Java中线程的中断及其原理。</p><p>Java的中断是一种协作机制，也就是说通过中断并不能直接中断另外一个线程，而需要被中断的线程自己处理中断。</p><p>在Java的中断模型中，每个线程都有一个boolean类型的标识，代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。例如，当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。</p><p>官方一点的表述：</p><p>Java中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><h2 id="中断方法"><a href="#中断方法" class="headerlink" title="中断方法"></a>中断方法</h2><p>Thread类中提供了线程中断相关的方法，主要是下面的3方法，他们具体的作用见下面的表格：</p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td>void interrupt()</td><td>中断线程，设置线程的中断位为true</td></tr><tr><td>boolean isInterrupted()</td><td>检查线程的中断标记位，true-中断状态， false-非中断状态</td></tr><tr><td>static boolean interrupted()</td><td>静态方法，返回当前线程的中断标记位，同时清除中断标记，改为false。比如当前线程已中断，调用interrupted()，返回true, 同时将当前线程的中断标记位改为false, 再次调用interrupted()，会发现返回false</td></tr></tbody></table><p><strong>记忆方法推荐:</strong></p><p>interrupt()是一个动词，表示中断线程。<br>Interrupted()是一个形容词，用于检查线程的中断位并修改中断位，<br>isInterrupted()方法只是简单的检查，interrupted()在检查的同时还会对中断位进行操作。</p><h3 id="void-interrupt"><a href="#void-interrupt" class="headerlink" title="void interrupt()"></a>void interrupt()</h3><p><strong>方法原型：</strong></p><pre><code class="line-numbers language-java">/** * 中断此线程。 * &lt;p&gt;线程可以中断自身，这是允许的。在这种情况下，不用进行安全性验证（{@link #checkAccess() checkAccess} 方法检测） * &lt;p&gt;若当前线程由于 wait() 方法阻塞，或者由于join()、sleep()方法，然后线程的中断状态将被清除，并且将收到 {@link InterruptedException}。 * &lt;p&gt;如果线程由于 IO操作（{@link java.nio.channels.InterruptibleChannel InterruptibleChannel}）阻塞，那么通道 channel 将会关闭， * 并且线程的中断状态将被设置，线程将收到一个 {@link java.nio.channels.ClosedByInterruptException} 异常。 * &lt;p&gt;如果线程由于在 {@link java.nio.channels.Selector} 中而阻塞，那么线程的中断状态将会被设置，它将立即从选择操作中返回。 *该值可能是一个非零值，就像调用选择器的{@link java.nio.channels.Selector＃wakeupakeup}方法一样。** &lt;p&gt;如果上述条件均不成立，则将设置该线程的中断状态。&lt;/p&gt;* &lt;p&gt;中断未运行的线程不必产生任何作用。* @throws  SecurityException 如果当前线程无法修改此线程*/public void interrupt()</code></pre><p>很多人看到 interrupt() 方法，认为“中断”线程不就是让线程停止嘛。实际上， interrupt() 方法实现的根本就不是这个效果， <strong>interrupt()方法更像是发出一个信号</strong>，这个信号会改变线程的一个标识位属性（中断标识），对于这个信号如何进行响应则是无法确定的（可以有不同的处理逻辑）。<strong>很多时候调用 interrupt() 方法非但不是为了停止线程</strong>，反而是为了让线程继续运行下去。设置线程中断不影响线程的继续执行</p><p><strong>interrupt() 方法的作用</strong>：设置该线程的中断标志为true并立即返回（该线程并不一定是当前线程，而是指调用该方法的Thread实例所代表的线程），<strong>但线程实际上并没有被中断而会继续向下执行</strong>，<strong>会由用户自己决定要不要终止线程以及什么时候终止线程</strong>；如果线程因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起，其他线程调用该线程的interrupt()方法会使该线程抛出InterruptedException异常而返回。</p><p>interrupt()是实例方法，是调用该方法的对象所表示的那个线程的interrupt()。</p><h4 id="可中断的阻塞"><a href="#可中断的阻塞" class="headerlink" title="可中断的阻塞"></a>可中断的阻塞</h4><p>针对线程处于由sleep, wait, join，方法调用产生的阻塞状态时，调用interrupt方法，会抛出异常InterruptedException，同时会清除中断标记位，自动改为false。</p><p>LockSupport.park也会相应中断，但是不会抛出异常，也不会清空中断标记。</p><p>一般情况下，抛出异常时，会清空Thread的interrupt状态，在编程时需要注意；</p><h4 id="不可中断的阻塞"><a href="#不可中断的阻塞" class="headerlink" title="不可中断的阻塞"></a>不可中断的阻塞</h4><ol><li>java.io包中的同步Socket I/O</li><li>java.io包中的同步I/O</li><li>Selector的异步I/O</li><li>Lock.lock()方法不会响应中断；Lock.lockInterruptibly()方法则会响应中断并抛出异常，区别在于park()等待被唤醒时lock会继续执行park()来等待锁，而 lockInterruptibly会抛出异常；</li><li>sychronized加的锁。synchronized被唤醒后会尝试获取锁，失败则会通过循环继续park()等待，因此实际上是不会被interrupt()中断的;</li></ol><h4 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h4><h5 id="中断sleep、wait、join等方法"><a href="#中断sleep、wait、join等方法" class="headerlink" title="中断sleep、wait、join等方法"></a>中断sleep、wait、join等方法</h5><pre><code class="line-numbers language-java">private static void test1() throws InterruptedException {    Thread t1 = new Thread(() -&gt; {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            log.error("error", e);        }    }, "t1");     t1.start();    Thread.sleep(500);    t1.interrupt();    Thread.sleep(100);    log.info(" interrupt status : {}", t1.isInterrupted());}</code></pre><p><img src="/attachment/60e30dab5a25315ce6f02c0a10d8f5ff.png"></p><p>结论： 阻塞方法sleep响应中断，抛出InterruptedException，t1线程也就不会再继续向下执行了，同时清除中断标记位为false。</p><h5 id="中断LockSupport-park方法"><a href="#中断LockSupport-park方法" class="headerlink" title="中断LockSupport.park方法"></a>中断LockSupport.park方法</h5><pre><code class="line-numbers language-java">public static void test3() throws InterruptedException {    Thread t3 = new Thread(() -&gt; {        log.debug("t3 park.....");        LockSupport.park();        log.debug("t3 unpark.....");        log.debug("interrupt status: [{}]", Thread.currentThread().isInterrupted());                log.debug("t3 第二次 park.....");        LockSupport.park();        log.debug("t3 中断位为true, park失效.....");    }, "t3");     t3.start();    Thread.sleep(1000);    t3.interrupt();}</code></pre><p><img src="/attachment/ea7226a9521317d4e7b5bcd50dd03321.png"></p><p>结论： 阻塞方法park响应中断，即t3被LockSupport.park()阻塞，然后主线程调用t3.interrupt()，park()方法就响应中断，结束阻塞，并且不会抛出异常，t3线程继续向下执行，同时不会清除中断标记位，仍为true。</p><h5 id="中断普通方法"><a href="#中断普通方法" class="headerlink" title="中断普通方法"></a>中断普通方法</h5><pre><code class="line-numbers language-java">private static void test2() throws InterruptedException {    Thread t2 = new Thread(() -&gt; {        while (true) {            boolean isInterrupted = Thread.currentThread().isInterrupted();            if (isInterrupted) {                log.info("interrupt status: {}", isInterrupted);                break;            }        }    }, "t2");     t2.start();    Thread.sleep(500);    t2.interrupt();    Thread.sleep(100);    log.info(" thread status, {}, interrupt status : {}", t2.getState(), t2.isInterrupted());}</code></pre><p><img src="/attachment/070b411e20b0b3a9b52790c8180bb6d2.png"></p><p>结论： 打断正常运行的线程，线程要自己决定是否响应中断，在线程执行过程中不会清空中断状态，但是线程结束后，会重置线程的中断状态位。</p><h5 id="中断IO相关方法"><a href="#中断IO相关方法" class="headerlink" title="中断IO相关方法"></a>中断IO相关方法</h5><p>interrupt方法源码中有一段代码如下：</p><pre><code class="line-numbers language-java">private volatile Interruptible blocker;private final Object blockerLock = new Object();synchronized (blockerLock) {    Interruptible b = blocker;    if (b != null) {        interrupt0();           // Just to set the interrupt flag        b.interrupt(this);        return;    }}</code></pre><p>其中blocker是Thread的成员变量，Thread提供了blockedOn方法可以设置blocker:</p><pre><code class="line-numbers language-java">void blockedOn(Interruptible b) {    synchronized (blockerLock) {        blocker = b;    }}</code></pre><p>如果一个nio通道实现了InterruptibleChannel接口，就可以响应interrupt()中断，其原理就在InterruptibleChannel接口的抽象实现类AbstractInterruptibleChannel的方法begin()中：</p><pre><code class="line-numbers language-java">protected final void begin() {    if (interruptor == null) {        interruptor = new Interruptible() {                public void interrupt(Thread target) {                    synchronized (closeLock) {                        if (!open)                            return;                        open = false;                        interrupted = target;                        try {                            AbstractInterruptibleChannel.this.implCloseChannel();                        } catch (IOException x) { }                    }                }};    }    blockedOn(interruptor);//设置当前线程的blocker为interruptor    Thread me = Thread.currentThread();    if (me.isInterrupted())        interruptor.interrupt(me);} protected final void end(boolean completed)    throws AsynchronousCloseException{    blockedOn(null);//设置当前线程的blocker为null    Thread interrupted = this.interrupted;   //如果发生中断，Thread.interrupt方法会调用Interruptible的interrupt方法，  //设置this.interrupted为当前线程    if (interrupted != null &amp;&amp; interrupted == Thread.currentThread()) {        interrupted = null;        throw new ClosedByInterruptException();    }    if (!completed &amp;&amp; !open)        throw new AsynchronousCloseException();} //Class java.nio.channels.Channels.WritableByteChannelImplpublic int write(ByteBuffer src) throws IOException {    ......        try {        begin();        out.write(buf, 0, bytesToWrite);    finally {        end(bytesToWrite &gt; 0);    }    ......} //Class java.nio.channels.Channels.ReadableByteChannelImplpublic int read(ByteBuffer dst) throws IOException {    ......        try {        begin();        bytesRead = in.read(buf, 0, bytesToRead);    finally {        end(bytesRead &gt; 0);    }    ......}</code></pre><p>以上述代码为例，nio通道的ReadableByteChannel每次执行阻塞方法read()前，都会执行begin()，把Interruptible回调接口注册到当前线程上。当线程中断时，Thread.interrupt()触发回调接口Interruptible关闭io通道,导致read方法返回，最后在finally块中执行end()方法检查中断标记，抛出ClosedByInterruptException;</p><p>Selector的实现类似，所以它也可以响应中断：</p><pre><code class="line-numbers language-java">//java.nio.channels.spi.AbstractSelectorprotected final void begin() {    if (interruptor == null) {        interruptor = new Interruptible() {                public void interrupt(Thread ignore) {                    AbstractSelector.this.wakeup();                }};    }    AbstractInterruptibleChannel.blockedOn(interruptor);    Thread me = Thread.currentThread();    if (me.isInterrupted())        interruptor.interrupt(me);}protected final void end() {AbstractInterruptibleChannel.blockedOn(null);} //sun.nio.ch.class EPollSelectorImplprotected int doSelect(long timeout) throws IOException {    ......    try {        begin();        pollWrapper.poll(timeout);    } finally {        end();    }    ......}</code></pre><h3 id="boolean-isInterrupted"><a href="#boolean-isInterrupted" class="headerlink" title="boolean isInterrupted()"></a>boolean isInterrupted()</h3><p><strong>方法原型：</strong></p><pre><code class="line-numbers language-java">/** * 测试此线程是否已被中断。线程的中断状态不受此方法的影响。 * 如果中断时，线程并没有存活，那么该方法返回 false。意思就是，如果线程还没有 start 启动，或者已经消亡，那么返回依然是 false. * @return  如果该线程已被中断，返回true；否则返回 false */public boolean isInterrupted()</code></pre><p>isInterrupted()方法的作用：只判断此线程（此线程指的是调用isInterrupted()方法的Thread实例所代表的线程）是否被中断 ，是则返回true，否则返回false，不清除中断状态。</p><p>如果线程还没有 start 启动，或者已经消亡，那么返回依然是 false。中断状态只代表是否有线程调用中断方法，并不代表这个线程是否在运行。</p><p>isInterrupted()是实例方法，是调用该方法的对象所表示的那个线程的isInterrupted()。</p><h3 id="boolean-interrupted"><a href="#boolean-interrupted" class="headerlink" title="boolean interrupted()"></a>boolean interrupted()</h3><p>方法原型：</p><pre><code class="line-numbers language-java">/** * 测试当前线程是否已被中断。 * 通过此方法可以清除线程的中断状态. * 换句话说，如果此方法要连续调用两次，则第二个调用将返回false(除非当前线程在第一个调用清除了它的中断状态之后，且在第二个调用对其进行检查之前再次中断) * 如果中断时，线程并没有存活（还未启动），那么该方法返回 false * @return   如果该线程已被中断，返回true；否则返回 false */public static boolean interrupted()</code></pre><p>interrupted()方法的作用：判断当前线程（注意，这里指的是当前线程，不是调用该方法的Thread实例所代表的线程）是否被中断（检查中断标志），返回一个boolean（当前的中断标志），被中断则返回true，否则返回false。并清除中断状态（将中断标志设置为false）。因为该方法是static方法，内部是获取当前调用线程的中断标志而不是调用interrupted()方法的实例对象的中断标志。</p><p>这里有一点需要注意，调用interrupted()方法时，它会先记录下当前的中断标志位，然后才会去清除中断状态，也就是将中断标志位设置为false，最后返回之前记录的中断标志位。也就是说如果在调用interrupted()方法前当前线程已经中断了（中断标志为true），那么第一次调用interrupted()方法返回的就是true，但是第一次调用之后当前线程的中断标志就被interrupted()方法设置为false了，所以第二次再调用interrupted()方法时中断状态已经被清除，将返回一个false。</p><h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><p>定义一个MyThread类，继承Thread，如下：</p><pre><code class="line-numbers language-java">public class MyThread extends Thread {    @Override    public void run() {        for (int i = 0; i &lt; 10; i++) {            System.out.println("i =" + (i + 1));        }    }}</code></pre><p>在main方法中测试：</p><pre><code class="line-numbers language-java">public class Do {    public static void main(String[] args ) {        MyThread thread = new MyThread();        thread.start();        thread.interrupt();        System.out.println("第一次调用thread.isInterrupted()：" + thread.isInterrupted());        System.out.println("第二次调用thread.isInterrupted()：" + thread.isInterrupted());        System.out.println("thread是否存活：" + thread.isAlive());    }}</code></pre><p> 输出如下：</p><p><img src="/attachment/617af893646386f8c20dfd09253542c7.png"></p><p>从结果可以看出调用interrupt()方法后，线程仍在继续运行，并未停止，但已经给线程设置了中断标志，两个isInterrupted()方法都会输出true，也说明isInterrupted()方法并不会清除中断状态。</p><p>下面我们把代码修改一下，多加两行调用interrupted()方法：</p><pre><code class="line-numbers language-java">public class Do {    public static void main(String[] args ) {        MyThread thread=new MyThread();        thread.start();        thread.interrupt();        System.out.println("第一次调用thread.isInterrupted()："+thread.isInterrupted());        System.out.println("第二次调用thread.isInterrupted()："+thread.isInterrupted());         //测试interrupted（）函数        System.out.println("第一次调用thread.interrupted()："+thread.interrupted());        System.out.println("第二次调用thread.interrupted()："+thread.interrupted());        System.out.println("thread是否存活："+thread.isAlive());    }}</code></pre><p>输出如下：</p><p><img src="/attachment/c87920fd6138072f82fabb1857849a4b.png"></p><p>从输出结果看，可能会有疑惑，为什么后面两个interrupted方法输出的都是false，而不是预料中的一个true、一个false？</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们会发现这几个Java方法，底层其实是调用native方法实现的，所以线程的中断状态，并不是由 Java 来决定。实际上，Thread 类中并没有维护线程的中断状态。线程中断状态不是 Thread 类的标志位，而是操作系统中对线程的中断标志。</p><h3 id="interrupt-方法源码"><a href="#interrupt-方法源码" class="headerlink" title="interrupt()方法源码"></a>interrupt()方法源码</h3><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><pre><code class="line-numbers language-java">public void interrupt() {    // 除非当前线程是自己中断自己，否则将调用此线程的 checkAccess 方法，这可能导致抛 SecurityException。    if (this != Thread.currentThread())        checkAccess();    synchronized (blockerLock) {        Interruptible b = blocker;        if (b != null) {            interrupt0();           // Just to set the interrupt flag            b.interrupt(this);            return;        }    }    interrupt0();} public final void checkAccess() {    SecurityManager security = System.getSecurityManager();    if (security != null) {        security.checkAccess(this);    }}</code></pre><p> 本质调用的就是这个native方法，interrupt的功能都是在这个native方法中实现的</p><pre><code class="line-numbers language-java">// 中断线程的底层方法private native void interrupt0();</code></pre><p> interrupt中文是打断的意思，意思是可以打断中止正在运行的线程，比如:</p><ol><li>Object#wait()、Thread#join()、Thread#sleep()这些方法运行后，线程的状态是WAITING或TIMED_WAITING，这时候打断这些线程，就会抛出InterruptedException异常，使线程的状态直接到TERMINATED。且中断标志被清除，重新设置为false</li><li>如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，我们中断当前线程，连接（Channel）会被关闭，线程会被设置为中断状态，并抛出ClosedByInterruptException异常;</li><li>如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会立即返回，就像调用了选择器的 wakeup 方法一样。</li></ol><p>如果上面三种情况都没有发生，就会去调用native方法interrupt0()，当前线程的中断标志就会被设置为true。</p><p>中断非活动的线程不会有任何的反应。</p><p>我们举一个例子来说明如何打断WAITING的线程，代码如下:</p><pre><code class="line-numbers language-java">public class ThreadInterrupt {    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                System.out.println(Thread.currentThread().getName() + " begin run");                try {                    System.out.println("子线程开始沉睡30s");                    Thread.sleep(30000L);                } catch (InterruptedException e) {                    System.out.println("子线程被打断");                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + " end run");            }        });        // 开一个子线程去执行        thread.start();        Thread.sleep(1000L);        System.out.println("主线程等待1s后,发现子线程还没有运行成功,打断子线程");        thread.interrupt();    }}</code></pre><h3 id="isInterrupted-方法源码"><a href="#isInterrupted-方法源码" class="headerlink" title="isInterrupted()方法源码"></a>isInterrupted()方法源码</h3><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre><code class="line-numbers language-java">public boolean isInterrupted() {    // 传递 false 说明不清除中断标志    return isInterrupted(false);}</code></pre><p>本质调用的是native方法isInterrupted，是通过这个native方法实现的功能</p><pre><code class="line-numbers language-java">private native boolean isInterrupted(boolean ClearInterrupted);</code></pre><p>检测线程是否被中断，是则返回true，否则返回false。</p><h3 id="interrupted-方法源码"><a href="#interrupted-方法源码" class="headerlink" title="interrupted()方法源码"></a>interrupted()方法源码</h3><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><pre><code class="line-numbers language-java">public static boolean interrupted() {        // 传递 true 说明清除中断标志    return currentThread().isInterrupted(true);}</code></pre><p> 本质调用的是native方法isInterrupted</p><pre><code class="line-numbers language-java">/** * 测试某些线程是否已被中断。线程的中断状态不受此方法的影响。 * ClearInterrupted参数决定线程中断状态是否被重置，若为true则重置。 */private native boolean isInterrupted(boolean ClearInterrupted);</code></pre><p>检测当前线程是否被中断，返回值同上 isInterrupted() ，不同的是，如果发现当前线程被中断，会清除中断标志；换句话说，如果要连续两次调用此方法，则第二个调用将返回false（除非在第一次调用清除了其中断状态之后，在第二次调用对其进行检查之前，当前线程再次被中断）。</p><p>该方法是static方法，内部是获取当前调用线程的中断标志而不是调用interrupted()方法的实例对象的中断标志。</p><h2 id="interrupt-中断行为研究"><a href="#interrupt-中断行为研究" class="headerlink" title="interrupt()中断行为研究"></a>interrupt()中断行为研究</h2><h3 id="原理简单讲解"><a href="#原理简单讲解" class="headerlink" title="原理简单讲解"></a>原理简单讲解</h3><p>首先声明，本文不会去贴native方法的cpp实现，而是以伪代码的形式来理解这些native方法。</p><ul><li>Thread对象的native实现里有一个成员代表线程的中断状态，我们可以认为它是一个bool型的变量。初始为false。</li><li>Thread对象的native实现里有一个成员代表线程是否可以阻塞的许可permit，我们可以认为它是一个int型的变量，但它的值只能为0或1。当为1时，再累加也会维持1。初始为0。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>park调用后一定会消耗掉permit，无论unpark操作先做还是后做（看上面对park讲解的源码中，在park开始和结尾都执行了一遍消耗permit的操作，所以无论unpark操作在park操作之前还是之后，只要是调用了park，那么现成的permit最后一定是0）。</li><li>如果中断状态为true，那么park无法阻塞。</li><li>unpark会使得permit为1，并唤醒处于阻塞的线程。</li><li>interrupt()会使得中断状态为true，并调用unpark。</li><li>sleep() / wait() / join()调用后一定会消耗掉中断状态，无论interrupt()操作先做还是后做（看上面对sleep讲解的源码中，在sleep开头和结尾都执行了一遍消耗中断状态的代码，所以无论interrupt操作在sleep之前还是之后，只要是调用了sleep，那么线程的中断状态最后一定是false）。</li></ul><p>关于这一点，“如果中断状态为true，那么park无法阻塞”。在AQS源码里的acquireQueued里，由于acquireQueued是阻塞式的抢锁，线程可能重复着 阻塞-&gt;被唤醒 的过程，所以在这个过程中，如果遇到了中断，一定要用Thread.interrupted()将中断状态消耗掉，并将这个中断状态暂时保存到一个局部变量中去。不然只要遇到中断一次后，线程在抢锁失败后就无法阻塞了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 join()方法</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-join-fang-fa/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-join-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-join-方法"><a href="#【Java-多线程并发】-join-方法" class="headerlink" title="【Java 多线程并发】 join()方法"></a>【Java 多线程并发】 join()方法</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 join()方法date: 2023-07-04 23:28tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 join()方法</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>join()方法是Thread类中的一个方法，可以由线程对象调用。<br>在当前线程调用join()方法时并不需要提前自己写同步代码块来获取对象锁，调用了join()方法也不会释放当前线程所持有的对象锁。</p><p><strong>适用场景</strong></p><p>需要等待某几件事情完成后才能继续往下执行</p><p><strong>作用</strong></p><ul><li>当线程任务量大时，保证 main 线程在这些线程运行结束后再结束、</li><li>可控制子线程间执行顺序</li></ul><p><img src="/attachment/46a94732ba66d0e1059297cf76666a94.png"></p><p><strong>注意点</strong></p><ul><li>join阻塞的是当前线程，并不是join方法的线程对象对应的线程</li><li>唤醒当前线程的操作是在JVM底层实现的，并没有显式调用notifyAll()方法</li><li>当前线程A在进入到线程对象B的join方法中使获取了线程对象B的锁，在join内部调用wait()方法时又会释放掉线程对象B的锁，在线程B执行完后当前线程才会再次获取线程对象B的锁</li><li>线程A调用线程对象B的join方法时，只有当此时线程对象已经被启动并且还没有执行完时才会起作用</li></ul><p><strong>底层</strong></p><p>通过wait和notifyall来实现线程的通信达到线程阻塞的目的；</p><p><strong>join和wait方法的区别</strong></p><ul><li>wait方法会让当前线程释放对象锁，并进入等待状态，直到被其他线程唤醒或者超时时间到达。</li><li>join方法不会让当前线程释放对象锁，而是让当前线程进入到等待状态等待目标线程执行完毕或者超时时间到达。</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>join()方法是Thread类中的一个方法，可以由线程对象调用。</p><p>在线程操作中，可以使用join()方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行，即等待线程执行终止。在当前线程调用join()方法时并不需要提前自己写同步代码块来获取对象锁，调用了join()方法也不会释放当前线程所持有的对象锁。因为join方法在源码层面就是一个被synchronized修饰的同步方法，所以会进入到方法时会获取到对象锁的，具体在后面的源码中会讲解。</p><h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><p>需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul><li>当线程任务量大时，保证 main 线程在这些线程运行结束后再结束、</li><li>可控制子线程间执行顺序</li></ul><p><strong>Java中如何让多线程按照自己指定的顺序执行？</strong></p><p>这个问题最简单的回答是通过Thread.join来实现，Thread.join的作用之一是用来保证线程的顺序性的。下面这段代码演示了Thread.join的作用：</p><pre><code class="line-numbers language-java">public class JoinDemo extends Thread{    int i;    Thread previousThread; //上一个线程    public JoinDemo(Thread previousThread,int i){        this.previousThread=previousThread;        this.i=i;    }    @Override    public void run() {        try {          //调用上一个线程的join方法，大家可以自己演示的时候可以把这行代码注释掉            previousThread.join();         } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("num:"+i);    }    public static void main(String[] args) {        Thread previousThread=Thread.currentThread();        for(int i=0;i&lt;10;i++){            JoinDemo joinDemo=new JoinDemo(previousThread,i);            joinDemo.start();            previousThread=joinDemo;        }    }}</code></pre><p>上面的代码，注意 previousThread.join部分，大家可以把这行代码注释以后看看运行效果，在没有加join的时候运行的结果是不确定的。加了join以后，运行结果按照递增的顺序展示出来。</p><p>thread.join的含义是当前线程需要等待previousThread线程终止之后才从thread.join返回。简单来说，就是线程没有执行完之前，会一直阻塞在join方法处。</p><p><img src="/attachment/8905728076b719d1ed8b5b0783e0730c.png"></p><p><img src="/attachment/46a94732ba66d0e1059297cf76666a94.png"></p><h2 id="join-方法和join-long-timeout-方法的使用"><a href="#join-方法和join-long-timeout-方法的使用" class="headerlink" title="join()方法和join(long timeout)方法的使用"></a>join()方法和join(long timeout)方法的使用</h2><p>例子：</p><pre><code class="line-numbers language-java">public static void main(String[] args){    ...    thread1.join();    thread2.join();    System.out.println("all child thread over!");}</code></pre><p>主线程首先会在调用thread1.join() 后被阻塞，等待thread1执行完毕后，调用thread2.join()，等待thread2 执行完毕（有可能），以此类推，最终会等所有子线程都结束后main函数才会返回。如果其他线程调用了被阻塞线程的 interrupt() 方法，被阻塞线程会抛出 InterruptedException 异常而返回。</p><p>通过上面的例子，我们就能知道join()方法是线程对象调用的，哪个线程对象调用这个方法，就会让哪个线程强制执行，也就是除了这个调用join方法的线程对象对应的线程以外，其他线程都被阻塞，等待这个被强制执行的线程执行完毕后，其他线程才能继续向下执行。</p><p>join()方法还提供可以传入时间参数的方法，即指定的等待时间内被join的线程还没执行完，就不再等待，继续向下执行。带参和不带参数方法的区别在于等待方式的不同：</p><ul><li>当调用join()方法时，当前线程会被阻塞，进入到WAITING状态（join方法就是在当前线程的环境下被另一个线程对象调用的），直到调用join方法的线程对象对应的线程执行完毕后才会继续执行。如果调用join方法的线程对象对应的线程已经执行完毕，那么当前线程会立即继续执行。</li><li>当调用join(long timeout)方法时，当前线程也会被阻塞，进入到TIMED_WAITING状态，但是最多只会等待指定的时间（以毫秒为单位），如果等待的时间超过了指定的时间或者调用join方法的线程对象对应的线程已经执行完毕，那么当前线程会立即继续执行。</li></ul><p>这里要注意，虽然是通过一个线程对象调用的join方法，但是这个join方法还是在当前线程的环境下调用的，所以其实调用join方法的线程还是当前线程，并不是那个线程对象的线程调用的join方法。</p><p>给出一个实例帮助理解：</p><pre><code class="line-numbers language-java">public class JoinExample {    private static final int TIMES = 100;    private class JoinThread extends Thread {        JoinThread(String name){           super(name);        }        @Override        public void run() {            for (int i = 0; i &lt; TIMES; i++) {                System.out.println(getName() + " " + i);            }        }    }     public static void main(String[] args) {        JoinExample example = new JoinExample();        example.test();    }    private void test() {       for (int i = 0; i &lt; TIMES; i++) {           if (i == 20) {               Thread jt1 = new JoinThread("子线程1");               Thread jt2 = new JoinThread("子线程2");               jt1.start();               jt2.start();               // main 线程调用了jt1线程和jt2线程的join()方法               // main 线程必须等到 jt1和jt2线程 执行完之后才会向下执行               try {                   // 需要等到jt1执行完成之后，才向下执行。在jt1没有执行完期间，其他线程无法运行。                   jt1.join();                   // 需要等到jt2执行完成之后，才向下执行。在jt2没有执行完期间，其他线程无法运行。                   jt2.join();                   // join还存在可以传入时间参数的方法：join(long mills) - 等待时间内被join的线程还没执行，就不再等待，继续向下执行               } catch (InterruptedException e) {                   e.printStackTrace();               }           }           System.out.println(Thread.currentThread().getName() + "  " + i);        }    }}</code></pre><h2 id="方法源码"><a href="#方法源码" class="headerlink" title="方法源码"></a>方法源码</h2><p>上面的例子中主线程是如何被阻塞的？又是通过什么方法唤醒的呢？下面我们就通过源码来看看Thread.join方法做了什么事情。</p><p>在底层源码不管是无参数，还是有参数的join都是使用的同一个带参源码方法。</p><h3 id="无参数方法"><a href="#无参数方法" class="headerlink" title="无参数方法"></a>无参数方法</h3><pre><code class="line-numbers language-java">// 无参数join()方法public final void join() throws InterruptedException {    // 不指定等待时间，就传入0，就会一直等待调用的线程执行完后才会继续向下执行    join(0);}</code></pre><h3 id="有参数方法"><a href="#有参数方法" class="headerlink" title="有参数方法"></a>有参数方法</h3><p>join源码底层本质是利用当前线程的线程对象的isAlive()方法和wait()方法实现的。源码如下：</p><pre><code class="line-numbers language-java">// join方法向外抛出了异常，所以使用join方法需要在外层处理异常或者继续向上抛出异常// 我们可以看到这个方法是被synchronized修饰的方法，假设当前线程是A，线程A执行了线程对象B的join方法，// 那么线程A进入到join方法中，就会获取到对象B的对象锁，之所以要用synchronized修饰join方法，就是为了获取B的对象锁，// 因为join方法底层是利用wait方法实现的，而调用某个对象的wait方法需要持有该对象的锁才行// 下面的所有讲解就是按照假设当前线程是A，线程A执行了线程对象B的join方法的前提下讲的，此时join方法就是在线程对象B中public final synchronized void join(long millis)    throws InterruptedException {    // 下面整个代码环境都是在对象B中的，所以里面直接调用的方法按照Java语法规则，只要没有指定方法所在的对象，那么就都是调用的当前所在对象中的方法，也就是线程对象B中的方法    // 获取当前时间    long base = System.currentTimeMillis();    long now = 0;    // 传参小于0，非法参数，抛出异常    if (millis &lt; 0) {        throw new IllegalArgumentException("timeout value is negative");    }    // 传入0超时时间意味着永远等待，直到B线程执行完毕    if (millis == 0) {        // 这个isAlive()是线程对象B中的方法        // isAlive()方法检查的是调用该方法的线程对象对应的线程是否还在运行，也就是检查线程B（被等待线程）是否在还在运行        while (isAlive()) {            // 如果B线程还在执行，则当前线程A会调用wait()方法使自己阻塞（等待），直到被等待的B线程执行结束当前线程才会继续执行。            // 下面这个wait放大，是线程对象B的wait方法，当前线程A执行了对象B的wait方法，使得当前线程阻塞等待。因为join方法被synchronized修饰，所以当前线程已经持有了对象B的锁了，才能调用B对象的wait方法            // 传入0也表示没有等待期限，只有当某个线程调用了B对象的notify()/notifyAll()方法，才有可能会使在对象B上的等待队列中等待的线程A唤醒            wait(0);        }    // 传入的超时时间不为0，意味着如果当前线程A等待了超过millis毫秒了，线程对象B对应的线程还没有执行完，那么也会自动被唤醒继续向下执行，不会一直等待了      } else {        // 最多等待 millis 毫秒        // isAlive()判断线程B是否执行完成        while (isAlive()) {            // 每一轮循环都会重新计算还剩下多少等待时间，用最多的等待时间减去当前的时间            long delay = millis - now;            // 如果delay小于等于0了，说明已经到了等待时间了，这个时候不管线程B是否执行完了，都直接跳出循环，后续会去唤醒当前线程A            if (delay &lt;= 0) {                break;            }            // 如果此时还没有超时并且线程B没有执行完，那么就当前线程A就继续调用线程对象B的wait方法，并且传入最多还要等待的时间，来使当前线程阻塞指定的时间            wait(delay);            // 每一轮循环都会获取一次当前的时间            now = System.currentTimeMillis() - base;        }    }    // join方法执行到最后，JVM底层会去执行让当前线程A唤醒的操作，源码中并没有显式调用notify()/notifyAll()方法，整个唤醒操作是在JVM底层实现的}</code></pre><p>join()方法是用于让一个线程等待另一个线程执行完毕的方法。当一个线程A执行了另一个线程B的join()方法后，线程A将会被挂起，直到线程B执行完毕。</p><p>join()方法的底层实现原理是基于对象的wait()和notify()方法来实现的。当一个线程A执行另一个线程B的join()方法时，线程A会进入等待状态（WAITING），线程B会运行直到执行完毕。当线程B执行完毕后，JVM底层会自动调用对象的notifyAll()方法来通知所有等待在该对象上的线程，包括线程A。此时，线程A会重新进入就绪状态（在Java线程中其实就是进入到RUNNABLE状态），等待获取CPU资源继续向下执行。</p><h3 id="注意点一：join阻塞的是当前线程，并不是join方法的线程对象对应的线程"><a href="#注意点一：join阻塞的是当前线程，并不是join方法的线程对象对应的线程" class="headerlink" title="注意点一：join阻塞的是当前线程，并不是join方法的线程对象对应的线程"></a>注意点一：join阻塞的是当前线程，并不是join方法的线程对象对应的线程</h3><p>有很多人不理解join为什么阻塞的是当前线程，而不是调用join方法的线程对象对应的线程呢？不理解的原因是阻塞当前线程A的wait()方法是放在线程对象B这个实例中被调用的，让大家误以为应该阻塞B线程。但实际上当前线程会持有线程对象B的对象的锁（因为join方法使用synchronized修饰的，所以当前线程也就获取了线程对象B的锁），在线程对象B调用的wait()方法时，而这个wait()方法的调用者线程对象B是在当前线程环境中的。所以造成当前线程阻塞。</p><h3 id="注意点二：唤醒当前线程的操作是在JVM底层实现的，并没有显式调用notifyAll-方法"><a href="#注意点二：唤醒当前线程的操作是在JVM底层实现的，并没有显式调用notifyAll-方法" class="headerlink" title="注意点二：唤醒当前线程的操作是在JVM底层实现的，并没有显式调用notifyAll()方法"></a>注意点二：唤醒当前线程的操作是在JVM底层实现的，并没有显式调用notifyAll()方法</h3><p>为什么线程B执行完毕就能够唤醒当前线程呢？或者说是在什么时候唤醒的？</p><p>这里我们要注意一点，被等待的线程并不会真正地调用notifyAll()方法来唤醒其他等待线程，而是由底层的JVM代码实现自动唤醒等待线程的功能。这个功能在底层被称为“monitor enter”和“monitor exit”，是由JVM来负责管理的。具体实现细节比较复杂，但是对于Java开发者来说，只需要知道在使用join()方法等待线程执行完毕时，等待的线程会被自动唤醒，不需要手动调用notify()或notifyAll()方法。在Thread类的join()方法的源码中，没有直接调用notify()或notifyAll()方法的代码。但是，join()方法的底层实现确实是基于对象的wait()和notify()方法来实现的。</p><p>如果想要知道实现唤醒的具体细节，我们就得翻jdk的源码，但是如果大家对线程有一定的基本了解的话，通过wait方法阻塞的线程，需要通过notify或者notifyall来唤醒。所以在线程执行完毕以后会有一个唤醒的操作，只不过并不是显式调用，而是在JVM底层代码实现的。</p><p>接下来在hotspot的源码中找到 thread.cpp，看看被等待线程执行结束以后有没有做相关的事情来证明我们的猜想</p><pre><code class="line-numbers language-java">void JavaThread::exit(bool destroy_vm, ExitType exit_type) {    assert(this == JavaThread::current(),  "thread consistency check");    ...    // Notify waiters on thread object. This has to be done after exit() is called    // on the thread (if the thread is the last thread in a daemon ThreadGroup the    // group should have the destroyed bit set before waiters are notified).    ensure_join(this);     assert(!this-&gt;has_pending_exception(), "ensure_join should have cleared");    ...}</code></pre><h3 id="注意点三：当前线程A在进入到线程对象B的join方法中使获取了线程对象B的锁，在join内部调用wait-方法时又会释放掉线程对象B的锁，在线程B执行完后当前线程才会再次获取线程对象B的锁"><a href="#注意点三：当前线程A在进入到线程对象B的join方法中使获取了线程对象B的锁，在join内部调用wait-方法时又会释放掉线程对象B的锁，在线程B执行完后当前线程才会再次获取线程对象B的锁" class="headerlink" title="注意点三：当前线程A在进入到线程对象B的join方法中使获取了线程对象B的锁，在join内部调用wait()方法时又会释放掉线程对象B的锁，在线程B执行完后当前线程才会再次获取线程对象B的锁"></a>注意点三：当前线程A在进入到线程对象B的join方法中使获取了线程对象B的锁，在join内部调用wait()方法时又会释放掉线程对象B的锁，在线程B执行完后当前线程才会再次获取线程对象B的锁</h3><p>在Java中，每个对象都有一个相关联的锁，也称为监视器锁。当一个线程需要访问被该锁保护的对象时，它必须先获得该锁的所有权。只有获得锁的线程才能调用wait()、notify()和notifyAll()方法。因此，在join()方法中，使用了synchronized关键字来使当前线程获取到Thread对象的锁，确保只有一个线程可以进入join()方法，避免出现竞态条件。</p><p>当前线程A调用线程对象B的join方法时，当前线程会尝试获取线程对象B的锁，获取对象B的锁成功后，就会在join方法内部会调用对象B的wait方法，此时当前线程A就会释放线程对象B的锁，使得线程A进入等待状态。此时线程B就会又获取到线程对象B的锁，当线程对象B执行完毕后，JVM底层会调用notifyAll方法唤醒所有等待线程，包括线程A，底层调用了唤醒方法后，线程B又会释放掉线程对象B的锁，此时线程A会重新获取线程对象B的锁（因为是线程A调用的线程对象B的join方法，join方法又是被synchronized修饰的方法，如果线程A唤醒后不再次持有对象B的锁，就没有办法继续在join方法内部继续向下执行了），然后继续执行后面的代码。</p><h3 id="注意点四：线程A调用线程对象B的join方法时，只有当此时线程对象已经被启动并且还没有执行完时才会起作用"><a href="#注意点四：线程A调用线程对象B的join方法时，只有当此时线程对象已经被启动并且还没有执行完时才会起作用" class="headerlink" title="注意点四：线程A调用线程对象B的join方法时，只有当此时线程对象已经被启动并且还没有执行完时才会起作用"></a>注意点四：线程A调用线程对象B的join方法时，只有当此时线程对象已经被启动并且还没有执行完时才会起作用</h3><p>当一个线程对象被创建后，调用该线程对象的start()方法可以启动该线程，线程开始执行。而当一个线程在执行过程中调用另一个线程对象的join()方法时，会让该线程执行完毕后再继续执行当前线程。</p><p>start()方法会创建一个新的线程，并且让这个新线程执行run()方法中的代码。如果没有调用start()方法，那么线程对象B只是一个普通的对象，并没有对应的线程。如果线程对象还没有执行start()方法，那么在当前线程中调用该线程对象的join()方法不会有任何效果，因为线程还没有开始执行。这种情况下当前线程调用另一个线程对象的join()方法会使当前线程进入等待状态，直到被等待的线程结束或者超时，但是被等待的线程并没有开始执行，甚至都不存在这个线程，所以当前线程会一直处于等待状态，直到超时或者被中断。</p><p>还有一点需要注意的是，当线程A执行join()方法等待线程B执行完毕时，如果线程B已经执行完毕了，那么线程A并不会阻塞，而是直接退出join()方法，继续执行下面的代码。</p><p>所以，在使用join()方法之前，一定要确保调用了start()方法来启动相应的线程。</p><p>以上join()方法的简单实现原理。实际上，Java虚拟机在实现中还考虑了许多细节，以确保线程的正确协作和优化执行效率。</p><p><strong>总结：</strong></p><p>当一个线程对象调用了join方法后，它就会让当前线程（即调用join方法的线程）进入等待状态，直到这个线程对象对应的线程执行完毕为止。<br>join方法的底层实现原理是基于对象的wait和notify方法来实现的。在当前线程的环境下当线程对象调用了join方法时，当前线程会获取这个对象的锁，并且调用这个对象的wait方法来使当前线程阻塞等待。当这个对象对应的线程执行完毕后，JVM底层会调用notifyAll方法来唤醒所有等待在这个对象上的线程，包括当前线程。这个唤醒过程是在JVM底层实现的，作为用户的我们看不到显式的调用唤醒方法的代码。<br>源码中有相关的体现，可以参考Thread类中join和isAlive方法以及JVM中ensure_join和lock.notify_all方法（就是JVM中的这两个方法实现了join方法中唤醒当前线程的操作）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Thread.join其实底层是通过wait和notifyall来实现线程的通信达到线程阻塞的目的；</p><p>join和wait方法的区别是：</p><ul><li>wait方法会让当前线程释放对象锁，并进入等待状态，直到被其他线程唤醒或者超时时间到达。</li><li>join方法不会让当前线程释放对象锁，而是让当前线程进入到等待状态等待目标线程执行完毕或者超时时间到达。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程的通知与等待</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-de-tong-zhi-yu-deng-dai/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-de-tong-zhi-yu-deng-dai/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程的通知与等待"><a href="#【Java-多线程并发】-线程的通知与等待" class="headerlink" title="【Java 多线程并发】 线程的通知与等待"></a>【Java 多线程并发】 线程的通知与等待</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程的通知与等待date: 2023-07-04 23:08tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 线程的通知与等待</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>wait()、notify/notifyAll() 方法都是Object的本地final方法，无法被重写。</p><p><strong>obj.wait()</strong></p><p>wait()是Object里面的方法，Object是所有对象的父类，即所有对象都可以调用wait()方法。</p><p>直到发生以下几种情况才会恢复执行：</p><ul><li>其他线程调用了该共享对象的 notify() 方法或者 notifyAll() 方法（继续往下走）</li><li>其他线程调用了该线程的 interrupt() 方法，该线程会 InterruptedException 异常返回</li></ul><p><strong>使用前需要持有线程共享对象的锁</strong></p><p>当线程调用wait() 之后，就会释放该对象的监视器锁</p><p>Java的线程通信实质上是共享内存，而不是直接通信</p><p><strong>obj.notify()</strong></p><p>一个线程调用共享对象的 notify() 方法后，会唤醒一个在该共享变量上调用 wait(…) 系列方法后阻塞的线程。</p><p>不会释放掉线程持有的锁。</p><ul><li>一个共享变量上可能会有多个线程在等待，notify()具体唤醒哪个等待的线程是随机的；</li><li>被唤醒的线程不能马上从wait()方法返回并继续执行，它必须在获取了共享对象的监视器锁后才可以返回</li></ul><p><strong>notifyAll() 方法</strong></p><p>会唤醒所有在该共享变量上由于调用wait系列方法而被挂起的线程。<br>在生产者消费者模型中，推荐使用notifyAll，因为notify唤醒的线程不确定是生产者或消费者。</p><h2 id="【Java-多线程并发】-线程的通知与等待-1"><a href="#【Java-多线程并发】-线程的通知与等待-1" class="headerlink" title="【Java 多线程并发】 线程的通知与等待"></a>【Java 多线程并发】 线程的通知与等待</h2><p>wait()、notify/notifyAll() 方法都是Object的本地final方法，无法被重写。这些方法都是native方法。</p><h2 id="先总结一下这三个方法带来的Java线程状态变化"><a href="#先总结一下这三个方法带来的Java线程状态变化" class="headerlink" title="先总结一下这三个方法带来的Java线程状态变化"></a>先总结一下这三个方法带来的Java线程状态变化</h2><p>当Java线程调用wait()方法后，该线程会进入等待队列，并且会释放占用的锁资源。线程状态会变为WAITING或TIMED_WAITING。该线程不会被挂起到外存，而是在内存中等待被唤醒。线程等待的条件通常是由其他线程调用notify()或notifyAll()方法来唤醒该线程。</p><p>当线程被唤醒时，它会重新尝试获取锁资源并从wait()方法返回。线程状态会变为BLOCKED，直到它获得了锁资源为止。如果成功获取锁资源，线程状态会变为RUNNABLE，然后可以继续执行。如果获取锁资源失败，则线程会继续等待，并且状态会维持在BLOCKED或WAITING或TIMED_WAITING状态，直到它再次被唤醒。</p><p>需要注意的是，线程在等待期间会消耗一定的资源，因此应该避免过多的线程等待。另外，线程在等待期间不会占用CPU时间片，因此可以减少CPU的利用率，提高系统的性能。</p><h2 id="obj-wait"><a href="#obj-wait" class="headerlink" title="obj.wait()"></a>obj.wait()</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>wait()是Object里面的方法，Object是所有对象的父类，即所有对象都可以调用wait()方法。wait方法还有可以传入等待时长的，可以让线程等待指定的时间后自动被唤醒。调用wait()会使Java线程进入到WAITING状态，调用wait(long time)会使Java线程进入到TIMED_WAITING状态。（WAITING和TIMED_WAITING状态就是阻塞状态）</p><p>当一个线程调用一个共享变量的wait()方法时，该线程会阻塞（等待）。直到发生以下几种情况才会恢复执行：</p><ul><li>其他线程调用了该共享对象的 notify() 方法或者 notifyAll() 方法（继续往下走）</li><li>其他线程调用了该线程的 interrupt() 方法，该线程会 InterruptedException 异常返回</li></ul><p>等待线程：假设调用的是obj对象的wait()方法，wait的执行线程，也就是被暂停的线程，就称为对象obj上的等待线程。对象的wait方法可能被不同的线程执行，所以同一个对象可能会有多个等待线程。</p><h3 id="wait-方法到底会让哪个线程阻塞？"><a href="#wait-方法到底会让哪个线程阻塞？" class="headerlink" title="wait()方法到底会让哪个线程阻塞？"></a>wait()方法到底会让哪个线程阻塞？</h3><p>当一个线程调用某个对象的wait()方法时，这个线程会进入该对象的等待队列，等待被其他线程唤醒。</p><p>具体来说，当一个线程调用对象的wait()方法时，该线程会释放该对象的锁并进入等待状态（WAITING/TIMED_WAITING），直到被其他线程调用该对象的notify()或notifyAll()方法唤醒。在等待过程中，该线程不会占用 CPU 资源，它会被阻塞在内存中，直到被唤醒后才会有机会重新进入运行状态。</p><p>因此，调用了wait()方法的线程会被阻塞，并释放该对象的锁。被唤醒后，它会重新尝试获取该对象的锁并从wait()方法返回，进入BLOCKED状态，直到它获得了锁资源为止，当他重新获取到之前调用对象的锁资源后，就可以继续进入到运行状态。我们就可以理解为在那个线程环境中执行了某个对象的wait()方法，那么这个线程环境就会被阻塞，进入到等待状态，也就是调用了wait()方法时所在的当前线程会被阻塞。</p><p>需要注意的是，被阻塞的是当前线程，而不是该对象。当调用了wait()方法后，当前线程会进入等待状态，而该对象依然存在，并不会被阻塞。其他线程仍然可以访问该对象，只是在当前线程持有该对象的锁时，其他线程不能获取该对象的锁。之所以要强调这一点，是因为有的时候可能当前线程在调用某个对象的wait()方法时，这个对象是另一个线程的对象，也就是在线程A中调用线程B对象的wait()方法，这种情况我们一定不要搞混乱，一定要直到被阻塞的是线程A，并不是线程B，线程B不会受到影响。</p><h3 id="wait-long-timeout-方法如何实现自动唤醒"><a href="#wait-long-timeout-方法如何实现自动唤醒" class="headerlink" title="wait(long timeout)方法如何实现自动唤醒"></a>wait(long timeout)方法如何实现自动唤醒</h3><p>当一个线程内调用某个对象的wait(long timeout)方法时，它将被阻塞，并释放该对象的锁。底层实现中，系统会在等待一定时间后自动唤醒该线程，使其重新进入对象的同步队列中。当该线程被唤醒时，它会重新尝试获取对象的锁，成功获取到锁后就会继续执行。</p><p>具体来说，当线程调用wait(long timeout)方法时，系统会记录下当前时间（假设为t1），并将线程加入到对象的等待队列中。接下来，系统会使该线程进入阻塞状态，直到下面任意一个条件发生：</p><ul><li>其他线程调用了该对象的notify()或notifyAll()方法，并且该线程被唤醒。</li><li>指定的等待时间已经过去，并且该线程被唤醒。</li></ul><p>如果是第一种情况：该线程被唤醒后会尝试重新获取该对象的锁，如果获取成功，则继续执行。如果获取不成功，该线程将重新进入等待队列中，等待下一次被唤醒。</p><p>如果是第二种情况：系统会在指定的等待时间（timeout）到达时，自动唤醒该线程，将其移除等待队列，然后使其重新进入对象的同步队列中去尝试获取该对象的锁。</p><p>需要注意的是，在等待时间到达之前，如果其他线程调用了该对象的notify()或notifyAll()方法，则该线程会被唤醒并尝试重新获取锁，而不必等待指定的等待时间过去。</p><p>总之，调用wait(long timeout)方法时，底层系统会自动实现等待指定时间后自动唤醒该线程的功能，而无需用户手动干预。自动唤醒的操作是在底层JVM中实现的，并没有显式地调用notify()或notifyAll()方法。wait方法是一个本地的native方法。</p><p>wait()无参方法其实底层还是调用的wait(long timeout)有参方法，只不过传入的是0，只要传入的是0，就是没有等待时常，只要没有其他线程显式调用notify()或notifyAll()方法来唤醒该线程的话，该线程就会一直在等待（阻塞）状态。</p><h4 id="同步队列和等待队列"><a href="#同步队列和等待队列" class="headerlink" title="同步队列和等待队列"></a>同步队列和等待队列</h4><p>在上面的论述中，提到了同步队列和等待队列，这里单独讲一下它俩避免搞混乱。</p><p>等待队列和同步队列是同一个概念，都是指的同步器（锁）的内部队列。当线程调用了wait(long timeout)方法后，会将当前线程加入到同步器的等待队列中。如果等待时间超过了设定的timeout，系统会自动将该线程从等待队列中移除，然后重新加入到同步队列中等待获取锁。</p><p><mark style="background: #FFF3A3A6;">等待队列和同步队列是同一个队列，只是同步队列是等待获取锁的线程所在的队列，而等待队列是等待被唤醒的线程所在的队列。</mark></p><p>这里要注意等待队列和同步队列虽然都是指的同一个队列，但是它们是在不同的状态下使用的，具有不同的作用。</p><ul><li>等待队列是指等待被唤醒的线程所在的队列，它的作用是存放调用了Object.wait()方法后被阻塞的线程。当一个线程调用了wait方法后，它就会被放入到等待队列中，等待被唤醒。</li><li>同步队列是指等待获取锁的线程所在的队列，它的作用是存放那些正在等待获取锁的线程。当一个线程试图获取一个对象的锁时，如果锁已经被其他线程占用，那么它就会被放入同步队列中，等待获取锁。</li></ul><p>因此，在调用wait(long timeout)方法时，如果等待的时间超过了timeout设定的时间，系统会自动将该线程从等待队列中移除，然后重新加入到同步队列中等待获取锁。这里的移除和重新加入都是在同一个队列中完成的，也就是同步队列。</p><p>可能到了这里你就会迷惑了，怎么两个作用不同的队列是同一个队列呢，这样不同的线程混在同一个队列中岂不都乱了。</p><p>实际上，<mark style="background: #FFF3A3A6;">等待被唤醒的线程和等待获取锁的线程是分别存放在同一个队列的不同部分中的，而不是混合在一起的。在 Java 中，同步队列的实现通常是一个双向链表，链表中的每个节点都可以代表一个线程或者一个等待状态。</mark>当一个线程等待获取对象的锁时，它会被加入到队列的尾部，同时释放持有的锁；当一个线程调用 wait() 方法进入等待状态时，它会被加入到队列的头部。</p><p>因此，当一个线程调用了 wait() 方法后，它会被放到队列的头部等待被唤醒，而等待获取锁的线程则在队列的尾部等待。这样就保证了等待被唤醒的线程和等待获取锁的线程的位置是不会混淆的，不会出现混乱的情况。</p><h3 id="使用前需要持有线程共享对象的锁"><a href="#使用前需要持有线程共享对象的锁" class="headerlink" title="使用前需要持有线程共享对象的锁"></a>使用前需要持有线程共享对象的锁</h3><p>在使用wait()、notify()和notifyAll()方法方法前，需要先持有锁。如果调用线程共享对象的wait()、notify()和notifyAll()方法的线程没有事先获取该对象的监视器锁，调用线程会抛出IllegalMonitorStateException 异常。<mark style="background: #FFB8EBA6;">当线程调用wait() 之后，就会释放该对象的监视器锁</mark>。</p><p><strong>使用wait()、notify()和notifyAll()方法方法前，需要先持有锁：</strong></p><ul><li>表象：wait、notify(ALL)方法需要调用 monitor 对象</li><li>本质：Java的线程通信实质上是共享内存，而不是直接通信</li></ul><p><strong>那么，一个线程如何才能获取一个共享变量的监视器锁？</strong></p><p>1、 执行synchronized 同步代码块，使用该共享变量作为参数。</p><pre><code class="line-numbers language-java">synchronized(共享变量) {    // TODO}</code></pre><p>2、调用该共享变量的同步方法（synchronized 修饰）</p><pre><code class="line-numbers language-java">synchronized void sum(int a, int b) {    // TODO}</code></pre><p> 如下代码示例，线程A与线程B，在线程A中调用共享变量obj的wait()方法，在线程B中进行唤醒notify()。</p><pre><code class="line-numbers language-java">/** * Object的Wati()方法的使用 */@Slf4jpublic class WaitTest {     public static void main(String[] args) {         // 定义一个共享变量        Object obj = new Object();         // 创建线程A        Thread threadA = new Thread(new Runnable() {            @Override            public void run() {                log.info("线程" + Thread.currentThread().getName()+"开始执行");                try {                    // 获取共享变量的对象锁                    synchronized(obj){                        // 线程A 等待                        log.info("线程" + Thread.currentThread().getName()+"等待");                        // 调用wait()，线程A阻塞，并且释放掉获取到的obj的对象锁                        obj.wait();                    }                } catch (InterruptedException e) {                    e.printStackTrace();                }                 log.info("线程" + Thread.currentThread().getName()+"执行结束");            }        },"A");          // 创建线程B        Thread threadB = new Thread(new Runnable() {            @Override            public void run() {                log.info("线程" + Thread.currentThread().getName()+"开始执行");                // 获取共享变量锁                synchronized (obj){                    //  线程B 唤醒或者中断  调用obj的唤醒操作或者使A线程中断的操作都可以将正在阻塞的A线程唤醒                    log.info("线程" + Thread.currentThread().getName()+"唤醒");                    obj.notify(); // 唤醒操作                    // threadA.interrupted(); // 中断操作                }                log.info("线程" + Thread.currentThread().getName()+"执行结束");            }        },"B");          // 启动线程A        threadA.start();        try {            // 等待200ms,让线程B获取资源，在这200ms期间A就被阻塞了，释放了obj对象锁            Thread.sleep(200);        } catch (InterruptedException e) {            e.printStackTrace();        }         // 启动线程B        threadB.start();    }}</code></pre><p>执行结果：</p><pre><code class="line-numbers language-console">线程A开始执行线程B开始执行线程B执行结束线程A执行结束</code></pre><p>可以看到主程序线程A启动之后，休眠了200ms让出cup执行权，线程B开始执行后调用notify()方法对阻塞线程A进行唤醒。</p><p>故：当一个线程调用一个共享变量的wait()方法时，该调用线程会被阻塞挂起，直到发生下面几件事情之一才返回：（1）其他线程调用了该共享对象的notify()或者notifyAll()方法；（2）其他线程调用了该线程的interrupt()方法，该线程抛出InterruptedException异常返回。</p><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><ul><li>wait()方法一般配合while使用<ul><li>被唤醒后会重新竞争锁，之后从上次wait位置重新运行</li><li>while 多次判断，防止在wait这段时间内对象被修改</li></ul></li></ul><h2 id="obj-notify"><a href="#obj-notify" class="headerlink" title="obj.notify()"></a>obj.notify()</h2><p>一个线程调用共享对象的 notify() 方法后，会唤醒一个在该共享变量上调用 wait(…) 系列方法后阻塞的线程。</p><p><strong>通知线程</strong>：调用notify/notifyAll方法时所在的线程叫做通知线程。</p><h3 id="调用notify-或notifyAll-不会释放线程的锁"><a href="#调用notify-或notifyAll-不会释放线程的锁" class="headerlink" title="调用notify()或notifyAll()不会释放线程的锁"></a>调用notify()或notifyAll()不会释放线程的锁</h3><p>当线程调用notify()或notifyAll()方法时，它不会释放掉线程持有的锁。</p><p>在Java中，每个对象都有一个相关联的锁，也称为监视器锁。当一个线程需要访问被该锁保护的对象时，它必须先获得该锁的所有权。所以只有获得锁的线程才能调用wait()、notify()和notifyAll()方法。</p><p>当线程调用notify()或notifyAll()方法时，它仅仅是唤醒等待在该对象上的一个或多个线程，以便它们可以继续执行。它不会释放线程持有的锁。因此，其他线程仍然无法访问被该锁保护的对象，直到调用notify()或notifyAll()方法的线程释放锁资源。</p><p>在多线程编程中，必须小心地管理锁，以避免死锁和竞争条件等问题。通常，为了确保线程安全和避免死锁，必须确保在访问共享资源时只有一个线程持有锁。当然，这也需要合理地使用wait()、notify()和notifyAll()方法来协调线程的执行顺序。</p><p>值得注意的是：</p><ul><li>一个共享变量上可能会有多个线程在等待，notify()具体唤醒哪个等待的线程是随机的；</li><li>被唤醒的线程不能马上从wait()方法返回并继续执行，它必须在获取了共享对象的监视器锁后才可以返回，等到唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程也不一定会获取到共享对象的监视器锁，这是因为该线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行；</li></ul><h2 id="notifyAll-方法"><a href="#notifyAll-方法" class="headerlink" title="notifyAll() 方法"></a>notifyAll() 方法</h2><p>notifyAll() 方法则会唤醒所有在该共享变量上由于调用wait系列方法而被挂起的线程。</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>比较经典的就是生产者和消费者的例子。</p><p>在生产者消费者模型中，推荐使用notifyAll，因为notify唤醒的线程不确定是生产者或消费者。</p><pre><code class="line-numbers language-java">public class NotifyWaitDemo {       // 共享变量队列的最大容量    public static final int MAX_SIZE = 1024;    // 共享变量    public static Queue queue = new Queue();     public static void main(String[] args) {        // 生产者        Thread producer = new Thread(() -&gt; {            // 获取共享变量的锁才能调用wait()方法            synchronized (queue) {                // 一般wait()都配合着while使用，因为线程唤醒后需要不断地轮循来尝试获取锁                while (true) {                    // 当队列满了之后就挂起当前线程（生产者线程）                    // 并且，释放通过queue的监视器锁，让消费者对象获取到锁，执行消费逻辑                    if (queue.size() == MAX_SIZE) {                        try {                            // 阻塞生产者线程，并且使当前线程释放掉共享变量的锁                            queue.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    // 空闲则生成元素，并且通知消费线程                    queue.add();                    // 唤醒消费者来消费，建议用notifyAll()，因为notify()无法确定会唤醒哪一个线程                    queue.notifyAll();                }            }        });         // 消费者        Thread consumer = new Thread(() -&gt; {            // 需要先获取锁            synchronized (queue) {                while (true) {                    // 当队列已经空了之后就挂起当前线程（消费者线程）                    // 并且，释放通过queue的监视器锁，让生产者对象获取到锁，执行生产逻辑                    if (queue.size() == 0) {                        try {                            // 阻塞消费者线程，并释放共享对象的锁                            queue.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    // 空闲则消费元素，并且通知生产线程                    queue.take();                    queue.notifyAll();                }            }        });          // 先执行生产者线程        producer.start();        try {            // 将当前线程睡眠1000ms，让生产者先将队列生产满，然后wait阻塞起来，并且释放持有的锁。为了后续能执行消费者线程            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        // 执行消费者线程        consumer.start();    }      // 共享变量    static class Queue {        private int size = 0;        public int size() {            return this.size;        }        // 生产操作        public void add() {            // TODO            size++;            System.out.println("执行add 操作，current size: " +  size);        }        // 消费操作        public void take() {            // TODO            size--;            System.out.println("执行take 操作，current size: " +  size);        }    }}</code></pre><h2 id="wait-x2F-notify-x2F-notifyAll-为什么定义在-Object-类中？"><a href="#wait-x2F-notify-x2F-notifyAll-为什么定义在-Object-类中？" class="headerlink" title="wait()/notify()/notifyAll() 为什么定义在 Object 类中？"></a>wait()/notify()/notifyAll() 为什么定义在 Object 类中？</h2><p>调用这些方法来等待和唤醒时必须持有同一个锁，而锁可以是任意对象的锁（即也有可能是Thread线程对象的锁），所以这三个方法有可能被任何一个对象调用，而Object类是所有Java对象的顶级父类，既然有了任意对象都可能调用这三个方法的需求，所以可以被任意对象调用的方法通常是定义在Object类中。</p><p>Thread类继承了Object类，所以Thread也可以调用者三个方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程睡眠、阻塞、挂起、终止</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-shui-mian-zu-sai-gua-qi-zhong-zhi/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-shui-mian-zu-sai-gua-qi-zhong-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程睡眠、阻塞、挂起、终止"><a href="#【Java-多线程并发】-线程睡眠、阻塞、挂起、终止" class="headerlink" title="【Java 多线程并发】 线程睡眠、阻塞、挂起、终止"></a>【Java 多线程并发】 线程睡眠、阻塞、挂起、终止</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程睡眠、阻塞、挂起、终止date: 2023-07-04 22:50tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 线程睡眠、阻塞、挂起、终止</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>睡眠会使线程进入到睡眠状态指定的时间，过了指定时间后就会被唤醒继续向下执行。睡眠能够使线程在执行时间内暂停执行，过了指定时间之后就会自动恢复执行。此时线程也在内存中。</li><li>挂起会让线程进入挂起状态，恢复之后线程才会继续向下执行。挂起能够使线程暂停执行，并且暂停执行期间线程被转移到了外存中。</li><li>阻塞会使线程进入到阻塞状态，恢复之后线程才会继续向下执行。阻塞能够使线程暂停执行，此时线程在内存中阻塞等待。</li></ul><p><strong>睡眠</strong></p><ul><li>Thread.sleep()</li><li>由用户控制的</li><li>睡眠时线程不会释放对象锁</li><li>睡眠时间到了则恢复到就绪态</li></ul><p><strong>挂起</strong></p><ul><li>thread1.suspend() // 挂起   </li><li>thread1.resume()  // 挂起</li><li>由用户控制的</li><li>挂起恢复需要用户主动控制</li><li>挂起时线程不会释放对象锁</li></ul><p><strong>终止</strong></p><ul><li>thread1.stop()</li><li>由用户控制的</li><li>强制结束线程的执行</li></ul><p><strong>阻塞</strong></p><ul><li>被动的</li><li>线程在等待某种事件或者资源的表现</li></ul><p><strong>挂起的原因</strong></p><ul><li>终端用户的请求。</li><li>父线程的请求。</li><li>负荷调节的需要。</li><li>操作系统的需要。</li><li>对换的需要。</li></ul><h2 id="【Java-多线程并发】-线程睡眠、阻塞、挂起、终止-1"><a href="#【Java-多线程并发】-线程睡眠、阻塞、挂起、终止-1" class="headerlink" title="【Java 多线程并发】 线程睡眠、阻塞、挂起、终止"></a>【Java 多线程并发】 线程睡眠、阻塞、挂起、终止</h2><h3 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h3><p>线程睡眠，也叫线程休眠，是由用户控制的（用户主动调用相关方法才能使线程睡眠），<strong>睡眠恢复则是自动完成的</strong>，睡眠时间到了则恢复到就绪态，<strong>睡眠时线程不会释放对象锁</strong>。</p><p><strong>睡眠方法:</strong></p><p>Thread.sleep()</p><p><strong>备注：</strong></p><p>sleep方法属于Thread类的静态方法，可以直接通过Thread类对象来调用执行，使当前线程睡眠。<br>sleep()底层是用native的C++方法sleep(long millis)实现的。<br>睡眠恢复之后会继续从睡眠时执行到的位置继续向下执行，而不是重新开始执行</p><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>线程挂起是由用户控制的，挂起恢复需要用户主动控制，挂起时线程不会释放对象锁。</p><p><strong>挂起方法:</strong></p><ul><li>thread1.suspend() // 挂起   </li><li>thread1.resume()  // 挂起</li></ul><p><strong>备注：</strong></p><ul><li>suspend、resume这两个方法都需要线程对象调用，可以使调用该方法的线程对象挂起。</li><li>但是这两个方法现在均已被废弃，不建议使用，因为容易引发死锁</li><li>这两个方法底层是通过native的C++方法suspend0()和resume0()实现的</li><li>挂起恢复之后会继续从挂起时执行到的位置继续向下执行，而不是重新开始执行</li></ul><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>终止是由用户控制的，终止一个线程时会强制结束线程的执行，不管run方法是否执行完了，并且还会释放这个线程所持有的所有的锁对象。</p><p><strong>终止方法:</strong> </p><ul><li>thread1.stop()</li></ul><p><strong>备注：</strong></p><ul><li>stop()方法需要线程对象调用，可以使调用该方法的线程对象挂起。</li><li>stop()方法已废弃，不建议使用</li><li>stop()方法底层是通过native的C++方法stop0()实现的</li><li>终止操作会将线程彻底结束，下次该线程需要从头开始启动执行</li></ul><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><strong>阻塞是被动的</strong>，是线程在等待某种事件或者资源的表现，如果线程需要等待某个时间或者资源的时候，线程会自动进入到阻塞状态，一旦获得所需资源或者事件信息就自动恢复到就绪态。</p><p><strong>恢复之后会继续从阻塞时执行到的位置继续向下执行，而不是重新开始执行。</strong></p><h3 id="操作系统中睡眠、阻塞、挂起的区别形象解释"><a href="#操作系统中睡眠、阻塞、挂起的区别形象解释" class="headerlink" title="操作系统中睡眠、阻塞、挂起的区别形象解释"></a>操作系统中睡眠、阻塞、挂起的区别形象解释</h3><p>首先这些术语都是对于线程来说的，并且这里将睡眠、阻塞、挂起都看成是一种行为。对线程的控制就好比你控制了一个雇工为你干活。你对雇工的控制是通过编程来实现的：</p><ul><li>挂起线程的意思就是你对主动对雇工说：“你睡觉去吧，用着你的时候我主动去叫你，然后接着干活”。</li><li>使线程睡眠（sleep）的意思就是你主动对雇工说：“你睡觉去吧，某时某刻过来报到，然后接着干活”。</li><li>线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉了，但是你不能怪雇工，因为本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统。</li></ul><p>睡眠、阻塞、挂起这三者的共同本质就是正在执行的进程/线程，由于某些原因(主、被动)释放CPU，暂停执行。(这里讨论的均是处于运行状态的进/线程)</p><h2 id="线程的睡眠"><a href="#线程的睡眠" class="headerlink" title="线程的睡眠"></a>线程的睡眠</h2><p>线程的睡眠比较简单，这里就不做详细的讲解了，就记住睡眠是用户主动操作，用户设置好睡眠时间，线程暂停指定的时间后会自动恢复，继续向下执行。</p><h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><p>线程的终止比较简单，这里就不做详细的讲解了，就记住终止是用户主动操作，终止操作会将线程彻底结束，下次该线程需要从头开始启动执行。</p><p>进程的终止也是同样的道理。</p><h2 id="线程的挂起"><a href="#线程的挂起" class="headerlink" title="线程的挂起"></a>线程的挂起</h2><p>挂起线程在操作系统中可以定义为暂时被淘汰出内存的线程，机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的线程被暂时调离出内存，将其调到外存，当条件允许的时候，会被操作系统再次调回内存，重新进入等待被执行的状态即就绪态。</p><h3 id="挂起的原因"><a href="#挂起的原因" class="headerlink" title="挂起的原因"></a>挂起的原因</h3><ul><li>终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的线程暂停执行；若此时用户线程正处于就绪状态而未执行，则该线程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。</li><li>父线程的请求。有时父线程希望挂起自己的某个子线程，以便考察和修改子线程，或者协调各子线程间的活动。</li><li>负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的线程挂起，以保证系统能正常运行。</li><li>操作系统的需要。操作系统有时希望挂起某些线程，以便检查运行中的资源使用情况或进行记账。</li><li>对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的线程换至外存上。</li></ul><p>进程的挂起和上面讲的线程的挂起完全一样，把上面文字描述的线程改成进程就可以了。</p><h2 id="线程的阻塞"><a href="#线程的阻塞" class="headerlink" title="线程的阻塞"></a>线程的阻塞</h2><h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><p>线程在运行的过程中因为某些原因而发生阻塞，阻塞状态的线程的特点是：该线程放弃CPU的使用，暂停运行，只有等到导致阻塞的原因消除之后才恢复运行。或者是被其他的线程中断（interrupt方法），该线程也会退出阻塞状态，同时抛出InterruptedException。</p><h3 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h3><p>正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）暂时无法继续执行。此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态。</p><p>进程阻塞的原因：线程中的阻塞、Socket客户端的阻塞、Socket服务器端的阻塞。</p><h3 id="一般线程中的阻塞"><a href="#一般线程中的阻塞" class="headerlink" title="一般线程中的阻塞"></a>一般线程中的阻塞</h3><p>被动阻塞，下面这两种将阻塞看成一种被动触发的阻塞行为，这里将阻塞看作是一种行为：</p><ul><li>线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。</li><li>线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。</li></ul><p>还有一些情况是主动调用，使线程进入到阻塞状态：</p><ul><li>线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。</li><li>线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行。</li></ul><h3 id="Socket客户端的阻塞："><a href="#Socket客户端的阻塞：" class="headerlink" title="Socket客户端的阻塞："></a>Socket客户端的阻塞：</h3><ul><li>请求与服务器连接时，调用connect方法，进入阻塞状态，直至连接成功。</li><li>当从Socket输入流读取数据时，在读取足够的数据之前会进入阻塞状态。比如说通过BufferedReader类使用readLine()方法时，在没有读出一行数据之前，数据量就不算是足够，会处在阻塞状态下。</li><li>调用Socket的setSoLinger()方法关闭了Socket延迟，当执行Socket的close方法时，会进入阻塞状态，知道底层Socket发送完所有的剩余数据</li></ul><h3 id="Socket服务器的阻塞："><a href="#Socket服务器的阻塞：" class="headerlink" title="Socket服务器的阻塞："></a>Socket服务器的阻塞：</h3><ul><li>线程执行ServerSocket的accept()方法，等待客户的连接，直到接收到客户的连接，才从accept方法中返回一个Socket对象</li><li>从Socket输入流读取数据时，如果输入流没有足够的数据，就会进入阻塞状态</li><li>线程向Socket的输出流写入一批数据，可能进入阻塞状态</li></ul><p>当程序阻塞时，会降低程序的效率，于是人们就希望能引入非阻塞的操作方法。所谓非阻塞方法，就是指当线程执行这些方法时，如果操作还没有就绪，就立即返回，不会阻塞着等待操作就绪。Java.nio 提供了这些支持非阻塞通信的类。</p><h2 id="阻塞和挂起的相同点和不同点"><a href="#阻塞和挂起的相同点和不同点" class="headerlink" title="阻塞和挂起的相同点和不同点"></a>阻塞和挂起的相同点和不同点</h2><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><ul><li>线程/进程都暂停执行</li><li>线程/进程都释放CPU，即两个过程都会涉及上下文切换</li></ul><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ul><li>对系统资源占用不同：虽然都释放了CPU，但阻塞的线程/进程仍处于内存中，而挂起的线程/进程通过“对换”技术被换出到外存（磁盘）中。</li><li>发生时机不同：阻塞一般在线程/进程等待资源（IO资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS为了提高内存利用率需要将暂时不能运行的线程/进程（处于就绪或阻塞队列的线程/进程）调出到磁盘。</li><li>恢复时机不同：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的线程/进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面对这四种操作的简介，我们就能明白这四者的区别，睡眠、挂起和终止是一种主动的行为，而阻塞则是一种被动的行为，也可以将阻塞理解为是一种状态。</p><p>睡眠、挂起、阻塞都会使线程暂时停止向下执行，但是恢复了之后会接着之前执行到的位置继续向下执行。我们不用去纠结这三种行为具体有什么区别，他们只是三种不同的能使线程暂停的行为而已。虽然实现的细节和过程都有些许不同，但是本质都是使线程暂停执行，恢复之后还会接着执行。</p><p>睡眠、挂起、阻塞是三种不同的行为，对于这三种行为正确定描述应该是：</p><ul><li>睡眠会使线程进入到睡眠状态指定的时间，过了指定时间后就会被唤醒继续向下执行。睡眠能够使线程在执行时间内暂停执行，过了指定时间之后就会自动恢复执行。此时线程也在内存中。</li><li>挂起会让线程进入挂起状态，恢复之后线程才会继续向下执行。挂起能够使线程暂停执行，并且暂停执行期间线程被转移到了外存中。</li><li>阻塞会使线程进入到阻塞状态，恢复之后线程才会继续向下执行。阻塞能够使线程暂停执行，此时线程在内存中阻塞等待。</li></ul><p>通过上面的描述，虽然这三种行为都能使线程暂停执行，但其实在暂停执行的一些细节上还是有区别的，一定要注意区分。</p><p>终止就是让线程彻底停止，不管run方法是否执行完了，终止以后下次该线程需要从头开始启动执行。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Java中线程的创建和运行</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-java-zhong-xian-cheng-de-chuang-jian-he-yun-xing/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-java-zhong-xian-cheng-de-chuang-jian-he-yun-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Java中线程的创建和运行"><a href="#【Java-多线程并发】-Java中线程的创建和运行" class="headerlink" title="【Java 多线程并发】 Java中线程的创建和运行"></a>【Java 多线程并发】 Java中线程的创建和运行</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Java中线程的创建和运行date: 2023-07-04 22:40tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 Java中线程的创建和运行</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>创建和运行线程的三种方法</strong></p><ul><li>继承 Thread 类并且重写 run 方法</li><li>实现 Runnable接口的 run 方法</li><li>使用 Callable接口和FutureTask类方式</li></ul><p><img src="/attachment/0d8b97a19f87b52b2a5b487579313162.png"></p><p><strong>Thread类和Runnable接口的区别</strong></p><ul><li>Runnable接口可以实现线程之间资源共享，而Thread类不能</li><li>实现Runnable接口相对于继承Thread类的优点<ul><li>适合多个相同程序代码的线程去处理同一资源的情况。</li><li>可以避免由于Java的单继承特性带来的局限。</li><li>增强了程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。</li><li>线程池只能放入实现 Runable 或 Callable 类线程，不能直接放入继承 Thread 的类</li></ul></li></ul><h2 id="线程的创建和运行"><a href="#线程的创建和运行" class="headerlink" title="线程的创建和运行"></a>线程的创建和运行</h2><h3 id="创建和运行线程的三种方法"><a href="#创建和运行线程的三种方法" class="headerlink" title="创建和运行线程的三种方法"></a>创建和运行线程的三种方法</h3><p>Java里的程序天生就是多线程的，那么有几种启动线程的方式？ </p><p>Java 线程创建有3种方式：</p><ul><li>继承 Thread 类并且重写 run 方法</li><li>实现 Runnable接口的 run 方法</li><li>使用 Callable接口和FutureTask类方式</li></ul><h3 id="三者之间的继承关系"><a href="#三者之间的继承关系" class="headerlink" title="三者之间的继承关系"></a>三者之间的继承关系</h3><p><img src="/attachment/0d8b97a19f87b52b2a5b487579313162.png"></p><p>由此我们知道了，其实这三种创建方法的根源，都是来源于Runnable接口，这三种方法往上层追溯都能追到Runnble接口。</p><h2 id="Thread类和Runnable接口的区别"><a href="#Thread类和Runnable接口的区别" class="headerlink" title="Thread类和Runnable接口的区别"></a>Thread类和Runnable接口的区别</h2><h3 id="Runnable接口可以实现线程之间资源共享，而Thread类不能"><a href="#Runnable接口可以实现线程之间资源共享，而Thread类不能" class="headerlink" title="Runnable接口可以实现线程之间资源共享，而Thread类不能"></a>Runnable接口可以实现线程之间资源共享，而Thread类不能</h3><p>实际上Thread类和Runnable接口之间在使用上也是有所区别的，如果一个类继承Thread类，就不适合于多个线程共享资源，而实现了Runnable接口，则可以方便的实现资源的共享。</p><p><img src="/attachment/22da1b0896f3f6d927660bb115b16556.png"></p><p>由上文我们就可以知道，Thread类和Runnable接口最大的区别就是继承Thread类不能资源共享，而实现Runnable接口可以资源共享。 </p><h4 id="为什么Runnable可以共享数据："><a href="#为什么Runnable可以共享数据：" class="headerlink" title="为什么Runnable可以共享数据："></a>为什么Runnable可以共享数据：</h4><p>总结起来原因就是用Runnable接口的方法可以对<mark style="background: #FFB8EBA6;">两个不同的Thread类</mark>的构造方法<mark style="background: #FFB8EBA6;">传入相同的实现Runnable接口的对象</mark>，那么这两个不同的Thread线程类<mark style="background: #FFB8EBA6;">本质操控的是同一个Runnable接口的实现对象</mark>了，调用的也是同一个run()方法，自然这两个线程下就实现了共享同一个Runnable实现类中的数据了。</p><p>如果两个Thread类的构造方法传入不同的Runnable接口实现类，那么两个Thread线程对象操作的不是同一个Runnable实现类，两个线程也就不能共享数据了。</p><h3 id="实现Runnable接口相对于继承Thread类的优点"><a href="#实现Runnable接口相对于继承Thread类的优点" class="headerlink" title="实现Runnable接口相对于继承Thread类的优点"></a>实现Runnable接口相对于继承Thread类的优点</h3><p>可见，实现Runnable接口相对于继承Thread类来说，有如下显著的优势：</p><ul><li>适合多个相同程序代码的线程去处理同一资源的情况。</li><li>可以避免由于Java的单继承特性带来的局限。</li><li>增强了程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。</li><li>线程池只能放入实现 Runable 或 Callable 类线程，不能直接放入继承 Thread 的类</li></ul><h2 id="实现-Runnable-接口和实现-Callable-接口的区别"><a href="#实现-Runnable-接口和实现-Callable-接口的区别" class="headerlink" title="实现 Runnable 接口和实现 Callable 接口的区别"></a>实现 Runnable 接口和实现 Callable 接口的区别</h2><ol><li>Runnable 是自从 java1.1 就有了，而 Callable 是 1.5 之后才加上去的</li><li>实现 Callable 接口的任务线程能返回执行结果，而实现 Runnable 接口的任务线程不能返回结果</li><li>Callable 接口的 call()方法允许抛出异常，而 Runnable 接口的 run()方法的异常只能在内部消化，不能继续上抛</li><li>加入线程池运行，Runnable 使用 ExecutorService 的 execute 方法，Callable 使用 submit 方法。注：Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取返回结果，当不调用此方法时，主线程不会阻塞</li></ol><h2 id="Thread类和Runnable接口关于启动线程的源码解析"><a href="#Thread类和Runnable接口关于启动线程的源码解析" class="headerlink" title="Thread类和Runnable接口关于启动线程的源码解析"></a>Thread类和Runnable接口关于启动线程的源码解析</h2><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>Java 中实现多线程有两种「基本方式」：继承 Thread 类和实现 Runnable 接口。从实现的编程手法来看，认为这是两种实现方式并无不妥。但是究其实现根源，这么讲其实并不准确。</p><p>其实多线程从根本上讲只有一种实现方式，就是实例化 Thread，并且提供其执行的 run 方法。无论你是通过继承 Thread还是实现 Runnable接口，最终都是重写或者实现了 run 方法。而你真正启动线程都是通过实例化 Thread，调用其 start 方法。</p><p>来看下两种不同实现方式的例子：</p><h4 id="继承-Thread-方式"><a href="#继承-Thread-方式" class="headerlink" title="继承 Thread 方式"></a>继承 Thread 方式</h4><pre><code class="line-numbers language-java">public class MyThread extends Thread {      public void run() {          System.out.println("MyThread.run()");      }  }  MyThread myThread1 = new MyThread();  MyThread myThread2 = new MyThread();  myThread1.start();  myThread2.start();  </code></pre><h4 id="实现-Runnable-方式"><a href="#实现-Runnable-方式" class="headerlink" title="实现 Runnable 方式"></a>实现 Runnable 方式</h4><pre><code class="line-numbers language-java">public class MyThread extends OtherClass implements Runnable {      public void run() {           System.out.println("MyThread.run()");      }  } MyThread myThread = new MyThread();  Thread thread = new Thread(myThread);  thread.start(); </code></pre><p>第一种方式中，MyThread 继承了 Thread 类，启动时调用的 start 方法，其实还是他父类 Thread 的 start 方法。并最终触发执行 Student 重写的 run 方法。</p><p>第二种方式中，MyThread 实现 Runnable 接口，将MyThread对象作为参数传递给 Thread 构造函数。接下来还是调用了 Thread 的 start 方法。最后则会触发传入的 Runnable 实现类的 run 方法。</p><p>两种方式都是创建 Thread 或者 Thread 的子类，通过 Thread 的 start 方法启动。唯一不同是第一种 run 方法实现在 Thread 子类中。第二种则是把 run 方法逻辑转移到 Runnable 的实现类中。线程启动后，第一种方式是 thread 对象运行自己的 run 方法逻辑，第二种方式则是调用 Runnable 实现的 run 方法逻辑。</p><h3 id="Thread-start-方法源码分析"><a href="#Thread-start-方法源码分析" class="headerlink" title="Thread.start()方法源码分析"></a>Thread.start()方法源码分析</h3><ol><li>检查线程的状态，是否可以启动；</li><li>把线程加入到线程 group 中；</li><li>调用了 start0 () 方法。</li></ol><p>undefined</p><h3 id="Runnable-run-方法源码分析"><a href="#Runnable-run-方法源码分析" class="headerlink" title="Runnable.run()方法源码分析"></a>Runnable.run()方法源码分析</h3><p><img src="/attachment/2619eedb6e8cb67ddd384c7b5a0fa941.png"></p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程，进程，协程的详细解释</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-jin-cheng-xie-cheng-de-xiang-xi-jie-shi/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-jin-cheng-xie-cheng-de-xiang-xi-jie-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程，进程，协程的详细解释"><a href="#【Java-多线程并发】-线程，进程，协程的详细解释" class="headerlink" title="【Java 多线程并发】 线程，进程，协程的详细解释"></a>【Java 多线程并发】 线程，进程，协程的详细解释</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程，进程，协程的详细解释date: 2023-07-04 22:27tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 线程，进程，协程的详细解释</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/e2e87ec25f97ccbe105a39fdfd27db00.png"></p><p><strong>线程、进程、协程的区别</strong></p><ul><li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度（内核态）。</li><li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度（内核态），至少标准线程是这样的。</li><li>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度，也就是由程序自己来控制调度（用户态）。</li></ul><h2 id="什么是进程和线程"><a href="#什么是进程和线程" class="headerlink" title="什么是进程和线程"></a>什么是进程和线程</h2><p><img src="/attachment/623163233364ba657539f1140eee74c4.png"></p><h3 id="进程是什么呢？"><a href="#进程是什么呢？" class="headerlink" title="进程是什么呢？"></a>进程是什么呢？</h3><p>进程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行的程序的实例，包括程序计数器、寄存器和程序变量的当前值。进程是系统进行资源分配和调度的一个独立单位，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。</p><p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><p>进程有哪些特征？</p><ul><li>进程依赖于程序运行而存在，进程是动态的，程序是静态的；</li><li>进程是<mark style="background: #FFB8EBA6;">操作系统进行资源分配和调度的一个独立单位</mark>（CPU除外，线程是处理器任务调度和执行的基本单位）；</li><li>每个进程拥有独立的地址空间，地址空间包括代码区、数据区和堆栈区，进程之间的地址空间是隔离的，互不影响。</li></ul><h3 id="线程又是什么呢？"><a href="#线程又是什么呢？" class="headerlink" title="线程又是什么呢？"></a>线程又是什么呢？</h3><p>进程的创建、销毁与切换存在着较大的时空开销，因此人们急需一种轻型的进程技术来减少开销。在80年代，线程的概念开始出现，线程被设计成进程的一个执行路径，同一个进程中的线程共享进程的资源（共享进程的堆和方法区资源），因此系统对线程的调度所需的成本远远小于进程。</p><p>线程是进程的一个实体，<mark style="background: #FFB8EBA6;">是CPU调度和分派的基本单位</mark>，它是比进程更小的能独立运行的执行单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（每个线程有自己的程序计数器、虚拟机栈和本地方法栈、一组寄存器），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>直白地讲，线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。线程拥有自己的栈空间。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。</p><pre><code class="line-numbers language-java">public class MultiThread {    public static void main(String[] args) {        // 获取 Java 线程管理 MXBean    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();        // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);        // 遍历线程信息，仅打印线程 ID 和线程名称信息        for (ThreadInfo threadInfo : threadInfos) {            System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());        }    }}</code></pre><p> 上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><pre><code class="line-numbers language-console">[5] Attach Listener //添加事件[4] Signal Dispatcher // 分发处理给 JVM 信号的线程[3] Finalizer //调用对象 finalize 方法的线程[2] Reference Handler //清除 reference 线程[1] main //main 线程,程序入口</code></pre><p>从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p><h3 id="线程和进程之间的关系"><a href="#线程和进程之间的关系" class="headerlink" title="线程和进程之间的关系"></a>线程和进程之间的关系</h3><p>一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p><p>操作系统、进程、线程之间的关系图：</p><p><img src="/attachment/e2e87ec25f97ccbe105a39fdfd27db00.png"></p><h3 id="进程与线程的模型图："><a href="#进程与线程的模型图：" class="headerlink" title="进程与线程的模型图："></a>进程与线程的模型图：</h3><p><img src="/attachment/80dad1aac29a582c41b48a8cf834d3dd.png"></p><h3 id="下面来思考这样一个问题：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？"><a href="#下面来思考这样一个问题：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？" class="headerlink" title="下面来思考这样一个问题：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？"></a>下面来思考这样一个问题：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？</h3><p><strong>程序计数器为什么是私有的?</strong></p><p>程序计数器主要有下面两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><p><strong>虚拟机栈和本地方法栈为什么是私有的?</strong></p><ul><li><strong>虚拟机栈</strong>： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈</strong>： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中本地方法栈与Java 虚拟机栈合二为一。</li></ul><p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p><p><strong>堆和方法区为什么是共享的？</strong></p><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。为了所有线程都能够使用这些信息，所以堆和方法区是共享的。</p><p>理论过于抽象难解，下面还是用大家喜闻乐见的现实中的例子去类比，没错还是工厂的例子：</p><p><img src="/attachment/519ee40abb6a039ea95b08677301a8a5.png"></p><p>在计算机这个大工厂中，进程被比作一个车间，为生产活动提供了设计图、场地、生产线（线程）等生产要素，而线程是这个车间中的一条条生产线。生产线本身会有一个操作台，具体的零件在这里被生产。生产线必须由工人操作才能动起来，当工人来到一个生产线旁并启动它之前，必须查阅生产线的生产记录以便弄清楚这个生产线的零件加工到哪种程度了，然后才能准确地接续生产，当工人停止生产线前也必须记录这次的生产进度以备下次读取，这些进度信息可以理解为上下文，读取和记录生产进度的过程称为上下文切换。</p><p>一个工人可以在多条生产线间穿梭操作，就像CPU在不同线程间切换一样，这个动作被称为并发，与之对应的，多个工人操作多条生产线同时生产，称为并行。如果生产线不需要太多原料输入就能生产，那这种生产任务被称作CPU密集型，反之如果生产线大部分时间在等待原料的输入，那这种任务被称为IO密集型。显然，前者最好一条生产线由一个工人专管效率更高，而后一种任务，一个人在原料输入的间隙去操作其他生产线，无疑能提高工人利用率。</p><h3 id="线程共享了进程哪些资源？线程是如何共享进程资源的？"><a href="#线程共享了进程哪些资源？线程是如何共享进程资源的？" class="headerlink" title="线程共享了进程哪些资源？线程是如何共享进程资源的？"></a>线程共享了进程哪些资源？线程是如何共享进程资源的？</h3><p>线程是如何共享进程资源的？这个问题的答案其实很简单，就一句话：同一个进程内的线程共享其所属进程的地址空间，因此地址空间里有啥就共享啥。</p><p>面试官很可能继续问你能不能说具体点呢？接下来我们就来详细讲解一下这个问题。</p><h4 id="逆向思考"><a href="#逆向思考" class="headerlink" title="逆向思考"></a>逆向思考</h4><p>查理芒格经常说这样一句话：“反过来想，总是反过来想”，如果你对线程之间共享了哪些进程资源这个问题想不清楚的话那么也可以反过来思考，那就是有哪些资源是线程私有的。</p><h4 id="线程私有资源"><a href="#线程私有资源" class="headerlink" title="线程私有资源"></a>线程私有资源</h4><p>线程运行的本质其实就是函数的执行，函数的执行总会有一个源头，这个源头就是所谓的入口函数，CPU从入口函数开始执行从而形成一个执行流，只不过我们人为的给执行流起一个名字，这个名字就叫线程。</p><p>既然线程运行的本质就是函数的执行，那么函数执行都有哪些信息呢？</p><p>函数运行时的信息保存在栈帧中，栈帧中保存了函数的返回值、调用其它函数的参数、该函数使用的局部变量以及该函数使用的寄存器信息，如图所示，假设函数A调用函数B：</p><p><img src="/attachment/7d8be43819f0bc1f1a18155111789a1a.png"></p><p>此外，CPU执行指令的信息保存在一个叫做程序计数器的寄存器中，通过这个寄存器我们就知道接下来要执行哪一条指令。由于操作系统随时可以暂停线程的运行，因此我们保存以及恢复程序计数器中的值就能知道线程是从哪里暂停的以及该从哪里继续运行了。</p><p><mark style="background: #FFF3A3A6;">由于线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此每个线程都有自己独立的、私有的栈区。</mark></p><p><img src="/attachment/9d97f8000e5dcabac650d57416632b21.png"></p><p>同时函数运行时需要额外的寄存器来保存一些信息，像部分局部变量之类，这些寄存器也是线程私有的，一个线程不可能访问到另一个线程的这类寄存器信息。</p><p>从上面的讨论中我们知道，到目前为止，所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器是线程私有的。</p><p>以上这些信息有一个统一的名字，就是线程上下文（thread context）。</p><p>我们也说过操作系统调度线程需要随时中断线程的运行并且需要线程被暂停后可以继续运行，操作系统之所以能实现这一点，依靠的就是线程上下文信息。</p><p>现在你应该知道哪些是线程私有的了吧。除此之外，剩下的都是线程间共享资源。那么剩下的还有什么呢？还有图中的这些：</p><p><img src="/attachment/1bbeb1887b3c209424fce33746ae64ca.png"></p><p>这其实就是进程地址空间的样子，也就是说线程会共享进程地址空间中除线程上下文信息中的所有内容，意思就是说线程可以直接读取这些内容。</p><p>接下来我们分别来看一下这些区域（文件、堆区、代码区、数据区）。</p><h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p>进程地址空间中的代码区是线程都可以访问的区域，因为这个区域是只读的，多个线程使用是没有问题的，这里保存的是什么呢？从名字中有的同学可能已经猜到了，没错，这里保存的就是我们写的代码，更准确的是编译后的可执行机器指令。</p><p>那么这些机器指令又是从哪里来的呢？答案是从可执行文件中加载到内存的，可执行程序中的代码区就是用来初始化进程地址空间中的代码区的。</p><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>堆区是程序员比较熟悉的，我们在C/C++中用malloc或者new出来的数据就存放在这个区域，很显然，只要知道变量的地址，也就是指针，任何一个线程都可以访问指针指向的数据，因此堆区也是线程共享的属于进程的资源。</p><p><img src="/attachment/08743cff826f124c02d61923482294b6.png"></p><h3 id="线程和进程之间有什么区别"><a href="#线程和进程之间有什么区别" class="headerlink" title="线程和进程之间有什么区别"></a>线程和进程之间有什么区别</h3><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ul><li>本质区别：进程是操作系统资源分配的基本单位，而线程是CPU处理器任务调度和执行的基本单位。</li><li>包含关系：一个程序至少有一个进程，一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li>资源开销：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小，从而极大地提高了程序的运行效率。</li><li>影响关系：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。</li><li>划分尺度：线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>执行区别：线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>逻辑角度：从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li><li>如何协作：线程是通过共享内存来进行通信的。只有线程才能共享内存，进程是不可以的，因为进程所持有的资源都是独立的。</li></ul><p>有人给出了很好的归纳：</p><ul><li>线程是进程划分成的更小的运行单位。</li><li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li><li>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</li><li>无论进程还是线程，都是由操作系统所管理的。</li></ul><h3 id="线程和进程的优缺点"><a href="#线程和进程的优缺点" class="headerlink" title="线程和进程的优缺点"></a>线程和进程的优缺点</h3><p>线程和进程在使用上各有优缺点：</p><ul><li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li><li>同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</li></ul><p>注：对称多处理（Symmetrical Multi-Processing）简称SMP，是指在一个计算机上汇集了一组处理器(多CPU)，各CPU之间共享内存子系统以及总线结构。它是相对非对称多处理技术而言的、应用十分广泛的并行技术。</p><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程?"></a>为什么要使用多线程?</h3><p>先从总体上来说：</p><ul><li><p>从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p></li><li><p>从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程的并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。<br>再深入到计算机底层来探讨：</p></li><li><p>单核时代： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</p></li><li><p>多核时代: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</p></li></ul><h3 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h3><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><h3 id="什么是协程-1"><a href="#什么是协程-1" class="headerlink" title="什么是协程"></a>什么是协程</h3><p>协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><p><img src="/attachment/764416aca3c8aa7762cbe2c32c339f13.png"></p><p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p><p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p><strong>协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。</strong></p><h3 id="协程与线程的区别"><a href="#协程与线程的区别" class="headerlink" title="协程与线程的区别"></a>协程与线程的区别</h3><p>协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。 </p><p>一个程序可以包含多个协程，可以对比与一个进程包含多个线程， </p><p>因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，从当前协程切换到其他协程由当前协程来控制。 </p><p>协程和线程区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</p><h3 id="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"><a href="#协程的特点在于是一个线程执行，那和多线程比，协程有何优势？" class="headerlink" title="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"></a>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</h3><ul><li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</li><li>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul><h2 id="线程、进程、协程的区别"><a href="#线程、进程、协程的区别" class="headerlink" title="线程、进程、协程的区别"></a>线程、进程、协程的区别</h2><ul><li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度（内核态）。</li><li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度（内核态），至少标准线程是这样的。</li><li>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度，也就是由程序自己来控制调度（用户态）。</li></ul><p>一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。</p><p>协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。打个比方：</p><p>假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。在一个线程中，协程其实只能串行执行，所以无法使用多CPU来实现协程真正的并行执行，协程没有标准线程那样同时使用多CPU的能力。</p><p><img src="/attachment/525d224eff97779f96a9766c1517326b.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 ReentrantReadWriteLock</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantreadwritelock/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantreadwritelock/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-ReentrantReadWriteLock"><a href="#【Java-多线程并发】-ReentrantReadWriteLock" class="headerlink" title="【Java 多线程并发】 ReentrantReadWriteLock"></a>【Java 多线程并发】 ReentrantReadWriteLock</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 ReentrantReadWriteLockdate: 2023-07-04 22:01tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 ReentrantReadWriteLock</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ReentrantReadWriteLock采用读写锁的思想，能提高并发的吞吐量；</p><p><strong>读写锁</strong></p><ul><li>读锁和写锁的占用（重入）次数都是共用state字段，高位记录读锁，地位记录写锁，所以读锁和写锁的最大占用次数为2^16；</li><li>读锁和写锁都是可重入的；</li><li>读锁是共享锁，允许多个线程获取，互相不会影响，即读读不互斥；</li><li>写锁是排他锁（互斥锁），只允许一个线程获取；</li><li>读写、写读和写写是会互斥的，前者占有着锁，后者需要进入AQS队列中排队；</li><li>读写锁都是悲观锁，在读多写少的情况下，可能会出现写线程“饿死”的情况，即写线程一直获取不到锁。</li></ul><p><strong>原理</strong></p><ul><li>ReentrantReadWriteLock中的NonfairSync和FairSync分别实现了两种阻塞的策略，writerShouldBlock和readerShouldBlock。</li><li>一个线程获取了读锁，在非公平锁的情况下，其他等待获取读锁的线程都可以尝试获取读锁，在公平锁的情况下，按照AQS同步队列的顺利来获取，如果队列前面有一个等待写锁的线程在排队，则后面所有等待获取读锁的线程都将无法获取读锁，也就是说多个连续的读线程是一个接着一个被唤醒的，而不是一次性唤醒所有读线程；</li><li>只有多个读锁都完全释放了才会唤醒下一个写线程；</li><li>只有写锁完全释放了才会唤醒下一个等待者，这个等待者有可能是读线程，也可能是写线程；</li></ul><p><strong>锁升级和锁降级</strong></p><p>读写锁允许锁降级，不允许锁升级</p><h2 id="【Java-多线程并发】-ReentrantReadWriteLock-1"><a href="#【Java-多线程并发】-ReentrantReadWriteLock-1" class="headerlink" title="【Java 多线程并发】 ReentrantReadWriteLock"></a>【Java 多线程并发】 ReentrantReadWriteLock</h2><p>读写锁是一种特殊的锁，它把对共享资源的访问分为读访问和写访问，多个线程可以同时对共享资源进行读访问，但是同一时间只能有一个线程对共享资源进行写访问，使用读写锁可以极大地提高并发量。读锁是一个共享锁，写锁是一个互斥锁（排他锁）。</p><p>ReentrantReadWriteLock就是JUC中提供的读写锁工具类。之前我们学的ReentrantLock是一把互斥锁，而这个ReentrantReadWriteLock就可以实现共享锁（读锁）的功能。它是基于AQS提供的共享锁实现方法。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="互斥关系"><a href="#互斥关系" class="headerlink" title="互斥关系"></a>互斥关系</h3><p>读写锁具有以下特性：</p><table><thead><tr><th>是否互斥</th><th>读</th><th>写</th></tr></thead><tbody><tr><td>读</td><td>否</td><td>是</td></tr><tr><td>写</td><td>是</td><td>是</td></tr></tbody></table><p>可以看到，读写锁除了读读不互斥，其他的读写、写读、写写都是互斥的。</p><p>需要注意的是，上面都是基于不同线程对同一资源的操作来说的，因为相同的线程一定不互斥，ReentrantReadWriteLock是可重入的锁，相同的线程重复获取同一个锁是没有问题的，当然同一个线程的锁升级是不被允许的。</p><h3 id="锁升级和锁降级"><a href="#锁升级和锁降级" class="headerlink" title="锁升级和锁降级"></a>锁升级和锁降级</h3><p>锁升级和锁降级主要是对同一个线程获取锁的规则限制，如果是不同线程获取锁的互斥规则就按照上一节讲的特性来执行。</p><p>读写锁允许锁降级，不允许锁升级，比如当一个线程持有读写锁，它先去获取了一个写锁，然后该线程再去获取读锁，这属于锁降级，是允许的，还有就是这个线程先获取了一个写锁，再去获取一个写锁，或者该线程先获取了一个读锁，再获取一个读锁，这种锁是平级变化的也是允许的。但是如果该线程获取了读锁，然后该线程再去获取写锁，这属于锁升级，是不允许的。</p><p>在讲解完源码之后，我们会在文章的最后基于源码，来举几个例子说明为什么ReentrantReadWriteLock不允许锁升级，只允许锁降级。</p><h2 id="ReentrantReadWriteLock的使用案例"><a href="#ReentrantReadWriteLock的使用案例" class="headerlink" title="ReentrantReadWriteLock的使用案例"></a>ReentrantReadWriteLock的使用案例</h2><p>ReentrantReadWriteLock不同线程之间只允许读读并发，其他情况都是互斥的。</p><h3 id="关于读读并发需要注意的事项"><a href="#关于读读并发需要注意的事项" class="headerlink" title="关于读读并发需要注意的事项"></a>关于读读并发需要注意的事项</h3><p>我们先用一个案例来文字说明一下ReentrantReadWriteLock的执行流程：</p><p>比如先有一个t1线程获取到写锁，等待队列中有一些其他线程的读锁或写锁在阻塞等待。</p><p>当t1释放锁之后会按照FIFO的原则去唤醒在等待队列中等待的线程；如果第一个被唤醒的线程t2是尝试获取写锁，则无可厚非，可以让t2获取写锁，因为现在已经没有线程持有读写锁了；但不会再跟着唤醒t3，只有等t2执行完成之后才会去唤醒t3；假设被唤醒的t3是尝试获取读锁，那么t3会去判断它在等待队列中的下一个t4线程是不是要获取读锁，如果是读锁则把t4唤醒；t4唤醒之后会判断后面的t5是不是读锁；如果t5也是则唤醒t5；依次类推；但是假设判断到了t6时，发现t6是要尝试获取写锁则就不会唤醒t6了；即使后面的t7是读锁也不会唤醒t7，唤醒过程就终止在t6了，t6和t6后面的线程继续在等待队列中等待；下面这个代码说明了这个现象</p><pre><code class="line-numbers language-java">public class LockDemo {    // 创建ReentrantReadWriteLock读写锁对象    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();    // 通过读写锁对象获取读锁    static Lock r = rwl.readLock();    // 通过读写锁对象获取写锁    static Lock w = rwl.writeLock();    public static void main(String[] args) throws InterruptedException {        /**         * t1  最先拿到写（W）锁，然后睡眠了5s         * 等t1释放了锁之后才会叫醒别人         */        Thread t1 = new Thread(() -&gt; {            w.lock();            try {                log.debug("t1 +");                TimeUnit.SECONDS.sleep(5);                log.debug("5s 之后");            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                w.unlock();            }        }, "t1");        t1.start();        TimeUnit.SECONDS.sleep(1);        /**         * t1在睡眠的过程中，t2不能拿到锁读锁，因为读写互斥         * t2就会一直阻塞等待t1释放写锁         */        Thread t2 = new Thread(() -&gt; {            try {                r.lock();                log.debug("t2----+-------");                TimeUnit.SECONDS.sleep(1);            } catch (Exception e) {                e.printStackTrace();            } finally {                log.debug("t2-----jian-------");                r.unlock();            }        }, "t2");        t2.start();        TimeUnit.SECONDS.sleep(1);         /**         * t1在睡眠的过程中，t3也不能拿到读锁，因为读写互斥         * t3也一直阻塞等待         *         * 当t1释放写锁之后，t3和t2能同时拿到读锁，因为读读并发         */        Thread t3 = new Thread(() -&gt; {            try {                r.lock();                log.debug("t3----+-------");                TimeUnit.SECONDS.sleep(1);            } catch (Exception e) {                e.printStackTrace();            } finally {                log.debug("t3----释放-------");                r.unlock();            }        }, "t3");        t3.start();         /**         * t4尝试获取写锁         * t1睡眠的时候，t4也阻塞，在同步队列中的顺序应该 t2 t3  t4         * 当t1将写锁释放之后，就会开始唤醒同步队列的锁，唤醒t2后因为t2是读锁，所以继续向后判断t3，         * 发现t3也是读锁就也将t3唤醒，然后再去判断t4，发现t4是要获取写锁，则不再唤醒t4，也不再向后判断了，唤醒操作中止在t4线程         */        Thread t4 = new Thread(() -&gt; {            try {                w.lock();                log.debug("t4--------+---");                TimeUnit.SECONDS.sleep(10);                log.debug("t4--------醒来---");            } catch (Exception e) {                e.printStackTrace();            } finally {                log.debug("t4--------jian---");                w.unlock();            }        }, "t4");        t4.start();         /**         * t5 是读锁         * 因为唤醒操作中止在t4了，t5也不会被唤醒，继续在等待队列中等待         */        Thread t5 = new Thread(() -&gt; {             try {                r.lock();                log.debug("t5--------+---");            } catch (Exception e) {                e.printStackTrace();            } finally {                log.debug("t5--------jian---");                r.unlock();            }        }, "t5");        t5.start();    }}</code></pre><p>在了解了ReentrantReadWriteLock使用案例后，我们再来看是如何实现读写锁的。</p><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><img src="/attachment/cb5ba58e64389c5f5e32399df1977dd6.png"></p><p>ReentrantReadWriteLock中的类分成三个部分：</p><ol><li>ReentrantReadWriteLock本身实现了ReadWriteLock接口，这个接口只提供了两个方法readLock()和writeLock()；</li><li>同步器，包含一个继承了AQS的Sync内部类，以及其两个子类FairSync和NonfairSync；</li><li>ReadLock和WriteLock两个内部类实现了Lock接口，它们具有锁的一些特性。</li></ol><h2 id="读写锁的数据结构"><a href="#读写锁的数据结构" class="headerlink" title="读写锁的数据结构"></a>读写锁的数据结构</h2><p><img src="/attachment/8fe9ffd62d7b97d47c0700abb69d8906.png"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h3><p>在我们详细分析ReentrantReadWriteLock源码之前，需要先了解一下该类的读写锁设计，因为这里和以前其他的锁不太一样，需要单独拿出来讲一下。</p><p>ReentrantReadWriteLock仍然是基于AQS，也是依旧使用AQS的state字段来表示读写锁被持有的次数（同步状态），高16位用来标记读锁的同步状态，低16位用来标记写锁的同步状态。</p><pre><code class="line-numbers language-java">// ReentrantReadWriteLock.Syncabstract static class Sync extends AbstractQueuedSynchronizer {    // 划分的边界线，用16位来划分    static final int SHARED_SHIFT   = 16;    // 读锁的基本单位，也就是读锁加1或者减1的基本单位（1左移16位后的值）    static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);    // 读锁的最大值（在计算读锁的时候需要先右移16位）    static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;    // 写锁的掩码，state值与掩码做与运算后得到写锁的真实值    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;     // 获取读锁被占用的次数    static int sharedCount(int c){        return c &gt;&gt;&gt; SHARED_SHIFT;    }     // 获取写锁被占用的次数    static int exclusiveCount(int c){        return c &amp; EXCLUSIVE_MASK;    }}</code></pre><p>结构如下图所示：</p><p><img src="/attachment/adfe93bebcf38e63bfcbfaf6d42d5c83.png"></p><p>举个例子，比如state当前为</p><p>0010 1011 0001 1010 1110 1000 1011 0101</p><p>这个二进制数的前16位就标识读锁的同步状态，后16位就是写锁的同步状态</p><h4 id="使用sharedCount-计算读锁被占用的次数"><a href="#使用sharedCount-计算读锁被占用的次数" class="headerlink" title="使用sharedCount()计算读锁被占用的次数"></a>使用sharedCount()计算读锁被占用的次数</h4><p>将state向右无符号移动16位，这个操作就会将后16位移除，然后前16位就移动到了后16位的位置上，并用0来补齐，结果如下：</p><p><mark style="background: #FFF3A3A6;">0010 1011 0001 1010</mark> 1110 1000 1011 0101</p><p>无符号位右移16位</p><p>0000 0000 0000 <mark style="background: #FFF3A3A6;">0000 0010 1011 0001 1010</mark></p><h4 id="使用exclusiveCount-计算写锁被占用的次数"><a href="#使用exclusiveCount-计算写锁被占用的次数" class="headerlink" title="使用exclusiveCount()计算写锁被占用的次数"></a>使用exclusiveCount()计算写锁被占用的次数</h4><p>将state和写锁掩码按位取与，这样就能将前16位全部变为0，只保留后16位的数，计算过程如下：</p><p>SHARED_SHIFT = 16</p><p>将1左移16位，低位用0补齐</p><p>SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT) = 1 &lt;&lt; 16 = 0000 0000 0000 0001 0000 0000 0000 0000</p><p>将SHARED_UNIT减1得出写锁掩码</p><p>EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1 = 0000 0000 0000 0001 0000 0000 0000 0000 - 1 = 0000 0000 0000 0000 1111 1111 1111 1111</p><p>将state和写锁掩码按位取与</p><p>0010 1011 0001 1010 <mark style="background: #FFF3A3A6;">1110 1000 1011 0101</mark></p><p>0000 0000 0000 0000 1111 1111 1111 1111</p><p>结果得</p><p>0000 0000 0000 0000 <mark style="background: #FFF3A3A6;">1110 1000 1011 0101</mark></p><h4 id="记录每个线程持有读锁的重入次数"><a href="#记录每个线程持有读锁的重入次数" class="headerlink" title="记录每个线程持有读锁的重入次数"></a>记录每个线程持有读锁的重入次数</h4><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>在统计读锁被每个线程持有重入的次数时，ReentrantReadWriteLock采用的是HoldCounter来实现的，具体如下：</p><pre><code class="line-numbers language-java">// ReentrantReadWriteLock.Syncabstract static class Sync extends AbstractQueuedSynchronizer {    // 持有读锁的线程重入的次数。这个类的对象就是要存储到TreadLocal中的value    // 初始化HoldCounter时，count默认设置为0，这个在后面的源码中是有用处的    static final class HoldCounter {        // 重入的次数        int count = 0;        // 持有读锁线程的线程id        final long tid = getThreadId(Thread.currentThread());    }      /**     * 采用ThreadLocal机制，做到线程之间的隔离     * 每个线程都持有自己独有的ThreadLock，用来存储自己持有读锁的重入次数     *      * 这个ThreadLocalHoldCounter就是存储在ThreadLocalMap中ThreadLocal的key,ThreadLocal的value就是HoldCounter     * 可以理解为每一个线程都持有一个自己的ThreadLocalHoldCounter，里面存储着自己持有读锁的重入次数     */    static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; {        // 重写ThreadLocal的初始化方法，这样在第一次调用ThreadLocal的get()方法是就可以自动将其初始化        public HoldCounter initialValue() {                       // 初始化一个HoldCounter对象，并存入ThreadLocal中            return new HoldCounter();        }    }     /**     * 线程持有可重入读锁的次数，这里就是记录下当前线程的ThreadLocalHoldCounter     * readHolds就可以理解为绑定在当前线程上的ThreadLocal     */    private transient ThreadLocalHoldCounter readHolds;     /**     * 缓存最后一个成功获取读锁的线程的重入次数，这样做的好处：     *    避免了通过访问ThreadLocal来获取读锁的信息，相对于直接从本地缓存中获取，从ThreadLocal中获取数据效率更低。     *    这个优化的前提是假设多数情况下，一个获取读锁的线程，使用完以后就会释放读锁，也就是说最后获取读锁的线程和最先释放读锁的线程大多数情况下是同一个线程，获取了读锁用完之后马上就释放。     *    这样就能保证一个线程获取了读锁，后续如果再重入获取读锁，就不需要去从ThreadLocal中获取持有次数了，直接就能从本地缓存cachedHoldCounter中获取     *    而且用完了锁之后就会马上释放，这样在执行释放锁方法的时候，当前要释放读锁的线程仍然是最后一个获取读锁的线程，所以修改持有次数就可以直接操作cachedHoldCounter变量而不用使用ThreadLocal了，提高了执行效率     *      */    private transient HoldCounter cachedHoldCounter;     /**     * 第一个获取读锁的线程，这里直接用的是Thread线程对象记录。单独记录第一个获取读锁线程的作用：     * 1、记录将共享数量从0变成1的线程     * 2、对于无竞争的读锁来说进行线程重入次数数据的追踪的成本是比较低的，省去了去ThreadLocal中查找而性能高效     * 3、在一定程度上确实可以减少ThreadLocal的使用，降低一些内存消耗     * 4、获取当前线程的读锁重入次数时，若是当前线程时第一个获取读锁的线程则可以免去ThreadLocal中查找，也能提高一点性能     *      * 虽然看起来性能提高不是很多的，但是JUC正是在这一点点的代码优化中将性能提高到极致的，能优化一点是一点     */    private transient Thread firstReader = null;     /**     * 第一个获取读锁线程的重入次数，直接用int来记录重入次数     */    private transient int firstReaderHoldCount;     Sync() {        // 在构造函数中就初始化创建了一个ThreadLocalHoldCounter对象        readHolds = new ThreadLocalHoldCounter();        setState(getState()); // ensures visibility of readHolds    }}</code></pre><p>通过源码我们就可以看出，记录每个线程持有读锁的重入次数，主要应用到三个数据结构</p><ol><li><strong>ThreadLocalHoldCounter readHolds</strong>：这个对象就是绑定在每个线程上的ThreadLocal，也就是说readHolds在每个线程上都存有一份，并且在线程间独立，由绑定的线程独享。存在该ThreadLocal中的value就是HoldCounter类对象，通过HoldCounter对象来记录当前线程持有读锁的重入次数。</li><li><strong>HoldCounter cachedHoldCounter</strong>：<mark style="background: #BBFABBA6;">记录最后一个成功获取读锁的线程及其获取读锁的重入次数</mark>，需要注意的是最后一个成功获取读锁是指在所有成功获取到过该读锁的线程当中，不管线程是否已经中止，只要是在时间上最后一个获取读锁的线程，就会被记录在cachedHoldCounter中。比如此时有t1、t2、t3依次成功获取读锁，当前cachedHoldCounter指向的是t3，然后t3将读锁全部释放了，后面t2不再尝试获取读锁，那么此时cachedHoldCounter中记录的ThreadId就还是t3的，而不会修改为指向t2，因为在时间上t2获取锁的时间就是比当时t3晚，但是如果t2再次尝试获取读锁，那么cachedHoldCounter就会更新指向t2，因为t2成了在时间上最后一次成功获取锁的线程。</li><li><strong>Thread firstReader 和 int firstReaderHoldCount</strong>：<mark style="background: #BBFABBA6;">分别用来记录第一个成功获取读锁的线程和该线程持有读锁的重入次数。</mark>这里的第一个成功获取读锁是指当一个线程成功持有读锁后，该读锁总的被线程持有的次数从0变为1，那么这个线程就被记录位该读锁的firstReader。比如此时有t1、t2、t3依次成功获取读锁，t1是被记录为firstReader，然后t1将读锁释放了，firstReader就会被设置为null，而不会更新指向为t2，因为t2获取读锁的时候，该读锁总的被线程持有数并不是从0变为1的，所以就不算是firstReader。只有当t2和t3将自己的读锁全部释放，然后再来一个t4成功获取读锁，这个t4才会被认为是firstReader，因为t4持有读锁时该读锁总的被线程持有的次数从0变为1。</li></ol><p>第一个获取读锁的线程的重入次数信息会被记录在firstReader和firstReaderHoldCount中，并不会使用这个线程的ThreadLocal来记录重入次数信息。但是最后一个获取读锁的线程的重入次数信息仍然会存储在该线程的ThreadLocal中，并且会单独拿出一个本地缓存变量cachedHoldCounter来只想存储在ThreadLocal中的重入次数计数器，这样就可以直接通过本地缓存变量来获得HoldCounter，不需要通过ThreadLocal来查询获取了，提高了效率。</p><p>至于在使用过程中，这三个数据结构的具体变化和使用流程，我们在后面讲解获取释放读锁源码的时候会举例讲解，这里我们来讲解一下为什么使用三个数据结构来分别记录不同线程锁持有读锁的重入次数，这样设计到底有什么作用和好处。</p><h5 id="为什么这样设计"><a href="#为什么这样设计" class="headerlink" title="为什么这样设计"></a>为什么这样设计</h5><p>其实最开始读写锁只是使用了ThreadLocalHoldCounter来记录每个线程持有读锁的重入次数，因为这个方法是最简单方便的，直接将每个线程持有读锁的重入次数存入到该线程独享的ThreadLocal中，非常方便存取。但是在后续的时候过程当中，他们就逐渐发现了问题：</p><ol><li>当读锁的数量很大，持有读锁的线程数量很多的时候，就会导致需要使用大量的ThreadLocal来存储线程锁持有读锁的重入次数，比方说m是锁的个数，n是每个锁持有的线程数，每个线程有一个内部有一个ThreadLocal来记录锁重入，这样就会有m*n个内存占用，这就造成了内存占用率过高。而且在jdk1.6的时候，ReentrantReadWriteLock还有一个小bug就是在ThreadLocal使用完之后没有调用remove()，这样就会造成ThreadLocal内存泄露的问题，更增加了内存占用率。</li><li>当大量使用ThreadLocal的时候，效率就会变慢，因为相对于直接从本地缓存对象中取出数据，从ThreadLocal中查找获取数据性能开销更大，如果能尽量避免使用ThreadLocal有助于提高性能。<br>基于以上两点原因，所以在后续的版本中就添加了cachedHoldCounter、firstReader、firstReader。并且也修复了使用完ThreadLocal后不调用remove()的bug。</li></ol><h5 id="添加cachedHoldCounter的原因："><a href="#添加cachedHoldCounter的原因：" class="headerlink" title="添加cachedHoldCounter的原因："></a>添加cachedHoldCounter的原因：</h5><p>在一些情况下，线程在拿到读锁使用完之后会马上释放锁，这就可能释放锁的线程就是最后一个获取到读锁的线程，这样我们单独创建一个对象来存储最后一个拿到读锁的线程的重入次数信息，每次释放锁的时候就可以直接从本地缓存对象中获取数据，不需要通过线程的ThreadLocal了，提高了效率。而且在最后一个获取读锁的线程马上又重入读锁时，也可以直接操作cachedHoldCounter，避免使用ThreadLocal，并且也能保证cachedHoldCounter和ThreadLocal数据是同步变化的，因为cachedHoldCounter指向的重入次数计数器和最后一个获取到读锁线程的ThreadLocal存储的重入次数计数器实际上是同一个对象。</p><h5 id="添加firstReader-和-firstReaderHoldCount的原因："><a href="#添加firstReader-和-firstReaderHoldCount的原因：" class="headerlink" title="添加firstReader 和  firstReaderHoldCount的原因："></a>添加firstReader 和  firstReaderHoldCount的原因：</h5><ol><li>如果第一次获取读锁的线程来执行获取锁和释放锁，就可以直接使用firstReader和firstReaderHoldCount来修改线程的重入次数信息。在一定程度上确实减少ThreadLocal的使用，免去了去ThreadLocal中查找，能提高一些性能。并且也可以降低一些内存的使用，假设一个线程需要获取50000个不同的读锁，就可以减少50000个ThreadLocal的内存使用。</li><li>对于无竞争时，只有一个线程获取读锁的计数省去了去ThreadLocal中查找而性能高效。但是一般情况都是有竞争的，所以实际收效甚微。</li></ol><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>ReentrantReadWriteLock 一共有5个内部类，具体如下：</p><ul><li>Sync：公平锁和非公平锁的抽象类</li><li>NonfairSync：非公平锁的具体实现</li><li>FairSync：公平锁的具体实现</li><li>ReadLock：读锁的具体实现</li><li>WriteLock：写锁的具体实现</li></ul><h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><pre><code class="line-numbers language-java">// 读锁private final ReentrantReadWriteLock.ReadLock readerLock;// 写锁private final ReentrantReadWriteLock.WriteLock writerLock;// 同步器final Sync sync;</code></pre><p>维护了读锁、写锁和同步器。</p><p>属性中的读锁和写锁是私有属性，需要通过这两个方法来获取读锁和写锁：</p><pre><code class="line-numbers language-java">public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; } public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }</code></pre><h3 id="主要构造方法"><a href="#主要构造方法" class="headerlink" title="主要构造方法"></a>主要构造方法</h3><pre><code class="line-numbers language-java">// 默认构造方法public ReentrantReadWriteLock() {    this(false);}// 是否使用公平锁的构造方法public ReentrantReadWriteLock(boolean fair) {    // 设置同步器实现公平锁还是非公平锁    sync = fair ? new FairSync() : new NonfairSync();    // 初始化读锁和线索对象    readerLock = new ReadLock(this);    writerLock = new WriteLock(this);}</code></pre><p>它提供了两个构造方法，默认构造方法使用的是非公平锁模式，在构造方法中初始化了读锁和写锁。</p><p>我们从读锁ReadLock和写锁WriteLock的源码开始分析，然后顺着这个思路将整个ReentrantReadWriteLock中所有的核心源码（所有的包括内部类）进行分析。</p><h3 id="ReadLock类源码解析"><a href="#ReadLock类源码解析" class="headerlink" title="ReadLock类源码解析"></a>ReadLock类源码解析</h3><pre><code class="line-numbers language-java">// ReentrantReadWriteLock.ReadLockpublic static class ReadLock implements Lock, java.io.Serializable {    // 同步器    private final Sync sync;    /**     * 通过ReentrantReadWriteLock中的公平锁或非公平锁来初始化sync变量     */    protected ReadLock(ReentrantReadWriteLock lock) {          sync = lock.sync;    }    /**     * 阻塞的方式获取锁，因为读锁是共享锁，所以调用acquireShared方法     */    public void lock() {          sync.acquireShared(1);    }    /**     * 可中断且阻塞的方式获取锁     */    public void lockInterruptibly() throws InterruptedException {          sync.acquireSharedInterruptibly(1);    }    /**     * 超时尝试获取锁，非阻塞的方式     */    public boolean tryLock(long timeout, TimeUnit unit)          throws InterruptedException {          return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));    }    /**     * 尝试获取读锁，非阻塞的方式     */    public boolean tryLock() {          return sync.tryReadLock();    }    /**     * 释放锁     */    public void unlock() {          sync.releaseShared(1);    }}</code></pre><h4 id="读锁共享锁"><a href="#读锁共享锁" class="headerlink" title="读锁共享锁"></a>读锁共享锁</h4><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><pre><code class="line-numbers language-java">// ReentrantReadWriteLock.ReadLock.lock()public void lock() {    // 获取读锁（共享锁）    sync.acquireShared(1);} // AbstractQueuedSynchronizer.acquireShared()// AQS中提供了获取共享锁的模板方法，供用户调用public final void acquireShared(int arg) {    // 该方法是在ReentrantReadWriteLock的内部类Sync中实现的    // 尝试获取共享锁（返回1表示成功，返回-1表示失败）    if (tryAcquireShared(arg) &lt; 0)        // 获取读锁失败了就可能要排队        doAcquireShared(arg);} // ReentrantReadWriteLock.Sync.tryAcquireShared()protected final int tryAcquireShared(int unused) {    // 获取当前线程    Thread current = Thread.currentThread();    // 状态变量的值    // 在读写锁模式下，高16位存储的是共享锁（读锁）被获取的次数，低16位存储的是互斥锁（写锁）被获取的次数    int c = getState();    /**     * 条件1：获取互斥锁（读锁）的被持有的次数，判断是否不等于0     * 条件2：判断当前线程是否持有互斥锁（写锁）     *      * 如果条件1和条件2同时成立，表明其它线程获得了写锁，因为读写和写读互斥，直接返回-1，该线程获取读锁失败     */    if (exclusiveCount(c) != 0 &amp;&amp;        getExclusiveOwnerThread() != current)        return -1;    // 读锁被获取的次数    int r = sharedCount(c);        // 执行到这里说明此时还没有线程获取写锁，尝试去更新state的值获取读锁    /**     * 条件1：读者是否需要排队（是否是公平模式），readerShouldBlock()返回true说明需要排队     * 条件2：读锁被持有次数是否小于上限     * 条件3：尝试CAS更新读锁state值是否成功     *      * 如果三个条件均成立，则说明当前线程尝试获取读锁成功，就可以执行后续的修改当前线程持有读锁重入次数的操作了     */    if (!readerShouldBlock() &amp;&amp;        r &lt; MAX_COUNT &amp;&amp;        compareAndSetState(c, c + SHARED_UNIT)) {        // 获取读锁成功        // 判断之前是否有线程持有该读锁        if (r == 0) {            // 如果之前还没有线程获取读锁，记录第一个读者为当前线程，直接使用firstReader和firstReaderHoldCount进行记录，不适用ThreadLocal            firstReader = current;            // 第一个读者重入的次数为1            firstReaderHoldCount = 1;        // 如果有线程获取了读锁且是当前线程就是第一个读者        } else if (firstReader == current) {            // 则把其重入次数加1            firstReaderHoldCount++;        } else {            // 如果执行到了这里，说明有线程获取了读锁且当前线程不是第一个读者            // 这种情况我们先从本地缓存中获取最后一个获取该读锁线程的重入次数保存器            HoldCounter rh = cachedHoldCounter;                      /**             * 条件1：本地缓存cachedHoldCounter是否存有数据             * 条件2：当前线程是否为记录在cachedHoldCounter中最后一次获取该读锁的线程             *              * 条件1和条件2只要有任意一个成立，就说明此时cachedHoldCounter还未记录数据或者当前线程并不是最后一个获取读锁的线程             * 则进入到该if分支中去从readHolds中获取当前线程的重入次数保存器，并且更新cachedHoldCounter的记录，因为当前线程已经成了最新的（也就是最后一次）获取读锁的线程了             * readHolds本身是一个ThreadLocal，它和当前线程绑定在一起，里面存储的是HoldCounter             */            if (rh == null || rh.tid != getThreadId(current))                /**                 * 如果当前线程的readHolds是第一次调用get()，就会给该线程创建一个ThreadLocalMap，然后初始化一个ThreadLocalHoldCounter存入该线程的ThreadLocalMap中，并将这个ThreadLocalHoldCounter返回                 * 如果不是第一调用get()，就会直接将与该线程绑定的ThreadLocalHoldCounter返回                 *                  * 这里就将rh引用指向该线程的ThreadLocalHoldCounter，同时更新cachedHoldCounter指向该线程的cachedHoldCounter，也就是说最后一个获取读锁的线程的重入保存器会存储在本地缓存cachedHoldCounter变量中一份，还会存储在该线程的ThreadLocalHoldCounter一份，一共存量份。这九个firstReader有所不同，firstReader的重入信息只会存储在本地缓存变量中，不会存储在ThreadLocal中                 * 这里需要注意一下rh是一个引用地址，这个引用指向当前线程的ThreadLocalHoldCounter对象，也就是说修改rh，就相当于将该线程的ThreadLocalHoldCounter对象也修改了                 */                cachedHoldCounter = rh = readHolds.get();            // 如果没有进入上面的if分支，说明当前线程就是存储在cachedHoldCounter中的线程，也就是最后一个成功获取到该读锁的线程                // 判断该线程重入该读锁的次数是否为0            else if (rh.count == 0)                // 如果rh的次数为0，把它放到ThreadLocal中去                /**                 * 如果进入到这个分支，说明当前cachedHoldCounter中存储的线程id就是当前线程                 * 但是这个线程已经将之前自己持有的该读锁全部释放了，我们知道在最后一个成功获取到该读锁的线程完全释放掉持有的读锁后，                 * cachedHoldCounter并不会跟着清空，只是会其中存储的该线程的读锁冲入次数清零，但是记录的线程id还是以前的线程                 * 只有当以后又来了另一个线程成功获取到读锁，才会更新cachedHoldCounter中的数据，存储新线程的重入次数                 *                  * 这样的机制下就会出现这样一种情况，就是原有的最后一次获取读锁的线程t将锁全部释放以后，没有其他线程再来获取读锁                 * 因为t已经将所有的锁释放了，所以在执行释放锁操作之后，就会调用remove()方法，将该线程的ThreadLocalHoldCounter从该线程的ThreadLocalMap中删除，注意，并没有删除ThreadLocalMap                 * 然后t又一次获取了读锁，这个时候正好cachedHoldCounter记录的线程id还是t线程的，但是重入次数count已经是0了，所以就会进入到这个分支中                 *                  * 因为此时当前线程的ThreadLocalMap中已经没有了ThreadLocalHoldCounter，所以重新向readHold中set进去HoldCounter对象来创建ThreadLocalHoldCounter                 * 这里就不能通过get()来初始化创建ThreadLocalHoldCounter了，具体原因可以见讲解ThreadLocal源码的文章                 */                readHolds.set(rh);            // 重入的次数加1。这里需要注意，rh是指向一个HoldCounter对象的引用，对rh的修改操作，其实就是修改了指向的那个HoldCounter对象            // 也就是说修改了rh，也就同步修改了cachedHoldCounter和readHolds中的HoldCounter对象的数据            rh.count++;        }        // 获取读锁成功，返回1        return 1;    }    // 如果CAS失败，则通过这个方法再去尝试获取读锁（如果此时其它线程仍在持有写锁，一样返回-1表示失败，因为写读，读写互斥）    return fullTryAcquireShared(current);} // ReentrantReadWriteLock.Sync.exclusiveCount()abstract static class Sync extends AbstractQueuedSynchronizer {    // 划分的边界线，用16位来划分    static final int SHARED_SHIFT   = 16;    // 写锁的掩码，state值与掩码做与运算后得到写锁的真实值    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;      // 获取写锁被占用的次数    static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }        // 获取读锁被占用的次数    static int sharedCount(int c) { return c &gt;&gt;&gt; SHARED_SHIFT; }} // ReentrantReadWriteLock.Sync.fullTryAcquireShared()final int fullTryAcquireShared(Thread current) {    /**     * 调用该方法的线程都是希望获取读锁的线程，有3种情况：     * 1、在尝试通过CAS操作修改state时由于有多个竞争读锁的线程导致CAS操作失败     * 2、需要排队等待获取读锁的线程（公平锁）     * 3、超过读锁限制的最大申请次数的线程     */    HoldCounter rh = null;    // 自旋尝试获取锁    for (;;) {         // 获取读写锁的状态变量        int c = getState();        // 判断当前写锁被持有的次数是否为0，如果不为0说明已经有线程持有写锁了，直接返回-1，因为写读，读写互斥        if (exclusiveCount(c) != 0) {            if (getExclusiveOwnerThread() != current)                return -1;        // 当前线程是否需要被阻塞（公平锁）        } else if (readerShouldBlock()) {            // 判断当前线程是不是第一个持有读锁的线程            if (firstReader == current) {                // assert firstReaderHoldCount &gt; 0;            // 当前线程不是第一个持有读锁的线程                } else {                // 判断rh是否为null，进而判断是不是刚刚进行第一轮循环                if (rh == null) {                    // 获取最后一个获取读锁的线程数据                    rh = cachedHoldCounter;                    // 判断该线程是不是最后一个获取读锁的线程                    if (rh == null || rh.tid != getThreadId(current)) {                        // 如果不是，则通过ThreadLocal获取该线程的重入次数保存器                        rh = readHolds.get();                        // 如果当前线程对该读锁的重入次数为0，则调用ThreadLocal的remove方法，将该ThreadLocal移除，避免ThreadLocal出现内存泄漏                        // 只有从ThreadLocal中获取重入次数保存器时才需要remove，如果是cachedHoldCounter中的，就不会进到这个if分支中，不需要去做额外的删除，因为不会有内存泄漏的问题                        if (rh.count == 0)                            readHolds.remove();                    }                }                // 当前线程获取锁失败                if (rh.count == 0)                    return -1;            }        }        // 判断是否超过读锁的最大值        if (sharedCount(c) == MAX_COUNT)            throw new Error("Maximum lock count exceeded");        // 尝试CAS修改读锁的state值        if (compareAndSetState(c, c + SHARED_UNIT)) {            // 最新获取到读锁的线程设置相关的信息，这里就和tryAcquireShared中修改线程的重入次数信息基本一样了            if (sharedCount(c) == 0) {                firstReader = current;                firstReaderHoldCount = 1;            } else if (firstReader == current) {                // 当前线程重复获取锁（重入）                firstReaderHoldCount++;             } else {                // 在readHolds中记录获取锁的线程的信息                if (rh == null)                    rh = cachedHoldCounter;                if (rh == null || rh.tid != getThreadId(current))                    rh = readHolds.get();                // 最后一下获取锁的线程将读锁全部释放之后，再次获取读锁就会进入到这个分支                    else if (rh.count == 0)                    // 重新将重入保存期添加到readHolds（ThreadLocal）中                    readHolds.set(rh);                rh.count++;                // 更新最后一次成功获取到锁的线程                cachedHoldCounter = rh; // cache for release            }            // 进入到这个if分支就是成功获取到读锁了，返回1            return 1;        }    }} // AbstractQueuedSynchronizer.doAcquireShared()// 详细讲解可以见AQS源码文章，这个方法相当于互斥锁的acquireQueued()方法private void doAcquireShared(int arg) {    // 将线程添加到AQS同步等待队列中    final Node node = addWaiter(Node.SHARED);    // 阻塞线程是否失败    boolean failed = true;    try {        // 中断标记，是否要将当前线程中断        boolean interrupted = false;        // 自旋不断尝试获取锁        for (;;) {            // 获取当前节点的前一个节点            final Node p = node.predecessor();            // 如果前一个节点是头节点（说明是第一个排队的节点）            if (p == head) {                // 再次尝试获取读锁                int r = tryAcquireShared(arg);                // 如果成功了                if (r &gt;= 0) {                    // 头节点后移并传播                    // 传播即唤醒后面连续的读节点，这也是我们在本章节最开始举的例子，当一个在等待队列中等待获取读锁的线程被唤醒并成功获取读锁后，就会开始将它后面连续的也是在等待申请读锁的线程一并唤醒                    // 注意这里必须得是连续的，如果中间出现了一个等待申请写锁的线程，则唤醒操作到此为止                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    // 判断该线程是否被中断                    if (interrupted)                        selfInterrupt();                    // 将阻塞标志设置为false，说明没有阻塞节点线程                    failed = false;                    return;                }            }            // 如果没获取到读锁，判断是否可以将node节点阻塞，如果可以则将其阻塞，等待被唤醒            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  // 判断node节点能否被唤醒                parkAndCheckInterrupt()) // 真正对node节点进行阻塞的方法，阻塞之后这个线程就会停在这个方法内                // 如果parkAndCheckInterrupt()执行了阻塞并且返回当前线程的中断信号是true，则将这个方法中设置的中断信号变量设置为true，用来向上一层返回当前线程的中断标志                interrupted = true;        }    } finally {        // 如果阻塞线程失败了        if (failed)            // 取消获取锁            cancelAcquire(node);    }} // AbstractQueuedSynchronizer.setHeadAndPropagate()// 将等待队列头节点后移，并向后传播唤醒连续的申请读锁的等待线程private void setHeadAndPropagate(Node node, int propagate) {    // h为旧的头节点    Node h = head;    // 设置当前节点为新头节点    setHead(node);        // 如果旧的头节点或新的头节点为空或者其等待状态小于0（表示状态为SIGNAL/PROPAGATE）    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) {        // 需要传播        // 取下一个节点        Node s = node.next;        // 如果下一个节点为空，或者是需要获取读锁的节点        if (s == null || s.isShared())            // 唤醒下一个节点            doReleaseShared();    }} // AbstractQueuedSynchronizer.doReleaseShared()// 这个方法只会唤醒一个节点private void doReleaseShared() {    for (;;) {        Node h = head;        if (h != null &amp;&amp; h != tail) {            int ws = h.waitStatus;            // 如果头节点状态为SIGNAL，说明要唤醒下一个节点            if (ws == Node.SIGNAL) {                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;            // loop to recheck cases                // 唤醒下一个节点                unparkSuccessor(h);            }            else if (ws == 0 &amp;&amp;                     // 把头节点的状态改为PROPAGATE成功才会跳到下面的if                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                // loop on failed CAS        }        // 如果唤醒后head没变，则跳出循环        if (h == head)                   // loop if head changed            break;    }}</code></pre><p>这里面很多方法流程和ReentrantLock类似，如果有基础的话看这些源码会比较容易。</p><h5 id="大致的逻辑："><a href="#大致的逻辑：" class="headerlink" title="大致的逻辑："></a>大致的逻辑：</h5><ol><li>先尝试获取读锁；</li><li>如果成功了直接结束；</li><li>如果失败了，进入doAcquireShared()方法；</li><li>doAcquireShared()方法中首先会生成一个新节点并进入AQS队列中；</li><li>如果头节点正好是当前节点的上一个节点，再次尝试获取锁；</li><li>如果成功了，则设置头节点为新节点，并传播；</li><li>传播即唤醒下一个读节点（如果下一个节点是读节点的话）；</li><li>如果头节点不是当前节点的上一个节点或者（5）失败，则阻塞当前线程等待被唤醒；</li><li>唤醒之后继续走（5）的逻辑；</li></ol><h5 id="在整个逻辑中是在哪里连续唤醒读节点的呢？"><a href="#在整个逻辑中是在哪里连续唤醒读节点的呢？" class="headerlink" title="在整个逻辑中是在哪里连续唤醒读节点的呢？"></a>在整个逻辑中是在哪里连续唤醒读节点的呢？</h5><p>答案是在doAcquireShared()方法中，在这里一个节点A获取了读锁后，会唤醒下一个读节点B，这时候B也会获取读锁，然后B继续唤醒C，依次往复，也就是说这里的节点是一个唤醒一个这样的形式，必须得是在队列中连续的读节点才会被唤醒，而不是一个节点获取了读锁后一次性唤醒后面所有的读节点。</p><p>下面再讲一下非阻塞获取读锁的操作，相对就要简单很多了：</p><h5 id="在整个逻辑中是在哪里连续唤醒读节点的呢？-1"><a href="#在整个逻辑中是在哪里连续唤醒读节点的呢？-1" class="headerlink" title="在整个逻辑中是在哪里连续唤醒读节点的呢？"></a>在整个逻辑中是在哪里连续唤醒读节点的呢？</h5><p>答案是在doAcquireShared()方法中，在这里一个节点A获取了读锁后，会唤醒下一个读节点B，这时候B也会获取读锁，然后B继续唤醒C，依次往复，也就是说这里的节点是一个唤醒一个这样的形式，必须得是在队列中连续的读节点才会被唤醒，而不是一个节点获取了读锁后一次性唤醒后面所有的读节点。</p><h5 id="非阻塞获取读锁"><a href="#非阻塞获取读锁" class="headerlink" title="非阻塞获取读锁"></a>非阻塞获取读锁</h5><p>下面再讲一下非阻塞获取读锁的操作，相对就要简单很多了：</p><pre><code class="line-numbers language-java">// ReentrantReadWriteLock.ReadLock.tryLock()// 非阻塞的尝试获取读锁public boolean tryLock() {    return sync.tryReadLock();} // ReentrantReadWriteLock.Sync.tryReadLock()// 非阻塞尝试获取读锁final boolean tryReadLock() {    // 获取当前线程    Thread current = Thread.currentThread();    // 自旋尝试获取读锁    for (;;) {         // 获取读写锁状态变量的值        int c = getState();        /**         * 条件1：获取互斥锁（读锁）的被持有的次数，判断是否不等于0         * 条件2：判断当前线程是否持有互斥锁（写锁）         *          * 如果条件1和条件2同时成立，表明其它线程获得了写锁，因为读写和写读互斥，直接返回-1，该线程获取读锁失败         */        if (exclusiveCount(c) != 0 &amp;&amp;            getExclusiveOwnerThread() != current)            return false;        // 读锁被获取的次数            int r = sharedCount(c);        // 读锁的总重入次数是否超过最大次数限制        if (r == MAX_COUNT)            throw new Error("Maximum lock count exceeded");        /**         * 通过CAS操作设置state的值，如果成功表示尝试获取读锁成功，需要做以下几件事情：         * 1、如果是第一获取读锁要记录第一个获取读锁的线程信息         * 2、如果是当前获取锁的线程和第一次获取锁的线程相同，需要更新第一获取线程的重入次数         * 3、更新获取读锁线程相关的信息         *          * 这个if就只有一个CAS操作，没有阻塞操作了，如果CAS失败就继续自旋尝试获取锁         */        if (compareAndSetState(c, c + SHARED_UNIT)) {            // 下面的操作和之前讲过的一样            if (r == 0) {                firstReader = current;                firstReaderHoldCount = 1;            } else if (firstReader == current) {                firstReaderHoldCount++;            } else {                HoldCounter rh = cachedHoldCounter;                if (rh == null || rh.tid != getThreadId(current))                    cachedHoldCounter = rh = readHolds.get();                else if (rh.count == 0)                    readHolds.set(rh);                rh.count++;            }            // 成功获取读锁，返回true            return true;        }    }}</code></pre><h4 id="读锁释放锁"><a href="#读锁释放锁" class="headerlink" title="读锁释放锁"></a>读锁释放锁</h4><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><pre><code class="line-numbers language-java">// java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.unlockpublic void unlock() {    // 释放读锁（共享锁）    sync.releaseShared(1);} // java.util.concurrent.locks.AbstractQueuedSynchronizer.releaseSharedpublic final boolean releaseShared(int arg) {    // 如果尝试释放成功了，就唤醒下一个节点    if (tryReleaseShared(arg)) {        // 这个方法实际是唤醒下一个节点，在上一小节已经讲过了        doReleaseShared();        // 释放锁成功        return true;    }    // 释放锁失败    return false;} // java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryReleaseShared// 只有所有持有该读锁的线程全部都完全释放了该锁时，才会返回true，其他情况一律返回falseprotected final boolean tryReleaseShared(int unused) {    // 获取当前线程    Thread current = Thread.currentThread();    // 当前线程是否为第一个获取读锁的线程    if (firstReader == current) {        // 如果第一个读者（读线程）是当前线程，就把它重入的次数减1。如果减到0了就把firstReader置为空。firstReader可以被置为空，cachedHoldCounter只要是写入数据之后就不会被置为空了        if (firstReaderHoldCount == 1)            firstReader = null;        else            firstReaderHoldCount--;    } else {        // 如果第一个读者不是当前线程，从记录最后一个获取读锁的本地缓存变量中获取重入次数保存期        HoldCounter rh = cachedHoldCounter;        /**         * 条件1：cachedHoldCounter是否为空         * 条件2：当前线程是否是最后一个获取读锁的线程         *          * 条件1或条件2只要有成立的，就会进入到该if分支中，说明cachedHoldCounter还没有记录最后一个获取锁的线程或者当前线程并不是最后一个获取读锁的线程         */        if (rh == null || rh.tid != getThreadId(current))            // 该线程不是最后获取读锁的线程，则从其ThreadLocal中获取重入次数保存器            rh = readHolds.get();        // 获取当前线程对读锁的重入次数        int count = rh.count;        // 如果当前线程的重入次数已经小于等于1了，说明这次释放了读锁之后该线程就完全释放了该读锁，需要将该线程对存储该读锁重入次数的ThreadLocal删除掉，否则可能会导致ThreadLocal内存泄漏        if (count &lt;= 1) {            // 调用ThreadLocal的remove()            readHolds.remove();            // 如果还没有释放锁这个线程的读锁重入次数就小于等于0了，说明出现了错误，抛出异常            if (count &lt;= 0)                throw unmatchedUnlockException();        }        // 将重入次数减1        --rh.count;    }    // 再去更新读写锁的state变量    for (;;) {        // 共享锁获取的次数减1        int c = getState();        int nextc = c - SHARED_UNIT;        // 通过CAS更新state        if (compareAndSetState(c, nextc))            // 如果减为0了说明已经没有线程持有该读锁了，这种情况才返回true。否则返回false            return nextc == 0;    }} // java.util.concurrent.locks.AbstractQueuedSynchronizer.doReleaseShared// 行为跟方法名有点不符，实际是唤醒下一个节点private void doReleaseShared() {    for (;;) {        Node h = head;        if (h != null &amp;&amp; h != tail) {            int ws = h.waitStatus;            // 如果头节点状态为SIGNAL，说明要唤醒下一个节点            if (ws == Node.SIGNAL) {                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;            // loop to recheck cases                // 唤醒下一个节点                unparkSuccessor(h);            }            else if (ws == 0 &amp;&amp;                     // 把头节点的状态改为PROPAGATE成功才会跳到下面的if                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                // loop on failed CAS        }        // 如果唤醒后head没变，则跳出循环        if (h == head)                   // loop if head changed            break;    }}</code></pre><h5 id="解锁的大致流程如下："><a href="#解锁的大致流程如下：" class="headerlink" title="解锁的大致流程如下："></a>解锁的大致流程如下：</h5><ol><li>将当前线程重入的次数减1；</li><li>将共享锁总共被获取的次数减1；</li><li>如果共享锁获取的次数减为0了，说明共享锁被完全释放了，那就唤醒下一个节点；</li></ol><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>举个例子，t1、t2、t3三个节点依次获取了一次共享锁，三者释放的顺序分别为t1、t3、t2，那么最后t2释放共享锁的时候tryReleaseShared()才会返回true，因为此时读锁才被所有线程完全释放了。这样才会去唤醒等待队列中的下一个读节点。</p><p>至此我们就将读锁的主要源码分析完了，下面我们就举几个例子让大家能更直观的了解ReentrantReadWriteLock的执行流程。也能更深刻理解cachedHoldCounter、firstReader、firstReaderHoldCount的作用。</p><p><strong>例子1</strong>：第一个线程t1进来拿读锁，然后t1就一直不释放，第二个线程t2进来拿读锁，此时这个t2就是最后一个拿到读锁的线程，t2的读锁重入次数会记录在cachedHoldCounter中，并且也会存储到t2线程的ThreadLocal中一份。然后t2再去释放锁，此时就会将cachedHoldCounter的重入次数减为0，但是cachedHoldCounter中记录的线程id仍然是t2的，并不会因为t2完全释放了读锁就将cachedHoldCounter置为空，因为从时间角度上t2仍然是最后一个成功获取读锁的线程。同时t2绑定的存储重入次数计数器的ThreadLocal会被remove掉。如果t2释放了读锁之后又再一次获取读锁，这个时候它就会直接进入到获取读锁源码的else if (rh.count == 0)这个分支中，重新将t2线程的HoldCounter存储到ThreadLocal中，具体注释在上面源码中已经写好了。</p><p><strong>例子2</strong>：第一个线程t1进来拿读锁，这个时候t1是第一个拿到读锁的线程，所以它的读锁重入次数记录会被记录在firstReader和firstReaderHoldCount中，但是并不会使用ThreadLocal来记录t1的重入次数。然后t1不释放，第二个线程t2进来拿读锁，然后t2不释放，t1先释放，t1完全释放了读锁，这个时候因为t1是第一个获取所得读锁的线程，所以直接操作firstReader，将其置为空，并不会将firstReader指向t2。然后再来一个t3获取读锁，这是t3成了最后一次获取读锁的线程，将cachedHoldCounter保存t3的重入次数计数器，但是firstReader和firstReaderHoldCount不会有任何变化。最后t2、t3全部彻底释放读锁后，再来一个线程t4获取读锁，此时就会将firstReader和firstReaderHoldCount转而记录t4的重入信息，因为t4使该读锁被占有次数从0变为1，属于第一个成功获取读锁的线程。</p><p><strong>例子3</strong>：第一个线程t1拿读锁，然后t1不释放，第二个线程t2进来拿读锁，也先不释放，第三个线程t3进来拿读锁，也先不释放。t1获取到读锁后，它的重入次数信息被保存在firstReader和firstReaderHoldCount中，并不会记录到t1线程的ThreadLocal中，t2线程拿锁后，它的重入次数计数器就会存储到cachedHoldCounter本地缓存变量中一份，存储到t2绑定的ThreadLocal中一份，最后t3拿到读锁之后，cachedHoldCounter就会转而存储t3的重入次数信息，并且也会在t3绑定的ThreadLocal中存储一份重入次数计数器，这里需要注意，cachedHoldCounter指向的重入次数计数器和ThreadLocal中存储的重入次数计数器其实是同一个对象，改一个就全都改了。然后t3将读锁完全释放，cachedHoldCounter中记录的重入次数变为0，线程id仍然是记录的t3的，并不会转而记录t2线程的重入信息。后面再来一个t4获取读锁，这个时候cachedHoldCounter就会转而记录t4的重入信息，此时t4就成为了最后一个获取读锁的线程。</p><h3 id="WriteLock类源码解析"><a href="#WriteLock类源码解析" class="headerlink" title="WriteLock类源码解析"></a>WriteLock类源码解析</h3><pre><code class="line-numbers language-java">public static class WriteLock implements Lock, java.io.Serializable {    private final Sync sync;    /**     * 通过ReentrantReadWriteLock中的公平锁或非公平锁来初始化sync变量     */    protected WriteLock(ReentrantReadWriteLock lock) {        sync = lock.sync;    }    /**     * 阻塞的方式获取写锁     */    public void lock() {        sync.acquire(1);    }    /**     * 中断的方式获取写锁     */    public void lockInterruptibly() throws InterruptedException {        sync.acquireInterruptibly(1);    }    /**     * 尝试获取写锁     */    public boolean tryLock( ) {        return sync.tryWriteLock();    }    /**     * 超时尝试获取写锁     */    public boolean tryLock(long timeout, TimeUnit unit)            throws InterruptedException {        return sync.tryAcquireNanos(1, unit.toNanos(timeout));    }    /**     * 释放写锁     */    public void unlock() {        sync.release(1);    }}</code></pre><h4 id="写锁获取锁"><a href="#写锁获取锁" class="headerlink" title="写锁获取锁"></a>写锁获取锁</h4><h5 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h5><pre><code class="line-numbers language-java">// java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.lock()public void lock() {    // 获取互斥锁（写锁）    sync.acquire(1);}// java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire()public final void acquire(int arg) {    // 先尝试获取锁    // 如果失败，则会进入队列中排队，后面的逻辑跟ReentrantLock一模一样了    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}// java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryAcquire()protected final boolean tryAcquire(int acquires) {    // 获取当前线程    Thread current = Thread.currentThread();    // 状态变量state的值    int c = getState();    // 互斥锁被获取的次数    int w = exclusiveCount(c);    // c != 0朔说明此时读写锁已经被线程占有了    if (c != 0) {        /**         * 条件1：如果c!=0且w==0，说明共享锁被获取的次数不为0         * 条件2：当前线程是不是持有该写锁的线程         *          * 条件1和条件2只要有任意一个成立，就会进入该if分支中返回false         * 条件1成立，说明此时已经有线程获取读锁了，如果获取读锁的线程是其他线程，那么读写互斥，不能够获取到写锁。如果获取读锁的线程就是当前线程，因为不允许锁升级，所以也不能获取到写锁，直接返回false         * 条件2成立，说明该写锁已经被其他线程获取了，所以当前线程不能获取到该写锁，返回false         */        if (w == 0 || current != getExclusiveOwnerThread())            // 返回false，获取写锁失败            return false;        // 溢出检测，写锁持有次数是否超过了最大限制        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error("Maximum lock count exceeded");        // 到这里说明当前线程已经获取过写锁，这里是重入了，直接把state加1即可        // 注意这里直接用state+acquires就行了，因为state后16为本来就是记录写锁占有次数的，直接在state基础上做加法即可        setState(c + acquires);        // 获取写锁成功        return true;    }    // 如果c等于0，说明此时还没有线程持有该读写锁，那就尝试更新state的值（非公平模式writerShouldBlock()返回false，不会阻塞排队，直接去尝试CAS修改state）    // 如果失败了，说明CAS获取写锁失败，返回false    // 如果成功了，说明获取写锁成功，把自己设置为占有者，并返回true    if (writerShouldBlock() ||        !compareAndSetState(c, c + acquires))        return false;    setExclusiveOwnerThread(current);    return true;}// 获取写锁失败了后面的逻辑跟ReentrantLock是一致的，进入队列排队，这里就不列源码了</code></pre><h5 id="写锁获取的过程大致如下："><a href="#写锁获取的过程大致如下：" class="headerlink" title="写锁获取的过程大致如下："></a>写锁获取的过程大致如下：</h5><ol><li>尝试获取锁；</li><li>如果有读者占有着读锁，尝试获取写锁失败；</li><li>如果有其它线程占有着写锁，尝试获取写锁失败；</li><li>如果是当前线程占有着写锁，尝试获取写锁成功，state值加1；</li><li>如果没有线程占有着锁（<code>state==0</code>），当前线程尝试更新state的值，成功了表示尝试获取锁成功，否则失败；</li><li>尝试获取锁失败以后，进入队列排队，等待被唤醒；</li><li>后续逻辑跟ReentrantLock是一致；</li></ol><h5 id="非阻塞获取读锁-1"><a href="#非阻塞获取读锁-1" class="headerlink" title="非阻塞获取读锁"></a>非阻塞获取读锁</h5><p>下面再讲一下非阻塞获取读锁的操作，相对就要简单很多了：</p><pre><code class="line-numbers language-java">// ReentrantReadWriteLock.WriteLock.tryLock()// 非阻塞的尝试获取写锁public boolean tryLock( ) {    return sync.tryWriteLock();} // ReentrantReadWriteLock.Sync.tryWriteLock()final boolean tryWriteLock() {    // 获取当前线程    Thread current = Thread.currentThread();    int c = getState();    // 读锁或者写锁已经被线程持有    if (c != 0) {        int w = exclusiveCount(c);        // 写锁第一次获取锁或者当前线程不是第一次获取写锁的线程（也就是不是owner），直接失败        if (w == 0 || current != getExclusiveOwnerThread())            return false;        // 超出写锁的最大次数，直接失败        if (w == MAX_COUNT)            throw new Error("Maximum lock count exceeded");    }    // 竞争写锁的线程修改state，    // 如果成功将自己设置成锁的owner，    // 如果失败直接返回    if (!compareAndSetState(c, c + 1))        return false;    setExclusiveOwnerThread(current); // 设置当前线程持有锁    return true;}</code></pre><h4 id="写锁释放锁"><a href="#写锁释放锁" class="headerlink" title="写锁释放锁"></a>写锁释放锁</h4><h5 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h5><pre><code class="line-numbers language-java">// java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.unlock()public void unlock() {    sync.release(1);} //java.util.concurrent.locks.AbstractQueuedSynchronizer.release()public final boolean release(int arg) {    // 如果尝试释放锁成功（完全释放锁）    // 就尝试唤醒下一个节点    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;} // java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryRelease()protected final boolean tryRelease(int releases) {    // 如果写锁不是当前线程占有着，抛出异常    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    // 状态变量的值减1    int nextc = getState() - releases;    // 是否完全释放了该写锁    boolean free = exclusiveCount(nextc) == 0;    if (free)        setExclusiveOwnerThread(null);    // 设置状态变量的值    setState(nextc);    // 如果完全释放了写锁，返回true    return free;}</code></pre><h5 id="写锁释放的过程大致为："><a href="#写锁释放的过程大致为：" class="headerlink" title="写锁释放的过程大致为："></a>写锁释放的过程大致为：</h5><ol><li>先尝试释放锁，即状态变量state的值减1；</li><li>如果减为0了，说明完全释放了锁；</li><li>完全释放了锁才唤醒下一个等待的节点；</li></ol><h3 id="基于源码讨论一下锁升级和锁降级的问题"><a href="#基于源码讨论一下锁升级和锁降级的问题" class="headerlink" title="基于源码讨论一下锁升级和锁降级的问题"></a>基于源码讨论一下锁升级和锁降级的问题</h3><h4 id="如果同一个线程先获取读锁，再获取写锁会怎样？"><a href="#如果同一个线程先获取读锁，再获取写锁会怎样？" class="headerlink" title="如果同一个线程先获取读锁，再获取写锁会怎样？"></a>如果同一个线程先获取读锁，再获取写锁会怎样？</h4><pre><code class="line-numbers language-java">protected final boolean tryAcquire(int acquires) {    // 获取当前线程    Thread current = Thread.currentThread();    // 状态变量state的值    int c = getState();    // 互斥锁被获取的次数    int w = exclusiveCount(c);    // c != 0朔说明此时读写锁已经被线程占有了    if (c != 0) {        /**         * 条件1：如果c!=0且w==0，说明共享锁被获取的次数不为0         * 条件2：当前线程是不是持有该写锁的线程         *          * 条件1和条件2只要有任意一个成立，就会进入该if分支中返回false         * 条件1成立，说明此时已经有线程获取读锁了，如果获取读锁的线程是其他线程，那么读写互斥，不能够获取到写锁。如果获取读锁的线程就是当前线程，因为不允许锁升级，所以也不能获取到写锁，直接返回false         * 条件2成立，说明该写锁已经被其他线程获取了，所以当前线程不能获取到该写锁，返回false         */        if (w == 0 || current != getExclusiveOwnerThread())            // 返回false，获取写锁失败            return false;        // 溢出检测，写锁持有次数是否超过了最大限制        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error("Maximum lock count exceeded");        // 到这里说明当前线程已经获取过写锁，这里是重入了，直接把state加1即可        // 注意这里直接用state+acquires就行了，因为state后16为本来就是记录写锁占有次数的，直接在state基础上做加法即可        setState(c + acquires);        // 获取写锁成功        return true;    }        ......}</code></pre><p>分析上面的源码，在tryAcquire()方法中，如果此时该线程已经获取了读锁了，那么该读写锁的state肯定不等于0（c != 0），然后就有两种可能，一个是此时还有有任何线程获取写锁（w == 0），这种情况下就会进入到if (w == 0 || current != getExclusiveOwnerThread())这个分支里，返回false获取写锁失败。返回之后外层方法会让当前线程阻塞等待。</p><p>这里例子说明了ReentrantReadWriteLock不允许锁升级。</p><p>可以通过下面的方法验证：</p><pre><code class="line-numbers language-java">readLock.lock();writeLock.lock();writeLock.unlock();readLock.unlock();</code></pre><h4 id="如果同一个线程先获取写锁，再获取读锁会怎样？"><a href="#如果同一个线程先获取写锁，再获取读锁会怎样？" class="headerlink" title="如果同一个线程先获取写锁，再获取读锁会怎样？"></a>如果同一个线程先获取写锁，再获取读锁会怎样？</h4><pre><code class="line-numbers language-java">// ReentrantReadWriteLock.Sync.tryAcquireShared()protected final int tryAcquireShared(int unused) {    // 获取当前线程    Thread current = Thread.currentThread();    // 状态变量的值    // 在读写锁模式下，高16位存储的是共享锁（读锁）被获取的次数，低16位存储的是互斥锁（写锁）被获取的次数    int c = getState();    /**     * 条件1：获取互斥锁（读锁）的被持有的次数，判断是否不等于0     * 条件2：判断当前线程是否持有互斥锁（写锁）     *      * 如果条件1和条件2同时成立，表明其它线程获得了写锁，因为读写和写读互斥，直接返回-1，该线程获取读锁失败     */    if (exclusiveCount(c) != 0 &amp;&amp;        getExclusiveOwnerThread() != current)        return -1;    // 读锁被获取的次数    int r = sharedCount(c);        // 执行到这里说明此时还没有线程获取写锁，尝试去更新state的值获取读锁    /**     * 条件1：读者是否需要排队（是否是公平模式），readerShouldBlock()返回true说明需要排队     * 条件2：读锁被持有次数是否小于上限     * 条件3：尝试CAS更新读锁state值是否成功     *      * 如果三个条件均成立，则说明当前线程尝试获取读锁成功，就可以执行后续的修改当前线程持有读锁重入次数的操作了     */    if (!readerShouldBlock() &amp;&amp;        r &lt; MAX_COUNT &amp;&amp;        compareAndSetState(c, c + SHARED_UNIT)) {        // 获取读锁成功        // 判断之前是否有线程持有该读锁        if (r == 0) {            // 如果之前还没有线程获取读锁，记录第一个读者为当前线程，直接使用firstReader和firstReaderHoldCount进行记录，不适用ThreadLocal            firstReader = current;            // 第一个读者重入的次数为1            firstReaderHoldCount = 1;        // 如果有线程获取了读锁且是当前线程就是第一个读者        } else if (firstReader == current) {            // 则把其重入次数加1            firstReaderHoldCount++;        } else {            ......        }        // 获取读锁成功，返回1        return 1;    }    // 如果CAS失败，则通过这个方法再去尝试获取读锁（如果此时其它线程仍在持有写锁，一样返回-1表示失败，因为写读，读写互斥）    return fullTryAcquireShared(current);}</code></pre><p>分析上面的源码，在tryAcquireShared()方法中，在if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current)分支处并不会返回，因为是当前线程获取的写锁，不满足getExclusiveOwnerThread() != current；如果在if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) 这个分支上原子更新成功就说明获取了读锁，然后就会执行后续的代码把其读锁重入次数+1。</p><p>这里例子说明了ReentrantReadWriteLock允许锁降级。</p><p>可以通过下面的方法验证：</p><pre><code class="line-numbers language-java">writeLock.lock();readLock.lock();readLock.unlock();writeLock.unlock();</code></pre><h4 id="为什么不能锁升级"><a href="#为什么不能锁升级" class="headerlink" title="为什么不能锁升级"></a>为什么不能锁升级</h4><p>通过上面的两个例子，我们可以感受到同一个线程先读后写和先写后读是完全不一样的，为什么不一样呢？</p><p><strong>先读后写</strong>，一个线程占有读锁后，其它线程还是可以占有读锁的，这时候如果在其它线程占有读锁之前让自己占有了写锁，其它线程又不能占有读锁了，这段程序会非常难实现，逻辑也很奇怪，所以，设计成只要一个线程占有了读锁，其它线程包括它自己都不能再获取写锁。</p><p><strong>先写后读</strong>，一个线程占有写锁后，其它线程是不能占有任何锁的，这时候，即使自己占有一个读锁，对程序的逻辑也不会有任何影响，所以，一个线程占有写锁后是可以再占有读锁的，只是这个时候其它线程依然无法获取读锁。</p><p>我们假设几个例子就能更好地理解为什么不能锁升级。</p><p>假设有 A，B 和 C 三个线程，它们都已持有读锁。假设线程 A 尝试从读锁升级到写锁。那么它必须等待 B 和 C 释放掉已经获取到的读锁。如果随着时间推移，B 和 C 逐渐释放了它们的读锁，此时线程 A 确实是可以成功升级并获取写锁。</p><p>但是我们考虑一种特殊情况。</p><p>假设线程 A 和 B 都想升级到写锁，那么对于线程 A 而言，它需要等待其他所有线程，包括线程 B 在内释放读锁。而线程 B 也需要等待所有的线程，包括线程 A 释放读锁。这就是一种非常典型的<strong>死锁</strong>的情况。谁都愿不愿意率先释放掉自己手中的锁。由此可见，是不能够允许锁升级的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 ReentrantLock</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantlock/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantlock/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-ReentrantLock"><a href="#【Java-多线程并发】-ReentrantLock" class="headerlink" title="【Java 多线程并发】 ReentrantLock"></a>【Java 多线程并发】 ReentrantLock</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 ReentrantLockdate: 2023-07-04 17:10tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: ReentrantLock是一个可重入且互斥的锁，它具有与使用synchronized监视器锁相同的基本行为和语义，但它是继承了Lock接口，与synchronized关键字相比，它更灵活、更强大，增加了轮询、超时、中断等高级功能。</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ReentrantLock就是一个互斥锁，默认是非公平锁。并且是一个可中断的锁。</p><p><img src="/attachment/cccb34882995538c30ba928c37ef4b5b.png"></p><p><strong>特点</strong></p><ul><li>可重入性</li><li>公平性</li><li>条件变量</li><li>可中断</li></ul><p><strong>使用流程</strong></p><ol><li>创建一个ReentrantLock对象。</li><li>在需要保护共享资源的代码块中，使用lock()方法获取锁。</li><li>在使用完共享资源后，使用unlock()方法释放锁。</li><li>相比于synchronized关键字，ReentrantLock提供了更多的灵活性和功能，但也需要手动管理锁的获取和释放。</li></ol><p><strong>原理</strong><br>ReentrantLock是基于AQS来实现的<br>AQS中还维护了一个条件锁内部类ConditionObject，这个内部类中也维护了一个条件队列</p><p><strong>数据结构</strong></p><p>三个内部类：Sync、NonfairSync、FairSync。</p><ol><li>抽象类Sync继承自AbstractQueuedSynchronizer，实现了AQS的部分方法；</li><li>NonfairSync继承自Sync，实现了Sync中的方法，主要用于非公平锁的获取；</li><li>FairSync继承自Sync，实现了Sync中的方法，主要用于公平锁的获取。</li></ol><h2 id="【Java-多线程并发】-ReentrantLock-1"><a href="#【Java-多线程并发】-ReentrantLock-1" class="headerlink" title="【Java 多线程并发】 ReentrantLock"></a>【Java 多线程并发】 ReentrantLock</h2><p>ReentrantLock是一个可重入且互斥的锁，它具有与使用synchronized监视器锁相同的基本行为和语义，但它是继承了Lock接口，与synchronized关键字相比，它更灵活、更强大，增加了轮询、超时、中断等高级功能。</p><p>Reentrant = Re + entrant，Re是重复、又、再的意思，entrant是enter的名词或者形容词形式，翻译为进入者或者可进入的，所以Reentrant翻译为可重复进入的、可再次进入的，因此ReentrantLock翻译为可重入锁或者再入锁。</p><p>顾名思义，重入锁是指一个线程获取锁之后再尝试获取锁时会自动获取锁，是一种递归无阻塞的同步机制，synchronized也是重入锁。ReentrantLock除了支持可重入锁之外，还支持获取锁时的公平和非公平选择。</p><p>ReentrantLock的类图如下：</p><p><img src="/attachment/cccb34882995538c30ba928c37ef4b5b.png"></p><p>我们可以看到ReentrantLock只是实现了Lock接口，但是其本身并没有继承AQS抽象类，而是通过ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。如果在绝对时间上，先对锁进行获取的请求你一定先被满足，那么这个锁是公平的，反之，是不公平的。公平锁的获取，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock的公平与否，可以通过它的构造函数来决定。ReentrantLock默认是非公平锁，之所以这样是因为非公平锁普遍情况下比公平锁效率要高。</p><p>那么公平锁为什么普遍没有非公平锁的效率高呢？这是因为非公平模式会在一开始就尝试两次获取锁，如果当时正好state的值为0，它就会成功获取到锁，少了排队导致的阻塞/唤醒过程，并且减少了线程频繁的切换带来的性能损耗。但是，并不是任何场景都是以TPS作为唯一指标，非公平锁有可能会导致一开始排队的线程一直获取不到锁，导致线程饿死。而公平锁能够减少“饥饿”发生的概率，等待越久的请求越能够得到优先满足。</p><p>总结起来，ReentrantLock就是一个互斥锁，默认是非公平锁。并且是一个可中断的锁。</p><h2 id="ReentrantLock的特点"><a href="#ReentrantLock的特点" class="headerlink" title="ReentrantLock的特点"></a>ReentrantLock的特点</h2><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>与synchronized关键字一样，ReentrantLock允许线程重复获取同一个锁。当一个线程已经获取了锁，并且再次请求获取该锁时，它将会成功获取锁，而不会被阻塞。这种机制可以避免死锁情况的发生。</p><h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>ReentrantLock可以选择公平锁和非公平锁。公平锁会按照线程的请求顺序来获取锁，而非公平锁允许插队，可能导致某些线程始终无法获取到锁。默认情况下，ReentrantLock是非公平锁。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>ReentrantLock提供了条件变量（Condition），可以通过条件变量实现更灵活的线程间通信。通过调用ReentrantLock的newCondition()方法来创建一个条件变量，然后可以使用await()、signal()和signalAll()等方法进行线程的等待和唤醒。</p><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>ReentrantLock支持线程的中断。当一个线程等待获取锁时，可以通过调用interrupt()方法中断该线程，使其放弃对锁的请求。</p><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>使用ReentrantLock的基本流程如下：</p><ol><li>创建一个ReentrantLock对象。</li><li>在需要保护共享资源的代码块中，使用lock()方法获取锁。</li><li>在使用完共享资源后，使用unlock()方法释放锁。</li><li>相比于synchronized关键字，ReentrantLock提供了更多的灵活性和功能，但也需要手动管理锁的获取和释放。在一些复杂的并发场景下，使用ReentrantLock可以更好地控制线程的访问顺序和等待机制。</li></ol><pre><code class="line-numbers language-java">Lock lock = new ReentrantLock();lock.lock(); try {    // do something...} finally {    lock.unlock();}</code></pre><p>在使用Lock接口下的锁时，要注意以下几点：</p><ul><li>要在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</li><li>尽量不要将获取锁的过程写在try块中，因为如果在获取锁（可以是自定义的锁）的过程中发生了异常，在异常抛出的同时，也会导致锁的无故释放。</li></ul><h2 id="ReentrantLock的数据结构"><a href="#ReentrantLock的数据结构" class="headerlink" title="ReentrantLock的数据结构"></a>ReentrantLock的数据结构</h2><h3 id="主要内部类"><a href="#主要内部类" class="headerlink" title="主要内部类"></a>主要内部类</h3><p>ReentrantLock中主要定义了三个内部类：Sync、NonfairSync、FairSync。</p><pre><code class="line-numbers language-java">abstract static class Sync extends AbstractQueuedSynchronizer {} static final class NonfairSync extends Sync {} static final class FairSync extends Sync {}</code></pre><ol><li>抽象类Sync继承自AbstractQueuedSynchronizer，实现了AQS的部分方法；</li><li>NonfairSync继承自Sync，实现了Sync中的方法，主要用于非公平锁的获取；</li><li>FairSync继承自Sync，实现了Sync中的方法，主要用于公平锁的获取。</li></ol><p>由此可以看出，AQS是ReentrantLock类的基石。</p><h4 id="Sync类源码"><a href="#Sync类源码" class="headerlink" title="Sync类源码"></a>Sync类源码</h4><pre><code class="line-numbers language-java">abstract static class Sync extends AbstractQueuedSynchronizer {    private static final long serialVersionUID = -5179523762034025860L;        abstract void lock();       final boolean nonfairTryAcquire(int acquires) {        final Thread current = Thread.currentThread();        int c = getState();        if (c == 0) {            if (compareAndSetState(0, acquires)) {                setExclusiveOwnerThread(current);                return true;            }        }        else if (current == getExclusiveOwnerThread()) {            int nextc = c + acquires;            if (nextc &lt; 0) // overflow                throw new Error("Maximum lock count exceeded");            setState(nextc);            return true;        }        return false;    }     protected final boolean tryRelease(int releases) {        int c = getState() - releases;        if (Thread.currentThread() != getExclusiveOwnerThread())            throw new IllegalMonitorStateException();        boolean free = false;        if (c == 0) {            free = true;            setExclusiveOwnerThread(null);        }        setState(c);        return free;    }     protected final boolean isHeldExclusively() {        return getExclusiveOwnerThread() == Thread.currentThread();    }     final ConditionObject newCondition() {        return new ConditionObject();    }    final Thread getOwner() {        return getState() == 0 ? null : getExclusiveOwnerThread();    }    final int getHoldCount() {        return isHeldExclusively() ? getState() : 0;    }    final boolean isLocked() {        return getState() != 0;    }    private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException {        s.defaultReadObject();        setState(0); // reset to unlocked state    }}</code></pre><h4 id="NonfairSync类源码"><a href="#NonfairSync类源码" class="headerlink" title="NonfairSync类源码"></a>NonfairSync类源码</h4><pre><code class="line-numbers language-java">static final class NonfairSync extends Sync {    private static final long serialVersionUID = 7316153563782823691L;     final void lock() {        if (compareAndSetState(0, 1))            setExclusiveOwnerThread(Thread.currentThread());        else            acquire(1);    }     protected final boolean tryAcquire(int acquires) {        return nonfairTryAcquire(acquires);    }}</code></pre><h4 id="FairSync类源码"><a href="#FairSync类源码" class="headerlink" title="FairSync类源码"></a>FairSync类源码</h4><pre><code class="line-numbers language-java">static final class FairSync extends Sync {    private static final long serialVersionUID = -3000897897090466540L;    final void lock() {        acquire(1);    }     protected final boolean tryAcquire(int acquires) {        final Thread current = Thread.currentThread();        int c = getState();        if (c == 0) {            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) {                setExclusiveOwnerThread(current);                return true;            }        }        else if (current == getExclusiveOwnerThread()) {            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error("Maximum lock count exceeded");            setState(nextc);            return true;        }        return false;    }}</code></pre><p>公平锁和非公平锁的实现类中只实现了获取锁的方法，也就是说只有获取锁时非公平锁和公平锁有区别，在释放锁的时候就都是用AQS提供的释放锁的模板方法了，公平锁和非公平锁的释放锁的方法也就没有区别了。</p><h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><pre><code class="line-numbers language-java">private final Sync sync;</code></pre><p>主要属性就一个sync，它在构造方法中初始化，决定使用公平锁还是非公平锁的方式获取锁。</p><h3 id="主要构造方法"><a href="#主要构造方法" class="headerlink" title="主要构造方法"></a>主要构造方法</h3><pre><code class="line-numbers language-java">// 默认构造方法，ReentrantLock默认是非公平锁public ReentrantLock() {    sync = new NonfairSync();} // 自己可选择使用公平锁还是非公平锁，传入true是公平锁，传入false是非公平锁public ReentrantLock(boolean fair) {    sync = fair ? new FairSync() : new NonfairSync();}</code></pre><ol><li>默认构造方法使用的是非公平锁；</li><li>第二个构造方法可以自己决定使用公平锁还是非公平锁；</li></ol><h3 id="ReentrantLock数据结构总结"><a href="#ReentrantLock数据结构总结" class="headerlink" title="ReentrantLock数据结构总结"></a>ReentrantLock数据结构总结</h3><p>我们先从ReentrantLock锁的使用角度来分析，我们在使用该锁的时候就是将需要保证线程安全的代码块用ReentrantLock.lock()和ReentrantLock.unlock()包裹起来，这样就能保证这个代码块内部的资源在同一时间段内只会被同一个线程所使用，就避免了线程风险。通过ReentrantLock的使用流程，就能更好的理解为什么它要被称为“锁”。其实ReentrantLock就相当于一个带着锁的栅栏，这个带锁的栅栏把想要保证线程安全的，也就是想要“锁”起来代码块前后“包”起来，只有持有这个ReentrantLock的线程才可以打开栅栏门进入到这个栅栏内部，其他不持有ReentrantLock的线程，是没有办法打开栅栏门进入到栅栏内部的。而这个栅栏门前，会有一条专门的“通道”，所有想要进到栅栏里面的线程必须都在这里排队等待，等到持有锁的线程从栅栏里面出来后，就会把锁的钥匙留在门口，然后在外面排队的线程中，排在第一位的线程就能拿到钥匙，成功持有了这个锁，它就可以打开栅栏门进入到栅栏内部了，这个用来排队的“通道”就是同步等待队列。这个就是锁的基本运作流程，通过这个流程我们就能很好的了解到ReentrantLock的主要数据结构。</p><p>ReentrantLock有一个<mark style="background: #FFB8EBA6;">继承了AQS的内部类</mark>，通过这个内部类就实现了锁的功能，这个内部类会根据用户的指定来创建公平锁实现或非公平锁实现，并且将实现对象作为ReentrantLock的一个成员属性来此存储，这个成员属性sync就是基于AQS来实现的。AQS中维护了一个同步队列（也可称为等待队列），节点类型是Node，是一个双向链表，并且AQS还继承了AbstractOwnableSynchronizer这个抽象类，这个抽象类中有一个成员属性用来记录持有当前锁，通过继承这个抽象类，AQS也就能记录当前持有锁的线程了。所以ReentrantLock就通过继承了AQS的内部类，维护了一个记录持有当前锁的线程的属性还有一个同步等待队列，进而实现锁的功能。</p><p>ReentrantLock中还有一个<mark style="background: #FFB8EBA6;">条件锁</mark>，这个也是通过AQS来实现的，AQS中有一个ConditionObject内部类，ConditionObject这个类实现了条件锁的功能，所以ReentrantLock就通过它的继承AQS的内部类实现了条件锁的功能。ConditionObject类中也维护了一个队列，节点类型也是Node，是一个单向链表，这个队列被称为条件队列，这个队列中就存储的是所有正在等待该条件的线程节点。一个ConditionObject类对象就可以看作是一种条件，在这个对象中维护的条件队列中存储的就全部都是等待该条件的线程，这些线程获取ReentrantLock锁之后，假如用户使用了ReentrantLock的条件锁，如果此时还没有满足条件锁ConditionObject的条件，该线程就会被阻塞等待，放到条件队列中去。所有等待该条件的线程都会被放到队列中去。当满足条件之后，就会从队列中取出第一个节点来将其唤醒继续向下执行。这就是条件锁的实现流程。</p><p>综上所述，我们就能整体的理解ReentrantLock的数据结构了，<mark style="background: #FFB8EBA6;">ReentrantLock是基于AQS来实现的</mark>，AQS中维护了持有当前锁的线程，还有等待该锁的同步等待队列，所有等待该锁的线程都会进入到该队列排队，依次获取锁，保证并发安全。<mark style="background: #FFB8EBA6;">AQS中还维护了一个条件锁内部类ConditionObject，这个内部类中也维护了一个条件队列</mark>，一个ConditionObject就代表着一种条件，所有持有该锁的线程如果不满足条件就都会进入到这个条件队列中等待，直到满足条件之后就会在条件队列中依次被唤醒。如果ReentrantLock需要条件锁的功能，就可以创建一个条件锁对象来根据用户的需要来实现相关逻辑。</p><p>所以ReentrantLock中核心的数据结构就是一个同步等待队列，一个条件锁对象中的条件队列，还有一个记录持有当前锁线程的属性，通过这几个结构实现了ReentrantLock锁的功能。</p><h2 id="ReentrantLock的方法"><a href="#ReentrantLock的方法" class="headerlink" title="ReentrantLock的方法"></a>ReentrantLock的方法</h2><h3 id="获取锁（均继承自Lock接口）："><a href="#获取锁（均继承自Lock接口）：" class="headerlink" title="获取锁（均继承自Lock接口）："></a>获取锁（均继承自Lock接口）：</h3><h4 id="void-lock"><a href="#void-lock" class="headerlink" title="void lock()"></a>void lock()</h4><p>获取锁，调用该方法当前线程将会获取锁，当锁获取后，该方法将返回。</p><p>该方法优先考虑获取锁，待获取锁成功后，才响应中断，在获取到锁之前，不会响应中断。</p><p><strong>执行过程：</strong></p><p>调用lock()方法，在获取锁的过程中但是还没获取到锁时（尝试获取锁或正在队列中阻塞等待），如果检测到Thread.isInterrupted，线程会忽略中断，只是将记录是否中断的一个变量设置为true，然后继续尝试获取锁，直到成功获取锁之后，将记录是否终端的变量返回给上一层，在上一层进行中断处理，调用Thread.currentThread().interrupt()方法响应中断。在这个整个过程中lock()都不会抛出异常。</p><h4 id="void-lockInterruptibly-throws-InterruptedException"><a href="#void-lockInterruptibly-throws-InterruptedException" class="headerlink" title="void lockInterruptibly() throws InterruptedException"></a>void lockInterruptibly() throws InterruptedException</h4><p>可中断获取锁，与 lock()方法不同之处在于该方法优先考虑响应中断，线程会立刻响应中断，即在线程获取锁的过程中如果执行线程中断命令，会直接抛出异常。</p><p><strong>执行过程：</strong></p><p>调用lockInterruptibly()方法，在获取锁的过程中但是还没获取到锁时（尝试获取锁或正在队列中阻塞等待），如果检测到Thread.isInterrupted，线程会立刻抛出中断异常，但是在这期间并没有处理中断状态，也就是没有调用Thread.currentThread().interrupt()相关方法。异常会一层一层向外抛出，直到调用lockInterruptibly()的位置，由调用者自己处理中断。</p><h4 id="boolean-tryLock"><a href="#boolean-tryLock" class="headerlink" title="boolean tryLock()"></a>boolean tryLock()</h4><p>尝试非阻塞的获取锁，调用该方法立即返回，是一个有返回值的方法，试图申请一个锁，在成功获得锁后返回true，否则，立即返回false，并不会阻塞等待锁释放，线程可以立即离开去做其他的事情。</p><h4 id="boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException"><a href="#boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="boolean tryLock(long time,TimeUnit unit) throws InterruptedException"></a>boolean tryLock(long time,TimeUnit unit) throws InterruptedException</h4><p>超时获取锁，是一个具有超时参数的尝试获取锁的方法，阻塞时间不会超过给定的值；如果成功则返回true。以下情况会返回：</p><ol><li>时间内获取到了锁，返回true</li><li>时间内被中断，返回false</li><li>时间到了没有获取到锁，返回false</li></ol><h3 id="释放锁（继承自Lock接口）"><a href="#释放锁（继承自Lock接口）" class="headerlink" title="释放锁（继承自Lock接口）"></a>释放锁（继承自Lock接口）</h3><h4 id="void-unlock"><a href="#void-unlock" class="headerlink" title="void unlock()"></a>void unlock()</h4><p>释放锁</p><h3 id="条件锁（继承自Lock接口）："><a href="#条件锁（继承自Lock接口）：" class="headerlink" title="条件锁（继承自Lock接口）："></a>条件锁（继承自Lock接口）：</h3><h4 id="Condition-newCondition"><a href="#Condition-newCondition" class="headerlink" title="Condition newCondition()"></a>Condition newCondition()</h4><p>创建一个条件锁</p><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><h4 id="int-getHoldCount"><a href="#int-getHoldCount" class="headerlink" title="int getHoldCount()"></a>int getHoldCount()</h4><p>查询当前线程保持此锁定的个数，即调用lock()方法的次数。</p><pre><code class="line-numbers language-java">    public class ReentrantLockMethodTest1 {             private ReentrantLock reentrantLock = new ReentrantLock();             public void test1(){            try{                reentrantLock.lock();                System.out.println("Lock count---" + reentrantLock.getHoldCount());                test2();            } finally {                reentrantLock.unlock();            }        }             public void test2(){                 try{                reentrantLock.lock();                System.out.println("Lock count---" + reentrantLock.getHoldCount());            }finally {                reentrantLock.unlock();            }        }             public static void main(String[] args){                 ReentrantLockMethodTest1 reentrantLockMethodTest1 = new ReentrantLockMethodTest1();            reentrantLockMethodTest1.test1();        }}</code></pre><p>运行结果：</p><p><img src="/attachment/5c921f7d5b090d746b0c08811899cfd1.png"></p><h4 id="Collection-lt-Thread-gt-getQueuedThreads"><a href="#Collection-lt-Thread-gt-getQueuedThreads" class="headerlink" title="Collection<Thread> getQueuedThreads()"></a>Collection&lt;Thread&gt; getQueuedThreads()</h4><p>返回正在等待获取此锁的线程的集合。</p><h4 id="boolean-isHeldByCurrentThread"><a href="#boolean-isHeldByCurrentThread" class="headerlink" title="boolean isHeldByCurrentThread()"></a>boolean isHeldByCurrentThread()</h4><p>判断当前线程是否获取到了该锁</p><h2 id="ReentrantLock原理总结"><a href="#ReentrantLock原理总结" class="headerlink" title="ReentrantLock原理总结"></a>ReentrantLock原理总结</h2><p>自旋、LockSupport、CAS、队列</p><h3 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h3><p>通过自旋，让线程等待资源被释放。</p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>但是如果一直自旋，就会一直抢占CPU，自旋就是一个死循环，什么也不干，这样反而会白白浪费CPU资源，所以就还引入了LockSupport，来对线程进行休眠阻塞，这样就能把CPU资源释放出来。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS保证了互斥性，可以在不影响太多效率的情况下，让资源不会被多个线程同时进行抢占</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>被阻塞的线程就会被添加到队列中，线程就在队列中排队等待获取资源。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先我们来看获取锁的这几个方法源码实现。主要有：lock()、lockInterruptibly()、tryLock()、tryLock(long time,TimeUnit unit)</p><h3 id="lock-方法"><a href="#lock-方法" class="headerlink" title="lock()方法"></a>lock()方法</h3><p>获取锁，调用该方法当前线程将会获取锁，当锁获取后，该方法将返回。该方法优先考虑获取锁，待获取锁成功后，才响应中断，在获取到锁之前，不会响应中断。</p><p>lock()方法涉及到非公平锁和公平锁两种不同的实现方法，这里我们就从公平锁和非公平锁两个角度来讲解源码的实现。</p><p>后面的其他获取锁的方法有一些也会因为RenntractLock属性sync的实现类不同，而导致实现源码不同的情况。也就是会因公平锁和非公平锁的不同而采用不同的实现方法，但是依旧是使用不同的sycn实现类方法而已。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>这里我们假设ReentrantLock的实例是通过以下方式获得的：</p><pre><code class="line-numbers language-java">ReentrantLock reentrantLock = new ReentrantLock(true); public ReentrantLock(booleanfair) {    sync = fair ? new FairSync() : new NonfairSync();}</code></pre><p>下面的是加锁的主要逻辑：</p><h5 id="FairSync-lock"><a href="#FairSync-lock" class="headerlink" title="FairSync.lock()"></a>FairSync.lock()</h5><pre><code class="line-numbers language-java">// ReentrantLock.lock()public void lock() {    // 调用的sync属性的lock()方法    // 我们这一节讲公平锁，所以这里的sync是FairSync的实例    sync.lock();} // ReentrantLock.FairSync.lock()final void lock() {    // 调用AQS的acquire()方法获取锁    // 注意，这里传的值为1    acquire(1);} // AbstractQueuedSynchronizer.acquire()public final void acquire(int arg) { // AQS提供的可以直接调用的模板方法    // 尝试获取锁    if (!tryAcquire(arg) &amp;&amp; // 锁竞争逻辑        /**         * 如果上面获取锁失败了，就入队等待         * 1、addWaiter()：为当前线程创建一个Node，添加到阻塞等待队列中，队列就是一个双向链表。在这个方法中的线程还是在运行当中的         *    注意addWaiter()这里传入的节点模式为独占模式。addWaiter()入参是用来标识当前锁是共享锁还是互斥锁的标志，ReentrantLock是一个互斥锁，所以这里传入的是Node.EXCLUSIVE互斥标志         * 2、acquireQueued()：对新添加到队列中的等待线程进行阻塞，线程是在这个方法中被阻塞的。线程被阻塞后再被唤醒，会继续在这个方法中自旋去调用tryAcquire(arg)尝试获取锁，最后成功获取锁并返回         */        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        // 这一步操作就是调用中断方法来改变线程的中断状态，这样做就可以把中断信号往外层转递，程序员自己设计的代码也就可以识别到中断信号来自定义相关响应操作。执行这个方法是当前线程肯定是没有获取到锁        selfInterrupt();} // ReentrantLock.FairSync.tryAcquire()protected final boolean tryAcquire(int acquires) { // tryAcquire方法（尝试非阻塞获取锁）是由AQS进行声明，但是需要使用者自行实现的方法。所以这个方法是由ReentrantLock实现的    // 当前线程    final Thread current = Thread.currentThread();    // 查看当前状态变量的值    int c = getState();    // 如果状态变量的值为0，说明暂时还没有人占有锁，可以去尝试获取锁    if (c == 0) {        // !hasQueuedPredecessors()：如果没有其它线程在排队，那么当前线程尝试更新state的值为acquires        // 如果更新成功，则说明当前线程获取了锁        if (!hasQueuedPredecessors() &amp;&amp; // 判断当前是否已经有其他线程正在等待。 通过这个方法就保证了如果等待队列中第一个线程节点被release()唤醒来抢占锁，它是100%能够成功获取锁的，这就是公平锁的特性。如果是非公平锁，当队列头部节点被release()唤醒后就不一定能抢占到锁了，有可能被别的线程抢先一步抢占            compareAndSetState(0, acquires)) { // 相当于一个比较交换的原子操作，由unsafe提供的native本地方法            // 当前线程获取了锁，把自己设置到exclusiveOwnerThread变量中            // exclusiveOwnerThread是AQS的父类AbstractOwnableSynchronizer中提供的变量            setExclusiveOwnerThread(current);            // 返回true说明成功获取了锁            return true;        }    }    // 如果当前线程本身就占有着锁，现在又尝试获取锁，那么，直接让它获取锁并返回true。这里我们就可以看出来ReentrantLock实现了可重入性    else if (current == getExclusiveOwnerThread()) {        // 状态变量state的值加acquires        int nextc = c + acquires;        // 如果溢出了，则报错        if (nextc &lt; 0)            throw new Error("Maximum lock count exceeded");        // 将累加的新状态量设置到state变量中        // 这里不需要CAS更新state        // 因为当前线程占有着锁，其它线程只会CAS把state从0更新成1，是不会成功的        // 所以不存在竞争，自然不需要使用CAS来更新        setState(nextc);        // 当线程获取锁成功        return true;    }    // 当前线程尝试获取锁失败    return false;} // AbstractQueuedSynchronizer.hasQueuedPredecessors()public final boolean hasQueuedPredecessors() {    Node t = tail;     // head指针节点    Node h = head;    Node s;    // 这个方法就是查看队头有没有线程节点，如果有就看一下这个队头线程节点是不是当前线程节点，如果队头存在节点并且不是当前线程节点，就说明此时队列中有别的线程正在等待，返回true    return h != t &amp;&amp;        ((s = h.next) == null || s.thread != Thread.currentThread());} // AbstractQueuedSynchronizer.addWaiter()// 调用这个方法，说明上面tryAcquire()尝试获取锁失败了。addWaiter方法传入的参数是Node的属性：共享属性（Node.SHARED），独占(互斥)属性（Node.EXCLUSIVE）// 线程入队,将Node节点加入同步对联，而Node节点是与Thread绑定的，也就相当于将线程入队。addWaiter这个操作将线程入队之后，并没有将线程阻塞，对线程的阻塞操作在acquireQueued方法中创建节点Node，Node中的重要属性有这些： pre,next,waitestate,thread    waitestate节点的生命状态：信号量  一个节点的waitestate属性值表示的是这个节点下一个节点的生命状态：        SIGNAL = -1 //可被唤醒   指这个节点的下一个节点可被唤醒        CANCELLED = 1 //代表出现异常，中断引起的，需要废弃结束        CONDITION = -2 // 条件等待，这个是在条件锁中使用的Node状态        PROPAGATE = -3 // 传播，可以用来广播的状态        0 // 初始状态Init状态。一个对象被创建出来，int类型的属性默认值都是0 private Node addWaiter(Node mode) {    // 为当前线程创建一个Node节点。Node是AbstractQueuedSynchronizer中的一个静态内部类，主要用来存储线程信息    Node node = new Node(Thread.currentThread(), mode);    /**     * 这里先尝试把新节点加到尾节点后面（尾插法）     * 如果成功了就返回新节点     * 如果没成功再调用enq()方法不断尝试添加     */    // 获取尾节点    Node pred = tail;    // 如果尾节点不为空，则将新建节点尾插到CLH等待队列中    if (pred != null) {        // 设置新节点的前驱节点为现在的尾节点        node.prev = pred;        // CAS更新尾节点为新节点        if (compareAndSetTail(pred, node)) {            // 如果成功了，把旧尾节点的下一个节点指向新节点            pred.next = node;            // 并返回新节点            return node;        }    }    // 如果上面尝试入队新节点没成功（有两个原因：1、被别的线程抢先插入了节点。 2、当前CLH队列还未初始化），调用enq()处理    enq(node);    return node;} // AbstractQueuedSynchronizer.enq()// 将线程节点添加到等待队列private Node enq(final Node node) {    // 自旋，不断尝试将节点添加到CLH等待队列    for (;;) {        // 本轮循环获取现在最新的队列尾节点        Node t = tail;        /**         * 如果尾节点为空，说明队列还未初始化         * 这个分支是为了给CLH队列初始化，在AQS中规定，如果head=tail=null，就说明这个队列还没有初始化。         * 创建一个空的Node节点，然后要head和tail都先指向这个空的节点，这样就完成CLH队列初始化。         * 其实就相当于队列头指向的是一个空节点，然后空节点后面的才是真正存储信息的Node节点。         * 之所以这样设计，是因为每个节点的waitStatus = SIGNAL时，表示的是下一个节点的生存状态，所以队列中第一个存有线程的节点，必须也要有一个前驱结点来标识它的生存状态         */        if (t == null) {            // 初始化head头指针节点和tail尾指针节点            if (compareAndSetHead(new Node())) // 创建一个空的Node节点，并且用CAS将其赋值给head属性                // 将尾节点指向当前初始化的头节点，完成队列初始化。然后在下一轮循环中就可以尝试将Node节点插入队列了                tail = head;        } else {            // 如果尾节点不为空，说明当前队列已经完成了初始化，可以尝试向队列中插入Node节点            // 设置新节点的前一个节点为现在的尾节点            node.prev = t;            // 因为入队也存在竞争，所以通过一个比较交换的原子操作，先看一下当前队列的尾节点是不是我们预想的尾节点t，如果是，说明队列还没有被修改过，插入不存在并发风险，直接插入。            // 如果不是t，说明队列已经被修改，需要重新继续进行自旋，获取最新的tail，来准备入队。            if (compareAndSetTail(t, node)) { // compareAndSetTail方法在判断可以将node尾插到尾部后，就会将node的pre节点指向现在的tail，然后再将tail指向刚刚插入的node节点，这两步是用原子操作完成的                // 成功了，则设置旧尾节点的下一个节点为新节点                t.next = node;                // 并返回旧尾节点，结束自旋                return t;            }        }        // 开始新一轮循环，更新最新的tail节点    }} // AbstractQueuedSynchronizer.acquireQueued()// 调用上面的addWaiter()方法使得新节点已经成功入队了，下面这个方法就是将当前节点阻塞。当线程被唤醒之后，也会在这个方法中继续自旋调用tryAcquire(arg)尝试获取锁，直到成功获取锁后返回//   该方法的返回值是中断标记，如果该方法是正常返回的，那么说明当前线程一定已经成功获取锁了，这个返回值只是用来判断该线程的中断标志的//   如果是true，说明线程是被中断唤醒的，需要响应中断信号，如果是false，则说明线程没有被中断/**    如果当前节点是队列中的第一个线程节点，节点阻塞之前还得再尝试一次获取锁：    1、能够获取到，节点出队，并且把head指针往后挪一个节点，也就是指向了当前节点，然后将当前节点的内部属性都清空，当前节点就变成了head指针节点，也就完成了当前节点的出队    2、不能获取到，将节点阻塞，然后等待被唤醒        1.首先第1轮循环，修改当前节点的前驱节点的的waitStatus生命状态，修改成sinal=-1，表示当前节点可以被唤醒，只有保证当前节点可以被唤醒之后，才可以放心的将其阻塞        2.第2轮循环，阻塞线程，并且需要判断线程是否是由中断信号唤醒的，进而设置中断信号，在该线程成功获取到锁之后去响应中断 */final boolean acquireQueued(final Node node, int arg) {    // 阻塞线程是否失败    boolean failed = true;    try {        // 中断标记，是否要将当前线程中断        boolean interrupted = false;        // 自旋        for (;;) {            // 获取当前节点的前一个节点            final Node p = node.predecessor();            // 判断当前节点的前一个节点是否为head指针节点，如果是，说明当前节点是队列中的第一个线程节点，则不对其进行阻塞，来让这个线程再去尝试抢一次资源。            // 因为阻塞和唤醒操作涉及到用户态和内核态的上下文切换，非常耗时，尽量避免阻塞和唤醒操作。不管是公平锁还是非公平锁acquireQueued()的操作都是一样的            if (p == head &amp;&amp; tryAcquire(arg)) { // 调用ReentrantLock.FairSync.tryAcquire()方法再次尝试获取锁，如果是公平锁，头部节点被唤醒一定能成功获取到锁，但是非公平锁就不一定了                // 尝试获取锁成功，下面就需要将当前节点的node出队                // 将等待队列队中第一个线程节点node出队并不会涉及到并发异常的问题，因为仅仅只是将head指针向后移动一位，不涉及到其他的更改，所以不需要用CAS更新                // 将head指针节点指向node，并且将node节点的前驱节点和代表的线程属性都设置为null                setHead(node);                                /**                 * p是原head指针节点，也就是原来node节点的前驱结点，将原head指针节点从队列中删除                 * 将p节点，也就是head指针节点的next设置为空。                 * 此时head和tail都指向空的node节点，这里虽然没有操作tail的指向，但是在进入到acquireQueued之前，tail就指向了node节点（将node尾插入队列，tail就会指向node节点），                 * 在调用setHead方法的时候，又让head重新指向了node，所以此时head和tail又指向了同一个空节点，恢复到了初始状态                 */                p.next = null; // 这个p.next指向的是原来head指向的节点，但是现在head向后移动了一个位置，所以p节点，也就是原head节点也没什么用了，将其从队列中删除，将它的next指向设置为空，p节点就成了不可达对象，会被GC回收                // 将阻塞标志设置为false，说明没有阻塞节点线程                failed = false;                /**                 * 通过这个源码我们就发现，如果使用lock()方法获取锁，在尝试获取锁的过程中这个方法时忽略了中断信号的。                 * 但是在尝试获取锁的过程中，当前线程的中断状态被一直记录在了该方法中的局部变量interrupted中                 * 当该线程成功获取到锁的时候，才会响应中断信号，将记录在interrupted局部变量中的中断信号向上一层返回，在上一层的selfInterrupt()调用Thread.currentThread().interrupt()方法响应中断                 * 所以lock()方法优先考虑获取锁，待获取锁成功后，才响应中断，在获取到锁之前，不会响应中断。                 */                // 返回中断标记，告诉上一层调用位置，当前线程要不要对其进行中断                return interrupted;            }            /**             * 如果上面没有成功获取到资源，就需要对当前的线程进行阻塞。             * 1、首先判断node节点能否被阻塞             *      shouldParkAfterFailedAcquire()方法用来判断node节点能都被阻塞。             *      这里就是用到了每个Node节点的watStatus属性，只有当一个节点的前驱节点的watStatus属性是-1（可被唤醒）的时候，该节点才可以被从队列中唤醒。             *      这个方法就是用来判断当前node节点是不是可唤醒的状态，只有这个node节点是可唤醒的状态，我们才可以对其进行阻塞。             *      因为如果这个节点不能被唤醒的状态我们就对他阻塞，这个节点将永远不能被唤醒，就会留在线程栈空间中，造成空间浪费堆积。             *              * 2、然后对node节点进行阻塞             *      parkAndCheckInterrupt()方法用来对node节点进行阻塞             *      阻塞的线程会停留在parkAndCheckInterrupt方法中，直到被唤醒。当被阻塞节点在队列中排到第一个节点时，调用release()就会将其唤醒             *      被唤醒之后就会继续进行循环自旋，在下一轮的循环中执行到if (p == head &amp;&amp; tryAcquire(arg))分支时，被唤醒的队列头线程节点（队列头线程节点指的是head指针节点的下一个节点）就能够成功获取到资源了。             *      注意除了队列头线程节点被唤醒之外，其他后面的节点还是处在阻塞状态，不在自旋，这也就是我们前面所说的节约CPU资源。               */            // 判断是否可以将node节点阻塞，如果可以则将其阻塞            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  // 判断node节点能否被唤醒                // 真正对node节点进行阻塞的方法，阻塞之后这个线程就会停在这个方法内                parkAndCheckInterrupt())                // 如果parkAndCheckInterrupt()执行了阻塞并且返回当前线程的中断信号是true，则将这个方法中设置的中断信号变量设置为true，用来向上一层返回当前线程的中断标志                interrupted = true;        }    } finally {        /**         * failed标识当前线程的阻塞有没有失败         * acquireQueued()最初始把failed设置为true，只有进入到成功获取到锁的分支中，才会将failed设置为false。         * 所以除了成功获取锁return导致try{}执行结束以外，其他任何情况导致try{}执行结束都会使failed仍然等于true，也就是没有成功将线程阻塞过         *          * waitStatus = CANCELLED =  1，表示线程已被取消（等待超时或者被中断），需要废弃结束。         * 说的就是这种情况，当一个线程在acquireQueued()方法中因为被中断（响应中断的方法lockInterruptibly()在识别到终端信号之后会直接抛出异常就会将try{}代码块执行结束掉）或等待超时等原因而提前结束，就需要将该线程node节点生命状态设置为CANCELLED         * 在未来该节点的后继节点进入到shouldParkAfterFailedAcquire()方法时，就会将该节点给移出队列         */        // 如果阻塞线程失败了        if (failed)            // 取消获取锁            cancelAcquire(node);    }} // AbstractQueuedSynchronizer.setHead()/** * 将head指向node节点，并且将node节点中的thread线程属性，prev前驱结点指向都清空。将node节点构造成一个空节点 */private void setHead(Node node) {    head = node;    node.thread = null;    node.prev = null;} // AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire()/** * 这个方法是在上面的for()循环里面调用的。该方法用来判断node节点能不能被阻塞，判断规则就是看node节点是不是可被唤醒，只有可被唤醒的节点才可以放心将其阻塞。 * 通过获取node节点的前驱节点pred的waitStatus属性，来判断node节点可不可以被唤醒 * 第一次调用会把前一个节点的等待状态设置为SIGNAL，并返回false * 第二次调用才会返回true *  * 在本章节学习的内容中，总共有两个方法（shouldParkAfterFailedAcquire和unparkSuccessor）会涉及到对Node节点的waitestate属性进行修改，下面我们来简述一下大致变化流程： * 假设当前持有锁的线程是T0，T1是等待队列中的第一个线程节点 * T0线程调用release()方法释放锁时，release()会判断等待队列的head指针节点的waitestate是否不等于0，如果不等于0成立，就会在unparkSuccessor()方法中将head指针节点的waitstate属性设置为0 * release()方法还会通过unparkSuccessor()将head.next，也就是等待队列第一个线程节点T1唤醒，然后这个线程节点就会去继续尝试获取锁 * 但是在非公平锁的场景下，T1获取锁可能会再次失败，被外来的T2线程插队，T2线程抢占到锁。这个时候T1就会需要再次被阻塞，然后再重新走一遍之前走过的流程 * 此时T1的waitestate = 0，所以在第一次进入到shouldParkAfterFailedAcquire()当法中会先将其设置为SIGNA(-1)，然后返回到上层循环中再进行一轮循环，这个时候houldParkAfterFailedAcquire()才会返回true，然后执行后续的阻塞线程操作 * 所以这个T1线程会经历两轮循环，经历了waitestate由 -1 -&gt; 0 -&gt; -1的过程 */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {        /**     * 注意node的waitStatus字段我们在上面创建Node的时候并没有指定     * 也就是说使用的是默认值0     * 这里把各种等待状态再贴出来     *      * static final int CANCELLED =  1; //代表出现异常，中断引起的，需要废弃结束     * static final int SIGNAL    = -1; //可被唤醒   指这个节点的下一个节点可被唤醒     * static final int CONDITION = -2; // 条件等待，这个是在条件锁中使用的Node状态     * static final int PROPAGATE = -3; // 传播，可以用来广播的状态     */    // 获得node节点的前驱节点的waitStatus属性，用来标识node节点是不是可以被唤醒    int ws = pred.waitStatus;    // 如果node节点的前驱节点waitStatus属性为SIGNAL，说明node节点可以被唤醒，也就是可以被阻塞，返回true    if (ws == Node.SIGNAL)        return true;    // 如果node节点的前驱节点waitStatus大于0，说明前驱结点是出现异常的，也就是已取消状态，应该给移除掉（注意waitStatus = 1表示的是当前节点是异常状态，而不是后继节点是异常状态，所以当前节点node会被保留在队列中）    if (ws &gt; 0) {        // 这里就进行一个循环，将node前面连续的，所有waitStatus &gt; 0的结点都从队列中移除        do {            // 这个很好理解，就是一个简单的删除链表节点的过程            node.prev = pred = pred.prev;        } while (pred.waitStatus &gt; 0); // 遍历到节点waitStatus状态不再大于0时，停止删除操作        // 更新node最新的前驱节点        pred.next = node;    // 如果是其他情况，就将前驱结点的waitStatus设置为SIGNAL，也就是将node节点设置为可唤醒状态。    // 但是本次调用还是会返回false，在上一层调用shouldParkAfterFailedAcquire的位置是一个循环，所以返回上一层进行第二轮循环的时候，再次调用shouldParkAfterFailedAcquire，就会直接进入到第一个分支返回true了。    } else {        /**         * 如果前一个节点的状态小于等于0，则把其状态设置为等待唤醒         * 因为这一章节是以互斥锁为例进行讲解，所以这里可以简单地理解为把初始状态0设置为SIGNAL         * CONDITION是条件锁的时候使用的         * PROPAGATE是共享锁使用的         */        // 原子操作，将前驱节点的waitStatus设置为SIGNAL        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    }    return false;} // AbstractQueuedSynchronizer.parkAndCheckInterrupt()// 将当前线程进行阻塞private final boolean parkAndCheckInterrupt() {    // 阻塞当前线程    // 底层调用的是Unsafe的park()方法    LockSupport.park(this);    /**     * 这个作用就是告知上一层这个线程是不是被中断信号唤醒的     * 因为Park阻塞线程唤醒有两种方式：     *   1、中断（interrupt）     *   2、release()     *      * 如果当前线程是中断信号唤醒的，我们需要将这个中断信号向上层传递，告知上一层这个线程被中断了，当这个线程成功获取到锁之后，需要去响应中断     */    /**     * 返回当前线程的中断信号，并且将中断信号清除     *      * 之前有一个疑问，这里向上层返回当前线程的中断信号，为什么不直接使用isInterrupted()来得到中断信号向上返回，而非得使用interrupted()来获取中断信号向上层返回     * 当时觉得用interrupted()获取了中断信号，并且将其清除。将中断信号传递到外层之后，还需要再次使用selfInterrupt()来重新设置中断标志位，多此一举     * 但实际这里使用interrupted()是非常正确的，因为如果一个线程的中断标志位为true,那么LockSupport.park()对该线程将会失去效果，也就是无法对该线程进行阻塞。     * 当一个线程被唤醒以后，并不一定能成功获取锁，可能会被再次阻塞：     *      1、当公平锁等待队列中的非头部线程节点被中断信号唤醒之后，它并不能成功获取到锁，所以会被再次阻塞     *      2、当非公平锁等待队列中的线程节点（头部线程节点或非头部线程节点）被唤醒（release唤醒或中断信号唤醒）都不能保证其一定能获取到锁，都有可能再次被阻塞     * 所以必须保证下次仍能成功将其阻塞才可以，这里必须先暂时将线程的中断信号清除     */    return Thread.interrupted();} // AbstractQueuedSynchronizer.cancelAcquire()// 取消当前线程节点node获取锁，并且将当前节点的waitStatus设置为CANCELLED取消状态。但是此时并不会将该节点移出队列，在未来该节点的后继节点进入到shouldParkAfterFailedAcquire()方法时，才就会将该节点给移出队列// acquireQueued()方法中如果线程没有成功获取锁，try{}代码块中的代码中执行结束，在finally{}中就会执行这个方法，将当前线程的node设置为取消状态private void cancelAcquire(Node node) {    if (node == null)        return;    // 将node节点的线程属性置为空    node.thread = null;    // 将当前节点前面所有连续的waitStatus &gt; 0 的取消状态的节点都从队列中删除    Node pred = node.prev;    while (pred.waitStatus &gt; 0)        node.prev = pred = pred.prev;    // 删除取消状态的节点后，将node节点的前驱结点的next节点赋值给predNext    Node predNext = pred.next;    // 将当前节点设置为取消状态    node.waitStatus = Node.CANCELLED;    // 如果当前节点node是队列的尾部节点，则将node移除掉（使用原子操作，防止并发异常）    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {        compareAndSetNext(pred, predNext, null);    } else {        // If successor needs signal, try to set pred's next-link        // so it will get one. Otherwise wake it up to propagate.        int ws;        if (pred != head &amp;&amp;            ((ws = pred.waitStatus) == Node.SIGNAL ||                (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;            pred.thread != null) {            Node next = node.next;            if (next != null &amp;&amp; next.waitStatus &lt;= 0)                compareAndSetNext(pred, predNext, next);        } else {            unparkSuccessor(node);        }        node.next = node; // help GC    }} // AbstractQueuedSynchronizer.selfInterrupt()// 在acquire()中调用该方法，只有当线程在队列中阻塞等待时，被中断信号唤醒，等到这个线程成功获取到锁之后，就会向上层传递中断信号，进而会调用该方法来响应中断static void selfInterrupt() {    // 设置当前线程的中断信号为true    Thread.currentThread().interrupt();}</code></pre><h5 id="主要方法的调用关系"><a href="#主要方法的调用关系" class="headerlink" title="主要方法的调用关系"></a>主要方法的调用关系</h5><pre><code class="line-numbers language-java">ReentrantLock#lock() // 获取锁-&gt;ReentrantLock.FairSync#lock() // 公平模式获取锁    -&gt;AbstractQueuedSynchronizer#acquire() // AQS的获取锁方法        -&gt;ReentrantLock.FairSync#tryAcquire() // 尝试获取锁        -&gt;AbstractQueuedSynchronizer#addWaiter()  // 尝试获取锁失败，将线程添加到等待队列            -&gt;AbstractQueuedSynchronizer#enq()  // 如果上一个方法入队没有成功，则在这个方法中自旋，不断尝试入队        -&gt;AbstractQueuedSynchronizer#acquireQueued() // 这个方法就是来将入队的线程阻塞，并且里面有个for()循环，线程被唤醒后会在该方法中自旋继续尝试获取锁            -&gt;AbstractQueuedSynchronizer#shouldParkAfterFailedAcquire() // 检查当前节点是否可以被唤醒，进而决定能否对其进行阻塞            -&gt;AbstractQueuedSynchronizer#parkAndCheckInterrupt()  // 真正线程阻塞的方法</code></pre><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>这里我们假设ReentrantLock的实例是通过以下方式获得的（ReentrantLock默认是非公平锁）：</p><pre><code class="line-numbers language-java">ReentrantLock reentrantLock = new ReentrantLock(); // ReentrantLock默认是非公平锁public ReentrantLock() {    sync = new NonfairSync();}</code></pre><p>下面的是加锁的主要逻辑：</p><pre><code class="line-numbers language-java">// ReentrantLock.lock()public void lock() {    sync.lock();} // ReentrantLock.NonfairSync.lock()// 这个方法在公平锁模式下是直接调用的acquire(1);final void lock() {    // 和公平锁相比，这里会先直接尝试CAS更新状态变量，如果此时锁没有被线程占用，就能成功将状态变量由0变为1，即成功获取到锁    if (compareAndSetState(0, 1))        // 如果更新成功，说明获取到锁，把当前线程设为该锁的独占线程        setExclusiveOwnerThread(Thread.currentThread());    else        // 如果没有成功获取到锁，则执行acquire(1)方法，        acquire(1);} // AbstractQueuedSynchronizer.acquire()// 这里面的操作和公平锁都是一样的public final void acquire(int arg) {    // 调用尝试获取锁的方法，如果尝试获取锁失败，则将该线程添加到等待队列中    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();} // ReentrantLock.NonfairSync.tryAcquire()// 这里和公平锁不太一样，这里调用的是非公平锁的acquires方法：nonfairTryAcquire()protected final boolean tryAcquire(int acquires) {    // 调用父类的方法    return nonfairTryAcquire(acquires);} // ReentrantLock.Sync.nonfairTryAcquire()final boolean nonfairTryAcquire(int acquires) {    // 获取当前线程    final Thread current = Thread.currentThread();    // 获取当前state值    int c = getState();    if (c == 0) {        // 如果状态变量的值为0，再次尝试CAS更新状态变量的值        // 相对于公平锁模式少了!hasQueuedPredecessors()条件，非公平锁不需要判断是是否有线程在等待，而是直接去尝试获取锁        if (compareAndSetState(0, acquires)) {            // 将当前线程设置为此锁的占有者            setExclusiveOwnerThread(current);            return true;        }    }    // 如果当前线程就是正在持有此资源的线程，则可直接获取，也就是实现了可重入锁    else if (current == getExclusiveOwnerThread()) {        // 重入锁，累加state值        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error("Maximum lock count exceeded");        // 设置state的值        setState(nextc);        return true;    }    // 没有成功获取锁，则返回false    return false;}</code></pre><p>除了上述代码以外，其他代码流程非公平锁和公平锁都是一样的。</p><h4 id="公平锁和非公平锁总结"><a href="#公平锁和非公平锁总结" class="headerlink" title="公平锁和非公平锁总结"></a>公平锁和非公平锁总结</h4><p>公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock() 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。但是公平锁会先判断等待列中是否有处于等待状态的线程，如果有的话，就乖乖加入到等待线程中去排队，而不能直接插队获取锁。</li><li>非公平锁在调用 lock() 中的第一次CAS 失败后，和公平锁一样都会进入到acquire()方法，然后就会进入到tryAcquire()方法，在 tryAcquire 方法中，非公平锁调用的是自己实现好的nonfairTryAcquire()非公平tryAcquire方法，如果发现锁这个时候被释放了（state == 0），非公平锁就会直接 CAS 抢锁，不会管当前等待队列中有没有等待线程。但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>公平锁和非公平锁就这两点区别，相对于公平锁，非公平锁在一开始就多了两次直接尝试获取锁的过程。如果非公平锁这两次 CAS获取锁 都不成功，那么<mark style="background: #BBFABBA6;">后面非公平锁和公平锁的流程就是一样的，都要进入到阻塞队列等待唤醒</mark>。相对来说，<mark style="background: #BBFABBA6;">非公平锁会有更好的性能，因为它的吞吐量比较大</mark>。当然，<mark style="background: #BBFABBA6;">非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态</mark>。</p><h4 id="为什么ReentrantLock默认采用的是非公平模式？"><a href="#为什么ReentrantLock默认采用的是非公平模式？" class="headerlink" title="为什么ReentrantLock默认采用的是非公平模式？"></a>为什么ReentrantLock默认采用的是非公平模式？</h4><p>因为非公平模式效率比较高。之所以非公平效率高，是因为非公平模式会在一开始就尝试两次获取锁，如果当时正好state的值为0，它就会成功获取到锁，少了排队导致的阻塞/唤醒过程，并且减少了线程频繁的切换带来的性能损耗。</p><p>但是非公平模式也有一些弊端，比如非公平模式有可能会导致一开始排队的线程一直获取不到锁，导致线程饿死。</p><h3 id="lockInterruptibly-方法"><a href="#lockInterruptibly-方法" class="headerlink" title="lockInterruptibly()方法"></a>lockInterruptibly()方法</h3><ul><li>ReentrantLock.lockInterruptibly()：允许在尝试获取锁时由其它线程调用尝试获取锁的线程的Thread.interrupt方法来中断线程而直接返回，这时不用获取到锁，而会直接抛出一个InterruptedException。</li><li>ReentrantLock.lock()：方法不允许Thread.interrupt中断,即使检测到Thread.isInterrupted，一样会继续尝试获取锁，获取失败则阻塞等待。只是在最后获取锁成功后再把当前线程置为interrupted状态。</li></ul><p>总的来说，lockInterruptibly()支持线程中断，它与lock()方法的主要区别在于lockInterruptibly()获取锁的时候如果线程中断了，会抛出一个异常，而lock()不会管线程是否中断都会一直尝试获取锁，获取锁之后把自己标记为已中断，继续执行自己的逻辑，后面也会正常释放锁。我们就记住：</p><p>使用lockInterruptibly时：当前线程可以被其他线程直接中止结束，并且在其他线程中抛出异常信息；（优先考虑响应中断）<br>使用lock时：当前线程也可以响应其他线程的中断命令，但不会抛出异常信息，不会直接中止，而是会在成功获取到锁时将自己的中断标志设置true；（优先考虑获取锁）</p><p>具体实现以及与lock()方法的对比如下：</p><h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h4><pre><code class="line-numbers language-java">// ReentrantLock.lockInterruptibly()// 相当于ReentrantLock.lock()public void lockInterruptibly() throws InterruptedException {    // 这里调用的sync的acquireInterruptibly()方法，该方法是sync继承自AbstractQueuedSynchronizer的方法，由抽象类AbstractQueuedSynchronizer实现    sync.acquireInterruptibly(1);} // AbstractQueuedSynchronizer.acquireInterruptibly()// 相当于acquire(int arg)方法public final void acquireInterruptibly(int arg) throws InterruptedException {    // 在第一次调用acquireInterruptibly时，如果发现当前线程已经被中断了，则直接抛出中断异常，响应中断    if (Thread.interrupted())        throw new InterruptedException();        // 尝试获取锁    // 这里调用的sync的tryAcquire()方法，它的具体实现是根据当前ReentrantLock是公平锁还是非公平锁来决定的    // 如果当前sync是公平锁tryAcquire()方法就是使用的FairSync实现类中的tryAcquire()实现方法，如果当前是非公平锁，则使用的是NonfairSync实现类中的tryAcquire()方法，也就是nonfairTryAcquire()方法    if (!tryAcquire(arg))        // 尝试获取所失败之后        doAcquireInterruptibly(arg);}</code></pre><p>doAcquireInterruptibly()方法与acquireQueue()差别在于方法的返回途径有两种，一种是for循环结束，正常获取到锁；另一种是线程被唤醒后检测到中断请求，则立即抛出中断异常，该操作导致方法结束。</p><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.doAcquireInterruptibly()// 相当于acquireQueued(addWaiter(Node.EXCLUSIVE), arg))，将获取锁失败的线程添加到等待队列并阻塞private void doAcquireInterruptibly(int arg) throws InterruptedException {    // 为当前线程创建Node线程节点，并将其入队    final Node node = addWaiter(Node.EXCLUSIVE);    // 入队之后，开始对线程进行阻塞    // 阻塞线程是否失败    boolean failed = true;    try {        // 自旋        for (;;) {            // 获取当前节点的前一个节点            final Node p = node.predecessor();            // 如果当前节点是等待队列中的第一个线程节点，则调用tryAcquire()尝试获取锁            if (p == head &amp;&amp; tryAcquire(arg)) {                // 尝试获取锁成功，下面就需要将当前节点的node出队                // 将head指针节点指向node，并且将node节点的前驱节点和代表的线程属性都设置为null                setHead(node);                p.next = null; // help GC                // 将阻塞标志设置为false，说明没有阻塞节点线程                failed = false;                // 1.这里没有中断标识，也就没有返回中断标志，而是直接返回结束方法                // lock和lockInterruptibly区别就是对中断的处理方式                 return;            }            // shouldParkAfterFailedAcquire：判断线程可否安全阻塞            // parkAndCheckInterrupt：挂起线程并返回当时中断标识Thread.interrupted()            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                // 2.当parkAndCheckInterrupt返回中断标识为true时立即抛出异常中断线程，而不是和lock()一样记录中断标志，等到获取锁成功之后再响应中断                throw new InterruptedException();        }     // finally的执行一定会在throw new InterruptedException();抛出异常之前执行。finally代码块中的代码不管什么情况下，一定会被执行的    } finally {         /**         * failed标识当前线程的阻塞有没有失败         * doAcquireInterruptibly()最初始把failed设置为true，只有进入到成功获取到锁的分支中，才会将failed设置为false。         * 所以除了成功获取锁return导致try{}执行结束以外，其他任何情况导致try{}执行结束都会使failed仍然等于true，也就是没有成功将线程阻塞过         *          * waitStatus = CANCELLED =  1，表示线程已被取消（等待超时或者被中断），需要废弃结束。         * 说的就是这种情况，当一个线程在doAcquireInterruptibly()方法中因为被中断（响应中断的方法lockInterruptibly()在识别到终端信号之后会直接抛出异常就会将try{}代码块执行结束掉）或等待超时等原因而提前结束，就需要将该线程node节点生命状态设置为CANCELLED         * 在未来该节点的后继节点进入到shouldParkAfterFailedAcquire()方法时，就会将该节点给移出队列         */        // 如果阻塞线程失败了        if (failed)            // 取消获取锁，标注当前节点的生命状态为canceld信号量，这种状态的节点应该剔除            cancelAcquire(node);    }}</code></pre><p>除以上代码，其他的方法源码都和lock()一致。</p><h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><p>lock()会先尝试获取锁，失败后再将线程入队并阻塞等待，会在获取锁成功之后调用selfInterrupt()来将线程的中断标志设置true来响应中断：</p><pre><code class="line-numbers language-java">public final void acquire(int arg) {    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        // 获取锁成功后，中断当前线程。默认处理中断方式        selfInterrupt();}</code></pre><p>addWaiter封装Node节点插入到队列尾部，acquireQueued负责队列的挂起、出队、是否中断。acquireQueued方法只有一种返回途径，就是通过for循正常返回时，必定是成功获取到了锁。</p><pre><code class="line-numbers language-java">final boolean acquireQueued(final Node node, int arg) {    boolean failed = true;    try {        boolean interrupted = false;        for (;;) {            final Node p = node.predecessor();            if (p == head &amp;&amp; tryAcquire(arg)) {                setHead(node);                p.next = null; // help GC                failed = false;                // 1.在独占锁后，才返回中断标识                return interrupted;            }            //shouldParkAfterFailedAcquire：判断线程可否安全挂起            //parkAndCheckInterrupt：挂起线程并返回当时中断标识Thread.interrupted()            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                // 2.当parkAndCheckInterrupt返回中断标识为true时修改interrupted                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ReentrantLock的lockInterruptibly(中断)和lock(非中断加锁模式)的区别在于：线程尝试获取锁操作失败后，在等待过程中，如果该线程被其他线程中断了，它是如何响应中断请求的。lock方法会忽略中断请求，继续获取锁直到成功；而lockInterruptibly则直接抛出中断异常来立即响应中断，由上层调用者处理中断。</p><p>那么，为什么要分为这两种模式呢？这两种加锁方式分别适用于什么场合呢？根据它们的实现语义来理解，lock()适用于锁获取操作不受中断影响的情况，此时可以忽略中断请求正常执行加锁操作，因为该操作仅仅记录了中断状态（通过Thread.currentThread().interrupt()操作，只是恢复了中断状态为true，并没有对中断进行响应)。如果要求被中断线程不能参与锁的竞争操作，则此时应该使用lockInterruptibly方法，一旦检测到中断请求，立即返回不再参与锁的竞争并且取消锁获取操作（即finally中的cancelAcquire操作）</p><h3 id="tryLock-方法"><a href="#tryLock-方法" class="headerlink" title="tryLock()方法"></a>tryLock()方法</h3><p>尝试获取一次锁，成功了就返回true，没成功就返回false，不会继续尝试。</p><pre><code class="line-numbers language-java">// ReentrantLock.tryLock()public boolean tryLock() {    // 直接调用Sync的nonfairTryAcquire()方法    return sync.nonfairTryAcquire(1);} // ReentrantLock.Sync.nonfairTryAcquire()final boolean nonfairTryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    // 如果判断此时锁没有被占用    if (c == 0) {        // 通过CAS尝试获取锁，如果尝试失败则直接返回false        if (compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    // 如果此时锁已经被线程占用了，但是占用着就是当前线程，则直接进入累加同步状态变量。实现ReentrantLock的可重入特性    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error("Maximum lock count exceeded");        setState(nextc);        return true;    }    // 如果获取锁失败，直接返回false，不进入等待队列阻塞等待    return false;}</code></pre><p>tryLock()方法比较简单，直接以非公平的模式去尝试获取一次锁，获取到了或者锁本来就是当前线程占有着就返回true，否则返回false。</p><h3 id="tryLock-long-time-TimeUnit-unit-方法"><a href="#tryLock-long-time-TimeUnit-unit-方法" class="headerlink" title="tryLock(long time, TimeUnit unit)方法"></a>tryLock(long time, TimeUnit unit)方法</h3><p>尝试获取锁，并等待一段时间，如果在这段时间内都没有获取到锁，就返回false。该方法也优先响应中断，检测到中断信号就直接抛出异常结束方法。</p><pre><code class="line-numbers language-java">// ReentrantLock.tryLock()public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {    // 调用AQS中的方法    return sync.tryAcquireNanos(1, unit.toNanos(timeout));} // AbstractQueuedSynchronizer.tryAcquireNanos()public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {    // 如果线程中断了，抛出异常    if (Thread.interrupted())        throw new InterruptedException();    // 先尝试获取一次锁    return tryAcquire(arg) ||        doAcquireNanos(arg, nanosTimeout);} // AbstractQueuedSynchronizer.doAcquireNanos()// 相当于acquireQueued(addWaiter(Node.EXCLUSIVE), arg))，将获取锁失败的线程添加到等待队列并阻塞。并且该方法也优先响应中断，如果检测到中断信号就会直接抛出异常结束方法private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {    // 如果时间已经到期了，直接返回false    if (nanosTimeout &lt;= 0L)        return false;    // 到期时间    final long deadline = System.nanoTime() + nanosTimeout;    // AbstractQueuedSynchronizer.addWaiter()      // 为当前线程创建一个Node，添加到阻塞等待队列中，队列就是一个双向链表。在这个方法中的线程还是在运行当中的    // 注意addWaiter()这里传入的节点模式为独占模式。addWaiter()入参是用来标识当前锁是共享锁还是互斥锁的标志，ReentrantLock是一个互斥锁，所以这里传入的是Node.EXCLUSIVE互斥标志    final Node node = addWaiter(Node.EXCLUSIVE);    // 将阻塞标志设置为true，如果中途因为异常结束方法，还没来得及成功获取资源将failed设置为false，则在finally代码块中执行取消获取锁的方法    boolean failed = true;    try {        for (;;) {            // 获取当前节点的前一个节点            final Node p = node.predecessor();            // 判断当前节点的前一个节点是否为head指针节点，如果是，说明当前节点是队列中的第一个线程节点，来让这个线程再去尝试抢一次资源。            // tryAcquire(arg) 抢占线程的实现方式取决于当前sync是公平锁还是非公平锁，这里就是使用的sync.tryAcquire()。            if (p == head &amp;&amp; tryAcquire(arg)) {                // 抢占资源成功                setHead(node);                p.next = null; // help GC                // 未阻塞线程                failed = false;                // 返回true                return true;            }            // 计算当前离阻塞终止时间还有多久            nanosTimeout = deadline - System.nanoTime();            // 如果离阻塞终止时间小于等于0，说明已经到期了，就直接返回false，结束阻塞等待            if (nanosTimeout &lt;= 0L)                return false;            // spinForTimeoutThreshold = 1000L;            // 只有到期时间大于1000纳秒，才阻塞            // 小于等于1000纳秒，直接自旋解决就得了            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                nanosTimeout &gt; spinForTimeoutThreshold)                // 阻塞一段时间                // tryLock(long time, TimeUnit unit)方法在阻塞的时候会使用LockSupport.parkNanos()方法加上阻塞时间，并且会随时检查是否到期，只要到期了没获取到锁就返回false。                LockSupport.parkNanos(this, nanosTimeout);            if (Thread.interrupted())                throw new InterruptedException();        }    } finally {        //  failed标识当前线程的阻塞有没有失败        if (failed)            // 如果阻塞线程失败了，则取消获取锁            cancelAcquire(node);    }}</code></pre><h3 id="unlock-方法"><a href="#unlock-方法" class="headerlink" title="unlock()方法"></a>unlock()方法</h3><p>下面，我们再来看释放锁的unlock()方法源码。</p><p>公平锁和非公平锁在释放锁时是没有区别的，都是通过调用的AQS提供的模板方法实现的。</p><pre><code class="line-numbers language-java">// java.util.concurrent.locks.ReentrantLock.unlock()public void unlock() {    // 这里调用AQS释放锁的模板方法    sync.release(1);} // java.util.concurrent.locks.AbstractQueuedSynchronizer.release()  AQS提供的模板方法//  Park阻塞线程唤醒有两种方式：// 1、中断// 2、release()public final boolean release(int arg) {    // 调用AQS实现类的tryRelease()方法释放锁    if (tryRelease(arg)) {        // 成功释放资源        Node h = head;        // 如果头节点不为空，且等待状态不是0，就唤醒下一个节点        // 还记得waitStatus吗？        // 在每个节点阻塞之前会把其上一个节点的等待状态设为SIGNAL（-1）        // 所以，SIGNAL的准确理解应该是唤醒下一个等待的线程        if (h != null &amp;&amp; h.waitStatus != 0)            /**             * 将head的next节点的线程唤醒，并且将head节点的waitStatus重新恢复成0             * （这里之前我觉得保持原样-1更好，这样就能避免如果唤醒的线程再一次抢占资源的时候失败（这种情况在非公平锁可能发生，但是在公平锁不可能发生），             * 然后重新去对其进行阻塞的时候，判断它的是否可换性状态的时候，就可以直接判断是-1，然后进行阻塞了，不需要再重新将0设置为-1，             * 然后再进行第二轮循环，去设置对其进行阻塞。但是上这里将waitStatus还是保留-1都可以，源码这样写应该只是为了让抢锁的线程多一次抢占机会而已，没有别的作用)             */            unparkSuccessor(h);        return true;    }    return false;} // java.util.concurrent.locks.ReentrantLock.Sync.tryRelease()   Sync实现类覆写的tryRelease()protected final boolean tryRelease(int releases) {    // 计算释放锁之后该占有该资源的线程数    int c = getState() - releases;    // 如果当前线程不是占有着锁的线程，抛出异常    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    // 标识是否成功释放资源        boolean free = false;    // 如果状态变量的值为0了，说明完全释放了锁，则将占有该资源的线程变量置为空，这样其他的线程就可以来抢占该资源了    // 这也就是为什么重入锁调用了多少次lock()就要调用多少次unlock()的原因    // 如果不这样做，会导致锁不会完全释放，别的线程永远无法获取到锁    if (c == 0) {        // 置为true        free = true;        // 清空占有线程        setExclusiveOwnerThread(null);    }    // 设置状态变量的值    setState(c);    // 返回是否完全释放了资源    return free;} // java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor()// 这里就是将线程节点唤醒，接触阻塞状态, 传入的node就是队列的head指针节点private void unparkSuccessor(Node node) {    // 注意，这里的node是头节点        /*    * If status is negative (i.e., possibly needing signal) try    * to clear in anticipation of signalling.  It is OK if this    * fails or if status is changed by waiting thread.    * 如果状态是负的，尝试去清除这个信号，就把它设置为0。当然，如果清除失败或者说被其他    * 等待获取锁的线程修改了，也没关系。    * 这里为什么要去把状态修改为0呢？其实这个线程是要被唤醒的，修不修改都无所谓。    * 回忆一下上面的acquireQueued方法中调用了shouldParkAfterFailedAcquire    * 去把前一个节点状态改为-1，而在改之前会抢占一次锁，所以说这里的操作    * 其实并没有太大用处，可能可以为争抢锁的线程再多一次抢锁机会，故而成功失败均不影响    */    int ws = node.waitStatus;    // 状态为负值表示后继节点结点处于有效等待状态    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    /*    * Thread to unpark is held in successor, which is normally    * just the next node.  But if cancelled or apparently null,    * traverse backwards from tail to find the actual    * non-cancelled successor.    * 唤醒后继节点，通常是next节点，但是如果next节点被取消了或者为空，那么    * 就需要从尾部开始遍历，将无效节点先剔除    */    // 头节点的下一个节点    Node s = node.next;    // 如果下一个节点为空，或者其等待状态大于0（实际为已取消）    if (s == null || s.waitStatus &gt; 0) {        s = null;        // 从尾节点向前遍历取到队列最前面的那个状态不是已取消状态的节点        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    }    // 如果下一个节点不为空，则唤醒它    if (s != null)        LockSupport.unpark(s.thread);}</code></pre><p>释放锁的过程大致为：</p><ul><li>将state的值减1；</li><li>如果state减到了0，说明已经完全释放锁了，唤醒下一个等待着的节点；</li></ul><h3 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h3><p>ReentrantLock是通过继承AQS的内部类来实现条件锁的。通过创建一个条件锁的实体类ConditionObject，然后通过这个类来实现各种条件锁的功能。</p><pre><code class="line-numbers language-java">public class ReentrantLock implements Lock, java.io.Serializable {    private final Sync sync;    // 创建条件锁    public Condition newCondition() {        return sync.newCondition();    }    /**     * 抽象内部类     */    abstract static class Sync extends AbstractQueuedSynchronizer {        // 条件锁        final ConditionObject newCondition() {            return new ConditionObject();        }    }}</code></pre><h2 id="ReentrantLock总结图"><a href="#ReentrantLock总结图" class="headerlink" title="ReentrantLock总结图"></a>ReentrantLock总结图</h2><h3 id="总体流程图"><a href="#总体流程图" class="headerlink" title="总体流程图"></a>总体流程图</h3><p><img src="/attachment/a170dfec30f2469813728eb96e599b52.png"></p><h3 id="同步队列图"><a href="#同步队列图" class="headerlink" title="同步队列图"></a>同步队列图</h3><p><img src="/attachment/824cbb9f228cd3823fe700030b666144.png"></p><h3 id="调用层级图"><a href="#调用层级图" class="headerlink" title="调用层级图"></a>调用层级图</h3><p><img src="/attachment/db6d66e1219fa5ff0dd0931c957b27c7.png"></p><h2 id="性质分析"><a href="#性质分析" class="headerlink" title="性质分析"></a>性质分析</h2><h3 id="实现可重入"><a href="#实现可重入" class="headerlink" title="实现可重入"></a>实现可重入</h3><p>可重入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁阻塞，该特性的首先需要解决以下两个问题：</p><p>线程再次获取锁：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取成功；<br>锁的最终释放：线程重复n次获取了锁，随后在第n次释放该锁后，其它线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前线程被重复获取的次数，而被释放时，计数自减，当计数为0时表示锁已经成功释放。<br>ReentrantLock是通过自定义同步器来实现锁的获取与释放，我们以非公平锁（默认）实现为例，对锁的获取和释放进行详解。</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平性与否是针对锁获取顺序而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合FIFO原则。我们在前面介绍了非公平锁NonfairSync调用的nonfairTryAcquire(int)方法，在该方法中，只要通过CAS操作修改同步状态成功，则当前线程就获取到了锁，而公平锁则不同, </p><p>与nonfairTryAcquire(int)方法比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法, </p><p>该方法主要是对同步队列中当前节点是否有前驱节点进行判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p><h3 id="显式锁和隐式锁的区别（synchronized和lock的区别）"><a href="#显式锁和隐式锁的区别（synchronized和lock的区别）" class="headerlink" title="显式锁和隐式锁的区别（synchronized和lock的区别）"></a>显式锁和隐式锁的区别（synchronized和lock的区别）</h3><p>在面试的过程中有可能会问到：在Java并发编程中，锁有两种实现：使用隐式锁和使用显示锁分别是什么？两者的区别是什么？</p><p>所谓的显式锁和隐式锁的区别也就是说说Synchronized(下文简称：sync)和lock(下文就用ReentrantLock来代之lock)的区别。</p><p>Synchronized是JVM级别实现的锁和ReentantLock实现是完全不同的。</p><p>本节的主要内容：将通过七个方面详细介绍sync和lock的区别。通过生活case中的X二代和普通人比较大家更容易理解这两者之间的区别</p><p>Java中隐式锁：synchronized；显式锁：lock</p><h4 id="出身不同"><a href="#出身不同" class="headerlink" title="出身不同"></a>出身不同</h4><p>从sync和lock的出身(原始的构成)来看看两者的不同。</p><p>Sync：Java中的关键字，是由JVM来维护的。是JVM层面的锁。<br>Lock：是JDK5以后才出现的具体的类。使用lock是调用对应的API。是API层面的锁。</p><p>sync是底层是通过monitorenter进行加锁（底层是通过monitor对象来完成的，其中的wait/notify等方法也是依赖于monitor对象的。只有在同步块或者是同步方法中才可以调用wait/notify等方法的。因为只有在同步块或者是同步方法中，JVM才会调用monitory对象的）；通过monitorexit来退出锁的。</p><p>而lock是通过调用对应的API方法来获取锁和释放锁的。</p><h4 id="使用方式不同"><a href="#使用方式不同" class="headerlink" title="使用方式不同"></a>使用方式不同</h4><p>Sync是隐式锁，Lock是显示锁。所谓的显示和隐式就是在使用的时候，使用者要不要手动写代码去获取锁和释放锁的操作。</p><p>我们大家都知道，在使用sync关键字的时候，我们使用者根本不用写其他的代码，然后程序就能够获取锁和释放锁了。那是因为当sync代码块执行完成之后，系统会自动的让程序释放占用的锁。Sync是由系统维护的，如果非逻辑问题的话话，是不会出现死锁的。</p><p><mark style="background: #FFB8EBA6;">在使用lock的时候，我们使用者需要手动的获取和释放锁。</mark>如果没有释放锁，就有可能导致出现死锁的现象。手动获取锁方法：lock.lock()。释放锁：unlock方法。需要配合tyr/finaly语句块来完成。</p><p>用生活中的一个case来形容这个不同：官二代和普通人的你在进入机关大院的时候待遇。官二代不需要出示什么证件就可以进入，但是你需要手动出示证件才可以进入。</p><h4 id="等待是否可中断"><a href="#等待是否可中断" class="headerlink" title="等待是否可中断"></a>等待是否可中断</h4><p>Sync是不可中断的。除非抛出异常或者正常运行完成。</p><p>Lock可以中断的。中断方式：</p><p>1：调用设置超时方法tryLock(long timeout ,timeUnit unit)<br>2：调用lockInterruptibly()放到代码块中，然后调用interrupt()方法可以中断</p><p>生活中小case来理解这一区别：官二代一般不会做饭。都会去餐厅点餐等待着餐厅出餐。普通人的你既可以去餐厅等待，如果等待时间长的话，你就可以回去自己做饭了。</p><h4 id="加锁的时候是否可以公平"><a href="#加锁的时候是否可以公平" class="headerlink" title="加锁的时候是否可以公平"></a>加锁的时候是否可以公平</h4><p>Sync：非公平锁</p><p>lock：两者都可以的。默认是非公平锁。在其构造方法的时候可以传入Boolean值，true：公平锁，false：非公平锁</p><p>生活中小case来理解这个区别：官二代一般都不排队，喜欢插队的。普通人的你虽然也喜欢插队。但是如果遇到让排队的情况下，你还是会排队的。</p><h4 id="锁绑定多个条件来condition"><a href="#锁绑定多个条件来condition" class="headerlink" title="锁绑定多个条件来condition"></a>锁绑定多个条件来condition</h4><p>Sync：没有。要么随机唤醒一个线程；要么是唤醒所有等待的线程。<br>Lock: 用来实现分组唤醒需要唤醒的线程，可以精确的唤醒，而不是像sync那样，不能精确唤醒线程。</p><h4 id="从性能比较"><a href="#从性能比较" class="headerlink" title="从性能比较"></a>从性能比较</h4><p>synchronized是托管给JVM执行的，而lock是Java写的控制锁的代码。</p><p>在Java8版本中，在一开始线程没有很多的情况下，ReentrantLock效率比synchronized略高，但是仍在一个数量级上，随着线程增加到一定的数量，synchronized的效率比ReentrantLock非公平锁高了。</p><p>生活小case理解：在我们一般的认知中，官二代一般都是比较坑爹的吧。但是这几年也有很多官二代或者是富二代改变了态度，端正自己态度，靠自己能力而不是拼爹了。</p><h4 id="从使用锁的方式比较"><a href="#从使用锁的方式比较" class="headerlink" title="从使用锁的方式比较"></a>从使用锁的方式比较</h4><p>synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。</p><p>而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swa )。我们已经详细讲解了ReentrantLock的源代码，也发现了其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。</p><p>现代的CPU提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而compareAndSet()就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p><h3 id="Synchronized-和-ReenTrantLock-的对比总结"><a href="#Synchronized-和-ReenTrantLock-的对比总结" class="headerlink" title="Synchronized 和 ReenTrantLock 的对比总结"></a>Synchronized 和 ReenTrantLock 的对比总结</h3><h4 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h4><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><h4 id="synchronized-依赖于-JVM-而-ReenTrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReenTrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</h4><p>synchronized 是依赖于 JVM 实现的，是Java原生关键字锁。前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p><p>ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），是Java语言层面提供的锁。所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h4 id="ReenTrantLock-比-synchronized-增加了一些高级功能"><a href="#ReenTrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReenTrantLock 比 synchronized 增加了一些高级功能"></a>ReenTrantLock 比 synchronized 增加了一些高级功能</h4><p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p><p>ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。<br>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。<br>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p><h4 id="性能已不是选择标准"><a href="#性能已不是选择标准" class="headerlink" title="性能已不是选择标准"></a>性能已不是选择标准</h4><p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。</p><p>既然ReentrantLock的功能更丰富，而且效率也不低，我们是不是可以放弃使用synchronized了呢？</p><p>并不是的。因为synchronized是Java原生支持的，随着Java版本的不断升级，Java团队也是在不断优化synchronized，所以我认为在功能相同的前提下，最好还是使用原生的synchronized关键字来加锁，这样我们就能获得Java版本升级带来的免费的性能提升的空间。</p><p>另外，在Java8的ConcurrentHashMap中已经把ReentrantLock换成了synchronized来分段加锁了，这也是Java版本不断升级带来的免费的synchronized的性能提升。</p><table><thead><tr><th>功能</th><th>ReentrantLock</th><th>synchronized</th></tr></thead><tbody><tr><td>可重入</td><td>支持</td><td>支持</td></tr><tr><td>非公平</td><td>支持（默认）</td><td>支持</td></tr><tr><td>加锁/解锁方式</td><td>需要手动加锁、解锁，一般使用try..finally..保证锁能够释放</td><td>手动加锁，无需刻意解锁</td></tr><tr><td>按key锁</td><td>不支持，比如按用户id加锁</td><td>支持，synchronized加锁时需要传入一个对象</td></tr><tr><td>公平锁</td><td>支持，new ReentrantLock(true)</td><td>不支持</td></tr><tr><td>中断</td><td>支持，lockInterruptibly()</td><td>不支持</td></tr><tr><td>尝试加锁</td><td>支持，tryLock()</td><td>不支持</td></tr><tr><td>超时锁</td><td>支持，tryLock(timeout, unit)</td><td>不支持</td></tr><tr><td>获取当前线程获取锁的次数</td><td>支持，getHoldCount()</td><td>不支持</td></tr><tr><td>获取等待的线程</td><td>支持，getWaitingThreads()</td><td>不支持</td></tr><tr><td>检测是否被当前线程占有</td><td>支持，isHeldByCurrentThread()</td><td>不支持</td></tr><tr><td>检测是否被任意线程占有</td><td>支持，isLocked()</td><td>不支持</td></tr><tr><td>条件锁</td><td>可支持多个条件，condition.await()，condition.signal()，condition.signalAll()</td><td>只支持一个，obj.wait()，obj.notify()，obj.notifyAll()</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Condition条件锁</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-condition-tiao-jian-suo/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-condition-tiao-jian-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Condition条件锁"><a href="#【Java-多线程并发】-Condition条件锁" class="headerlink" title="【Java 多线程并发】 Condition条件锁"></a>【Java 多线程并发】 Condition条件锁</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Condition条件锁date: 2023-07-04 16:54tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 Condition条件锁</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>条件锁中也维护了一个队列，为了和AQS的同步队列区分，我这里称为条件队列，firstWaiter是队列的头节点，lastWaiter是队列的尾节点。</p><p><strong>Condition的条件队列和AQS的同步队列不完全一样</strong></p><p>Condition的条件队列和AQS的同步队列都是通过节点类Node组成的。<br>但是AQS的队列头节点是不存在任何值的，是一个虚节点； Condition的队列头节点是存储着实实在在的元素值的，是真实节点。<br>而且条件队列是一个单向队列，同步队列是一个双向队列</p><p><strong>await()方法</strong></p><p>先释放锁-&gt;等待条件-&gt;再次获取锁的过程</p><p><strong>signal()方法</strong></p><p>调用signal()方法的线程调用unlock()方法才是真正唤醒阻塞在条件上的节点<br>被唤醒之后，被唤醒的节点会再次尝试获取锁</p><p><img src="/attachment/f56b7827028739aaf2d301aee6eed091.png"></p><h2 id="【Java-多线程并发】-Condition条件锁-1"><a href="#【Java-多线程并发】-Condition条件锁-1" class="headerlink" title="【Java 多线程并发】 Condition条件锁"></a>【Java 多线程并发】 Condition条件锁</h2><p>任何一个Java对象都天然继承于Object类，在线程间实现通信的往往会应用到Object的几个方法，比如wait()，wait(long timeout)，wait(long timeout, int nanos)与notify()，notifyAll()几个方法实现等待/通知机制，同样的， 在java Lock体系下依然会有同样的方法实现等待/通知机制。从整体上来看Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是Java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。两者除了在使用方式上不同外，在功能特性上还是有很多的不同：</p><p><img src="/attachment/8575714f75a435eb9c8206d8cab51d78.png"></p><p>本章节我们就来详细讲解一下条件锁在Java中的实现。条件锁，就是指在获取锁之后发现当前业务场景自己无法处理，而需要等待某个条件的出现才可以继续处理时使用的一种锁。</p><p>比如，在阻塞队列中，当队列中没有元素的时候是无法弹出一个元素的，这时候就需要阻塞在条件notEmpty上，等待其它线程往里面放入一个元素后，唤醒这个条件notEmpty，当前线程才可以继续去做“弹出一个元素”的行为。</p><p>注意，这里的条件，必须是在<strong>获取锁之后去等待</strong>，对应到ReentrantLock的条件锁，就是获取锁之后才能调用condition.await()方法。</p><p>在Java中，条件锁的实现都在AQS的ConditionObject类中，ConditionObject实现了Condition接口，所以ReentrantLock的条件锁是基于AQS实现的。下面我们通过一个例子来进入到条件锁的学习中。</p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><pre><code class="line-numbers language-java">public class ReentrantLockTest {    public static void main(String[] args) throws InterruptedException {        // 声明一个重入锁        ReentrantLock lock = new ReentrantLock();        // 声明一个条件锁        Condition condition = lock.newCondition();        // 创建一个线程并执行，该线程就是当达到条件锁条件后，来执行后续的相关逻辑的。可以看作是一个消费者        new Thread(()-&gt;{            try {                // 获取锁                lock.lock();  // 1                try {                    System.out.println("before await");  // 2                    // 等待条件   该线程执行到这里就会进入到阻塞状态，直到达到了条件后，由其他线程执行signal()方法来告知该线程已经达到条件了，该线程就会在这里被唤醒继续向下执行                    condition.await();  // 3                    System.out.println("after await");  // 10                } finally {                    // 释放锁                    lock.unlock();  // 11                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }).start();                // 这里睡1000ms是为了让上面的线程先获取到锁        Thread.sleep(1000);        // main方法的当前线程来获取锁，该线程就是用来进行相关业务处理，进而达到条件锁条件的。可以看作是一个生产者        lock.lock();  // 4        try {            // 这里睡2000ms代表这个线程执行业务需要的时间，当完成这里的2000ms之后就认为是符合条件锁条件了            Thread.sleep(2000);  // 5            System.out.println("before signal");  // 6            // 通知条件已成立            condition.signal();  // 7            System.out.println("after signal");  // 8        } finally {            // 释放锁            lock.unlock();  // 9        }    }}</code></pre><p>上面的代码很简单，一个线程等待条件，另一个线程通知条件已成立，后面的数字代表代码实际运行的顺序。</p><p>由上面的例子我们也可以看出，await()和signal()方法都必须在获取锁之后释放锁之前使用；</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><h4 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h4><pre><code class="line-numbers language-java">package java.util.concurrent.locks;/** * 条件对象接口 * @since 1.5 * @author Doug Lea */public interface Condition {    /**     * 让线程进入等待，如果其他线程调用同一Condition对象的notify/notifyAll，那么等待的线程可能被唤醒     */    void await() throws InterruptedException;    /**     * 不抛出中断异常的await方法     */    void awaitUninterruptibly();    /**     * 带超时的await     */    long awaitNanos(long nanosTimeout) throws InterruptedException;    /**     * 带超时的await（可指定时间单位）     */    boolean await(long time, TimeUnit unit) throws InterruptedException;    /**     * 带超时的await（指定截止时间）     */    boolean awaitUntil(Date deadline) throws InterruptedException;    /**     * 唤醒等待的线程     */    void signal();    /**     * 唤醒所有线程     */    void signalAll();}</code></pre><h4 id="ConditionObject内部类"><a href="#ConditionObject内部类" class="headerlink" title="ConditionObject内部类"></a>ConditionObject内部类</h4><pre><code class="line-numbers language-java">//  AbstractQueuedSynchronizer.ConditionObjectpublic class ConditionObject implements Condition, java.io.Serializable {    ...    ...}</code></pre><h3 id="ConditionObject的主要属性"><a href="#ConditionObject的主要属性" class="headerlink" title="ConditionObject的主要属性"></a>ConditionObject的主要属性</h3><pre><code class="line-numbers language-java">public class ConditionObject implements Condition, java.io.Serializable {    /**         First node of condition queue.          指向条件队列的第一个Node节点    */    private transient Node firstWaiter;    /**         Last node of condition queue.           指向条件队列的最后一个Node节点    */    private transient Node lastWaiter;     /**         Mode meaning to reinterrupt on exit from wait          REINTERRUPT表示当前线程在其他线程调用signal后被中断     */    private static final int REINTERRUPT = 1;    /**         Mode meaning to throw InterruptedException on exit from wait          THROW_IE表示当前线程在其他线程调用signal前被中断    */    private static final int THROW_IE = -1;}</code></pre><p>可以看到条件锁中也维护了一个队列，为了和AQS的同步队列区分，我这里称为条件队列，firstWaiter是队列的头节点，lastWaiter是队列的尾节点。</p><p>ConditionObject中的条件队列和AQS中的同步队列使用的是相同的节点类型Node，但是两个队列还是有一些不同的，在后续会详细讲解。</p><h3 id="lock-newCondition-方法"><a href="#lock-newCondition-方法" class="headerlink" title="lock.newCondition()方法"></a>lock.newCondition()方法</h3><p>新建一个条件锁。这里以ReetrantLock为例。</p><pre><code class="line-numbers language-java">public class ReentrantLock implements Lock, java.io.Serializable {    private final Sync sync;    // 创建条件锁    public Condition newCondition() {        return sync.newCondition();    }    /**     * 抽象内部类     */    abstract static class Sync extends AbstractQueuedSynchronizer {        // 条件锁        final ConditionObject newCondition() {            return new ConditionObject();        }    }} // AbstractQueuedSynchronizer.ConditionObject.ConditionObject()public ConditionObject() { }</code></pre><p>新建一个条件锁最后就是调用的AQS中的ConditionObject类来实例化条件锁。</p><h3 id="condition-await-方法"><a href="#condition-await-方法" class="headerlink" title="condition.await()方法"></a>condition.await()方法</h3><p>condition.await()方法，表明现在要等待条件的出现，只有满足条件之后获取锁的线程才可以继续向后执行。</p><p>await()方法会新建一个节点放到条件队列中，接着完全释放锁，然后阻塞当前线程并等待条件的出现；</p><h4 id="ConditionObject-await"><a href="#ConditionObject-await" class="headerlink" title="ConditionObject.await()"></a>ConditionObject.await()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.ConditionObject.await()public final void await() throws InterruptedException {    // 如果线程中断了，抛出异常    if (Thread.interrupted())        throw new InterruptedException();    // 创建线程节点，并且添加节点到Condition的条件队列中，并返回该节点    Node node = addConditionWaiter();    // 完全释放当前线程获取的锁    // 因为锁是可重入的，所以这里要把获取的锁全部释放，这里用savedState记录一下该线程此时持有锁的数量，为了后续满足条件之后再让该线程重新获取相同数量的锁，恢复到最初的状态    int savedState = fullyRelease(node);    /*        中断标志，用来标识线程是否是被中断唤醒的        interruptMode = 0：表示不是被中断唤醒的        interruptMode != 0：表示是被中断唤醒的            interruptMode = REINTERRUPT = 1：表示当前线程在其他线程调用signal()之后被中断唤醒            interruptMode = THROW_IE = -1：表示当前线程在其他线程调用signal()之前被中断唤醒     */    int interruptMode = 0;    // 是否在同步队列中，如果该线程节点从条件队列移出到同步队列中，说明当前已经满足条件，线程已经被唤醒，则跳出循环    while (!isOnSyncQueue(node)) {        // 阻塞当前线程，等待满足条件后被唤醒        LockSupport.park(this);                // 上面部分是调用await()时释放自己占有的锁，并阻塞自己等待条件的出现        // *************************分界线*************************  //        // 下面部分是条件已经出现，该线程被唤醒，尝试重新去获取锁继续向后执行                // checkInterruptWhileWaiting()中会判断当前线程是否是被中断唤醒的        // 返回值非0表示是被中断唤醒的，会通过break跳出while。因为如果是中断唤醒的，有可能实际上该线程还没有等到条件满足的时候就被唤醒了，这样该线程的Node节点一定没有被转移到同步队列中，所以就不可能通过循环条件来跳出循环        // 只能是我们手动调用break来跳出循环，毕竟await()方法还是要响应中断的，不能在其他线程已经发出中断信号后，还让线程在这个循环里自选而不响应中断        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)            break;    }        // 尝试获取锁，注意第二个参数，这里需要获取所的数量要和该线程最初持有锁的数量相同，使该线程恢复到最开始的持有锁的状态    // 如果没获取到会再次阻塞（这个方法这里就不贴出来了，有兴趣的翻翻上一章的内容）    /**        我们从两个条件分别去分析        1、acquireQueued(node, savedState)            尝试获取锁，注意第二个参数，这里需要获取所的数量要和该线程最初持有锁的数量相同，使该线程恢复到最开始的持有锁的状态，            该方法在之前ReentrantLock章节中已经讲解过了，在这个方法中线程就会不断地尝试获取锁，如果没获取到就会再次阻塞在这个位置，等到被唤醒后继续抢占锁，直到成功获取锁之后该方法才会返回。            该方法的返回值是中断标记，如果该线程是被中断信号唤醒并且抢占到锁的，就会返回true，如果线程不是被中断唤醒的，则返回false                2、interruptMode != THROW_IE            interruptMode标识的是线程在等待条件满足被阻塞的过程当中，是否是被中断唤醒的            这里的条件interruptMode != THROW_IE表示该线程不是在其他线程调用signal()之前被中断唤醒的        所以第一个条件是表示该线程在重新获取锁的时被阻塞，然后又被唤醒重新获取到锁的过程中，是不是被中断唤醒的        第二个条件表示该线程被阻塞，等待条件满足的过程当中，是不是被中断唤醒的        第一个条件为true，说明该线程是在重新获取锁的过程中接收到过中断信号，也就说是这一次中断是在该线程等待条件被阻塞然后又被唤醒之后才发生的，这个中断信号一定是发生在其他线程调用signal()之后        第二个条件为true，说明该线程在其他线程调用signal之前没有接收到过中断信号        当两个条件都为true时，就会进入到if代码块中，将interruptMode = REINTERRUPT，也就是该线程收到了中断信号，并且是在其他线程调用signal()之后收到的中断信号        如果该线程实在signal之前被中断的，那么该线程的流程就到此结束了，需要从头再来获取锁，就不能执行后续的步骤了，也就不能进入到该if代码块中     */    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)        interruptMode = REINTERRUPT;    //     /**        清除取消的节点        如果node.nextWaiter还指向节点，说明此时node节点没有从条件队列中移除，也就是说node节点是被中断信号唤醒的，而不是被signal()唤醒的        这种情况下就有可能存在被取消的节点还在条件队列中，就需要去执行以下清除取消状态节点（也就是非Node.CONDITION状态的节点）的方法        该条件成立的例子：            假设有三个线程thread0、thread1、thread2，三个线程依次调用同一个ConditionObject的await()方法，            之后三者均在上面while中被park，此时，外部线程中断thread0，thread0会执行到这里，此时thread0仍在条件队列中，并且它后面还有thread1和thread2两个节点，此时条件为true     */    if (node.nextWaiter != null) // clean up if cancelled        // 移除条件队列中所有不是Node.CONDITION状态的节点        unlinkCancelledWaiters();    // interruptMode != 0时，说明当前线程被中断，interruptMode为THROW_IE或REINTERRUPT    if (interruptMode != 0)        // 方法中会根据interruptMode的值做相应处理，来响应中断        reportInterruptAfterWait(interruptMode);}</code></pre><h4 id="ConditionObject-addConditionWaiter"><a href="#ConditionObject-addConditionWaiter" class="headerlink" title="ConditionObject.addConditionWaiter()"></a>ConditionObject.addConditionWaiter()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.ConditionObject.addConditionWaiter()// 为线程创建Node节点并将其添加到条件队列当中去private Node addConditionWaiter() {    // 获取条件队列中最后一个节点    Node t = lastWaiter;    /**     * 如果条件队列的尾节点已取消（非Node.CONDITION状态），从头节点开始清除所有已取消的节点     *      * 该条件成立的例子：     *  1、假设有两个线程thread0、thread1，初始时，thread0在未持有锁的情况下调用AQS.CO.await()，     *     thread0执行到AQS.fullyRelease中时会将其对应节点的waitStatus字段设置为取消状态，     *     之后持有锁的thread1调用 AQS.CO.await()，会执行到这里，这是条件队列尾节点t.waitStatus为1     *      *  2、假设有两个线程thread0、thread1，初始时，thread0持有锁，之后调用AQS.CO.await()释放锁并阻塞在LockSupport.park(this)处，     *     之后外部线程中断thread0，thread0被唤醒后会执行到AQS.transferAfterCancelledWait里的if处将t.waitStatus设置为0，     *     之后thread1获取到锁，执行到这里时，t.waitStatus为0     */    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {        // 移除条件队列中所有不是Node.CONDITION状态的节点        unlinkCancelledWaiters();        // 重新获取最新的尾节点，经过unlinkCancelledWaiters()，lastWaiter可能已经改变        t = lastWaiter;    }    // 新建一个节点，将它的waitStatus等待状态设置为CONDITION    Node node = new Node(Thread.currentThread(), Node.CONDITION);    // 如果尾节点为空，则把新节点赋值给头节点（相当于初始化队列）    // 否则把新节点赋值给尾节点的nextWaiter指针    if (t == null)        firstWaiter = node;    else        t.nextWaiter = node;    // 更新尾节点指向    lastWaiter = node;    // 返回新节点    return node;}</code></pre><h4 id="AbstractQueuedSynchronizer-fullyRelease"><a href="#AbstractQueuedSynchronizer-fullyRelease" class="headerlink" title="AbstractQueuedSynchronizer.fullyRelease()"></a>AbstractQueuedSynchronizer.fullyRelease()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.fullyRelease()// 完全释放当前线程获取的锁final int fullyRelease(Node node) {    // 是否完全释放锁，true标识释放失败    boolean failed = true;    try {        // 获取状态变量的值，这个值代表着获取锁的个数        int savedState = getState();        // 一次性释放所有获得的锁        if (release(savedState)) {            // 成功释放锁，将failed置为false            failed = false;            // 返回该线程最初持有锁的个数            return savedState;        } else {            // 释放失败抛出异常            throw new IllegalMonitorStateException();        }    } finally {        // 如果释放失败，则将该节点的waitStatus设置为取消状态        if (failed)            node.waitStatus = Node.CANCELLED;    }}</code></pre><h4 id="AbstractQueuedSynchronizer-isOnSyncQueue"><a href="#AbstractQueuedSynchronizer-isOnSyncQueue" class="headerlink" title="AbstractQueuedSynchronizer.isOnSyncQueue()"></a>AbstractQueuedSynchronizer.isOnSyncQueue()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.isOnSyncQueue()// 判断当前线程节点是否在同步队列中final boolean isOnSyncQueue(Node node) {    // 如果等待状态是CONDITION，或者前一个指针为空，说明还没有移到AQS的队列中，返回false    if (node.waitStatus == Node.CONDITION || node.prev == null)        return false;    // 如果next指针有值，说明已经移到AQS的队列中了    if (node.next != null) // If has successor, it must be on queue        return true;    // 到这里说明node.waitStatus不为Node.CONDITION且node.prev不为null    // 从AQS的尾节点开始往前寻找看是否可以找到当前节点，找到了也说明已经在AQS的队列中了    return findNodeFromTail(node);}</code></pre><h4 id="AbstractQueuedSynchronizer-findNodeFromTail"><a href="#AbstractQueuedSynchronizer-findNodeFromTail" class="headerlink" title="AbstractQueuedSynchronizer.findNodeFromTail()"></a>AbstractQueuedSynchronizer.findNodeFromTail()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.findNodeFromTail()private boolean findNodeFromTail(Node node) {    Node t = tail;    for (;;) {        if (t == node)            return true;        if (t == null)            return false;        t = t.prev;    }}</code></pre><h4 id="ConditionObject-checkInterruptWhileWaiting"><a href="#ConditionObject-checkInterruptWhileWaiting" class="headerlink" title="ConditionObject.checkInterruptWhileWaiting()"></a>ConditionObject.checkInterruptWhileWaiting()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.ConditionObject.checkInterruptWhileWaiting()// 根据节点的中断情况来返回其中断标志private int checkInterruptWhileWaiting(Node node) {    /**     * 通过Thread.interrupted()来判断该线程是不是被中断，如果没有被中断则返回0     * 如果被中断了，则在通过transferAfterCancelledWait(node)来判断该线程是在其他线程调用signal()前被中断，还是调用signal()后被中断     *      返回THROW_IE表示当前线程在其他线程调用signal前被中断     *      返回REINTERRUPT表示当前线程在其他线程调用signal后被中断     *      具体的分界点就是node.waitStatus的值，若其值为Node.CONDITION，是signal前被中断，否则在signal后被中断     */    return Thread.interrupted() ?        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :        0;}</code></pre><h4 id="ConditionObject-transferAfterCancelledWait"><a href="#ConditionObject-transferAfterCancelledWait" class="headerlink" title="ConditionObject.transferAfterCancelledWait()"></a>ConditionObject.transferAfterCancelledWait()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.ConditionObject.transferAfterCancelledWait()// 返回true表示该节点是在调用signal()之前被中断的，返回false表示是调用signal()之后被中断的final boolean transferAfterCancelledWait(Node node) {    /**     * 如果node.waitStatus的值是Node.CONDITION，说明该节点还没有被signal()方法唤醒，也就是说该节点是在调用signal()前被中断的     *      * 例子：     * 该条件为true的情形：     *      假设仅有thread0，thread0持有锁后调用AQS.CO.await()被park，     *      之后被外部线程中断，会执行到这里，此时条件为true     * 该条件为false的情形：     *      假设有两个线程thread0、thread1，thread0，thread0持有锁后调用AQS.CO.await()被park，     *      thread1获取到锁后调用AQS.CO.signal，之后会执行到AQS.transferForSignal的第一个if处，     *      该if语句执行完后，这里node.waitStatus被修改为0，所以thread0执行这里的if语句时会失败     */    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {        // 被中断后就需要重新进入同步队列抢占锁，从头再来        enq(node);        return true;    }    // 到这里说明其他线程调用了signal()，将当前线程对应的节点加入同步队列，这里自旋等待入队完成    while (!isOnSyncQueue(node))        // 主动让出当前线程的CPU时间片        Thread.yield();     // 到这里就说明是在调用signal()之后被中断的，执行到这里的时候，这个线程节点已经进入到了同步队列中了，在后续的操作中就会执行acquireQueued(node, savedState)来不断尝试获取锁直到成功    return false;}  </code></pre><h4 id="ConditionObject-unlinkCancelledWaiters"><a href="#ConditionObject-unlinkCancelledWaiters" class="headerlink" title="ConditionObject.unlinkCancelledWaiters()"></a>ConditionObject.unlinkCancelledWaiters()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.ConditionObject.unlinkCancelledWaiters()// 清除掉条件队列中所有被取消的节点；private void unlinkCancelledWaiters() {    // 获取条件队列的头节点    Node t = firstWaiter;    Node trail = null;    /**     * 1、从firstWaiter开始，将整个链表中t.waitStatus != Node.CONDITION的节点移除掉；     * 2、节点移除后，将其前置节点的nextWaiter指向后置节点。     */    while (t != null) {        // 获取当前遍历到节点的下一个节点        Node next = t.nextWaiter;            if (t.waitStatus != Node.CONDITION) {            /*            * 当前节点状态不是CONDITION：            * 将当前节点的nextWaiter设置为null。            * 如果trail是空，则将firstWaiter指向之前保存的t.nextWaiter,            * 否则将trail.nextWaiter指向之前保存的t.nextWaiter。            */            t.nextWaiter = null;            if (trail == null)                firstWaiter = next;            else                trail.nextWaiter = next;            if (next == null)                lastWaiter = trail;        }        else            trail = t;        t = next;    }}</code></pre><h4 id="ConditionObject-reportInterruptAfterWait"><a href="#ConditionObject-reportInterruptAfterWait" class="headerlink" title="ConditionObject.reportInterruptAfterWait()"></a>ConditionObject.reportInterruptAfterWait()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.ConditionObject.reportInterruptAfterWait()// 根据中断标识来进行不同的处理private void reportInterruptAfterWait(int interruptMode) throws InterruptedException {    // 如果当前线程在其他线程调用signal()之前被中断唤醒，则直接抛出异常响应中断    if (interruptMode == THROW_IE)        throw new InterruptedException();    // 如果当前线程在其他线程调用signal()之后被中断唤醒，这种情况不会对条件锁流程造成影响，则设置中断标志，但不会抛出异常中止执行    else if (interruptMode == REINTERRUPT)        selfInterrupt();}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="Condition的条件队列和AQS的同步队列不完全一样"><a href="#Condition的条件队列和AQS的同步队列不完全一样" class="headerlink" title="Condition的条件队列和AQS的同步队列不完全一样"></a>Condition的条件队列和AQS的同步队列不完全一样</h5><p>Condition的条件队列和AQS的同步队列都是通过节点类Node组成的。<br>但是AQS的队列头节点是不存在任何值的，是一个虚节点； Condition的队列头节点是存储着实实在在的元素值的，是真实节点。<br>而且条件队列是一个单向队列，同步队列是一个双向队列</p><h5 id="各种等待状态（waitStatus）的变化"><a href="#各种等待状态（waitStatus）的变化" class="headerlink" title="各种等待状态（waitStatus）的变化"></a>各种等待状态（waitStatus）的变化</h5><p>首先，在条件队列中，新建节点的初始等待状态是CONDITION（-2）；<br>其次，移到AQS的队列中时等待状态会更改为0（AQS队列节点的初始等待状态为0）；<br>然后，在AQS的队列中如果需要阻塞，会把它上一个节点的等待状态设置为SIGNAL（-1）；<br>最后，不管在Condition队列还是AQS队列中，已取消的节点的等待状态都会设置为CANCELLED（1）；<br>另外，后面我们在共享锁的时候还会讲到另外一种等待状态叫PROPAGATE（-3）。</p><h5 id="相似的名称"><a href="#相似的名称" class="headerlink" title="相似的名称"></a>相似的名称</h5><p>AQS同步队列中下一个节点是next，上一个节点是prev；</p><p>Condition条件队列中下一个节点是nextWaiter，没有上一个节点。</p><h5 id="await-方法的流程"><a href="#await-方法的流程" class="headerlink" title="await()方法的流程"></a>await()方法的流程</h5><ol><li>新建一个节点加入到条件队列中去；</li><li>完全释放当前线程占有的锁；</li><li>阻塞当前线程，并等待条件的出现；</li><li>条件已出现（此时节点已经移到AQS的队列中），尝试获取锁；</li></ol><p>也就是说await()方法内部其实是<mark style="background: #FFB8EBA6;">先释放锁-&gt;等待条件-&gt;再次获取锁的过程</mark>。</p><h3 id="condition-signal-方法"><a href="#condition-signal-方法" class="headerlink" title="condition.signal()方法"></a>condition.signal()方法</h3><p>condition.signal()方法通知条件已经出现。</p><p>这个方法是由获取锁的其他线程执行的，用来唤醒正在阻塞等待满足条件的线程。</p><p>signal()方法会寻找条件队列中第一个可用节点移到AQS队列中；</p><h4 id="ConditionObject-signal"><a href="#ConditionObject-signal" class="headerlink" title="ConditionObject.signal()"></a>ConditionObject.signal()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.ConditionObject.signal()public final void signal() {    // 如果不是当前线程占有着锁，调用这个方法抛出异常    // 说明signal()也要在获取锁之后执行    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    // 获取条件队列的头节点，准备将条件队列头节点唤醒    Node first = firstWaiter;    // 如果有等待条件的节点，则通知它条件已成立    if (first != null)        doSignal(first);}</code></pre><h4 id="ConditionObject-doSignal"><a href="#ConditionObject-doSignal" class="headerlink" title="ConditionObject.doSignal()"></a>ConditionObject.doSignal()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.ConditionObject.doSignal()private void doSignal(Node first) {    // 从头节点开始遍历条件队列，仅唤醒第一个符合条件的线程    do {        // 将记录条件队列头节点的指向向后移动一位        if ( (firstWaiter = first.nextWaiter) == null)            // 如果移动后firstWaiter为null，说明已到队列尾部，将lastWaiter设置为null            lastWaiter = null;        // 将first与其后继节点断开，相当于把头节点从队列中出队        first.nextWaiter = null;    // 转移节点到AQS队列中    // 条件1：只要一个线程转移到AQS同步队列成功，transferForSignal返回true，就会终止该循环    // 条件2：用于判断是否遍历到了队列尾部    } while (!transferForSignal(first) &amp;&amp;             (first = firstWaiter) != null);}</code></pre><h4 id="AbstractQueuedSynchronizer-transferForSignal"><a href="#AbstractQueuedSynchronizer-transferForSignal" class="headerlink" title="AbstractQueuedSynchronizer.transferForSignal()"></a>AbstractQueuedSynchronizer.transferForSignal()</h4><pre><code class="line-numbers language-java">// AbstractQueuedSynchronizer.transferForSignal()// 将节点从条件队列移动到同步队列，返回移动是否成功final boolean transferForSignal(Node node) {    // 把节点的状态更改为0，也就是说即将移到AQS队列中    // 如果失败了，说明节点已经被改成取消状态了    // 返回false，通过上面的循环可知会寻找下一个可用节点    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))        return false;    // 调用AQS的入队方法把节点移到AQS的队列中    // 注意，这里enq()的返回值是node的上一个节点，也就是旧尾节点    Node p = enq(node);    // 同步队列中上一个节点的等待状态    int ws = p.waitStatus;    /**     * 如果上一个节点已取消了，或者更新状态为SIGNAL失败（也是说明上一个节点已经取消了），则直接唤醒当前节点对应的线程     *      * 问题：为什么只要符合这个条件if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))，就去执行 LockSupport.unpark(node.thread);来直接将线程节点唤醒呢？     * 因为执行到这个if条件时，当前的node节点已经在AQS的同步队列中了，然后符合这个if条件的情况就是此时node在同步队列中的前一个结点被取消了，     * 也就是当前节点的前一个结点的waitStatus状态已经不是SIGNAL，而是 CANCELLED了。     * 此时如果依然保持当前节点阻塞状态，因为它的前驱节点不是SIGNAL，就可能导致当前node节点无法正常被唤醒的情况。     * 所以这里安全起见，就先将当前node节点唤醒，唤醒后续继续执行await方法时，调用其中的acquireQueued(node, savedState)再重新根据之前讲过的规则判断当前节点是否可以被阻塞，     * 如果符合被阻塞条件，再去阻塞，如果不符合，再去按照我们以前讲过的ReetractLock中的逻辑去处理即可。     *      * 但是如果前面的节点是SIGNAL，也就说明当前node节点是可以被唤醒的，所以就可以保持当前node节点的被唤醒状态了。     * 这样Node节点就会在AQS的同步队列中阻塞等待，等到轮到他抢占锁的时候，就会被唤醒，唤醒之后就会在await中继续向下执行了，然后使用acquireQueued(node, savedState)再去重新抢占锁，这个方法会一直等到抢占锁成功后才会返回     *      * 总之执行完transferForSignal这个方法，一定能保证当前节点已经从条件队列中转移到了同步队列，也就是说此时已经符合了执行后续操作的条件，该线程可以继续尝试获取锁来执行后续的操作，     */    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))        // node.thread会从await()里的park处被唤醒，因为已经在同步队列中了，因此会跳出while，        // 进入AQS.acquireQueued中，若此时p前面仍有节点等待获取锁或p前面没有节点了但调用signal()        // 的线程仍未释放锁，node.thread在尝试几次后最终仍会在AQS.parkAndCheckInterrupt中被park        LockSupport.unpark(node.thread);    // 如果更新上一个节点的等待状态为SIGNAL成功了    // 则返回true，这时doSignal()中的循环不成立了，退出循环，也就是只通知了一个节点    // 此时当前节点还是阻塞状态    // 也就是说调用signal()的时候并不会真正唤醒一个节点    // 只是把节点从条件队列移到AQS队列中    return true;}</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>signal()方法的大致流程为：</p><ol><li>从条件队列的头节点开始寻找一个非取消状态的节点；</li><li>把它从条件队列移到AQS队列；</li><li>且只移动一个节点；</li></ol><p>注意，这里调用signal()方法后并不会真正唤醒一个节点，那么，唤醒一个节点是在什么时候呢？</p><p>我们可以再回去看一下本文最开始的使用案例，在其他线程调用signal()方法后，该线程最终会执行lock.unlock()方法，此时才会真正唤醒一个正在同步队列中的节点，唤醒的这个节点如果曾经是条件节点被转移到条件队列中的话，就会继续执行await()方法“分界线”下面的代码。也就是说，在调用signal()方法的线程调用unlock()方法才是真正唤醒阻塞在条件上的节点（此时节点已经在AQS队列中）；被唤醒之后，被唤醒的节点会再次尝试获取锁，后面的逻辑与lock()的逻辑基本一致了。</p><h3 id="condition-signalAll-方法"><a href="#condition-signalAll-方法" class="headerlink" title="condition.signalAll()方法"></a>condition.signalAll()方法</h3><p>AQS.CO.signalAll与AQS.CO.signal类似，区别是signalAll会将所有节点加入同步队列，除了doSignalAll方法以外，其他的方法都是一样的：</p><pre><code class="line-numbers language-java">private void doSignalAll(Node first) {    // 将条件队列的头节点和尾节点都置为null    lastWaiter = firstWaiter = null;    // 遍历条件队列，依次唤醒所有线程    do {        Node next = first.nextWaiter;        first.nextWaiter = null;        transferForSignal(first);        first = next;    } while (first != null);}</code></pre><h2 id="总结流程图"><a href="#总结流程图" class="headerlink" title="总结流程图"></a>总结流程图</h2><p>下面这就就是整个条件锁流程的时序图：</p><p><img src="/attachment/f56b7827028739aaf2d301aee6eed091.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Lock接口</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-lock-jie-kou/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-lock-jie-kou/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Lock接口"><a href="#【Java-多线程并发】-Lock接口" class="headerlink" title="【Java 多线程并发】 Lock接口"></a>【Java 多线程并发】 Lock接口</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Lock接口date: 2023-07-04 16:35tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 Lock接口</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Lock接口的实现（ReentrantLock等实现类）基本都是通过聚合了一个AbstractQueuedSynchronizer同步器的内部子类来完成线程访问控制的。</p><pre><code class="line-numbers language-java">public interface Lock {    // 获取锁    void lock();    // 获取锁（可中断）    void lockInterruptibly() throws InterruptedException;    // 尝试获取锁，如果没获取到锁，就返回false    boolean tryLock();    // 尝试获取锁，如果没获取到锁，就等待一段时间，这段时间内还没获取到锁就返回false    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;    // 释放锁    void unlock();    // 条件锁    Condition newCondition();}</code></pre><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在Java SE5之前，Java程序是靠synchronized关键字实现锁功能的，使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放，<strong>这种方式简化了同步的管理，可是扩展性没有显式地锁获取和释放来的好</strong>。例如，考虑下面这样一个情景：</p><p>针对一个场景，使用synchronized进行锁获取和释放，先获得锁A，然后获得锁B，当锁B获取之后，释放锁A同时获取锁C，当锁C获得后，在释放B同时获取锁D，以此类推。这时，使用synchronized关键字就不那么容易实现了，而使用显式地锁获取和释放则很简单。</p><p>在Java SE5之后，并发包中新增了Lock接口以及相关实现类，用来实现锁功能，它提供了与synchronized类似的同步功能，只是在使用时需要显式地获取和释放锁。<strong>虽然它缺少了隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized所不具备的特性。</strong></p><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><h3 id="Lock接口源码"><a href="#Lock接口源码" class="headerlink" title="Lock接口源码"></a>Lock接口源码</h3><pre><code class="line-numbers language-java">public interface Lock {    // 获取锁    void lock();    // 获取锁（可中断）    void lockInterruptibly() throws InterruptedException;    // 尝试获取锁，如果没获取到锁，就返回false    boolean tryLock();    // 尝试获取锁，如果没获取到锁，就等待一段时间，这段时间内还没获取到锁就返回false    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;    // 释放锁    void unlock();    // 条件锁    Condition newCondition();}</code></pre><p>Lock接口中主要定义了 获取锁、尝试获取锁、释放锁、条件锁等几个方法。</p><h3 id="Lock接口的实现类"><a href="#Lock接口的实现类" class="headerlink" title="Lock接口的实现类"></a>Lock接口的实现类</h3><p><img src="/attachment/63696a756c55744035360caf5ab6823a.png"></p><h3 id="Lock接口的使用"><a href="#Lock接口的使用" class="headerlink" title="Lock接口的使用"></a>Lock接口的使用</h3><p>Lock接口的使用很简单，常见的使用方式如下代码所示：</p><pre><code class="line-numbers language-java">Lock lock = new ReentrantLock();lock.lock(); try {    // do something...} finally {    lock.unlock();}</code></pre><p>在使用Lock锁的时候要注意以下几点：</p><ul><li>要在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</li><li>尽量不要将获取锁的过程写在try块中，因为如果在获取锁（可以是自定义的锁）的过程中发生了异常，在异常抛出的同时，也会导致锁的无故释放。</li></ul><h3 id="Lock接口的特性"><a href="#Lock接口的特性" class="headerlink" title="Lock接口的特性"></a>Lock接口的特性</h3><p>synchronized不具备的Lock接口提供的锁的主要特征如下：</p><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>尝试非阻塞地获取</td><td>当前线程尝试获取锁，如果这一刻锁没有被其他线程获取到，则成功获取并持有锁。</td></tr><tr><td>能被中断地获取锁</td><td>与synchronized不同，  获取到锁的线程能够相应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。</td></tr><tr><td>超时获取锁</td><td>在指定的截止时间之前获取锁，如果截止时间到了仍没有获取到锁，则返回。</td></tr></tbody></table><p> Lock是一个接口，它定义了锁获取和释放的基本操作，Lock的API如下所示：</p><table><thead><tr><th>方法名称</th><th>描&amp;nbsp; 述</th></tr></thead><tbody><tr><td>void lock()</td><td>获取锁，调用该方法当前线程会获取锁，当锁获取后，从该方法返回。</td></tr><tr><td>void lockInterruptibly() throws InterruptedException</td><td>可中断地获取锁，与 lock() 方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程。</td></tr><tr><td>boolean tryLock()</td><td>尝试非阻塞地获取锁，调用该方法后立即返回，如果能够获取锁则返回 true，否则返回 false。</td></tr><tr><td>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</td><td>超时地获取锁，当前线程在以下 3 种情况下会返回：1、&amp;nbsp; 当前线程在超时时间内获取了锁2、&amp;nbsp; 当前线程在超时时间内被中断3、&amp;nbsp; 超时时间结束，返回 false</td></tr><tr><td>void unlock()</td><td>释放锁</td></tr><tr><td>Condition newCondition()</td><td>获取等待通知组件，在组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await() 方法，而调用后，当前线程将会释放锁。</td></tr></tbody></table><p>Lock接口的实现（ReentrantLock等实现类）基本都是通过聚合了一个AbstractQueuedSynchronizer同步器的内部子类来完成线程访问控制的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 locks</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-locks/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-locks/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-locks"><a href="#【Java-多线程并发】-locks" class="headerlink" title="【Java 多线程并发】 locks"></a>【Java 多线程并发】 locks</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 locksdate: 2023-07-04 16:34tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 locks</code></pre><h2 id="【Java-多线程并发】-locks-1"><a href="#【Java-多线程并发】-locks-1" class="headerlink" title="【Java 多线程并发】 locks"></a>【Java 多线程并发】 locks</h2><p><img src="/attachment/0b7dfc3a9a9c28d6187483595b1bb0ca.png"></p><p>locks包中提供了很多种锁，locks包的结构如下：</p><p><img src="/attachment/dba657a615117613ae3f2db7fbd9caa1.png"></p><ul><li>AbstractOwnableSynchronizer：一个线程拥有的同步器，这个类提供了创建锁和相关同步器的基础。</li><li>AbstractQueuedLongSynchronizer：其原理与AbstractQueuedSynchronizer基本一致，只是它的所有的同步状态都是用long变量来维护的，而不是int，在需要64位的属性来表示状态的时候会很有用。</li><li>AbstractQueuedSynchronizer：为实现依赖于先进先出队列的阻塞锁和相关同步器（信号量、事件等等）提供的一个框架，它依靠int值来表示同步状态。</li><li>Condition：将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用。这个是被绑定在Lock上一起使用的。</li><li>Lock：该接口实现了比synchronized更多的功能，需要注意的是，为了确保可以释放锁，需要在finally语句块中unlock。</li><li>LockSupport：LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，而且park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。</li><li>ReadWriteLock：给接口是读写锁。读和写是互斥的，多个读锁不互斥，也就是说，在读的时候，不能写，在写的时候，不能读，但是在读的时候可以有多个线程同时读。</li><li>ReentrantLock：可重入锁</li><li>ReentrantReadWriteLock：可重入读写锁</li><li>StampedLock：Java 1.8提供了一种读写锁</li></ul><p>locks包里面最重要的就是提供了lock和ReadWrite两种接口，提供两种类型的锁。这两个接口也就形成了整个locks包的基石。</p><h2 id="【Java-多线程并发】-Lock接口"><a href="#【Java-多线程并发】-Lock接口" class="headerlink" title="【Java 多线程并发】 Lock接口"></a>【Java 多线程并发】 Lock接口</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-LockSupport"><a href="#【Java-多线程并发】-LockSupport" class="headerlink" title="【Java 多线程并发】 LockSupport"></a>【Java 多线程并发】 LockSupport</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-Condition条件锁"><a href="#【Java-多线程并发】-Condition条件锁" class="headerlink" title="【Java 多线程并发】 Condition条件锁"></a>【Java 多线程并发】 Condition条件锁</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-ReentrantLock"><a href="#【Java-多线程并发】-ReentrantLock" class="headerlink" title="【Java 多线程并发】 ReentrantLock"></a>【Java 多线程并发】 ReentrantLock</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-ReentrantReadWriteLock"><a href="#【Java-多线程并发】-ReentrantReadWriteLock" class="headerlink" title="【Java 多线程并发】 ReentrantReadWriteLock"></a>【Java 多线程并发】 ReentrantReadWriteLock</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 原理</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-yuan-li/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-原理"><a href="#【Java-多线程并发】-原理" class="headerlink" title="【Java 多线程并发】 原理"></a>【Java 多线程并发】 原理</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 原理date: 2023-07-04 16:30tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 原理</code></pre><h2 id="【Java-多线程并发】-Java内存模型基础知识"><a href="#【Java-多线程并发】-Java内存模型基础知识" class="headerlink" title="【Java 多线程并发】 Java内存模型基础知识"></a>【Java 多线程并发】 Java内存模型基础知识</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-volatile"><a href="#【Java-多线程并发】-volatile" class="headerlink" title="【Java 多线程并发】 volatile"></a>【Java 多线程并发】 volatile</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-synchronized"><a href="#【Java-多线程并发】-synchronized" class="headerlink" title="【Java 多线程并发】 synchronized"></a>【Java 多线程并发】 synchronized</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-CAS（Compare-And-Swap）"><a href="#【Java-多线程并发】-CAS（Compare-And-Swap）" class="headerlink" title="【Java 多线程并发】 CAS（Compare And Swap）"></a>【Java 多线程并发】 CAS（Compare And Swap）</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）"><a href="#【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）" class="headerlink" title="【Java 多线程并发】 AQS（Abstract Queued Synchronizer）"></a>【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-fail-fast-快速失败-机制"><a href="#【Java-多线程并发】-fail-fast-快速失败-机制" class="headerlink" title="【Java 多线程并发】 fail-fast(快速失败)机制"></a>【Java 多线程并发】 fail-fast(快速失败)机制</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 基础</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-ji-chu/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-基础"><a href="#【Java-多线程并发】-基础" class="headerlink" title="【Java 多线程并发】 基础"></a>【Java 多线程并发】 基础</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 基础date: 2023-07-04 16:27tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 基础</code></pre><h2 id="【Java-多线程并发】-进程与线程基本概念"><a href="#【Java-多线程并发】-进程与线程基本概念" class="headerlink" title="【Java 多线程并发】 进程与线程基本概念"></a>【Java 多线程并发】 进程与线程基本概念</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-Java多线程入门类和接口"><a href="#【Java-多线程并发】-Java多线程入门类和接口" class="headerlink" title="【Java 多线程并发】 Java多线程入门类和接口"></a>【Java 多线程并发】 Java多线程入门类和接口</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-线程组和线程优先级"><a href="#【Java-多线程并发】-线程组和线程优先级" class="headerlink" title="【Java 多线程并发】 线程组和线程优先级"></a>【Java 多线程并发】 线程组和线程优先级</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-Java线程间的通信"><a href="#【Java-多线程并发】-Java线程间的通信" class="headerlink" title="【Java 多线程并发】 Java线程间的通信"></a>【Java 多线程并发】 Java线程间的通信</h2><p>undefined</p><h2 id="【Java-多线程并发】-锁"><a href="#【Java-多线程并发】-锁" class="headerlink" title="【Java 多线程并发】 锁"></a>【Java 多线程并发】 锁</h2><p>undefined</p><p>undefined</p><h2 id="【Java-多线程并发】-线程安全和线程不安全的定义以及实现线程安全的方法有哪些"><a href="#【Java-多线程并发】-线程安全和线程不安全的定义以及实现线程安全的方法有哪些" class="headerlink" title="【Java 多线程并发】 线程安全和线程不安全的定义以及实现线程安全的方法有哪些"></a>【Java 多线程并发】 线程安全和线程不安全的定义以及实现线程安全的方法有哪些</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 ThreadLocal</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-threadlocal/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-threadlocal/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-ThreadLocal"><a href="#【Java-多线程并发】-ThreadLocal" class="headerlink" title="【Java 多线程并发】 ThreadLocal"></a>【Java 多线程并发】 ThreadLocal</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 ThreadLocaldate: 2023-07-04 15:58tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 ThreadLocal</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>ThreadLocal</strong></p><p>Thread的局部变量<br>提供线程内的局部变量，在多线程环境下访问时能保证各个线程内的ThreadLocal变量各自独立</p><p><strong>应用场景</strong></p><ul><li>每个线程需要一个独享的对象</li><li>当前用户信息需要被线程内所有方法共享</li></ul><p><strong>ThreadLocal的作用</strong></p><ol><li>让某个需要用到的对象在线程间隔离(每个线程都有自己的独立的对象)</li><li>在任何方法中都可以轻松获取到该对象</li></ol><p><strong>使用ThreadLocal带来的好处</strong></p><ol><li>达到线程安全</li><li>不需要加锁，提高执行效率</li><li>更高效地利用内存、节省开销</li><li>免去传参的繁琐</li></ol><p><strong>Thread、ThreadLocal、ThreadLocalMap关系</strong></p><p><img src="/attachment/0c9e2634a761b32ce0d372661a572852.png"></p><p><strong>数据结构</strong></p><p><img src="/attachment/d6f737e1a75f0c73d1dd5ccdf8df3f71.png"></p><p><strong>主要方法</strong></p><ol><li>T initialValue( )：初始化</li><li>void set(T t)：为这个线程设置一个新值</li><li>T get()：得到这个线程对应的value。如果是首次调用get() ,则会调用initialize来得到这个值</li><li>void remove( )：删除对应这个线程的值</li></ol><p><strong>ThreadLocalMap类</strong></p><ul><li>键：这个ThreadLocal</li><li>值：实际需要的成员变量，比如user或者simpleDateFormat对象</li></ul><p>线性探测法</p><p><strong>ThreadLocal注意点</strong></p><ul><li><p>内存泄漏<br>每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用。<br>key对应的value就不能被回收，因为有以下的调用链:Thread一&gt; ThreadLocalMap一&gt; Entry ( key为null )一&gt;Value。</p></li><li><p>空指针<br>在进行get之前，必须先set，否则可能会返回NULL，并且返回类型如果不是对象类型，而是基本数据类型的话，还会报空指针异常</p></li><li><p>共享对象<br>如果在每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，还是会有并发访问问题。</p></li><li><p>不需要强行使用ThreadLocal</p></li><li><p>优先使用框架的支持</p></li></ul><h2 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h2><p>在JDK1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p><p>ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。</p><p>在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal&lt;T&gt;。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</p><p>ThreadLocal的作用是提供线程内的局部变量，在多线程环境下访问时能保证各个线程内的ThreadLocal变量各自独立。也就是说，每个线程的ThreadLocal变量是自己专用的，其他线程是访问不到的，对自己的ThreadLocal变量也不会影响其他线程的ThreadLocal变量。</p><h2 id="ThreadLocal的用途"><a href="#ThreadLocal的用途" class="headerlink" title="ThreadLocal的用途"></a>ThreadLocal的用途</h2><p>两大使用场景：</p><p><strong>典型场景1</strong>：每个线程需要一个独享的对象(通常是工具类,典型需要使用的类有SimpleDateFormat和Random )。换句话说就是，多线程环境下需要对非线程安全对象的并发访问，并且该对象并不需要在线程间共享，只给每个线程自己使用即可，但是我们不想加锁，因为加锁很影响性能，降低并发量，这时候可以使用ThreadLocal来使得每个线程都持有一个该对象的副本。<br><strong>典型场景2</strong>：每个线程内需要保存全局变量(例如在拦截器中获取用户信息) , 可以让不同方法直接使用，避免参数传递的麻烦。比如我们在登陆时从拦截器获取到了用户的姓名，而在后面的的很多操作中可能还会用到这个名字，如果我们每一个方法都传参传入姓名的话就非常麻烦，不如直接把姓名这个数据存在这个请求线程内部，这样想什么时候用直接取出来即可。</p><h3 id="典型场景1-每个线程需要一个独享的对象"><a href="#典型场景1-每个线程需要一个独享的对象" class="headerlink" title="典型场景1 :每个线程需要一个独享的对象"></a>典型场景1 :每个线程需要一个独享的对象</h3><ul><li>每个Thread内有自己的实例副本，不共享</li><li>比喻：教材只有一本，全班人一起做笔记有线程安全问题。复印之后给每个人发一本，每人在自己的教材上记笔记就没问题了。</li></ul><h4 id="SimpleDateFormat的进化之路："><a href="#SimpleDateFormat的进化之路：" class="headerlink" title="SimpleDateFormat的进化之路："></a>SimpleDateFormat的进化之路：</h4><ol><li>2个线程分别用自己的SimpleDateFormat ,这没问题</li><li>后来延伸出10个 ,那就有10个线程和10个SimpleDateFormat ,这虽然写法不优雅(应该复用对象)，但勉强可以接受</li><li>但是当需求变成了1000个，频繁的创建销毁线程对象会带来巨大消耗，那么必然要用线程池(否则消耗内存太多)</li><li>所有的线程都共用同一个simpleDateFormat对象，减少对象开销。</li><li>共用一个simpleDateFormat对象线程不安全的，出现了并发安全问题</li><li>我们可以选择加锁 ，加锁后结果正常，但是效率低</li><li>在这里更好的解决方案是使用ThreadLocal，因为ThreadLocal是每个线程独享的，不会在多个线程之间共享，也就不会产生线程安全问题，并且ThreadLocal也不会像加锁一样影响性能</li></ol><p><strong>v0.1</strong></p><p><img src="/attachment/73c915be96cab8417b1015f25cbbedb8.png"></p><pre><code class="line-numbers language-java">/** * 描述：     两个线程打印日期 */public class ThreadLocalNormalUsage00 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                String date = new ThreadLocalNormalUsage00().date(10);                System.out.println(date);            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                String date = new ThreadLocalNormalUsage00().date(104707);                System.out.println(date);            }        }).start();    }     /**     * 将传入的秒转化为日期字符串     * @param seconds  单位秒     * @return     */    public String date(int seconds) {        //Date()入参的单位是毫秒，从1970.1.1 00:00:00 GMT计时，传入多少毫秒，就从这个日期上往上累加        Date date = new Date(1000 * seconds);        // 设置使其格式化工具        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        // 格式化输出字符串日期        return dateFormat.format(date);    }}</code></pre><p>两个线程使用同一个SimpleDateFormat结果还算是正常，都可以正常输出。我们再来看一下n个线程使用同一个SimpleDateFormat会出现什么情况。</p><p><strong>v0.2</strong></p><p><img src="/attachment/4a9c5d18c2e57ab174f8289ed336c2d4.png"></p><pre><code class="line-numbers language-java">/** * 描述：     30个线程打印日期 */public class ThreadLocalNormalUsage01 {    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 30; i++) {            int finalI = i;            new Thread(new Runnable() {                @Override                public void run() {                    String date = new ThreadLocalNormalUsage01().date(finalI);                    System.out.println(date);                }            }).start();            Thread.sleep(100);        }    }     public String date(int seconds) {        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时        Date date = new Date(1000 * seconds);        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        return dateFormat.format(date);    }}</code></pre><p>这样写依旧是可以正常运行，但是这里还有一点性能上的问题，如果需要的线程很多，比如增加到1000个，向上面这个写法就需要循环创建销毁1000次线程对象，这个过程是非常消耗性能的，所以我们引入线程池来优化线程管理。</p><p><strong>v0.3</strong></p><p><img src="/attachment/49aad0068ba57961293ad71c51295fdd.png"></p><pre><code class="line-numbers language-java">/** * 描述：     1000个打印日期的任务，用线程池来执行 */public class ThreadLocalNormalUsage02 {    // 如果线程很多的话，再像之前那样循环创建线程对象就会带来很大的开销了，创建销毁线程对象开销是很大的，这里我们就可以引入线程池来帮我们完成线程的创建管理减少开销    // 创建有10个线程的线程池，让着10个线程去完成这1000个任务    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 1000; i++) {            int finalI = i;            // 将线程执行代码直接传入线程池，让线程池帮我们运行            threadPool.submit(new Runnable() {                @Override                public void run() {                    String date = new ThreadLocalNormalUsage02().date(finalI);                    System.out.println(date);                }            });        }        // 关闭线程池        threadPool.shutdown();    }     public String date(int seconds) {        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时        Date date = new Date(1000 * seconds);        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        return dateFormat.format(date);    }}</code></pre><p>这个代码还是可以正常运行的，但是也有一个问题，就是虽然Thread对象不需要重复创建销毁1000次了，但是在date()方法中还是需要创建SimpleDateFormat对象，这个date()需要被调用1000次，那么就会创建1000次SimpleDateFormat对象，这样开销依旧很大，所以我们可以让所有的线程都共用同一个simpleDateFormat对象，这样就能避免频繁的创建对象了，并且共用一个对象看起来也不会有什么影响，我们只是用这个对象来格式化日期格式而已。</p><p><strong>v0.4</strong></p><p><img src="/attachment/0b6694a354da3d227e744870685142fd.png"></p><pre><code class="line-numbers language-java">/** * 描述：     1000个打印日期的任务，用线程池来执行 */public class ThreadLocalNormalUsage03 {    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);    // 创建静态全局变量，让所有线程共用这一个SimpleDateFormat对象    static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 1000; i++) {            int finalI = i;            threadPool.submit(new Runnable() {                @Override                public void run() {                    String date = new ThreadLocalNormalUsage03().date(finalI);                    System.out.println(date);                }            });        }        // 关闭线程池        threadPool.shutdown();    }    public String date(int seconds) {        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时        Date date = new Date(1000 * seconds);        return dateFormat.format(date);    }}</code></pre><p>这个代码执行结果就出现了问题，出现了多次打印相同时间的情况，这种情况本不应该发生的。这是因为SimpleDateFormat本身是线程不安全的，所以当多个线程同时使用同一个SimpleDateFormat对象是，就会出现并发安全问题。</p><p>我们可以通过加锁来解决线程安全问题。</p><p><strong>v0.5</strong></p><pre><code class="line-numbers language-java">/** * 描述：     加锁来解决线程安全问题 */public class ThreadLocalNormalUsage04 {    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);    static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 1000; i++) {            int finalI = i;            threadPool.submit(new Runnable() {                @Override                public void run() {                    String date = new ThreadLocalNormalUsage04().date(finalI);                    System.out.println(date);                }            });        }        threadPool.shutdown();    }    public String date(int seconds) {        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时        Date date = new Date(1000 * seconds);        String s = null;        // 使用synchronized加类锁来保证线程安全        synchronized (ThreadLocalNormalUsage04.class) {            s = dateFormat.format(date);        }        return s;    }}</code></pre><p>加了锁之后程序就可以正常运行了，没有线程安全问题了</p><p>但是最后通过加锁来解决线程安全问题后，就会导致1000个线程需要依次排队获取simpleDateFormat对象，会导致性能下降，吞吐量降低。所以我们就需要引入ThreadLocal来解决这个问题。</p><p>锁和ThreadLocal使用场景是有区别的，具体区别如下：</p><p><img src="/attachment/914eab2b8d1457a400c802810ddc9cbf.png"></p><p><strong>使用ThreadLocal来进行优化</strong></p><p><strong>v1.0</strong></p><p><img src="/attachment/9f70cf3932d646e4cf3107d0b217a403.png"></p><pre><code class="line-numbers language-java">/** * 描述：     利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存 */public class ThreadLocalNormalUsage05 {    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 1000; i++) {            int finalI = i;            threadPool.submit(new Runnable() {                @Override                public void run() {                    String date = new ThreadLocalNormalUsage05().date(finalI);                    System.out.println(date);                }            });        }        threadPool.shutdown();    }    public String date(int seconds) {        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时        Date date = new Date(1000 * seconds);//        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        // 获取ThreadLocal中的SimpleDateFormat对象。这个对象在每个线程中只有独有的一份，这里使用get()方法就会自动获取当前线程所持有的ThreadLocal中的SimpleDateFormat对象        SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal2.get();        return dateFormat.format(date);    }} // 使用ThreadLocal来进行优化class ThreadSafeFormatter {    // 创建ThreadLocal，并且覆写初始化方法initialValue()  这里将dateFormatThreadLocal设置为静态变量，就可以随时取用    public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() {        @Override        protected SimpleDateFormat initialValue() {            // 返回想要存入ThreadLocal的对象            return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        }    };     // 使用lambda表达式来简化写法    public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal2 = ThreadLocal            .withInitial(() -&gt; new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));}</code></pre><h3 id="典型场景2-当前用户信息需要被线程内所有方法共享"><a href="#典型场景2-当前用户信息需要被线程内所有方法共享" class="headerlink" title="典型场景2 :当前用户信息需要被线程内所有方法共享"></a>典型场景2 :当前用户信息需要被线程内所有方法共享</h3><p>一个比较繁琐的解决方案是把user作为参数层层传递,从service-1()传到service-2()，再从service-20传到service-3()。以此类推,但是这样做会导致代码冗余且不易维护。</p><p><img src="/attachment/27ffc194fbea138ea171a8a3af0a6836.png"></p><p>所以我们可以在每个线程内保存全局变量，可以让不同方法直接使用，避免参数传递的麻烦。并且也能保证每个线程是维护的自己的变量，和其他线程的变量区分开。这也就是通过ThreadLocal完成了一个上下文设计模式。</p><p>实现方法：</p><ul><li>用ThreadLocal保存一些业务内容(用户权限信息、从用户系统获取到的用户名、user ID等)</li><li>这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的</li><li>在线程生命周期内，都通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象(例如user对象)作为参数传递的麻烦</li><li>强调的是同一个请求内(同一个线程内)不同方法间的共享</li><li>不需重写initialValue()方法,但是必须手动调用set()方法</li></ul><p><img src="/attachment/f92830224e26ead501e9daabb35ddc27.png"></p><pre><code class="line-numbers language-java">/** * 描述：     演示ThreadLocal用法2：避免传递参数的麻烦 */public class ThreadLocalNormalUsage06 {    public static void main(String[] args) {        new Service1().process("");    }} // 获取用户姓名class Service1 {    public void process(String name) {        // 获取用户姓名        User user = new User("超哥");        // 使用set()方法将用户姓名写入当前线程的ThreadLocal中        UserContextHolder.holder.set(user);        new Service2().process();    }} class Service2 {    public void process() {        // 获取到当前线程ThreadLocal中存储的用户姓名        User user = UserContextHolder.holder.get();        System.out.println("Service2拿到用户名：" + user.name);        new Service3().process();    }} class Service3 {    public void process() {        User user = UserContextHolder.holder.get();        System.out.println("Service3拿到用户名：" + user.name);        UserContextHolder.holder.remove();    }} // 创建用来获取当前线程ThreadLocal的类class UserContextHolder {    // 设置静态变量，这里只需要new ThreadLocal即可，不需要在设置初始化方法了，    // 因为在这个应用场景中，ThreadLocal中的数据并不是在创建ThreadLocal就存储进去的    // 而是在调用方法的过程中才会写入到ThreadLocal种    public static ThreadLocal&lt;User&gt; holder = new ThreadLocal&lt;&gt;();} class User {    String name;    public User(String name) {        this.name = name;    }}</code></pre><h2 id="ThreadLocal的作用"><a href="#ThreadLocal的作用" class="headerlink" title="ThreadLocal的作用"></a>ThreadLocal的作用</h2><ol><li>让某个需要用到的对象在线程间隔离(每个线程都有自己的独立的对象)</li><li>在任何方法中都可以轻松获取到该对象</li></ol><p>根据共享对象的生成时机不同，选择 initialValue或set来保存对象</p><h3 id="场景一-initialValue"><a href="#场景一-initialValue" class="headerlink" title="场景一: initialValue"></a>场景一: initialValue</h3><p>如果我们能够确定在每个线程中要存储使用哪些对象，就可以用使用这个方法在初始化ThreadLocal对象的时候就将数据存入ThreadLocal中。在ThreadLocal第一次get的时候把对象给初始化出来，对象的初始化时机可以由我们控制</p><h3 id="场景二-set"><a href="#场景二-set" class="headerlink" title="场景二:set"></a>场景二:set</h3><p>如果需要保存到ThreadLocal里的对象的生成时机不由我们随意控制，例如拦截器生成的用户信息，就用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用。<br>只要让每个线程独有对象，而不再不同的线程之间共享对象，就不会有线程安全的问题了</p><h2 id="使用ThreadLocal带来的好处"><a href="#使用ThreadLocal带来的好处" class="headerlink" title="使用ThreadLocal带来的好处"></a>使用ThreadLocal带来的好处</h2><ol><li>达到线程安全</li><li>不需要加锁，提高执行效率</li><li>更高效地利用内存、节省开销:相比于每个任务都新建一个SimpleDateFormat ,显然用Threadlocal可以节省内存和开销</li><li>免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数。ThreadLocal使得代码耦合度更低，更优雅</li></ol><h2 id="ThreadLocal的原理"><a href="#ThreadLocal的原理" class="headerlink" title="ThreadLocal的原理"></a>ThreadLocal的原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>想学习原理，首先需要搞清楚Thread 、ThreadLocal以及ThreadLocalMap三者之间的关系：</p><p>每个Thread对象中都持有一个ThreadLocalMap成员变量，<strong>Thread和ThreadLocalMap是一对一的关系</strong>，而ThreadLocalMap可以理解成一个Map（但实际并不是Map类），用来存储该线程所有持有所有ThreadLocal，因为一个线程可能有多个ThreadLocal对象，用来获取不同的对象。<strong>ThreadLocal对象和要存储进这个ThreadLocal中的对象数据也是一对一的关系</strong>，一个ThreadLocal只能存储进一个对象，如果想要存储多个不同的对象，就需要创建多个不同的ThreadLocal来存储在ThreadLocalMap中。</p><pre><code class="line-numbers language-java">public class Thread implements Runnable {    ...    // Thread中成员属性ThreadLocalMap，用来存储该线程所持有的所有ThreadLocal对象    ThreadLocal.ThreadLocalMap threadLocals = null;    ...}  // ThreadLocalMap是ThreadLocal中的一个静态内部类static class ThreadLocalMap {    private Entry[] table;    ...    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {        /** The value associated with this ThreadLocal. */        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) {            super(k);            value = v;        }    }    ...}</code></pre><p>数据结构关系如下图所示</p><p><img src="/attachment/ecf427c0c6cda2cbcbd3af89654d7160.png"></p><h4 id="早期ThreadLocal设计对比"><a href="#早期ThreadLocal设计对比" class="headerlink" title="早期ThreadLocal设计对比"></a>早期ThreadLocal设计对比</h4><p>在JDK早期的设计中，每个ThreadLocal都有一个map对象，将线程作为map对象的key，要存储的变量作为map的value，如上一节所讲，和现在的ThreadLocal设计大不相同。</p><p>JDK8之后，每个Thread维护一个ThreadLocalMap对象，这个Map的key是ThreadLocal实例本身，value是存储的值要隔离的变量，是泛型，其具体过程如下：</p><ol><li>每个Thread线程内部都有一个Map（ThreadLocalMap::threadlocals）;</li><li>Map里面存储ThreadLocal对象（key）和线程的变量副本（value）;</li><li>Thread内部的Map由ThreadLocal维护，由ThreadLocal负责向map获取和设置变量值;</li><li>对于不同的线程，每次获取副本值时，别的线程不能获取当前线程的副本值，就形成了数据之间的隔离。</li></ol><p>JDK8之后设计的好处在于：</p><ol><li>每个Map存储的Entry的数量变少，在实际开发过程中，ThreadLocal的数量往往要少于Thread的数量，Entry的数量减少就可以减少哈希冲突。</li><li>当Thread销毁的时候，ThreadLocalMap也会随之销毁，ThreadLocal也就会跟着销毁，减少内存使用，早期的ThreadLocal并不会自动销毁。</li></ol><h3 id="Thread、ThreadLocal、ThreadLocalMap关系"><a href="#Thread、ThreadLocal、ThreadLocalMap关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap关系"></a>Thread、ThreadLocal、ThreadLocalMap关系</h3><p>Thread和ThreadLocal，人手一份</p><p><img src="/attachment/f0e07265b6b5e922b47f260605a28ee6.png"></p><p>ThreadLocal和ThreadLocalMap</p><p><img src="/attachment/def410a167bdc282d4ca31fe950db370.png"></p><p>三者总概括</p><p><img src="/attachment/d6f737e1a75f0c73d1dd5ccdf8df3f71.png"></p><p><img src="/attachment/0c9e2634a761b32ce0d372661a572852.png"></p><h3 id="ThreadLocal的主要方法及源码分析"><a href="#ThreadLocal的主要方法及源码分析" class="headerlink" title="ThreadLocal的主要方法及源码分析"></a>ThreadLocal的主要方法及源码分析</h3><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ol><li>T initialValue( )：初始化</li><li>void set(T t)：为这个线程设置一个新值</li><li>T get()：得到这个线程对应的value。如果是首次调用get() ,则会调用initialize来得到这个值</li><li>void remove( )：删除对应这个线程的值</li></ol><h4 id="T-initialValue-方法"><a href="#T-initialValue-方法" class="headerlink" title="T initialValue()方法"></a>T initialValue()方法</h4><p>initialValue方法没有默认实现的，如果我们要用initialValue方法，需要自己实现，通常是匿名内部类的方式</p><pre><code class="line-numbers language-java">// ThreadLocal.initialValue()// 该方法需要重写，否则ThreadLocal只会返回nullprotected T initialValue() {    return null;}</code></pre><ol><li>该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get的时候，才会触发</li><li>当线程第一次使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本initialValue方法，这正对应了ThreadLocal的两种典型用法</li><li>通常每个线程最多调用一次此方法，但如果已经调用了remove()后，再调用get()，则可以再次调用此方法</li><li>如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方法来重写initialValue()方法，以便在后续使用中可以初始化副本对象。</li></ol><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p>get方法是先取出当前线程的ThreadLocalMap，然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入，取出map中属于本ThreadLocal的value。注意，这个map以及map中的key和value都是保存在Thread线程对象中的，而不是保存在ThreadLocal中。</p><pre><code class="line-numbers language-java">// ThreadLocal.get()public T get() {    // 获取当前线程    Thread t = Thread.currentThread();    // 获取当前线程的ThreadLocalMap    ThreadLocalMap map = getMap(t);    // 如果当前的map不是空，说明该线程已经有ThreadLocal调用过get()被初始化过了    if (map != null) {        //         /**         * 从ThreadLocalMap中获取当前ThreadLocal的value值         * 这里就类似于Map,传入key值，然后去获取对应的value         * 这里传入的是this，这个get()方法是在ThreadLocal类当中的，那么这个this指的就是当前这个ThreadLocal对象，进而就能获取到存储到该ThreadLocal中的数据了         */        ThreadLocalMap.Entry e = map.getEntry(this);        // 如果不为空则返回value，如果当前ThreadLocal在map中没有数据，则还会执行该方法最后的setInitialValue()方法进行初始化        if (e != null) {            @SuppressWarnings("unchecked")            T result = (T)e.value;            // 返回存储到当前线程中的该ThreadLocal的值            return result;        }    }    // 如果当前的map是空，说明该线程还没有初始化过ThreadLocal，则调用初始化方法    return setInitialValue();} // ThreadLocal.getMap()ThreadLocalMap getMap(Thread t) {    return t.threadLocals;} // ThreadLocal.setInitialValue()private T setInitialValue() {    // 调用初始化方法，一般需要重写initialValue()方法，这样initialValue()就能初始化返回自己指定类型的对象    T value = initialValue();    // 获取当前线程    Thread t = Thread.currentThread();    // 当前线程的ThreadLocalMap    ThreadLocalMap map = getMap(t);    // 如果map已经创建了，则将当前ThreadLocal和要存入当前ThreadLocal的值作为key-value对存入ThreadLocalMap    if (map != null)        map.set(this, value);    // 如果当前线程还没有创建，则为当前线程创建ThreadLocalMap，并将ThreadLocal和要存入当前ThreadLocal的值存入    else        createMap(t, value);        // 返回初始化ThreadLocal的值    return value;}</code></pre><h4 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h4><p>该方法和setInitialValue()方法很类似</p><pre><code class="line-numbers language-java">// ThreadLocal.set()public void set(T value) {    // 获取当前线程    Thread t = Thread.currentThread();    // 获取当前线程的ThreadLocalMap    ThreadLocalMap map = getMap(t);    // 如果当前线程已经创建ThreadLocalMap了，则将当前ThreadLocal和要存入当前ThreadLocal的值作为key-value对存入ThreadLocalMap，如果该ThreadLocal以前存储过值了，则这个操作就会将原有的值覆盖掉    if (map != null)        map.set(this, value);    // 如果当前线程还没有创建，则为当前线程创建ThreadLocalMap，并将ThreadLocal和要存入当前ThreadLocal的值存入    else        createMap(t, value);}</code></pre><h4 id="T-remove-方法"><a href="#T-remove-方法" class="headerlink" title="T remove()方法"></a>T remove()方法</h4><pre><code class="line-numbers language-java">// ThreadLocal.remove()public void remove() {    // 获取当前线程的ThreadLocalMap    ThreadLocalMap m = getMap(Thread.currentThread());    // 删除map中以当前ThreadLocal为key的键值对    if (m != null)        m.remove(this);}</code></pre><h3 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h3><p>ThreadLocalMap类，它是ThreadLocal中的是个内部类。该类的对象是存储在Thread中的，即Thread.threadLocals</p><p>ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[] table，可以认为是一个map键值对（但实际上ThreadLocalMap类并不是一个Map类型）:</p><ul><li>键：这个ThreadLocal</li><li>值：实际需要的成员变量，比如user或者simpleDateFormat对象</li></ul><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>在冲突解决上，ThreadLocalMap和之前我们讲过的HashMap还是有一些区别的</p><p>HashMap在JDK1.8之后如果出现冲突就是采用拉链法，在有冲突的位置创建一个链表，将冲突节点都追加到链表中，当链表达到一定长度后则会将链表转换为红黑树，这就是HashMap解决冲突的方法</p><p><img src="/attachment/732c907f29cd13effb5298f924768d19.png"></p><p>而ThreadLocalMap这里采用的是<mark style="background: #FFB8EBA6;">线性探测法</mark>，也就是如果发生冲突，就继续找下一个空位置,而不是用拉链法或者创建红黑树来解决冲突。</p><h3 id="两种使用场景殊途同归"><a href="#两种使用场景殊途同归" class="headerlink" title="两种使用场景殊途同归"></a>两种使用场景殊途同归</h3><p>学完源码后，我们再返回去看最开始讲的两种应用场景，通过源码分析可以看出，使用setInitialValue和直接set最后都是利用map.set()方法来设置值。也就是说，最后都会对应到ThreadLocalMap的一个Entry，只不过是起点和入口不一样，场景一的起点是get()方法，场景二的起点是set()方法。</p><h2 id="ThreadLocal注意点"><a href="#ThreadLocal注意点" class="headerlink" title="ThreadLocal注意点"></a>ThreadLocal注意点</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>什么是内存泄漏：某个对象不再使用，但是占用的内存却不能被回收</p><p>ThreadLocalMap中的Entry（key）继承自WeakReference，是弱引用。</p><pre><code class="line-numbers language-java">// ThreadLocal.ThreadLocalMap.Entry// 这里Entry继承自弱引用的ThreadLocalstatic class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {    /** The value associated with this ThreadLocal. */    Object value;     Entry(ThreadLocal&lt;?&gt; k, Object v) {        // 调用继承父类的构造方法，也就是将ThreadLocal设置成了弱引用        super(k);        // 像这种普通的赋值，就是强引用        value = v;    }}</code></pre><p>弱引用的特点是，如果这个对象只被弱引用关联(没有任何强引用关联) ，那么这个对象就可以被回收，也就是说就算是有一个弱引用指向对象，GC也会无视掉这个引用，还是将这个对象看成不可达对象，会将其回收掉。所以弱引用不会阻止GC。</p><h4 id="Value的泄漏"><a href="#Value的泄漏" class="headerlink" title="Value的泄漏"></a>Value的泄漏</h4><p>ThreadLocalMap 的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用。正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收,因为没有任何强引用了，因为当线程中止之后，整个ThreadMap对象就会被回收，进而ThreadMap中存储的所有key-value对也都会被回收。</p><p>但是，如果线程不终止(比如线程需要保持很久，或者我们在用线程池的时候)，那么key对应的value就不能被回收，因为有以下的调用链:Thread一&gt; ThreadLocalMap一&gt; Entry ( key为null )一&gt;Value。</p><p>因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，随着线程ThreadLocal的增多就可能会出现OOM错误。</p><p>JDK已经考虑到了这个问题，所以在<mark style="background: #BBFABBA6;">ThreadLocalMap中的set、remove、rehash等方法中会扫描key为null的Entry</mark>，并把对应的value设置为null，这样value指向的对象就变成了不可达对象了，也就可以被回收了</p><p>源码例子：</p><pre><code class="line-numbers language-java">// ThreadLocal.ThreadLocalMap.resize()private void resize() {    Entry[] oldTab = table;    int oldLen = oldTab.length;    int newLen = oldLen * 2;    Entry[] newTab = new Entry[newLen];    int count = 0;    for (int j = 0; j &lt; oldLen; ++j) {        Entry e = oldTab[j];        if (e != null) {            ThreadLocal&lt;?&gt; k = e.get();            // 在扩容的时候会遍历判断key是不是为空，如果为null，则将其对应的value指向为空，这样就可以回收已经不用的对象了            if (k == null) {                e.value = null; // Help the GC            } else {                int h = k.threadLocalHashCode &amp; (newLen - 1);                while (newTab[h] != null)                    h = nextIndex(h, newLen);                newTab[h] = e;                count++;            }        }    }    setThreshold(newLen);    size = count;    table = newTab;}</code></pre><p>但是如果一个ThreadLocal不被使用,那么实际上set、remove、rehash方法也不会被调用、如果同时线程又不停止、那么调用链就一直存在、那么就导致了value的内存泄漏，这种情况下就需要我们在开发过程中严格遵守开发规范。</p><h4 id="如何避免内存泄露-阿里规约"><a href="#如何避免内存泄露-阿里规约" class="headerlink" title="如何避免内存泄露(阿里规约)"></a>如何避免内存泄露(阿里规约)</h4><p>调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal之后,应该调用remove方法。比如这个线程即将结束的时候，再使用拦截器将线程拦截，将它的ThreadLocal给remove掉即可。</p><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>在进行get之前，必须先set，否则可能会返回NULL，并且返回类型如果不是对象类型，而是基本数据类型的话，还会报空指针异常，最好是用包装类来替代基本数据类型。</p><h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>如果在每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是会有并发访问问题。所以一定要避免向ThreadLocal中存储static全局变量，这样依旧会导致并发异常。</p><h3 id="不需要强行使用ThreadLocal"><a href="#不需要强行使用ThreadLocal" class="headerlink" title="不需要强行使用ThreadLocal"></a>不需要强行使用ThreadLocal</h3><p>如果可以不使用ThreadLocal就解决问题，那么不要强行使用</p><ul><li>例如在任务数很少的时候，在局部变量中可以新建对象就可以解决问题，那么就不需要使用到ThreadLocal，因为这种情况下使用ThreadLocal带来的收益并不大，反而还会增加任务量</li></ul><h3 id="优先使用框架的支持"><a href="#优先使用框架的支持" class="headerlink" title="优先使用框架的支持"></a>优先使用框架的支持</h3><p>例如在Spring中，如果可以使用RequestContextHolder，那么就不需要自己维护ThreadLocal，因为自己可能会忘记调用remove()方法等，造成内存泄漏。</p><p>以Spring为例：</p><h4 id="Date-TimeContextHolder类"><a href="#Date-TimeContextHolder类" class="headerlink" title="Date TimeContextHolder类"></a>Date TimeContextHolder类</h4><pre><code class="line-numbers language-java">package org.springframework.format.datetime.standard;public final class DateTimeContextHolder {    // 将时间的上下文存储到ThreadLocal中，这样每一个线程就会拥有自己独立的时间设置    private static final ThreadLocal&lt;DateTimeContext&gt; dateTimeContextHolder = new NamedThreadLocal("DateTimeContext");    ...}</code></pre><p>这里就是Spring提供的ThreadLocal支持</p><h4 id="RequestContextHolder类"><a href="#RequestContextHolder类" class="headerlink" title="RequestContextHolder类"></a>RequestContextHolder类</h4><p>为每一个请求都设置一个ThreadLocal。每次HTTP请求都对应一个线程，线程之间相互隔离，这就是ThreadLocal的典型应用场景。</p><pre><code class="line-numbers language-java">package org.springframework.web.context.request;public abstract class RequestContextHolder {    private static final boolean jsfPresent = ClassUtils.isPresent("javax.faces.context.FacesContext", RequestContextHolder.class.getClassLoader());    // 这里的NameThreadLocal就是ThreadLocal，知识spring在ThreadLocal的基础上又加了一个name属性，用来标识Thread名称    private static final ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder = new NamedThreadLocal("Request attributes");    private static final ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder = new NamedInheritableThreadLocal("Request context");    public RequestContextHolder() {    }    ...}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 fail-fast(快速失败)机制</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-fail-fast-kuai-su-shi-bai-ji-zhi/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-fail-fast-kuai-su-shi-bai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-fail-fast-快速失败-机制"><a href="#【Java-多线程并发】-fail-fast-快速失败-机制" class="headerlink" title="【Java 多线程并发】 fail-fast(快速失败)机制"></a>【Java 多线程并发】 fail-fast(快速失败)机制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 fail-fast(快速失败)机制date: 2023-07-04 15:44tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 fail-fast(快速失败)机制</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。</p><p><strong>概述</strong></p><p>ConcurrentModificationException都是在<mark style="background: #FFB8EBA6;">操作Iterator时抛出的异常</mark>。</p><p>当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在ArrayList、HashMap的扩容代码中都有对变量modCount的操作，该变量的操作在add，remove等操作中都会发生改变。那么该变量到底有什么作用呢？</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。</p><p>当多个线程对同一个集合的内容进行操作时，就有可能出现在一个线程正在迭代集合的过程中，该集合因为别的线程对其的操作使得结构发生变化，这就会产生fail-fast事件，抛出 ConcurrentModificationException异常。</p><p>例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p><p>但是要注意，fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p><h2 id="fail-fast的出现场景"><a href="#fail-fast的出现场景" class="headerlink" title="fail-fast的出现场景"></a>fail-fast的出现场景</h2><p>在我们常见的java集合中就可能出现fail-fast机制,比如ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。</p><h3 id="单线程环境下的fail-fast："><a href="#单线程环境下的fail-fast：" class="headerlink" title="单线程环境下的fail-fast："></a>单线程环境下的fail-fast：</h3><h4 id="ArrayList发生fail-fast例子："><a href="#ArrayList发生fail-fast例子：" class="headerlink" title="ArrayList发生fail-fast例子："></a>ArrayList发生fail-fast例子：</h4><pre><code class="line-numbers language-java">public static void main(String[] args) {    List&lt;String&gt; list = new ArrayList&lt;&gt;();    for (int i = 0 ; i &lt; 10 ; i++ ) {         list.add(i + "");    }    Iterator&lt;String&gt; iterator = list.iterator();    int i = 0 ;    while(iterator.hasNext()) {         if (i == 3) {              list.remove(3);         }         System.out.println(iterator.next());         i ++;    }}</code></pre><p>该段代码定义了一个Arraylist集合，并使用迭代器遍历，在遍历过程中，刻意在某一步迭代中remove一个元素，这个时候，就会发生fail-fast。</p><p><img src="/attachment/ee567b532529a18cafb7333b8b222865.png"></p><h4 id="HashMap发生fail-fast："><a href="#HashMap发生fail-fast：" class="headerlink" title="HashMap发生fail-fast："></a>HashMap发生fail-fast：</h4><pre><code class="line-numbers language-java">public static void main(String[] args) {    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();    for (int i = 0 ; i &lt; 10 ; i ++ ) {         map.put(i+"", i+"");    }    Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();    int i = 0;    while (it.hasNext()) {         if (i == 3) {              map.remove(3+"");         }         Entry&lt;String, String&gt; entry = it.next();         System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());         i++;    }}</code></pre><p>该段代码定义了一个hashmap对象并存放了10个键值对，在迭代遍历过程中，使用map的remove方法移除了一个元素，导致抛出了 ConcurrentModificationException异常：</p><p><img src="/attachment/d020d07ccfa7d01cac15836dbfbabfdd.png"></p><h3 id="多线程环境下："><a href="#多线程环境下：" class="headerlink" title="多线程环境下："></a>多线程环境下：</h3><pre><code class="line-numbers language-java">public class FailFastTest {    public static List&lt;String&gt; list = new ArrayList&lt;&gt;();    private static class MyThread1 extends Thread {          @Override          public void run() {               Iterator&lt;String&gt; iterator = list.iterator();               while(iterator.hasNext()) {                    String s = iterator.next();                    System.out.println(this.getName() + ":" + s);                    try {                       Thread.sleep(1000);                   } catch (InterruptedException e) {                       e.printStackTrace();                   }               }               super.run();          }    }    private static class MyThread2 extends Thread {          int i = 0;          @Override          public void run() {               while (i &lt; 10) {                    System.out.println("thread2:" + i);                    if (i == 2) {                          list.remove(i);                    }                    try {                       Thread.sleep(1000);                   } catch (InterruptedException e) {                       e.printStackTrace();                   }                    i ++;               }          }    }    public static void main(String[] args) {          for(int i = 0 ; i &lt; 10;i++){               list.add(i+"");            }          MyThread1 thread1 = new MyThread1();          MyThread2 thread2 = new MyThread2();          thread1.setName("thread1");          thread2.setName("thread2");          thread1.start();          thread2.start();    }}</code></pre><p>启动两个线程，其中一个线程1对list进行迭代，另一个线程2在线程1的迭代过程中去remove一个元素，结果也是抛出了java.util.ConcurrentModificationException</p><p><img src="/attachment/93d6c98b0c68317bbbc4073890e69a0b.png"></p><p>上面都是讲的删除导致集合结构改变而造成快速失败的情况，如果是添加导致的集合结构改变，也是会出现快速失败的，这里就不再举例了。</p><h2 id="fail-fast的原理"><a href="#fail-fast的原理" class="headerlink" title="fail-fast的原理"></a>fail-fast的原理</h2><p>fail-fast是如何抛出ConcurrentModificationException异常的，又是在什么情况下才会抛出?</p><p>我们知道，对于集合如list，map类，我们都可以通过迭代器来遍历，而Iterator其实只是一个接口，具体的实现还是要看具体的集合类中的内部类去实现Iterator并实现相关方法。ConcurrentModificationException都是在<mark style="background: #FFB8EBA6;">操作Iterator时抛出的异常</mark>。这里我们就以ArrayList类为例。在ArrayList中，当调用list.iterator()时，其源码是：</p><pre><code class="line-numbers language-java">public Iterator&lt;E&gt; iterator() {    return new Itr();}</code></pre><p>即它会返回一个新的Itr类，而Itr类是ArrayList的内部类，实现了Iterator接口，而ArrayList的Iterator是在父类AbstractList.java中实现的。源码如下：</p><pre><code class="line-numbers language-java">package java.util;public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {    ...    // AbstractList中唯一的属性    // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1    protected transient int modCount = 0;     // 返回List对应迭代器。实际上，是返回Itr对象。    public Iterator&lt;E&gt; iterator() {        return new Itr();    }     // Itr是Iterator(迭代器)的实现类    private class Itr implements Iterator&lt;E&gt; {        // index of next element to return        int cursor = 0;         // index of last element returned; -1 if no such        int lastRet = -1;        // 修改数的记录值。        // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；        // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；        // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。        int expectedModCount = modCount;        public boolean hasNext() {            return cursor != size();        }         @SuppressWarnings("unchecked")        public E next() {            // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；            // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。            checkForComodification();            int i = cursor;            if (i &gt;= size)                throw new NoSuchElementException();            Object[] elementData = ArrayList.this.elementData;            if (i &gt;= elementData.length)                throw new ConcurrentModificationException();            cursor = i + 1;            return (E) elementData[lastRet = i];        }                public void remove() {            if (lastRet &lt; 0)                throw new IllegalStateException();            checkForComodification();             try {                ArrayList.this.remove(lastRet);                cursor = lastRet;                lastRet = -1;                expectedModCount = modCount;            } catch (IndexOutOfBoundsException ex) {                throw new ConcurrentModificationException();            }        }         @Override        @SuppressWarnings("unchecked")        public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {            Objects.requireNonNull(consumer);            final int size = ArrayList.this.size;            int i = cursor;            if (i &gt;= size) {                return;            }            final Object[] elementData = ArrayList.this.elementData;            if (i &gt;= elementData.length) {                throw new ConcurrentModificationException();            }            while (i != size &amp;&amp; modCount == expectedModCount) {                consumer.accept((E) elementData[i++]);            }            // update once at end of iteration to reduce heap write traffic            cursor = i;            lastRet = i - 1;            checkForComodification();        }         final void checkForComodification() {            if (modCount != expectedModCount)                throw new ConcurrentModificationException();        }    }    ...}</code></pre><p>其中，Itr类有三个属性：</p><pre><code class="line-numbers language-java">int cursor;       // index of next element to returnint lastRet = -1; // index of last element returned; -1 if no suchint expectedModCount = modCount;</code></pre><ul><li>cursor是指集合遍历过程中的即将遍历的元素的索引</li><li>lastRet是cursor -1，默认为-1，即不存在上一个时，为-1，它主要用于记录刚刚遍历过的元素的索引。</li><li>expectedModCount这个就是fail-fast判断的关键变量了，它初始值就为ArrayList中的modCount。（modCount是抽象类AbstractList中的变量，默认为0，而ArrayList 继承了AbstractList ，所以也有这个变量，modCount用于记录集合操作过程中作的修改次数，与size还是有区别的，并不一定等于size）</li></ul><p>我们一步一步来看Itr类中的方法：</p><pre><code class="line-numbers language-java">public boolean hasNext() {    return cursor != size;}</code></pre><p>迭代器迭代结束的标志就是hasNext()返回false，而该方法就是用cursor游标和size(集合中的元素数目)进行对比，当cursor等于size时，表示已经遍历完成。</p><p>接下来看看最关心的next()和remove()方法，看看为什么在迭代过程中，如果有线程对集合结构做出改变，就会发生fail-fast：</p><pre><code class="line-numbers language-java">@SuppressWarnings("unchecked")public E next() {    checkForComodification();    int i = cursor;    if (i &gt;= size)        throw new NoSuchElementException();    Object[] elementData = ArrayList.this.elementData;    if (i &gt;= elementData.length)        throw new ConcurrentModificationException();    cursor = i + 1;    return (E) elementData[lastRet = i];}  public void remove() {    if (lastRet &lt; 0)        throw new IllegalStateException();    checkForComodification();    try {        ArrayList.this.remove(lastRet);        cursor = lastRet;        lastRet = -1;        expectedModCount = modCount;    } catch (IndexOutOfBoundsException ex) {        throw new ConcurrentModificationException();    }}</code></pre><p> 从源码知道，每次调用next()和remove()方法，在实际访问元素/删除元素前，都会调用checkForComodification方法，该方法源码如下：</p><pre><code class="line-numbers language-java">final void checkForComodification() {    if (modCount != expectedModCount)        throw new ConcurrentModificationException();}</code></pre><p>可以看出，该方法才是判断是否抛出ConcurrentModificationException异常的关键。</p><p>在该段代码中，当modCount != expectedModCount时，就会抛出该异常。但是在一开始的时候，expectedModCount初始值默认等于modCount，为什么会出现modCount != expectedModCount？</p><p>很明显expectedModCount在整个迭代过程除了一开始赋予初始值modCount外，并没有在任何地方对其进行修改操作，不可能发生改变，所以可能发生改变的就只有modCount。下面我们在通过源码来看一下什么时候“modCount 不等于 expectedModCount”，通过ArrayList的源码，来看看modCount是如何被修改的。</p><pre><code class="line-numbers language-java">package java.util;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{    ...    // list中容量变化时，对应的同步函数    public void ensureCapacity(int minCapacity) {        modCount++;        int oldCapacity = elementData.length;        if (minCapacity &gt; oldCapacity) {            Object oldData[] = elementData;            int newCapacity = (oldCapacity * 3)/2 + 1;            if (newCapacity &lt; minCapacity)                newCapacity = minCapacity;            // minCapacity is usually close to size, so this is a win:            elementData = Arrays.copyOf(elementData, newCapacity);        }    }    // 添加元素到队列最后    public boolean add(E e) {        // 修改modCount        ensureCapacity(size + 1);  // Increments modCount!!        elementData[size++] = e;        return true;    }    // 添加元素到指定的位置    public void add(int index, E element) {        if (index &gt; size || index &lt; 0)            throw new IndexOutOfBoundsException(            "Index: "+index+", Size: "+size);        // 修改modCount        ensureCapacity(size+1);  // Increments modCount!!        System.arraycopy(elementData, index, elementData, index + 1,             size - index);        elementData[index] = element;        size++;    }    // 添加集合    public boolean addAll(Collection&lt;? extends E&gt; c) {        Object[] a = c.toArray();        int numNew = a.length;        // 修改modCount        ensureCapacity(size + numNew);  // Increments modCount        System.arraycopy(a, 0, elementData, size, numNew);        size += numNew;        return numNew != 0;    }    // 删除指定位置的元素    public E remove(int index) {        RangeCheck(index);        // 修改modCount        modCount++;        E oldValue = (E) elementData[index];        int numMoved = size - index - 1;        if (numMoved &gt; 0)            System.arraycopy(elementData, index+1, elementData, index, numMoved);        elementData[--size] = null; // Let gc do its work        return oldValue;    }    // 快速删除指定位置的元素    private void fastRemove(int index) {        // 修改modCount        modCount++;        int numMoved = size - index - 1;        if (numMoved &gt; 0)            System.arraycopy(elementData, index+1, elementData, index,                             numMoved);        elementData[--size] = null; // Let gc do its work    }    // 清空集合    public void clear() {        // 修改modCount        modCount++;        // Let gc do its work        for (int i = 0; i &lt; size; i++)            elementData[i] = null;        size = 0;    }    ...}</code></pre><p>从中，我们发现：无论是add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。</p><h2 id="fail-fast-产生的步骤"><a href="#fail-fast-产生的步骤" class="headerlink" title="fail-fast 产生的步骤"></a>fail-fast 产生的步骤</h2><ol><li>新建了一个ArrayList，名称为arrayList。</li><li>向arrayList中添加内容。</li><li>新建一个“线程a”，并在“线程a”中通过Iterator反复的读取arrayList的值。</li><li>新建一个“线程b”，在“线程b”中删除arrayList中的一个“节点A”。</li><li>这时，就会产生有趣的事件了。<ol><li>在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。</li><li>在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！</li><li>线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。</li></ol></li></ol><p>即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。类似的，hashMap中发生的原理也是一样的。</p><h2 id="避免fail-fast"><a href="#避免fail-fast" class="headerlink" title="避免fail-fast"></a>避免fail-fast</h2><p>了解了fail-fast机制的产生原理，接下来就看看如何解决fail-fast</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法。看看ArrayList中迭代器的remove方法的源码：</p><pre><code class="line-numbers language-java">public void remove() {    if (lastRet &lt; 0)        throw new IllegalStateException();    checkForComodification();    try {        ArrayList.this.remove(lastRet);        cursor = lastRet;        lastRet = -1;        expectedModCount = modCount;    } catch (IndexOutOfBoundsException ex) {        throw new ConcurrentModificationException();    }}</code></pre><p> 可以看到，该remove方法并不会修改modCount的值，并且不会对后面的遍历造成影响。但是该方法remove不能指定元素，只能remove当前遍历过的那个元素，这也是该方法的局限性。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用fail-fast机制的集合（如ArrayList、HashMap），建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。</p><p>以ArrayList为中只需要将ArrayList替换成java.util.concurrent包下对应的类即可解决fail-fast机制。</p><p>即，将代码</p><pre><code class="line-numbers language-java">private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></pre><p>替换为</p><pre><code class="line-numbers language-java">private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();</code></pre><p>则可以解决该办法。</p><p>CopyOnWriterArrayList在是使用上跟 ArrayList几乎一样， CopyOnWriter是写时复制的容器(COW)，在读写时是线程安全的。该容器在对add和remove等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于 CopyOnWriterArrayList在迭代过程并不会发生fail-fast现象。但 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。</p><p>下面我们以ArrayList对应的CopyOnWriteArrayList为例，再进一步谈谈java.util.concurrent包中是如何解决fail-fast事件的。下面是CopyOnWriteArrayList的源码：</p><pre><code class="line-numbers language-java">package java.util.concurrent;import java.util.*;import java.util.concurrent.locks.*;import sun.misc.Unsafe;public class CopyOnWriteArrayList&lt;E&gt;    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    ...    // 返回集合对应的迭代器    public Iterator&lt;E&gt; iterator() {        return new COWIterator&lt;E&gt;(getArray(), 0);    }    ...    private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {        private final Object[] snapshot;        private int cursor;        private COWIterator(Object[] elements, int initialCursor) {            cursor = initialCursor;            // 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。            // 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。            snapshot = elements;        }        public boolean hasNext() {            return cursor &lt; snapshot.length;        }        public boolean hasPrevious() {            return cursor &gt; 0;        }        public E next() {            if (! hasNext())                throw new NoSuchElementException();            return (E) snapshot[cursor++];        }        public E previous() {            if (! hasPrevious())                throw new NoSuchElementException();            return (E) snapshot[--cursor];        }        public int nextIndex() {            return cursor;        }        public int previousIndex() {            return cursor-1;        }        public void remove() {            throw new UnsupportedOperationException();        }        public void set(E e) {            throw new UnsupportedOperationException();        }        public void add(E e) {            throw new UnsupportedOperationException();        }    }    ...}</code></pre><p>从中，我们可以看出:</p><ol><li>和ArrayList继承于AbstractList不同，CopyOnWriteArrayList没有继承于AbstractList，它仅仅只是实现了List接口。</li><li>ArrayList的iterator()函数返回的Iterator是在AbstractList中实现的；而CopyOnWriteArrayList是自己实现Iterator。</li><li>ArrayList的Iterator实现类中调用next()时，会“调用checkForComodification()比较‘expectedModCount’和‘modCount’的大小”；但是，CopyOnWriteArrayList的Iterator实现类中，没有所谓的checkForComodification()，更不会抛出ConcurrentModificationException异常！</li></ol><p>对于HashMap，可以使用ConcurrentHashMap， ConcurrentHashMap采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来旧的数据，而写线程也可以并发的完成改变。即迭代不会发生fail-fast，但不保证获取的是最新的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-aqs-abstract-queued-synchronizer/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-aqs-abstract-queued-synchronizer/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）"><a href="#【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）" class="headerlink" title="【Java 多线程并发】 AQS（Abstract Queued Synchronizer）"></a>【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 AQS（Abstract Queued Synchronizer）date: 2023-07-04 10:53tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AQS（AbstractQueuedSynchronizer）是Java中用于实现同步器的抽象基类。它提供了一种基于FIFO队列的线程协作机制，可以用来构建各种类型的同步器，如锁、信号量、倒计时门栓等。</p><p>提供了两种模式的同步器：独占模式和共享模式。</p><p><img src="/attachment/784b7d93fd20b30245f5f9ad3cddaeb2.png"></p><p><strong>核心思想</strong></p><ul><li>使用一个共享的volatile int状态变量来表示同步状态</li><li>通过CAS操作来实现对状态的原子更新</li><li>LockSupport 进行唤醒等待</li></ul><p><strong>Node 节点</strong></p><p><img src="/attachment/38b8a40011ba88a19274139640820bd1.png"></p><p><strong>AQS的CLH队列</strong></p><p><img src="/attachment/e50d097ac9543916395f1e617f1ad06a.png"></p><p><strong>Lock.lock()</strong></p><p>acquire方法 获取锁</p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p><img src="/attachment/181312ae697df893b073e7115bbefd3f.png"></p><p><strong>Lock.unlock()</strong></p><p>release(int) 释放锁</p><ol><li>用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。</li><li>此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。</li><li>这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋<code>p==head</code>就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了</li></ol><p><img src="/attachment/d9e5766e3c4d20cab16d9fb97d3a85ed.png"></p><p><img src="/attachment/0b80cca207bd9ce71a59fd5950fb586f.png"></p><h2 id="【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）-1"><a href="#【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）-1" class="headerlink" title="【Java 多线程并发】 AQS（Abstract Queued Synchronizer）"></a>【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</h2><p>AQS（AbstractQueuedSynchronizer）是Java中用于实现同步器的抽象基类。它提供了一种基于FIFO队列的线程协作机制，可以用来构建各种类型的同步器，如锁、信号量、倒计时门栓等。</p><p>AQS提供了两种模式的同步器：独占模式和共享模式。独占模式只允许一个线程占用同步状态，如ReentrantLock就是一个独占模式的同步器。共享模式允许多个线程同时占用同步状态，如CountDownLatch和Semaphore就是共享模式的同步器。</p><p>AQS是一个非常重要的基础组件，很多并发工具和框架都是基于AQS来实现的，如ReentrantLock、CountDownLatch、Semaphore、ReentrantReadWriteLock等。了解AQS的原理和使用方法，对于深入理解Java并发编程和开发高效的多线程程序是非常有帮助的。</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>AQS的核心思想是使用一个共享的volatile int状态变量来表示同步状态，通过CAS操作来实现对状态的原子更新。AQS内部维护了一个等待队列，用于存储等待获取同步状态的线程。当线程尝试获取同步状态时，如果发现状态已被其他线程占用，则会将该线程封装成一个节点，插入等待队列的尾部，然后进入自旋等待或被阻塞。当占用同步状态的线程释放状态时，AQS会从等待队列中选择一个线程唤醒，使其重新尝试获取同步状态。</p><p><img src="/attachment/784b7d93fd20b30245f5f9ad3cddaeb2.png"></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><p>我们先来看下这样一个场景</p><p><img src="/attachment/97243ea0218d8532b0b29da280c32cb6.png"></p><p>在这里我们有一个能被多个线程共享操作的资源，在这个场景中应该能看出我们的数据是不安全的，因为我们并不能保证我们的操作是原子操作对吧。基于这个场景我们通过代码来看看效果</p><pre><code class="line-numbers language-java">package com.example.demo;public class AtomicDemo {    // 共享变量    private static int count = 0;    // 操作共享变量的方法    public static void incr(){        // 为了演示效果  休眠一下子        try {            Thread.sleep(1);            count ++;        } catch (InterruptedException e) {            e.printStackTrace();        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 1000 ; i++) {            new Thread(()-&gt;AtomicDemo.incr()).start();        }        Thread.sleep(4000);        System.out.println("result:" + count);    }}</code></pre><p>通过执行发现，执行的结果是一个不确定的值，但总是会小于等于1000，至于原因，是因为incr() 方法不是一个原子操作。为什么不是原子操作这个咱们今天就不深究此处了.<br>迎合今天的主题，我们通过Lock来解决</p><pre><code class="line-numbers language-java">package com.example.demo;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class AtomicDemo {    // 共享变量    private static int count = 0;    private static Lock lock = new ReentrantLock();    // 操作共享变量的方法    public static void incr(){        // 为了演示效果  休眠一下子        try {            lock.lock();            Thread.sleep(1);            count ++;        } catch (InterruptedException e) {            e.printStackTrace();        }finally {            lock.unlock();        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 1000 ; i++) {            new Thread(()-&gt;AtomicDemo.incr()).start();        }        Thread.sleep(4000);        System.out.println("result:" + count);    }}</code></pre><p>然后我们运行发现结果都是 1000了，这也就是1000个线程都去操作这个 count 变量，结果符合我们的预期了。那lock到底是怎么实现的呢？</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>我们先来分析分析</p><p><img src="/attachment/5793f5b90b3aa27d2c93ba1c916c3245.png"></p><p>这样的图片看着比较复杂，咱们简化下。</p><p><img src="/attachment/9b5006b67da26a5f6acfa603930cfa9e.png"></p><p>我们自己假设下，如果要你去设计这样的方法，你应该要怎么设计，他们需要实现哪些功能，</p><p>  首先是lock方法，它是不是要满足这几个功能。</p><p><img src="/attachment/5094d4f14876ce47cc6f4ee3bfe7c118.png"></p><p>需求清楚了，那我们怎么设计呢？<br>第一个互斥怎么做，也就是多个线程只有一个线程能抢占到资源，这个时候我们可以这样设置</p><pre><code class="line-numbers language-java">// 给一个共享资源Int state = 0 ; // 0表示资源没有被占用，可以抢占if(state == 0 ){   // 表示可以获取锁}else{   // 表示锁被抢占 需要阻塞等待}</code></pre><p><img src="/attachment/58c144cf2256b2ae7093405501d6dfd4.png"></p><p>然后就是没有抢占到锁的线程的存储，我们可以通过一个队列，利用FIFO来实现存储。<br>最后就是线程的阻塞和唤醒。大家说说有哪些阻塞线程的方式呀？</p><ul><li>wait/notify: 不合适，不能唤醒指定的线程</li><li>Sleep：休眠，类似于定时器</li><li>Condition：可以唤醒特定线程</li><li>LockSupport:<ul><li>LockSupport.park():阻塞当前线程</li><li>LockSupport.unpark(Thread t):唤醒特定线程</li></ul></li></ul><p>结合今天的主题，我们选择LockSupport来实现阻塞和唤醒。</p><p><img src="/attachment/9e7c7f12264864b43854c7b322cb73d0.png"></p><h2 id="AQS-源码分析"><a href="#AQS-源码分析" class="headerlink" title="AQS 源码分析"></a>AQS 源码分析</h2><h3 id="AQS-类图"><a href="#AQS-类图" class="headerlink" title="AQS 类图"></a>AQS 类图</h3><p><img src="/attachment/2fab0a0517af375be9d0ab1c61580de0.png"></p><p><img src="/attachment/bb258f0f3aee1757399361b039e26eaa.png"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="AQS的int类型变量state"><a href="#AQS的int类型变量state" class="headerlink" title="AQS的int类型变量state"></a>AQS的int类型变量state</h4><pre><code class="line-numbers language-java">    /**     * The synchronization state.     */    private volatile int state;</code></pre><h5 id="与之相关的操作"><a href="#与之相关的操作" class="headerlink" title="与之相关的操作"></a>与之相关的操作</h5><pre><code class="line-numbers language-java">    /**     * Returns the current value of synchronization state.     * This operation has memory semantics of a {@code volatile} read.     * @return current state value     */    protected final int getState() {        return state;    }    /**     * Sets the value of synchronization state.     * This operation has memory semantics of a {@code volatile} write.     * @param newState the new state value     */    protected final void setState(int newState) {        state = newState;    }    /**     * Atomically sets synchronization state to the given updated     * value if the current state value equals the expected value.     * This operation has memory semantics of a {@code volatile} read     * and write.     *     * @param expect the expected value     * @param update the new value     * @return {@code true} if successful. False return indicates that the actual     *         value was not equal to the expected value.     */    protected final boolean compareAndSetState(int expect, int update) {        // See below for intrinsics setup to support this        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);    }</code></pre><h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p><img src="/attachment/6aba206727c3b7cd83555883ec232611.png"></p><h5 id="属性说明"><a href="#属性说明" class="headerlink" title="属性说明"></a>属性说明</h5><p><img src="/attachment/38b8a40011ba88a19274139640820bd1.png"></p><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><pre><code class="line-numbers language-java">    /**     * Wait queue node class.     *     * &lt;p&gt;The wait queue is a variant of a "CLH" (Craig, Landin, and     * Hagersten) lock queue. CLH locks are normally used for     * spinlocks.  We instead use them for blocking synchronizers, but     * use the same basic tactic of holding some of the control     * information about a thread in the predecessor of its node.  A     * "status" field in each node keeps track of whether a thread     * should block.  A node is signalled when its predecessor     * releases.  Each node of the queue otherwise serves as a     * specific-notification-style monitor holding a single waiting     * thread. The status field does NOT control whether threads are     * granted locks etc though.  A thread may try to acquire if it is     * first in the queue. But being first does not guarantee success;     * it only gives the right to contend.  So the currently released     * contender thread may need to rewait.     *     * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new     * tail. To dequeue, you just set the head field.     * &lt;pre&gt;     *      +------+  prev +-----+       +-----+     * head |      | &lt;---- |     | &lt;---- |     |  tail     *      +------+       +-----+       +-----+     * &lt;/pre&gt;     *     * &lt;p&gt;Insertion into a CLH queue requires only a single atomic     * operation on "tail", so there is a simple atomic point of     * demarcation from unqueued to queued. Similarly, dequeuing     * involves only updating the "head". However, it takes a bit     * more work for nodes to determine who their successors are,     * in part to deal with possible cancellation due to timeouts     * and interrupts.     *     * &lt;p&gt;The "prev" links (not used in original CLH locks), are mainly     * needed to handle cancellation. If a node is cancelled, its     * successor is (normally) relinked to a non-cancelled     * predecessor. For explanation of similar mechanics in the case     * of spin locks, see the papers by Scott and Scherer at     * http://www.cs.rochester.edu/u/scott/synchronization/     *     * &lt;p&gt;We also use "next" links to implement blocking mechanics.     * The thread id for each node is kept in its own node, so a     * predecessor signals the next node to wake up by traversing     * next link to determine which thread it is.  Determination of     * successor must avoid races with newly queued nodes to set     * the "next" fields of their predecessors.  This is solved     * when necessary by checking backwards from the atomically     * updated "tail" when a node's successor appears to be null.     * (Or, said differently, the next-links are an optimization     * so that we don't usually need a backward scan.)     *     * &lt;p&gt;Cancellation introduces some conservatism to the basic     * algorithms.  Since we must poll for cancellation of other     * nodes, we can miss noticing whether a cancelled node is     * ahead or behind us. This is dealt with by always unparking     * successors upon cancellation, allowing them to stabilize on     * a new predecessor, unless we can identify an uncancelled     * predecessor who will carry this responsibility.     *     * &lt;p&gt;CLH queues need a dummy header node to get started. But     * we don't create them on construction, because it would be wasted     * effort if there is never contention. Instead, the node     * is constructed and head and tail pointers are set upon first     * contention.     *     * &lt;p&gt;Threads waiting on Conditions use the same nodes, but     * use an additional link. Conditions only need to link nodes     * in simple (non-concurrent) linked queues because they are     * only accessed when exclusively held.  Upon await, a node is     * inserted into a condition queue.  Upon signal, the node is     * transferred to the main queue.  A special value of status     * field is used to mark which queue a node is on.     *     * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill     * Scherer and Michael Scott, along with members of JSR-166     * expert group, for helpful ideas, discussions, and critiques     * on the design of this class.     */    static final class Node {        /** Marker to indicate a node is waiting in shared mode */        static final Node SHARED = new Node();        /** Marker to indicate a node is waiting in exclusive mode */        static final Node EXCLUSIVE = null;        /** waitStatus value to indicate thread has cancelled */        static final int CANCELLED =  1;        /** waitStatus value to indicate successor's thread needs unparking */        static final int SIGNAL    = -1;        /** waitStatus value to indicate thread is waiting on condition */        static final int CONDITION = -2;        /**         * waitStatus value to indicate the next acquireShared should         * unconditionally propagate         */        static final int PROPAGATE = -3;        /**         * Status field, taking on only the values:         *   SIGNAL:     The successor of this node is (or will soon be)         *               blocked (via park), so the current node must         *               unpark its successor when it releases or         *               cancels. To avoid races, acquire methods must         *               first indicate they need a signal,         *               then retry the atomic acquire, and then,         *               on failure, block.         *   CANCELLED:  This node is cancelled due to timeout or interrupt.         *               Nodes never leave this state. In particular,         *               a thread with cancelled node never again blocks.         *   CONDITION:  This node is currently on a condition queue.         *               It will not be used as a sync queue node         *               until transferred, at which time the status         *               will be set to 0. (Use of this value here has         *               nothing to do with the other uses of the         *               field, but simplifies mechanics.)         *   PROPAGATE:  A releaseShared should be propagated to other         *               nodes. This is set (for head node only) in         *               doReleaseShared to ensure propagation         *               continues, even if other operations have         *               since intervened.         *   0:          None of the above         *         * The values are arranged numerically to simplify use.         * Non-negative values mean that a node doesn't need to         * signal. So, most code doesn't need to check for particular         * values, just for sign.         *         * The field is initialized to 0 for normal sync nodes, and         * CONDITION for condition nodes.  It is modified using CAS         * (or when possible, unconditional volatile writes).         */        volatile int waitStatus;        /**         * Link to predecessor node that current node/thread relies on         * for checking waitStatus. Assigned during enqueuing, and nulled         * out (for sake of GC) only upon dequeuing.  Also, upon         * cancellation of a predecessor, we short-circuit while         * finding a non-cancelled one, which will always exist         * because the head node is never cancelled: A node becomes         * head only as a result of successful acquire. A         * cancelled thread never succeeds in acquiring, and a thread only         * cancels itself, not any other node.         */        volatile Node prev;        /**         * Link to the successor node that the current node/thread         * unparks upon release. Assigned during enqueuing, adjusted         * when bypassing cancelled predecessors, and nulled out (for         * sake of GC) when dequeued.  The enq operation does not         * assign next field of a predecessor until after attachment,         * so seeing a null next field does not necessarily mean that         * node is at end of queue. However, if a next field appears         * to be null, we can scan prev's from the tail to         * double-check.  The next field of cancelled nodes is set to         * point to the node itself instead of null, to make life         * easier for isOnSyncQueue.         */        volatile Node next;        /**         * The thread that enqueued this node.  Initialized on         * construction and nulled out after use.         */        volatile Thread thread;        /**         * Link to next node waiting on condition, or the special         * value SHARED.  Because condition queues are accessed only         * when holding in exclusive mode, we just need a simple         * linked queue to hold nodes while they are waiting on         * conditions. They are then transferred to the queue to         * re-acquire. And because conditions can only be exclusive,         * we save a field by using special value to indicate shared         * mode.         */        Node nextWaiter;        ...    }</code></pre><h4 id="AQS的CLH队列"><a href="#AQS的CLH队列" class="headerlink" title="AQS的CLH队列"></a>AQS的CLH队列</h4><p>CLH（三个大牛的名字组成）队列为一个双向队列</p><p><img src="/attachment/0934a76f178394183905378621d7af1d.png"></p><p><img src="/attachment/e50d097ac9543916395f1e617f1ad06a.png"></p><ul><li>有阻塞就需要排队，实现排队必然需要队列</li><li>State变量+CLH双端队列</li></ul><h3 id="定义的方法"><a href="#定义的方法" class="headerlink" title="定义的方法"></a>定义的方法</h3><p><img src="/attachment/d34781d4533fcb7b45e518d2a2fe9e10.png"></p><h2 id="Lock-lock"><a href="#Lock-lock" class="headerlink" title="Lock.lock()"></a>Lock.lock()</h2><p>抢占锁</p><ul><li>成功 -&gt; 设置成独占锁</li><li>失败 -&gt; [[#acquire方法]]</li></ul><pre><code class="line-numbers language-java">final void lock() {    if (compareAndSetState(0, 1))        setExclusiveOwnerThread(Thread.currentThread());    else        acquire(1);}</code></pre><p>这个方法逻辑比较简单，if条件成立说明 抢占锁成功并设置 当前线程为独占锁<br>else 表示抢占失败，acquire(1) 方法我们后面具体介绍</p><p>compareAndSetState(0, 1)：用到了CAS 是一个原子操作方法，底层是UnSafe.作用就是设置 共享操作的 state 由0到1. 如果state的值是0就修改为1<br>setExclusiveOwnerThread：代码很简单，进去看一眼即可</p><h3 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h3><p>获取锁</p><ol><li>尝试抢锁 -&gt; [[#tryAcquire(int)]]</li><li>抢锁失败 -&gt; 尝试入队 [[#addWaiter]]</li><li>都失败 -&gt; 自我中断selfInterrupt()</li></ol><pre><code class="line-numbers language-java">public final void acquire(int arg) {    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}</code></pre><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><h4 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h4><p>再次尝试抢占锁</p><p>-&gt; [[#nonfairTryAcquire]]</p><pre><code class="line-numbers language-java">protected final boolean tryAcquire(int acquires) {    return nonfairTryAcquire(acquires);}</code></pre><h5 id="nonfairTryAcquire"><a href="#nonfairTryAcquire" class="headerlink" title="nonfairTryAcquire"></a>nonfairTryAcquire</h5><p>非公平抢锁</p><ul><li>锁状态 == 0 尝试抢锁</li><li>锁状态 != 0 &amp;&amp; current == getExclusiveOwnerThread<ul><li>自己是拥有锁的线程</li><li>重入锁</li></ul></li><li>失败</li></ul><pre><code class="line-numbers language-java">final boolean nonfairTryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();//再次尝试抢占锁    if (c == 0) {        if (compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }// 重入锁的情况    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error("Maximum lock count exceeded");        setState(nextc);        return true;    }// false 表示抢占失败    return false;}</code></pre><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>将阻塞的线程添加到双向链表的结尾</p><ul><li>尾节点不为空 -&gt; CAS 进行节点插入</li><li>失败 -&gt; [[#enq(Node)]]</li></ul><pre><code class="line-numbers language-java">private Node addWaiter(Node mode) {    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）    Node node = new Node(Thread.currentThread(), mode);    //尝试快速方式直接放到队尾。    Node pred = tail;    if (pred != null) {        node.prev = pred;        if (compareAndSetTail(pred, node)) {            pred.next = node;            return node;        }    }    //上一步失败则通过enq入队。    enq(node);    return node;}</code></pre><h5 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h5><ul><li>自旋<ul><li>尾节点为空 -&gt; 创建空的标记节点作为 head 节点</li><li>正常流程 -&gt; CAS 自旋</li></ul></li></ul><pre><code class="line-numbers language-java">private Node enq(final Node node) {    //CAS"自旋"，直到成功加入队尾    for (;;) {        Node t = tail;        if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。            if (compareAndSetHead(new Node()))                tail = head;        } else {//正常流程，放入队尾            node.prev = t;            if (compareAndSetTail(t, node)) {                t.next = node;                return t;            }        }    }}</code></pre><p>第一个if语句</p><p><img src="/attachment/e5ca20a7d93f9b4d6bf077e328dd6b9a.png"></p><p>else语句</p><p><img src="/attachment/2493ba355912edfb15a754caa576bd6c.png"></p><p>线程3进来会执行如下代码</p><p><img src="/attachment/37f1218935d0da589749f30647061267.png"></p><p>那么效果图</p><p><img src="/attachment/286d9dcc65a7993137e029eb69fc433c.png"></p><h4 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h4><p>线程 进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源</p><p>OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似 ~ acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。</p><ul><li>结点进入队尾后，检查状态，找到安全休息点；</li><li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li><li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li></ul><pre><code class="line-numbers language-java">final boolean acquireQueued(final Node node, int arg) {    boolean failed = true;//标记是否成功拿到资源    try {        boolean interrupted = false;//标记等待过程中是否被中断过        //又是一个“自旋”！        for (;;) {            final Node p = node.predecessor();//拿到前驱            //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。            if (p == head &amp;&amp; tryAcquire(arg)) {                setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。                p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！                failed = false; // 成功获取资源                return interrupted;//返回等待过程中是否被中断过            }            //如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true        }    } finally {        if (failed) // 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。            cancelAcquire(node);    }}</code></pre><p>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</p><h5 id="shouldParkAfterFailedAcquire-Node-pred-Node-node"><a href="#shouldParkAfterFailedAcquire-Node-pred-Node-node" class="headerlink" title="shouldParkAfterFailedAcquire(Node pred, Node node)"></a>shouldParkAfterFailedAcquire(Node pred, Node node)</h5><ul><li>pred.waitStatus<ul><li>ws == Node.SIGNAL 如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</li><li>ws &gt; 0 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</li><li>ws &lt; 0 如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</li></ul></li></ul><pre><code class="line-numbers language-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {    int ws = pred.waitStatus;//拿到前驱的状态    if (ws == Node.SIGNAL)        //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了        return true;    if (ws &gt; 0) {        /*         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！         */        do {            node.prev = pred = pred.prev;        } while (pred.waitStatus &gt; 0);        pred.next = node;    } else {         //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    }    return false;}</code></pre><p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h5><p>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p><pre><code class="line-numbers language-java"> private final boolean parkAndCheckInterrupt() {     LockSupport.park(this);//调用park()使线程进入waiting状态     return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。 }</code></pre><p>好了，我们可以小结下了。</p><p>看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</p><h4 id="acquire-总结"><a href="#acquire-总结" class="headerlink" title="acquire() 总结"></a>acquire() 总结</h4><p>总结下它的流程吧</p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p><img src="/attachment/181312ae697df893b073e7115bbefd3f.png"></p><h2 id="Lock-unlock"><a href="#Lock-unlock" class="headerlink" title="Lock.unlock()"></a>Lock.unlock()</h2><h3 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a>release(int)</h3><p>它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()</p><pre><code class="line-numbers language-java">public final boolean release(int arg) {        if (tryRelease(arg)) {//这里是先尝试释放一下资源，一般都可以释放成功，除了多次重入但只释放一次的情况。            Node h = head;            //这里判断的是 阻塞队列是否还存在和head节点是否是tail节点，因为之前说过，队列的尾节点的waitStatus是为0的            if (h != null &amp;&amp; h.waitStatus != 0)                //到这里就说明head节点已经释放成功啦，就先去叫醒后面的直接节点去抢资源吧                unparkSuccessor(h);            return true;        }        return false;    }</code></pre><h4 id="tryRelease-int"><a href="#tryRelease-int" class="headerlink" title="tryRelease(int)"></a>tryRelease(int)</h4><p>此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</p><p>可以看到state - 1, 也就是我们前面说的每次上锁都会在state+1 ,并且判断当前线程是否是拥有锁的线程, 所以lock2次之后, unlock三次就会报错<br>当state=0 的时候将锁的线程置为null</p><pre><code class="line-numbers language-java">     protected final boolean tryRelease(int releases) {        int c = getState() - releases;        if (Thread.currentThread() != getExclusiveOwnerThread())            throw new IllegalMonitorStateException();        boolean free = false;        if (c == 0) {            free = true;            setExclusiveOwnerThread(null);        }        setState(c);        return free;    }</code></pre><h4 id="解锁后继节点"><a href="#解锁后继节点" class="headerlink" title="解锁后继节点"></a>解锁后继节点</h4><p>该⽅法的⽤途是：如果节点的接班⼈(successor)存在的话，则唤醒它</p><pre><code class="line-numbers language-java">private void unparkSuccessor(Node node) {    //这里，node一般为当前线程所在的结点。    int ws = node.waitStatus;    if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。        compareAndSetWaitStatus(node, ws, 0);    Node s = node.next;//找到下一个需要唤醒的结点s    if (s == null || s.waitStatus &gt; 0) {//如果为空或已取消        s = null;        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // 从后向前找。            if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。                s = t;    }    if (s != null)        LockSupport.unpark(s.thread);//唤醒}</code></pre><p>这个函数并不复杂。</p><h3 id="Release-总结"><a href="#Release-总结" class="headerlink" title="Release 总结"></a>Release 总结</h3><p>用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。<br>此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。<br>这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋<code>p==head</code>就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了</p><h2 id="加锁和解锁的队列演示"><a href="#加锁和解锁的队列演示" class="headerlink" title="加锁和解锁的队列演示"></a>加锁和解锁的队列演示</h2><p>AQS在加锁和解锁过程中，对队列节点的操作进⾏演示，在详细介绍演示之前，我 们先来整体看⼀下，如果有线程A、线程B和线程C这三个线程在AQS的调度下，会是什么样⼦的</p><p><img src="/attachment/2ba7ea1d6a245408c8c4bcff5a696b47.png"></p><p>其中，线程A⾸先抢到锁，所以它不需要链表进⾏排队。<br>那么线程B和线程C由于没有抢到锁（由 state是否等于0进⾏判断），那么就需要组成⼀个链表，头节点就是⼀个“空”的节点（即：通过 new Node()）创建的。<br>⽽线程B和线程C则会相机组成链表，并调⽤park阻塞操作。等待后续的 unpark解除阻塞</p><h3 id="加锁操作队列演示"><a href="#加锁操作队列演示" class="headerlink" title="加锁操作队列演示"></a>加锁操作队列演示</h3><p>线程A第一个执行了lock()</p><p><img src="/attachment/54acc591d256105fef2927de3bdbd139.png"></p><p>线程B第二个执行了lock(),此时会构建等待队列链表</p><p><img src="/attachment/565c37c99c97189bfbcce924d10da08a.png"></p><p>线程C再执行lock()</p><p><img src="/attachment/33c7e9e0232ab4f5bbd429a85e0dee8f.png"></p><h3 id="解锁操作队列"><a href="#解锁操作队列" class="headerlink" title="解锁操作队列"></a>解锁操作队列</h3><p>解锁操作伴随着加锁操作，那么下⾯我们先假设⼀个场景，即使线程A先抢到了锁，线程B阻塞等 待，那么当线程A执⾏完毕掉⽤了unlock⽅法后，如何唤醒线程B去继续抢锁的</p><p><img src="/attachment/d9e5766e3c4d20cab16d9fb97d3a85ed.png"></p><p>现在，我们把视野再拉回来。我们在上⾯演示了多个线程的加锁操作对线程等待队列的影响。那 么，我们再来看⼀下这些线程分别调⽤解锁操作，这个队列中的等待线程⼜会是怎么的操作逻辑 呢？好，下⾯我们就先来看⼀下线程A执⾏unlock操作</p><p><img src="/attachment/3bc5db2202c572c36134dc0a645cebf7.png"></p><p>线程B执行unlock</p><p><img src="/attachment/50cd55de7099a0fc76c02b674517dee4.png"></p><p>线程C执行</p><p><img src="/attachment/bb7525600f08290b6447c0f986da2860.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/attachment/0b80cca207bd9ce71a59fd5950fb586f.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-aqs-abstract-queued-synchronizer/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-aqs-abstract-queued-synchronizer/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）"><a href="#【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）" class="headerlink" title="【Java 多线程并发】 AQS（Abstract Queued Synchronizer）"></a>【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 AQS（Abstract Queued Synchronizer）date: 2023-07-04 08:31tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</code></pre><h2 id="【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）-1"><a href="#【Java-多线程并发】-AQS（Abstract-Queued-Synchronizer）-1" class="headerlink" title="【Java 多线程并发】 AQS（Abstract Queued Synchronizer）"></a>【Java 多线程并发】 AQS（Abstract Queued Synchronizer）</h2><p>Java 并发包（JUC）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如 ReentrangLock、Semaphore，它们的实现都用到了一个共同的基类 –AbstractQueuedSynchronizer, 简称 AQS（抽象队列同步器）。<strong>AQS 是一个用来构建锁和同步器的框架</strong>，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p><h2 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h2><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。</p><pre><code class="line-numbers language-java">private volatile int state;//共享变量，使用volatile修饰保证线程可见性</code></pre><p>状态信息通过 procted 类型的 <strong>getState</strong>，<strong>setState</strong>，<strong>compareAndSetState</strong> 进行操作。 state 表示被占用资源的线程个数，即大于 0 表示被占用状态</p><p>AQS 支持两种同步方式：</p><p><strong>1. 独占式</strong><br><strong>2. 共享式</strong></p><p>这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如 Semaphore，CountDownLatch，组合式的如 ReentrantReadWriteLock。总之，AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p><p>同步器的设计是基于<mark style="background: #FF5582A6;">模板方法模式</mark>的，一般的使用方式是这样：</p><ol><li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（<strong>这些重写方法很简单，无非是对于共享资源 state 的获取和释放</strong>）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这其实是模板方法模式的一个很经典的应用。</p><p>我们来看看 AQS 定义的这些可重写的方法：</p><ul><li><strong>protected boolean tryAcquire(int arg)</strong> : 独占式获取同步状态，试着获取，成功返回 true，反之为 false</li><li><strong>protected boolean tryRelease(int arg)</strong> ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；</li><li><strong>protected int tryAcquireShared(int arg)</strong> ：共享式获取同步状态，返回值大于等于 0，代表获取成功；反之获取失败；</li><li><strong>protected boolean tryReleaseShared(int arg)</strong> ：共享式释放同步状态，成功为 true，失败为 false</li><li><strong>protected boolean isHeldExclusively()</strong> ： 是否在独占模式下被线程占用。</li></ul><p>关于 AQS 的使用，我们来简单总结一下：</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>首先，我们需要去继承 AbstractQueuedSynchronizer 这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写 tryAcquire，tryRelease 方法，要实现共享锁，就去重写 tryAcquireShared，tryReleaseShared；最后，在我们的组件中调用 AQS 中的模板方法就可以了，而这些模板方法是会自动调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源 state 的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是 AQS 帮我们完成了。</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>对于使用者来讲，我们无需关心获取资源失败，线程排队，线程阻塞 / 唤醒等一系列复杂的实现，这些都在 AQS 中为我们处理好了。我们只需要负责好自己的那个环节就好，也就是获取 / 释放共享资源 state 的姿势 T_T。很经典的模板方法设计模式的应用，AQS 为我们定义好顶级逻辑的骨架，并提取出公用的线程入队列 / 出队列，阻塞 / 唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现即可。</p><h2 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h2><h3 id="同步器代码实现"><a href="#同步器代码实现" class="headerlink" title="同步器代码实现"></a>同步器代码实现</h3><p>上面大概讲了一些关于 AQS 如何使用的理论性的东西，接下来，我们就来看下实际如何使用，直接采用 JDK 官方文档中的小例子来说明问题</p><pre><code class="line-numbers language-java">import&nbsp;java.util.concurrent.locks.AbstractQueuedSynchronizer;public&nbsp;class&nbsp;Mutex&nbsp;implements&nbsp;java.io.Serializable {&nbsp;&nbsp;&nbsp;&nbsp;//静态内部类，继承AQS&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;class&nbsp;Sync&nbsp;extends&nbsp;AbstractQueuedSynchronizer {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//是否处于占用状态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;boolean&nbsp;isHeldExclusively() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;getState()&nbsp;==&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当状态为0的时候获取锁，CAS操作成功，则state状态为1，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;tryAcquire(int&nbsp;acquires) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(compareAndSetState(0,&nbsp;1))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setExclusiveOwnerThread(Thread.currentThread());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放锁，将同步状态置为0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;boolean&nbsp;tryRelease(int&nbsp;releases) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(getState()&nbsp;==&nbsp;0)&nbsp;throw&nbsp;new&nbsp;IllegalMonitorStateException();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setExclusiveOwnerThread(null);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setState(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//同步对象完成一系列复杂的操作，我们仅需指向它即可&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;Sync&nbsp;sync&nbsp;=&nbsp;new&nbsp;Sync();&nbsp;&nbsp;&nbsp;&nbsp;//加锁操作，代理到acquire（模板方法）上就行，acquire会调用我们重写的tryAcquire方法&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;lock() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sync.acquire(1);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;tryLock() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sync.tryAcquire(1);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//释放锁，代理到release（模板方法）上就行，release会调用我们重写的tryRelease方法。&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;unlock() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sync.release(1);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isLocked() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sync.isHeldExclusively();&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><h3 id="同步器代码测试"><a href="#同步器代码测试" class="headerlink" title="同步器代码测试"></a>同步器代码测试</h3><p>测试下这个自定义的同步器，我们使用之前文章中做过的并发环境下 a++ 的例子来说明问题（a++ 的原子性其实最好使用原子类 AtomicInteger 来解决，此处用 Mutex 有点大炮打蚊子的意味，好在能说明问题就好）</p><pre><code class="line-numbers language-java">import java.util.concurrent.CyclicBarrier;  // 线程栅栏类public class TestMutex {    private static CyclicBarrier barrier = new CyclicBarrier(31); // 包括主线程一共31个线程    private static int a = 0;    private static  Mutex mutex = new Mutex();    public static void main(String []args) throws Exception {        //说明:我们启用30个线程，每个线程对i自加10000次，同步正常的话，最终结果应为300000；        //未加锁前        for(int i=0;i&lt;30;i++){            Thread t = new Thread(new Runnable() {                @Override                public void run() {                    for(int i=0;i&lt;10000;i++){                        increment1();//没有同步措施的a++；                    }                    try {                        barrier.await();//等30个线程累加完毕                    } catch (Exception e) {                        e.printStackTrace();                    }                }            });            t.start();        }        barrier.await();        System.out.println("加锁前，a="+a);         //加锁后        barrier.reset();//重置CyclicBarrier        a=0;        for(int i=0;i&lt;30;i++){            new Thread(new Runnable() {                @Override                public void run() {                    for(int i=0;i&lt;10000;i++){                        increment2();//a++采用Mutex进行同步处理                    }                    try {                        barrier.await();//等30个线程累加完毕                    } catch (Exception e) {                        e.printStackTrace();                    }                }            }).start();        }        barrier.await();        System.out.println("加锁后，a="+a);    }    /**     * 没有同步措施的a++     * @return     */    public static void increment1(){        a++;    }    /**     * 使用自定义的Mutex进行同步处理的a++     */    public static void increment2(){        mutex.lock();        a++;        mutex.unlock();    }}</code></pre><p>测试结果：</p><pre><code>加锁前，a=279204加锁后，a=300000</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p> 我们先来简单描述下AQS的基本实现，前面我们提到过，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。（这个内置的同步队列称为”CLH”队列）。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点。AQS维护两个指针，分别指向队列头部head和尾部tail。</p><p>undefined</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于AQS的介绍及源码分析到此为止了。</p><p>AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是<mark style="background: #FF5582A6;">状态变量state</mark>和一个<mark style="background: #FF5582A6;">FIFO队列</mark>来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。</p><p>AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写<mark style="background: #BBFABBA6;">tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared</mark>几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 CAS（Compare And Swap）</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-cas-compare-and-swap/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-cas-compare-and-swap/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-CAS（Compare-And-Swap）"><a href="#【Java-多线程并发】-CAS（Compare-And-Swap）" class="headerlink" title="【Java 多线程并发】 CAS（Compare And Swap）"></a>【Java 多线程并发】 CAS（Compare And Swap）</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 CAS（Compare And Swap）date: 2023-07-03 23:52tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 CAS（Compare And Swap）</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CAS 的全称为 <strong>Compare And Swap</strong>，直译就是比较交换。<br>是一条 <strong>CPU</strong> <strong>的原子指令</strong><br>其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值<br>其实现方式是基于硬件平台的汇编指令</p><p>它就是 CPU 的<strong>一条</strong>原子指令。过程是这样：它包含 3 个参数</p><ul><li>内存位置（V）、</li><li>预期原值（E）</li><li>新值 (N)。</li></ul><p>V 表示要更新变量的值，E 表示预期值，N 表示新值。仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。</p><p><strong>CAS的应用</strong></p><ul><li>非阻塞算法 （nonblocking algorithms）</li></ul><p><strong>CAS 底层原理</strong></p><p>锁总线是通过 LOCK#信号实现的，锁缓存是通过缓存一致性协议实现的。</p><p><strong>CAS 存在的问题</strong></p><ul><li>循环时间太长</li><li>只能保证一个共享变量原子操作</li><li>ABA 问题</li><li>CAS 造成 Cache 一致性流量过大</li></ul><h2 id="锁机制存在的问题"><a href="#锁机制存在的问题" class="headerlink" title="锁机制存在的问题"></a>锁机制存在的问题</h2><p>在 JDK 5 之前 Java 语言是靠 synchronized 关键字保证同步的，这会导致有锁</p><p><strong>锁机制存在以下问题：</strong></p><p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。<br>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。<br>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p><p>volatile 是不错的机制，它是通过汇编语言中的 LOCK 指令实现的，但是 volatile 不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p><p>独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。</p><p>而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>乐观锁的缺点是不能解决脏读的问题</strong>。乐观锁用到的机制就是 CAS，（Compare and Swap）。</p><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS 的全称为 <strong>Compare And Swap</strong>，直译就是比较交换。是一条 <strong>CPU</strong> <strong>的原子指令</strong>，其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令，在 intel 的 CPU 中，使用的是 cmpxchg 指令，就是说 CAS 是靠硬件实现的，从而在硬件层面提升效率。</p><p>它是一个无锁的原子算法。所以它就是一个乐观锁，也就是不加锁。无锁也就没有加锁和解锁的过程，不存在阻塞，也就提高了效率，提高了 CPU 的吞吐量（单位时间内执行完成的操作条数就多了）</p><p>它就是 CPU 的<strong>一条</strong>原子指令。过程是这样：它包含 3 个参数</p><ul><li>内存位置（V）、</li><li>预期原值（E）</li><li>新值 (N)。</li></ul><p>V 表示要更新变量的值，E 表示预期值，N 表示新值。仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后，CAS 返回当前 V 的真实值（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值）。CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。</p><p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，<mark style="background: #BBFABBA6;">CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰</mark>。</p><p>与锁相比，使用 CAS 会使程序看起来更加复杂一些，但<strong>由于其非阻塞的，它对死锁问题天生免疫</strong>，并且，线程间的相互影响也非常小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有更优越的性能。</p><p>简单的说，CAS 需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，那说明它已经被别人修改过了。你就需要重新读取，再次尝试修改就好了。</p><h2 id="CAS的应用"><a href="#CAS的应用" class="headerlink" title="CAS的应用"></a>CAS的应用</h2><p>利用 CPU 的 CAS 指令，同时借助 JNI 来完成 Java 的非阻塞算法。其它<strong>原子操作</strong>都是利用类似的特性完成的。而整个 J.U.C 都是建立在 CAS 之上的，因此对于 synchronized 阻塞算法，J.U.C 在性能上有了很大的提升。</p><h3 id="非阻塞算法-（nonblocking-algorithms）"><a href="#非阻塞算法-（nonblocking-algorithms）" class="headerlink" title="非阻塞算法 （nonblocking algorithms）"></a>非阻塞算法 （nonblocking algorithms）</h3><p>非阻塞算法就是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。非阻塞算法就需要借助 CAS 操作来实现，这也是 CAS 的一个主要应用方向。</p><p>现代的 CPU 提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些 CPU 提供的特殊指令代替了锁定。</p><p>我们来看一下 AtomicInteger 类在没有锁的情况下是如何做到数据正确性的。</p><pre><code class="line-numbers language-java">public&nbsp;class&nbsp;AtomicInteger&nbsp;extends&nbsp;Number&nbsp;implements&nbsp;java.io.Serializable {&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;volatile&nbsp;int&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;final&nbsp;int&nbsp;get() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;final&nbsp;int&nbsp;getAndIncrement() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;current&nbsp;=&nbsp;get();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;next&nbsp;=&nbsp;current&nbsp;+&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(compareAndSet(current,&nbsp;next))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;current;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;final&nbsp;boolean&nbsp;compareAndSet(int&nbsp;expect,&nbsp;int&nbsp;update) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;unsafe.compareAndSwapInt(this,&nbsp;valueOffset,&nbsp;expect,&nbsp;update);&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>首先毫无疑问，在没有锁的机制下可能需要借助 volatile 原语，保证线程间的数据是可见的（共享的）。</p><pre><code class="line-numbers language-java">private&nbsp;volatile&nbsp;int&nbsp;value;&nbsp;</code></pre><p> 这样才获取变量的值的时候才能直接读取。</p><pre><code class="line-numbers language-java">public final int get() {    return value;}</code></pre><p>然后来看看 ++i 是怎么做到的。</p><pre><code class="line-numbers language-java">public final int incrementAndGet() {    for (;;) {        int current = get();        int next = current + 1;        if (compareAndSet(current, next))            return next;    }}</code></pre><p><strong>incrementAndGet()</strong> 采用了 CAS 操作，每次从内存中读取数据然后将此数据和 + 1 后的结果进行 CAS 操作，如果成功就返回结果，否则重试直到成功为止。</p><p>incrementAndGet() 方法中的 compareAndSet() 方法则是利用 JNI 来完成 CPU 指令的操作。通过判断当前的值 this 还是不是等于一开始的值 expect，如果还等于 expect，就说明期间没有其他线程对该数据进行了修改，不会出现并发一场，那么就将 this 改成 update 更新后的数据。</p><pre><code class="line-numbers language-java">public final boolean compareAndSet(int expect, int update) {       return unsafe.compareAndSwapInt(this, valueOffset, expect, update); // 仔细注意传进来的参数，理解该方法的作用}</code></pre><p>整体的过程就是这样子的，通过 JNI（Java 本地调用）来调用 C 语言代码，然后 C 语言代码来调用 CPU 的 CAS 指令来完成 Java 的非阻塞算法。其它原子操作都是利用类似的特性完成的。</p><p>其中</p><pre><code class="line-numbers language-java">unsafe.compareAndSwapInt(this,&nbsp;valueOffset,&nbsp;expect,&nbsp;update);</code></pre><p>类似：</p><pre><code class="line-numbers language-java">if&nbsp;(this&nbsp;==&nbsp;expect)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this&nbsp;=&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;}</code></pre><blockquote><p>Unsafe 是 CAS 的核心类， Java 无法直接访问底层操作系统，而是通过本地（ native ）方法来访问。不过尽管如此， JVM 还是开了一个后门： Unsafe ，它提供了硬件级别的原子操作， 这里的 compareAndSwapInt () 就是 Unsafe 类提供的硬件原子操作之一 。</p></blockquote><p>那么问题就来了，成功过程中需要2个步骤：比较this == expect，替换this = update，compareAndSwapInt如何这两个步骤的原子性呢？ 参考CAS的原理。</p><h2 id="CAS-底层原理"><a href="#CAS-底层原理" class="headerlink" title="CAS 底层原理"></a>CAS 底层原理</h2><p>归功于硬件指令集的发展，实际上，我们可以使用同步将这两个操作变成原子的，但是这么做就没有意义了。所以我们只能靠硬件来完成，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。这类指令常用的有：</p><ol><li>测试并设置（Tetst-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较并交换（Compare-and-Swap）</li><li>加载链接 / 条件存储（Load-Linked/Store-Conditional）</li></ol><p><img src="/attachment/df0b42c0b6908e024bbe4ba8e51dca40.png"><br>SMP（对称多处理器）架构图&nbsp;</p><ul><li>BUS：总线</li><li>每一个 CPU 都共用一根总线，与主内存相互交互。每一个 CPU 都有一个自己私有的 Cache</li></ul><p>CPU 实现原子指令有 3种方式：</p><h3 id="处理器自动保证基本内存操作的原子性"><a href="#处理器自动保证基本内存操作的原子性" class="headerlink" title="处理器自动保证基本内存操作的原子性"></a>处理器自动保证基本内存操作的原子性</h3><p>首先<strong>处理器会自动保证基本的内存操作的原子性</strong>。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾 6 和最新的处理器能自动保证单处理器对同一个缓存行里进行 16/32/64 位的操作是原子的，<strong>但是复杂的内存操作处理器不能自动保证其原子性</strong>，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p><h3 id="通过总线锁定来保证原子性"><a href="#通过总线锁定来保证原子性" class="headerlink" title="通过总线锁定来保证原子性"></a>通过总线锁定来保证原子性</h3><p><strong>总线锁定</strong>其实就是处理器使用了<strong>总线锁</strong>，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。但是该方法成本太大。因此有了下面的方式。</p><h3 id="通过缓存锁定来保证原子性"><a href="#通过缓存锁定来保证原子性" class="headerlink" title="通过缓存锁定来保证原子性"></a>通过缓存锁定来保证原子性</h3><p>在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把 CPU 和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定。</p><p>所谓<strong>缓存锁定</strong> 是指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行操作写回到内存时，处理器不在总线上输出 LOCK# 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p><p><strong>注意：有两种情况下处理器不会使用缓存锁定</strong></p><ol><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。</li><li>有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>锁总线是通过 LOCK#信号实现的，锁缓存是通过缓存一致性协议实现的。</p><h2 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h2><p>CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：循环时间太长、只能保证一个共享变量原子操作、ABA 问题。</p><h3 id="循环时间太长"><a href="#循环时间太长" class="headerlink" title="循环时间太长"></a>循环时间太长</h3><p>如果 CAS 一直不成功呢？这种情况绝对有可能发生，如果自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销。在 JUC 中有些地方就限制了 CAS 自旋的次数，例如 BlockingQueue 的 SynchronousQueue。</p><h3 id="只能保证一个共享变量原子操作"><a href="#只能保证一个共享变量原子操作" class="headerlink" title="只能保证一个共享变量原子操作"></a>只能保证一个共享变量原子操作</h3><p>看了 CAS 的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用 CAS 也不错。从 Java1.5 开始 JDK 提供了 <strong>AtomicReference</strong> <strong>类</strong>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>CAS 需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是 A，变成了 B，然后又变成了 A，那么在 CAS 检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的 ABA 问题。对于 ABA 问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加 1，即 A —&gt; B —&gt; A，变成 1A —&gt; 2B —&gt; 3A。</p><p>从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。这个类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。其实就类似于引入了版本概念，给每一个数据都有一个它唯一的版本号，通关检查版本号来判断数据是否被修改。</p><h3 id="CAS-造成-Cache-一致性流量过大"><a href="#CAS-造成-Cache-一致性流量过大" class="headerlink" title="CAS 造成 Cache 一致性流量过大"></a>CAS 造成 Cache 一致性流量过大</h3><p>现在几乎所有的锁都是可重入的，即已经获得锁的线程可以多次锁住 / 解锁监视对象，按照之前的 HotSpot 设计，每次加锁 / 解锁都会涉及到一些 CAS 操作（比如对等待队列的 CAS 操作），CAS 操作会延迟本地调用 (<strong>使本地调用不是那么及时</strong>)，因此偏向锁的想法是 一旦线程第一次获得了监视对象，之后让监视对象 “偏向” 这个线程，之后的多次调用则可以避免 CAS 操作，说白了就是置个变量，如果发现为 true 则无需再走各种加锁 / 解锁流程。轻量级锁就是基于 CAS 操作的</p><p>CAS 为什么会引入本地延迟？这要从 SMP（对称多处理器）架构说起，下图大概表明了 SMP 的结构：</p><p><img src="/attachment/953db50e7be4081b1869c04a70ff43ae.png"><br>SMP（对称多处理器）架构</p><p>其意思是 所有的 CPU 会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于 BUS 对称分布，因此这种结构称为 “对称多处理器”。</p><p>而 CAS 的全称为 Compare-And-Swap，是一条 CPU 的原子指令，其作用是让 CPU 比较后原子地更新某个位置的值，其实现方式是<strong>基于硬件平台的汇编指令</strong>，就是说 CAS 是靠硬件实现的，JVM 只是<strong>封装了汇编调用</strong>，那些 AtomicInteger 类便是使用了这些封装后的接口。</p><p>例如：Core1 和 Core2 可能会同时把主存中某个位置的值 Load 到自己的 L1 Cache 中，当 Core1 在自己的 L1 Cache 中修改这个位置的值时，会通过总线，使 Core2 中 L1 Cache 对应的值 “失效”，而 Core2 一旦发现自己 L1 Cache 中的值失效（称为 Cache 命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为 “<strong>Cache 一致性流量</strong>”，因为总线被设计为固定的 “通信能力”，如果 Cache 一致性流量过大，总线将成为瓶颈。而当 Core1 和 Core2 中的值再次一致时，称为 “<strong>Cache 一致性</strong>”，从这个层面来说，<strong>锁设计的终极目标便是减少 Cache 一致性流量</strong>。</p><p>而 CAS 恰好会导致 Cache 一致性流量，如果有很多线程都共享同一个对象，当某个 Core CAS 成功时必然会引起<strong>总线风暴</strong>，这就是所谓的<strong>本地延迟</strong>，<strong>本质上偏向锁就是为了消除 CAS，降低 Cache 一致性流量</strong>。</p><p><strong>相关参考：</strong></p><p><strong><em>Cache 一致性：</em></strong><br>上面提到 Cache 一致性，其实是有协议支持的，现在通用的协议是 MESI（最早由 Intel 开始支持），具体参考：<a href="http://en.wikipedia.org/wiki/MESI_protocol">http://en.wikipedia.org/wiki/MESI_protocol</a>。</p><p><strong><em>Cache 一致性流量的例外情况：</em></strong><br>其实也不是所有的 CAS 都会导致总线风暴，这跟 Cache 一致性协议有关，具体参考：<a href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a></p><p><strong><em>NUMA(Non Uniform Memory Access Achitecture）架构：</em></strong><br>与 SMP 对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个 Core 有自己的内存，针对这种结构此处不做讨论。</p><h2 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h2><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p><ul><li>A线程写volatile变量，随后B线程读这个volatile变量。</li><li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li></ul><p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为volatile；</li><li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li><li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS和非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：</p><p><img src="/attachment/87c17fb1e48f847a8ea49684a4c78bbe.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 synchronized</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-synchronized/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-synchronized"><a href="#【Java-多线程并发】-synchronized" class="headerlink" title="【Java 多线程并发】 synchronized"></a>【Java 多线程并发】 synchronized</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 synchronizeddate: 2023-07-03 22:31tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 synchronized</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>synchronized是利用锁的机制来实现同步的。</p><ul><li>原子性</li><li>可见性</li><li>有序性</li><li>可重入性</li></ul><p>synchronized有两种形式上锁，一个是对方法上锁，一个是构造同步代码块。<br><strong>底层原理相同</strong><br>在进入同步代码之前先获取锁，获取到锁之后锁的计数器+1，同步代码执行完锁的计数器-1，如果获取失败就阻塞式等待锁的释放。<br><strong>同步块识别方式不同</strong><br>一个是通过方法flags标志，一个是monitorenter和monitorexit指令操作。</p><p><strong>Mark Word</strong></p><p><img src="/attachment/4a1a2484e64e3be1161dd234ac28d54e.png"></p><p><strong>monitor对象</strong></p><p>在HotSpot虚拟机中monitor对象是由ObjectMonitor实现的（C++实现）<br><mark style="background: #FFB8EBA6;">每个对象都存在着一个monitor与之关联</mark></p><pre><code class="line-numbers language-java">ObjectMonitor() {    _header       = NULL;    _count        = 0;  //锁计数器    _waiters      = 0,    _recursions   = 0;    _object       = NULL;    _owner        = NULL;// 标记当前持有Monitor的线程    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet    _WaitSetLock  = 0 ;    _Responsible  = NULL ;    _succ         = NULL ;    _cxq          = NULL ;    FreeNext      = NULL ;    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表    _SpinFreq     = 0 ;    _SpinClock    = 0 ;    OwnerIsThread = 0 ;}</code></pre><p>当多个线程同时访问一段同步代码时：</p><ol><li>首先会进入_EntryList 集合，当线程获取到对象的monitor 后进入 _owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1</li><li>若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒</li><li>若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</li></ol><p><strong>synchronized的优化</strong></p><ul><li>锁膨胀<ul><li>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</li><li>偏向锁（Biased Locking）<ul><li>减少同一线程获取锁的代价</li><li>Mark Word 的偏向锁线程是否是自己</li><li>CAS 尝试获取 偏向锁</li></ul></li><li>轻量级锁<ul><li>允许多个线程获得锁，但是只允许他们顺序拿锁，不允许出现竞争，也就是拿锁失败的情况。</li><li>Lock Record</li><li>CAS操作</li></ul></li><li>重量级锁<ul><li>同一时间有多个线程竞争锁时，锁就会被升级成重量级锁</li><li>通过对象内部的<mark style="background: #FFB8EBA6;">监视器锁（Monitor）</mark>来实现的。</li><li>监视器锁本质又是依赖于底层的操作系统的<mark style="background: #FFB8EBA6;">Mutex Lock（互斥锁）</mark>来实现的。</li><li>从用户态转换到核心态</li></ul></li></ul></li></ul><p><img src="/attachment/e318185603b272de1623d7120e455ad8.png"></p><ul><li>锁消除（Lock Elision）<ul><li>JIT编译器对内部锁的具体实现所做的一种优化</li><li>借助逃逸分析实现的。</li><li>如果JIT经过逃逸分析之后发现同步块中使用的锁对象并没有逃逸出去，不可能被其他线程所使用，并无线程安全问题的话，就会做锁消除。</li></ul></li><li>锁粗化（Lock Coarsening）<ul><li>通过扩大锁的范围，避免反复加锁和释放锁。</li></ul></li><li>自适应自旋锁（Adaptive Locking）<ul><li>它的自旋的次数不再固定，其<mark style="background: #FFB8EBA6;">自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</mark></li></ul></li></ul><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>编写一个类似银行、医院的叫号程序（要求：多个窗口叫号，不重号、不跳号）</p><p><img src="/attachment/0ee025f84106a0ffd17abbf6fb738bba.png"></p><p>这个用到多线程来实现多个窗口叫号的功能，首先要解决的就是资源共享问题，因为不同线程（不同窗口）所使用的叫号计数器应该是同一个，否则就会出现重号的问题。</p><p>资源共享的解决方案有两种：</p><ul><li>使用static关键字修饰要共享的变量，将其变为全局静态变量，也就是放到了JMM的主内存中，这要就实现了资源的共享。</li><li>实现Runnable接口，这个接口和Thread类的区别之一就是可以实现资源的共享，因为实现Runnable接口的线程所操作的资源对象本质是是同一个对象</li></ul><p>解决完资源共享问题之后，还有一个新的问题，那就是并发量比较大的时候会出现：跳号、重号、超过最大值。因为在加号过程中对index的增加操作在工作空间，就需要将index从主内存复制到工作空间进行操作，操作完再更新主内存中的index数据。很明显这不是一个原子操作。这就造成了有可能线程1正在对index进行操作，还没有操作完线程2也对index进行操作，线程2无法感知index已经被更新，这就不符合原子性和可见性原则。这就需要使用到synchronized关键字来保证原子性和可见性。</p><p><strong>代码</strong></p><pre><code class="line-numbers language-java">public class  TicketDemo extends Thread{    private static int index=1;//    private static final int MAX=5000;    @Override    public void run() {        synchronized (this){            while(index&lt;=MAX){                System.out.println(Thread.currentThread().getName()+"叫到号码是："+(index++));            }        }    }    public static void main(String[] args) {        TicketDemo t1=new TicketDemo();        TicketDemo t2=new TicketDemo();        TicketDemo t3=new TicketDemo();        TicketDemo t4=new TicketDemo();        t1.start();        t2.start();        t3.start();        t4.start();    }}</code></pre><p>如果某一个资源被多个线程共享，为了避免因为资源抢占导致资源数据错乱，我们需要对线程进行同步，那么synchronized就是实现线程同步的关键字，可以说在并发控制中是必不可少的部分，今天就来看一下synchronized的使用和底层原理。可以通过synchronized关键字实现互斥同步，进而来实现线程安全。</p><h2 id="synchronized的特性"><a href="#synchronized的特性" class="headerlink" title="synchronized的特性"></a>synchronized的特性</h2><p>synchronized是利用锁的机制来实现同步的。下面synchronized的特性也就是该关键字在并发编程中能保证的特性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。但是像i++、i+=1等操作字符就不是原子性的，它们是分成读取、计算、赋值几步操作，原值在这些步骤还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。</p><p>被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。</p><p>注意！面试时经常会问比较synchronized和volatile，它们俩特性上最大的区别就在于原子性，volatile不具备原子性。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</p><p>synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</p><p>而volatile的实现类似，被volatile修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性值程序执行的顺序按照代码先后执行。</p><p>synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</p><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>synchronized和ReentrantLock都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁，同一个线程外层函数获取到锁之后，内层函数可以直接使用该锁。这样的好处就是避免死锁，如果不可重入，假设method1拿到锁之后，在method1中又调用了method2,如果method2没办法使用method1拿到的锁，那method2将一直等待，但是method1由于未执行完毕，又无法释放锁，就导致了死锁，可重入正好避免这这种情况。</p><p>可重入性就是monitor中的锁计数器来实现的，下面对monitor原理有讲解</p><h2 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h2><p>synchronized可以修饰静态方法、成员函数(非静态方法)，同时还可以直接定义代码块，但是归根结底它上锁的资源只有两类：一个是对象，一个是类。</p><p>synchronized修饰的对象有几种：</p><ul><li>修饰一个方法：被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li><li>修饰一个静态的方法：其作用的范围是整个方法，作用的对象是这个类的所有对象；</li><li>修饰一个代码块，指定加锁对象：被修饰的代码块称为同步语句块，其作用范围是大括号{}括起来的代码块，如果synchronized后面括号括起来的是一个类，那么作用的对象是这个类的所有实例对象；如果synchronized后面括号括起来的是一个对象实例，那么作用的对象是这个对象实例</li></ul><h3 id="根据修饰对象分类"><a href="#根据修饰对象分类" class="headerlink" title="根据修饰对象分类"></a>根据修饰对象分类</h3><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><h5 id="同步非静态方法"><a href="#同步非静态方法" class="headerlink" title="同步非静态方法"></a>同步非静态方法</h5><p>必须先获得该类的实例对象的锁才能进入同步块</p><pre><code class="line-numbers language-java">public synchronized void methodName(){    ……}</code></pre><h5 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h5><p>必须先获得该类的锁才能进入同步块</p><pre><code class="line-numbers language-java">public synchronized static void methodName(){    ……}</code></pre><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><h5 id="修饰对象实例"><a href="#修饰对象实例" class="headerlink" title="修饰对象实例"></a>修饰对象实例</h5><p>必须先获得该对象实例的锁才能进入同步代码块</p><pre><code class="line-numbers language-java">synchronized(this|object) {}</code></pre><h5 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h5><p>必须先获得该类锁才能进入同步代码块</p><pre><code class="line-numbers language-java">synchronized(类.class) {}</code></pre><h3 id="根据获取的锁分类"><a href="#根据获取的锁分类" class="headerlink" title="根据获取的锁分类"></a>根据获取的锁分类</h3><h4 id="获取对象锁"><a href="#获取对象锁" class="headerlink" title="获取对象锁"></a>获取对象锁</h4><pre><code class="line-numbers language-java">synchronized(this|object) {}</code></pre><p>如果有多个对象就有相对应的多个锁。</p><p>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</p><h4 id="获取类锁"><a href="#获取类锁" class="headerlink" title="获取类锁"></a>获取类锁</h4><pre><code class="line-numbers language-java">synchronized(类.class) {}</code></pre><p>也叫全局锁，不管有几个对象就公用一把锁。</p><p>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p><h2 id="synchronized锁的实现"><a href="#synchronized锁的实现" class="headerlink" title="synchronized锁的实现"></a>synchronized锁的实现</h2><p>synchronized关键字的功能是通过锁机制来实现的，也就是通过之前讲过的八种Java内存模型操作中的lock操作和unlock操作来实现的。注意，synchronized 内置锁 是一种 对象锁（锁的是对象而非引用变量），作用粒度是对象。Synchronized可以把任何一个非null对象(包括类的对象和类对象)作为”锁”。</p><h3 id="为什么synchronized通过锁机制可以保证原子性，可见性和有序性，其原理是什么？"><a href="#为什么synchronized通过锁机制可以保证原子性，可见性和有序性，其原理是什么？" class="headerlink" title="为什么synchronized通过锁机制可以保证原子性，可见性和有序性，其原理是什么？"></a>为什么synchronized通过锁机制可以保证原子性，可见性和有序性，其原理是什么？</h3><ul><li>用之前讲过的执行8中操作必须满足的条件，e条中一个变量在同一个时刻只允许一个线程对其进行lock，这就说明了持有一个锁的两个同步块只能串行进行，这也就保证了原子性和有序性。</li><li>可以看到最后一条synchronized 实现其实是靠lock和unlock实现的。在对一个变量unlock操作前。必须也先把此变量同步回主内存中。这就实现了可见性</li></ul><p>所以synchronized之所以能保证三个特性，是因为它是通过Java内存模型的lock操作和unlock操作来实现的，Java内存模型规定了执行这些操作必须满足的规则，通过这些机制synchronized就保证了这三个特性。</p><p><strong>了解完synchronized为什么能够通过锁机制满足三种特性之后，下面我们就来看一看锁机制在底层是怎么实现的。</strong></p><p>synchronized有两种形式上锁，一个是对方法上锁，一个是构造同步代码块。他们的底层实现其实都一样，在进入同步代码之前先获取锁，获取到锁之后锁的计数器+1，同步代码执行完锁的计数器-1，如果获取失败就阻塞式等待锁的释放。只是他们在同步块识别方式上有所不一样，从class字节码文件可以表现出来，一个是通过方法flags标志，一个是monitorenter和monitorexit指令操作。</p><h3 id="同步方法-1"><a href="#同步方法-1" class="headerlink" title="同步方法"></a>同步方法</h3><p>首先来看在方法上上锁，我们就新定义一个同步方法然后使用 javap -v  反编译进行反编译，查看其字节码</p><p><img src="/attachment/16d631e2934258b7073a0f8476efe6fa.png"></p><p><img src="/attachment/ba1c3b18b13c233f2061b33e8e93c9c2.png"></p><p>可以看到在add方法的flags里面多了一个ACC_SYNCHRONIZED标志，这标志用来告诉JVM这是一个同步方法，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就线程就会进入阻塞(BLOCK)状态，直到该锁被释放，当锁的计数器为0时，线程就会释放该锁。</p><p>同步方法直接就在头部标志位用ACC_SYNCHRONIZED标志标识，内部没有使用monitorenter和monitorexit指令操作，因为整个方法都是一个同步块。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h3 id="同步代码块-1"><a href="#同步代码块-1" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>我们新定义一个同步代码块，编译出class字节码，然后找到method方法所在的指令块，可以清楚的看到其实现上锁和释放锁的过程，截图如下：</p><p><strong>代码：</strong></p><p><img src="/attachment/cb12ca709728dbcdc2fed22925a87070.png"></p><p><strong>字节码：</strong></p><p><img src="/attachment/e24f0f7073b24f63d8f6cd30cf6b177e.png"></p><p>头部只有一个方法的普通标识ACC_PUBLIC表明这是一个普通的成员方法。</p><p>如果还有一个ACC_STATIC标识，表明这是一个静态方法</p><p>Monitorenter和Monitorexit指令，会让线程在执行时，使其持有的锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个线程在尝试获得与对象相关联的Monitor锁的所有权的时候：</p><p><strong>monitorenter指令</strong>会发生如下3种情况之一：</p><ul><li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li><li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li><li>这把锁已经被别的线程获取了，等待锁释放</li></ul><p><strong>monitorexit指令</strong>：</p><p>释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p><p>从反编译的同步代码块可以看到同步块是由monitorenter指令进入，然后monitorexit释放锁，在执行monitorenter之前需要尝试获取锁，如果这个对象没有被锁定，或者当前线程已经拥有了这个对象的锁，那么就把锁的计数器加1。当执行monitorexit指令时，锁的计数器也会减1。当获取锁失败时会被阻塞(BLOCK)，一直等待锁被释放。因为synchronized的锁是重入锁，所以锁的计数器可以大于1，只有当锁的计数器为0的时候，线程才会释放所持有的锁。</p><p>但是为什么会有两个monitorexit呢？其实第二个monitorexit是来处理异常的，仔细看反编译的字节码，正常情况下第一个monitorexit之后会执行goto指令，而该指令转向的就是23行的return，也就是说正常情况下只会执行第一个monitorexit释放锁，然后返回。而如果在执行中发生了异常，第二个monitorexit就起作用了，它是由编译器自动生成的，在发生异常时处理异常然后释放掉锁。</p><h2 id="synchronized锁的底层实现"><a href="#synchronized锁的底层实现" class="headerlink" title="synchronized锁的底层实现"></a>synchronized锁的底层实现</h2><p>在理解锁实现原理之前先了解一下Java的对象头和Monitor。</p><p>在 Java 中，每个对象都会有一个 monitor 对象（监视器）。<br>在JVM中，对象是分成三部分存在的：对象头（Object Header）、实例数据、对其填充。</p><p><img src="/attachment/6eb030e419bc97293a243b321588a2b7.png"></p><p><img src="/attachment/d25b1313df871447442eabee2c66c4cc.png"></p><p>实例数据和对其填充与synchronized无关，这里简单说一下（我也是阅读《深入理解Java虚拟机》学到的，读者可仔细阅读该书相关章节学习）。</p><ul><li>实例变量存放类的属性数据信息（就是成员属性的值），包括父类的属性信息；</li><li>填充数据不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，对齐填充仅仅是为了使字节对齐。</li></ul><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。HotSpot虚拟机的对象头主要结构是由Mark Word 和 Class Metadata Address组成，其中Mark Word存储一些自身运行时数据，如对象的hashCode、锁信息或分代年龄或GC标志等信息，这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特；Class Metadata Address是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例。如果是数组对象，对象头还会有一个额外的部分用于存储数组长度。</p><p><strong>对象头中的数据：</strong></p><p><img src="/attachment/57a09210c1023ad0422f71307e21b572.png"></p><p>锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：无锁状态、偏向锁、轻量级锁、重量级锁，其中无锁就是一种状态了。锁的类型和状态在对象头Mark Word中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的Mark Word数据。</p><p><strong>Mark Word中的数据：</strong></p><p><img src="/attachment/4a1a2484e64e3be1161dd234ac28d54e.png"></p><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效 率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。上图为32位系统Mark Word的数据结构图，看出Mark Word的数据长度是一定的，但是里面的内容会根据锁状态的改变而进行改变（横向看不同的锁状态在Mark Word中存储的数据是不同的）。</p><p>例如在32位的HotSpot虚拟机中，对象未被锁定的状态下， Mark Word的32个比特空间里的25个比特将用于存储对象哈希码，4个比特用于存储对象分代年龄（就是新生代to区和from区之间转移的次数），2 个比特用于存储锁标志位，还有1个比特固定为0（这表示未进入偏向模式）。对象除了未被锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记（标识该对象需要被GC清除）、可偏向等几种不同状态</p><h3 id="monitor对象"><a href="#monitor对象" class="headerlink" title="monitor对象"></a>monitor对象</h3><p>在HotSpot虚拟机中monitor对象是由ObjectMonitor实现的（C++实现）。<mark style="background: #FFB8EBA6;">每个对象都存在着一个monitor与之关联</mark>，monitor对象存在于每个Java对象的对象头中(对象头的MarkWord中的LockWord指向monitor的起始地址)，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，对象便处于锁定状态。所以说<mark style="background: #FFB8EBA6;">monitor是实现锁机制的基础</mark>，<mark style="background: #FFB8EBA6;">线程获取锁本质是线程获取Java对象对应的monitor对象</mark>。重量级锁就是通过ObjectMonitor实现的，也就是说重量级锁是基于对象的monitor来实现的。</p><p><strong>例子：</strong></p><pre><code class="line-numbers language-java">ObjectMonitor() {    _header       = NULL;    _count        = 0;  //锁计数器    _waiters      = 0,    _recursions   = 0;    _object       = NULL;    _owner        = NULL;// 标记当前持有Monitor的线程    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet    _WaitSetLock  = 0 ;    _Responsible  = NULL ;    _succ         = NULL ;    _cxq          = NULL ;    FreeNext      = NULL ;    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表    _SpinFreq     = 0 ;    _SpinClock    = 0 ;    OwnerIsThread = 0 ;}</code></pre><p>ObjectMonitor中有两个队列_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：</p><ol><li>首先会进入_EntryList 集合，当线程获取到对象的monitor 后进入 _owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1</li><li>若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒</li><li>若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</li></ol><p>monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)，<strong>同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</strong></p><p>下面通过此图讲解为什么notify/notifyAll/wait等方法必须在同步代码块中使用</p><p><img src="/attachment/3fe006b658351df2b1c17ba35c1fd016.png"></p><p>如上图所示，</p><ul><li>一个线程通过1号门进入Entry Set(入口区)，<ul><li>如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视区域的代码。</li><li>如果在入口区中有其它线程在等待，那么新来的线程也会和这些线程一起等待。</li></ul></li><li>线程在持有监视器的过程中，有两个选择，<ul><li>一个是正常执行监视器区域的代码，释放监视器，通过5号门退出监视器；</li><li>还有可能等待某个条件的出现，于是它会通过3号门到Wait Set（等待区）休息，直到相应的条件满足后再通过4号门进入重新获取监视器再执行。</li></ul></li></ul><p><strong>注意</strong></p><p>当一个线程释放监视器时，在入口区和等待区的等待线程都会去竞争监视器，如果入口区的线程赢了，会从2号门进入；如果等待区的线程赢了会从4号门进入。只有通过3号门才能进入等待区，在等待区中的线程只有通过4号门才能退出等待区，也就是说一个线程只有在持有监视器时才能执行wait操作，处于等待的线程只有再次获得监视器才能退出等待状态，<strong>在持有监视器的时候才有可能进入到等待区，所以只有在同步代码块中才能使用wait()方法，因为进入到同步代码块中才能保证线程一定持有监视器。</strong></p><p>监视器Monitor有两种同步方式：互斥与协作。</p><ul><li><strong>互斥的同步方式</strong>：在多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</li><li><strong>协作的同步方式</strong>：一个线程向缓冲区写数据，另一个线程从缓冲区读数据，如果读线程发现缓冲区为空就会等待，当写线程向缓冲区写入数据，就会唤醒读线程，这里读线程和写线程就是一个合作关系。JVM通过Object类的wait方法来使自己等待，在调用wait方法后，该线程会释放它持有的监视器，直到其他线程通知它才有执行的机会。一个线程调用notify方法通知在等待的线程，这个等待的线程并不会马上执行，而是要通知线程释放监视器后，它重新获取监视器才有执行的机会。如果刚好唤醒的这个线程需要的监视器被其他线程抢占，那么这个线程会继续等待。Object类中的notifyAll方法可以解决这个问题，它可以唤醒所有等待的线程，总有一个线程执行。</li></ul><h2 id="JVM对synchronized的优化"><a href="#JVM对synchronized的优化" class="headerlink" title="JVM对synchronized的优化"></a>JVM对synchronized的优化</h2><p>Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化等优化方法，又新增了两个锁的状态：偏向锁、轻量级锁。现在synchronized一共有四种锁的状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以<mark style="background: #FFB8EBA6;">升级不可降级</mark>，这种策略是为了提高获得锁和释放锁的效率。给synchronized性能带来了很大的提升。在 JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。下面讲解对synchronized锁进行优化的几种方法。</p><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>上面讲到锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁，并且膨胀方向不可逆。也就是说对象对应的锁是会根据当前线程申请，抢占锁的情况自行改变锁的类型。</p><h4 id="偏向锁（Biased-Locking）"><a href="#偏向锁（Biased-Locking）" class="headerlink" title="偏向锁（Biased Locking）"></a>偏向锁（Biased Locking）</h4><p>一句话总结它的作用：<mark style="background: #FFB8EBA6;">减少同一线程获取锁的代价</mark>。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，使用偏向锁也就去掉了这一部分的负担，也取消掉了加锁和解锁的过程消耗。</p><h5 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h5><p>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。</p><p>如果该锁第一次被一个线程持有，那么锁就进入偏向模式，此时Mark Word的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word的锁标记位是否为偏向锁以及当前线程ID是否等于Mark Word的ThreadID即可，这样就省去了大量有关锁申请的操作，减少不必要的CAS操作。申请获取偏向锁的时间非常短，这种锁在竞争不激烈的时候比较适用。如果程序中大多数的锁都总是被多个不同的线程访 问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>① 线程申请锁的时候首先都会检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；因为当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式，表示对象处于可偏向的状态，并且ThreadId为0，这时该对象是biasable&amp;unbiased状态。</p><p>如果当前对象处于可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤5）；否则执行步骤2），尝试获取偏向锁。一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束，由于锁竞争应该直接进入步骤4）</p><p>② 若当前对象的Mark Word中指向的持有锁的线程ID不是该线程ID，则该线程就尝试用CAS操作将自己的ThreadID放置到Mark Word中相应的位置，如果CAS操作成功，说明该线程成功获取偏向锁，进入到步骤3），否则进入步骤4）</p><p>③ 进入到这一步代表当前没有锁竞争，此时ThreadID已经不为0了，而是持有锁的线程ID。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等），只需要检查Mark Word的锁标记位是否为偏向锁以及当前线程ID是否等于Mark Word的ThreadID，如果都满足则进入步骤5）执行同步代码块。</p><p>④ 当线程执行CAS失败，表示另一个线程当前正在竞争该对象上的锁。当到达全局安全点时（cpu没有正在执行的字节，即获得偏向锁的线程当前没有执行，这个时间点是上没有正在执行的代码，注意当前持有偏向锁的线程不执行并不一定就是它的操作已经执行完成，要释放锁了）之前持有偏向锁的线程将被暂停，撤销偏向（偏向位置0）</p><p>然后判断锁对象是否还处于被锁定状态，如果没有被锁定，说明当前资源没有被线程使用，则恢复到无锁状态（01），以允许其余线程竞争。如果处于被锁定状态，说明当前资源正在被线程使用，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址（Lock Record）的指针放入对象头Mark Word，升级为轻量级锁状态（00），然后恢复持有锁的当前线程，进入轻量级锁的竞争模式；后续的同步操作就按照轻量级锁那样去执行。同时被撤销偏向锁的线程继续往下执行。</p><blockquote><p>注意：此处将 当前线程挂起再恢复的过程 中并没有发生锁的转移 ，锁仍然在当前线程手中，只是穿插了个 “将对象头中的线程 ID 变更为指向锁记录地址的指针” 这么个事（将偏向锁转换成轻量级锁）。</p></blockquote><p>⑤ 执行同步代码块；</p><p><img src="/attachment/5a5b923a9cf5ef8d1b48d82e1fb66908.png"></p><h5 id="对象的哈希码去哪了？"><a href="#对象的哈希码去哪了？" class="headerlink" title="对象的哈希码去哪了？"></a>对象的哈希码去哪了？</h5><p>当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原 来对象的哈希码怎么办呢？</p><p>在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因 为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，<mark style="background: #BBFABBA6;">当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了</mark>；而<mark style="background: #BBFABBA6;">当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。</mark>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。（意思就是线程之间获取锁是没有争抢的，线程A持有了资源X的锁，当时用完资源X之后，A线程释放掉资源X的锁，当线程B也想使用资源X去申请它的锁的时候，就再次申请获取资源X的锁，两个线程之间没有发成争抢，也就没有必要使用以前的互斥量还要休眠进程白白降低效率）</p><p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢。</p><h5 id="核心思想：-1"><a href="#核心思想：-1" class="headerlink" title="核心思想："></a>核心思想：</h5><p>如果说偏向锁是只允许一个线程获得锁，那么轻量级锁就是允许多个线程获得锁，但是只允许他们顺序拿锁，不允许出现竞争，也就是拿锁失败的情况。轻量级锁的加锁和解锁都是通过CAS操作是现实。</p><h5 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h5><p>① 线程1在执行同步代码块之前，如果此同步对象没有被锁定（锁标志位为“01”状态），JVM会先在当前线程的栈帧中创建一个名为<strong>锁记录</strong>（Lock Record）的空间用来存储锁记录，然后再把对象头中的MarkWord复制到该锁记录中，官方称之为Displaced Mark Word。然后线程尝试使用CAS将对象头中的MarkWord 替换为指向锁记录的指针（锁状态为轻量级锁的Mark Word中存储的就是指向持有锁的线程的所记录的指针，这个操作详细就是使用CAS操作尝试将对象Mark Word中的Lock Word更新为指向当前线程Lock Record的指针，并将Lock record里的owner指针指向object mark word）。如果成功，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。进入步骤3）。如果该操作失败，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入步骤5）执行同步块就可以了，否则就说明这个锁对象已经被其他线程抢占了，执行步骤2）</p><p><img src="/attachment/19790e9be1a641a5ad4da09aae1c57d4.png"></p><p><img src="/attachment/8dff4a55218c5023bc8abf1377a0a349.png"></p><blockquote><p>Lock Record是线程私有的数据结构，每一个线程都有一个可用Lock Record列表，同时还有一个全局的可用列表。每一个被锁住的对象Mark Word都会和一个Lock Record关联（对象头的MarkWord中的Lock Word指向Lock Record的起始地址），同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识（或者object mark word），表示该锁被这个线程占用。也就是对象头中是Mark Word与线程中是Lock Record</p></blockquote><p>② 如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，但是对锁进行了优化，线程会先进行一段时间的自旋状态（轮询申请锁），先并不会进入阻塞状态，如果在自旋期间成功获得锁，则进入步骤3）。如果自旋结束也没有获得锁，则膨胀成为重量级锁，并把锁标志位变为10，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针（Mark Word中重量级锁状态就存储指向重量级锁的指针），所有等待该锁的线程也必须进入阻塞状态，进入步骤3）</p><p>③ 锁的持有线程执行同步代码，执行完之后如果对象的 Mark Word仍然指向线程的锁记录，那就用CAS操作将对象当前的Mark Word用线程中复制的Displaced Mark Word替换回来（也就是执行了compare and swap 比较然后交换操作），即CAS替换Mark Word释放锁，如果CAS执行成功，那整个同步过程就顺利完成了，则流程结束；CAS执行失败则进行步骤4）</p><p>④ CAS执行失败说明期间有线程尝试获得锁并自旋失败，轻量级锁升级为了重量级锁，此时释放锁之后，还要唤醒等待的线程</p><p>⑤ 执行同步代码块；</p><h5 id="为什么升级为轻量锁时要把对象头里的Mark-Word复制到线程栈的锁记录中呢？"><a href="#为什么升级为轻量锁时要把对象头里的Mark-Word复制到线程栈的锁记录中呢？" class="headerlink" title="为什么升级为轻量锁时要把对象头里的Mark Word复制到线程栈的锁记录中呢？"></a>为什么升级为轻量锁时要把对象头里的Mark Word复制到线程栈的锁记录中呢？</h5><p>因为在申请对象锁时 <strong>需要以该值作为CAS的比较条件</strong>，同时在升级到重量级锁的时候，<strong>能通过这个比较判定是否在持有锁的过程中此锁被其他线程申请过</strong>，如果被其他线程申请了，则在释放锁的时候要唤醒被挂起的线程。</p><h5 id="为什么会尝试CAS不成功以及什么情况下会不成功？"><a href="#为什么会尝试CAS不成功以及什么情况下会不成功？" class="headerlink" title="为什么会尝试CAS不成功以及什么情况下会不成功？"></a>为什么会尝试CAS不成功以及什么情况下会不成功？</h5><p>CAS本身是不带锁机制的，其是通过比较而来。假设如下场景：线程A和线程B都在对象头里的锁标识为无锁状态进入，那么如线程A先更新对象头为其锁记录指针成功之后，线程B再用CAS去更新，就会发现此时的对象头已经不是其操作前的对象HashCode了，所以CAS会失败。也就是说，只有两个线程并发申请锁的时候会发生CAS失败。</p><p>然后线程B进行CAS自旋，等待对象头的锁标识重新变回无锁状态或对象头内容等于对象HashCode（因为这是线程B做CAS操作前的值），这也就意味着线程A执行结束（参见后面轻量级锁的撤销，只有线程A执行完毕撤销锁了才会重置对象头），此时线程B的CAS操作终于成功了，于是线程B获得了锁以及执行同步代码的权限。如果线程A的执行时间较长，线程B经过若干次CAS时钟没有成功，则锁膨胀为重量级锁，即线程B被挂起阻塞、等待重新调度。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是由轻量级锁升级而来，当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。</p><h5 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h5><p>Synchronized是通过对象内部的<mark style="background: #FFB8EBA6;">监视器锁（Monitor）</mark>来实现的。但是监视器锁本质又是依赖于底层的操作系统的<mark style="background: #FFB8EBA6;">Mutex Lock（互斥锁）</mark>来实现的。实现Mutex Lock又需要进行两个线程之间的切换，而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。它通过操作系统的互斥量和线程的阻塞和唤醒来实现锁机制。</p><p><strong>重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。</strong></p><h4 id="三种锁各自的优缺点和适用场景："><a href="#三种锁各自的优缺点和适用场景：" class="headerlink" title="三种锁各自的优缺点和适用场景："></a>三种锁各自的优缺点和适用场景：</h4><p><img src="/attachment/e318185603b272de1623d7120e455ad8.png"></p><h3 id="锁消除（Lock-Elision）"><a href="#锁消除（Lock-Elision）" class="headerlink" title="锁消除（Lock Elision）"></a>锁消除（Lock Elision）</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。锁消除可以节省毫无意义的请求锁的时间。比如下面代码的method1和method2的执行效率是一样的，因为object锁是私有局部变量，不存在所得竞争关系。</p><p><img src="/attachment/7204c63ed127fab8b87e34897cdfbada.png"></p><h4 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a>原理：</h4><p>“锁消除”，是JIT编译器对内部锁的具体实现所做的一种优化。锁消除是借助逃逸分析实现的。</p><p>在动态编译同步块的时候，JIT编译器可以借助一种被称为<mark style="background: #FF5582A6;">逃逸分析（Escape Analysis）</mark>的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p><p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。</p><p><strong>如以下代码：</strong></p><pre><code class="line-numbers language-java">public void f() {    bject hollis = new Object();    synchronized(hollis) {        ystem.out.println(hollis);    }}</code></pre><p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p><pre><code class="line-numbers language-java">public void f() {    Object hollis = new Object();    System.out.println(hollis);}</code></pre><blockquote><p> 这里，可能有读者会质疑了，代码是程序员自己写的，程序员难道没有能力判断要不要加锁吗？就像以上代码，完全没必要加锁，有经验的开发者一眼就能看的出来的。其实道理是这样，但是还是有可能有疏忽，虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，他们的方法很多都被进行了加锁处理，会存在隐形的加锁操作。比如我们经常在代码中使用StringBuffer作为局部变量，而StringBuffer中的append是线程安全的，有synchronized修饰的，这种情况开发者可能会忽略。</p></blockquote><p>总之，在使用synchronized的时候，如果JIT经过逃逸分析之后发现同步块中使用的锁对象并没有逃逸出去，不可能被其他线程所使用，并无线程安全问题的话，就会做锁消除。</p><h3 id="锁粗化（Lock-Coarsening）"><a href="#锁粗化（Lock-Coarsening）" class="headerlink" title="锁粗化（Lock Coarsening）"></a>锁粗化（Lock Coarsening）</h3><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。比如下面method3经过锁粗化优化之后就和method4执行效率一样了。</p><p><img src="/attachment/cbe57c1b219daf0c6b85acab7c028f64.png"></p><h5 id="对于锁粗化的的理解："><a href="#对于锁粗化的的理解：" class="headerlink" title="对于锁粗化的的理解："></a>对于锁粗化的的理解：</h5><p>很多人都知道，在代码中，需要加锁的时候，我们提倡尽量减小锁的粒度，这样可以避免不必要的阻塞。</p><p>这也是很多人原因是用同步代码块来代替同步方法的原因，因为往往他的粒度会更小一些，这其实是很有道理的。</p><p>还是我们去银行柜台办业务，最高效的方式是你坐在柜台前面的时候，只办和银行相关的事情。如果这个时候，你拿出手机，接打几个电话，问朋友要往哪个账户里面打钱，这就很浪费时间了。最好的做法肯定是提前准备好相关资料，在办理业务时直接办理就好了。</p><p>加锁也一样，把无关的准备工作放到锁外面，锁内部只处理和并发相关的内容。这样有助于提高效率。</p><p>那么，这和锁粗化有什么关系呢？可以说，大部分情况下，减小锁的粒度是很正确的做法，只有一种特殊的情况下，会发生一种叫做锁粗化的优化。</p><p>就像你去银行办业务，你为了减少每次办理业务的时间，你把要办的五个业务分成五次去办理，这反而适得其反了。因为这平白的增加了很多你重新取号、排队、被唤醒的时间。</p><p>如果在一段代码中连续的对同一个对象反复加锁解锁，其实是相对耗费资源的，这种情况可以适当放宽加锁的范围，减少性能消耗。</p><p>当JIT发现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散（粗化）到整个操作序列的外部。</p><p>如以下代码：</p><pre><code class="line-numbers language-java">for(int i=0;i&lt;100000;i++){      synchronized(this){      do();  }  </code></pre><p> 会被粗化成：</p><pre><code class="line-numbers language-java">synchronized(this){      for(int i=0;i&lt;100000;i++){      do();  } </code></pre><p>这其实和我们要求的减小锁粒度并不冲突。减小锁粒度强调的是不要在银行柜台前做准备工作以及和办理业务无关的事情。而锁粗化建议的是，同一个人，要办理多个业务的时候，可以在同一个窗口一次性办完，而不是多次取号多次办理。</p><h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><p>自旋锁在 JDK1.4.2 实就已经引入了，不过是默认关闭的，需要通过–XX:+UseSpinning参数来开启。JDK1.6及1.6之后，就改为默认开启的了。另外,在 JDK1.6 中引入了自适应的自旋锁。</p><p>之前如果线程尝试获得锁失败，就会进入到阻塞状态，线程进入到阻塞状态是需要操作系统来讲线程进行挂起，挂起和唤醒都是一个消耗时间和资源的操作，所以为了避免这种情况，就出现了自旋锁的概念。</p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p><p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要操作系统从用户态转入内核态中完成（用户态转换到内核态会耗费时间）。</p><p>自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。自旋次数的默认值是10次，用户可以修改–XX:PreBlockSpin来更改。</p><p><mark style="background: #FF5582A6;">自适应自旋锁（Adaptive Locking）</mark>：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其<mark style="background: #FFB8EBA6;">自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</mark>，这就解决了自旋锁带来的缺点。那它如何进行适应性自旋呢？</p><ul><li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。</li><li>反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li></ul><p>自旋锁和阻塞锁最大的区别就是，到底要不要放弃处理器的执行时间。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但是阻塞锁是放弃了CPU时间，进入了等待区，等待被唤醒。而自旋锁是一直“自旋”在那里，时刻的检查共享资源是否可以被访问。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程安全和线程不安全的定义以及实现线程安全的方法有哪些</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-xian-cheng-an-quan-he-xian-cheng-bu-an-quan-de-ding-yi-yi-ji-shi-xian-xian-cheng-an-quan-de-fang-fa-you-na-xie/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-xian-cheng-an-quan-he-xian-cheng-bu-an-quan-de-ding-yi-yi-ji-shi-xian-xian-cheng-an-quan-de-fang-fa-you-na-xie/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程安全和线程不安全的定义以及实现线程安全的方法有哪些"><a href="#【Java-多线程并发】-线程安全和线程不安全的定义以及实现线程安全的方法有哪些" class="headerlink" title="【Java 多线程并发】 线程安全和线程不安全的定义以及实现线程安全的方法有哪些"></a>【Java 多线程并发】 线程安全和线程不安全的定义以及实现线程安全的方法有哪些</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程安全和线程不安全的定义以及实现线程安全的方法有哪些date: 2023-07-03 22:18tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 线程安全和线程不安全的定义以及实现线程安全的方法有哪些</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><ul><li>不可变</li><li>绝对线程安全</li><li>相对线程安全</li><li>线程兼容</li><li>线程对立</li></ul><p><strong>互斥同步</strong></p><p>是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。</p><p><strong>线程执行互斥代码的过程</strong></p><ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存中</li><li>执行代码<ol><li>使用</li><li>赋值</li></ol></li><li>将更改后的共享变量值刷新到主内存中</li><li>释放互斥锁</li></ol><p><strong>实现互斥同步的方法</strong></p><ul><li>synchronized关键字</li><li>ReentrantLock</li></ul><p><strong>非阻塞同步</strong></p><ul><li>测试并设置（Test-and-Set）；</li><li>获取并增加（Fetch-and_Increment);</li><li>交换（Swap）；</li><li>比较并交换（Compare-and-Swap，下文称CAS）；</li><li>加载链接/条件储存（Load-Linked / Store-Conditional，下文称LL/SC）。</li></ul><p><strong>无同步方案</strong></p><ul><li>可重入代码（Reentant Code）</li><li>线程本地存储（Thread Local Storage）</li></ul><p><strong>引起线程安全问题的原因</strong></p><ul><li>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；</li><li>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行程序时出现意外结果。</p><p>在Java中也就是当多个线程访问一个对象时，如果不考虑这些线程在执行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p><p>我们讨论的java中的线程安全，就限定于多个线程之间存在<mark style="background: #FF5582A6;">共享数据</mark>访问这个前提，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的。</p><p>我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>在Java语言中不可变的对象一定是线程安全的，无论是对象的方法实现还是方的调用者，都不需要再采用任何的线程安全保障措施。</p><p>不可变对象(Immutable Object)：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。</p><ul><li>final关键字，只要一个不可变对象被正确构建出来（没有发生this引用逃逸，即对象还未构造完成this引用就被发布出去了），那其外部的可见状态永远不会发生改变，永远不会看到它在多个线程之中处于不一致的状态。</li><li>java.lang.String类的对象，它是一个典型的不可变对象，我们调用它substring（）、replace（）和concat（）这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象</li><li>String，枚举类型，以及java.lang.Number的部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型基本都是不可变的API；但同为Number的子类型的原子类AtomicInteger和AtomicLong则并非不可变的</li></ul><h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p><ul><li>例如java.util.Vector是一个线程安全的容器，它的get,add,size等方法<strong>都是被synchronized修饰的</strong>，效率很低 ，但确实是安全的。可是Vector并不是绝对线程安全，因为它被调用时并不是永远不需要同步手段，如多线程中一个线程在错误的时间里对元素进行了删除，就会导致边界异常。此时对删除需要进入同步块处理。</li><li>在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。Java给你的保证的线程安全，是说它的方法是执行是排它的，而不是对这个对象本身的多次调用情况下，还是安全的。</li></ul><h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>相对的线程安全就是我们通常意义上所讲的线程安全</p><p>要保证对这个对象<strong>单独的操作是线程安全</strong>的，调用时不需要做额外的保障措施，但对<strong>一些特定的顺序的连续调用</strong>，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><ul><li>Java中大部分都属于这类，如Vector，HashTable，Collections的synchronizedCollection()方法包装的集合(比如Collections.synchronizedList)，StringBuffer，statck，Enumeration (枚举，相当于迭代器)等。</li><li>在集合框架中，除了上面这些之外，其他的都是非线程安全的类和接口。</li></ul><h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>线程兼容是指对象本身并<strong>不是线程安全</strong>的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java  API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap，还有LinkedList，HashSet，TreeMap，TreeSet，StringBulider这些都是线程不安全类。</p><h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p><p>举个线程对立的例子是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend()和resume()方法已经被JDK声明废弃（@Deprecated）了。常见的线程对立的操作还有System.setIn()、Sytem.setOut()和System.runFinalizersOnExit()等。</p><h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><p>我们了解了什么是线程安全之后，那接下来的一个问题就是我们应该如何实现线程安全？这个听起来似乎是一件由代码如何编写来决定的事情，确实，如何实现线程安全与代码的编写有很大关系，但虚拟机提供的同步和锁机制（通过锁机制实现了同步）也起到了非常重要的作用。</p><p>这就让我们来讲讲其的具体实现吧~~</p><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>互斥同步（Mutual Exclusion &amp; Synchroniztion）是最常见的一种并发正确性保障手段。</p><ul><li>同步 - 指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，使用信号量的时候）线程使用。</li><li>互斥 - 是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。</li></ul><p>互斥是因，同步是果，互斥是方法，同步是目的。</p><h4 id="线程执行互斥代码的过程："><a href="#线程执行互斥代码的过程：" class="headerlink" title="线程执行互斥代码的过程："></a>线程执行互斥代码的过程：</h4><ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存中</li><li>执行代码<ol><li>使用</li><li>赋值</li></ol></li><li>将更改后的共享变量值刷新到主内存中</li><li>释放互斥锁</li></ol><p>注：这个过程也就是能看出就是保证可见性的原理</p><h4 id="实现互斥同步的方法–synchronized关键字"><a href="#实现互斥同步的方法–synchronized关键字" class="headerlink" title="实现互斥同步的方法–synchronized关键字"></a>实现互斥同步的方法–synchronized关键字</h4><p>在Java里面，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的首尾分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型（引用类型）的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法（static方法），或取对应的对象实例或Class对象来作为锁对象。</p><p>根据虚拟机规范的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放了。</p><p>如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p><p>在虚拟机规范对monitorenter和monitoreexit的行为描述中，有两点是需要特别注意的：</p><ul><li>synchronized同步块对同一条线程来说是<strong>可重入</strong>的，这意味着同一线程反复进入同步块 也不会出现自己把自己锁死的情况。</li><li>synchronized同步块块在持有锁的线程执行完毕并释放锁之前，会无条件地<strong>阻塞</strong>后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><h4 id="实现互斥同步的方法–ReentrantLock"><a href="#实现互斥同步的方法–ReentrantLock" class="headerlink" title="实现互斥同步的方法–ReentrantLock"></a>实现互斥同步的方法–ReentrantLock</h4><p>除了synchronized之外，我们还可以使用java.util.concurrent名中的重入锁（ReentrantLock）来实现同步，在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别。不过ReentrantLock比synchronized增加了一些高级功能，主要有以下三项：</p><ul><li>等待可中断 - 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁 - 多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li><li>锁绑定多个条件 - 一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。它属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。</p></li><li><p>互斥、同步、锁的关系</p></li></ul><p>互斥是因，同步是果，互斥是实现同步的一种手段。互斥同步是一种同步方法，也就是说互斥同步是实现同步的一种手段。而同步是实现线程安全的一种方法，所以互斥同步也就是实现线程安全的一种方法。<br>加锁是因，互斥是果，加锁是实现互斥的一种方法，进而加锁也就是实现同步的一种手段。锁机制就是通过操作系统中学的临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）等来实现的不同种类的锁。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>随着硬件指令集的发展，我们实现线程安全有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再进行其他的补偿措施（最常见的补偿措施就是不断地重试，直到试成功了为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作被称为非阻塞同步（No-Blocking Synchronization）。</p><p>为什么需要“硬件指令集的发展”才能进行呢？</p><p>因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指指令常用的有：</p><ul><li>测试并设置（Test-and-Set）；</li><li>获取并增加（Fetch-and_Increment);</li><li>交换（Swap）；</li><li>比较并交换（Compare-and-Swap，下文称CAS）；</li><li>加载链接/条件储存（Load-Linked / Store-Conditional，下文称LL/SC）。</li></ul><h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保障共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，这里简单介绍其中的两类：</p><ul><li>可重入代码（Reentant Code）- 这种代码也叫纯代码（Pure Code）,可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。特征: 例如不依赖存储在堆上的数据公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</li><li>线程本地存储（Thread Local Storage）- 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。符合这种特点的应用并不少见，比如大部分的消费队列的架构模式，经典WEB交互模型中的“一个请求对应一个服务器纯种”的处理方式。Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”的；如果一个变量要被某个线程独享，可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。</li></ul><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>是指不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p><p>举例说明：假设售票系统有1000张票，A和B同时来买票，如果是线程不安全，那么可能售票系统可能出现1000-1去同时执行的情况，最终结果是A和B都买完后剩下999张票，而不是998张。 </p><p>简单点说就是：</p><ul><li>线程安全  无论多少线程执行，结果都是预期，线程之间互不干扰，也无法干扰。</li><li>线程不安全  在单个线程下不会有问题，但在多线程环境中，结果会受到随机干扰，即线程的执行顺序会影响到其他线程的结果。</li></ul><h2 id="引起线程安全问题的原因"><a href="#引起线程安全问题的原因" class="headerlink" title="引起线程安全问题的原因"></a>引起线程安全问题的原因</h2><p>线程安全问题都是由全局变量及静态变量引起的：</p><ul><li>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；</li><li>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 LockSupport</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-locksupport/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-locksupport/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-LockSupport"><a href="#【Java-多线程并发】-LockSupport" class="headerlink" title="【Java 多线程并发】 LockSupport"></a>【Java 多线程并发】 LockSupport</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 LockSupportdate: 2023-07-03 15:59tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java 多线程并发】 LockSupport</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LockSupport是concurrent包中的一个线程阻塞工具类，所有的方法都是静态方法<br>LockSupport用来创建锁和其他同步类的基本线程阻塞原语。</p><ul><li>当调用 LockSupport.park()时，表示当前线程将会等待，直至获得许可，</li><li>当调用 LockSupport.unpark()时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。</li></ul><p><strong>设计思想</strong></p><p>**设置一个许可(permit)**，这个permit就相当于一个开关，0代表关闭，1代表打开。<br>调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。</p><p><strong>底层原理</strong></p><p>LockSupport的底层实现都是基于Unsafe.park()和Unsafe.unpark()。</p><ul><li>native层的JavaThread通过Parker的<mark style="background: #FF5582A6;">_counter</mark>来表示通行证，&gt;0表示可以通行，如果_counter=0，调用park线程会等待，直到被unpark唤醒，如果先调用unpack，再调用park会直接返回，并消费掉_counter（设置为0）。</li><li>Linux平台，线程等待和唤醒，加锁用的pthread_mutex_lock，解锁是pthread_mutex_unlock，唤醒是pthread_cond_signal，</li></ul><h2 id="【Java-多线程并发】-LockSupport-1"><a href="#【Java-多线程并发】-LockSupport-1" class="headerlink" title="【Java 多线程并发】 LockSupport"></a>【Java 多线程并发】 LockSupport</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>LockSupport是concurrent包中的一个线程阻塞工具类，所有的方法都是静态方法，不提供构造，可以让线程在任意位置阻塞，当然阻塞之后肯定得有唤醒的方法。</p><p>LockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用 LockSupport.park()时，表示当前线程将会等待，直至获得许可，当调用 LockSupport.unpark()时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。</p><h3 id="为什么说LockSupport是Java并发的基石？"><a href="#为什么说LockSupport是Java并发的基石？" class="headerlink" title="为什么说LockSupport是Java并发的基石？"></a>为什么说LockSupport是Java并发的基石？</h3><p>当需要阻塞或唤醒一个线程的时候，JVM都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也被称为构建同步组件的基础工具。</p><p>Java并发组件和并发工具类如下：</p><ul><li>并发组件：线程池、阻塞队列、Future和FutureTask、Lock和Condition。</li><li>并发工具：CountDownLatch、CyclicBarrier、Semaphore和Exchanger。</li></ul><p>并发组件和并发工具大都是基于AQS来实现的：</p><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p><p>而<strong>AQS中的控制线程又是通过LockSupport类来实现</strong>的，因此可以说，LockSupport是Java并发基础组件中的基础组件。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p><h2 id="LockSupport-设计思想"><a href="#LockSupport-设计思想" class="headerlink" title="LockSupport 设计思想"></a>LockSupport 设计思想</h2><p>LockSupport的设计思路就是为<strong>每一个线程</strong>设置一个许可，其实就是一个值，AQS中讲解的是state这个值。</p><p>LockSupport实现思路也类似，**设置一个许可(permit)**，这个permit就相当于一个开关，0代表关闭，1代表打开。默认是0的状态。调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累，也就是说你可以重复调用多次unpark方法这个值也一直是1，而不会因为多次调用而累加，调用一次park后这个值就会变成0，线程就会被阻塞。你也可以先调用unpark方法，将值先设置为1，然后再调用park方法，调用park方法时这个permit已经时1了那么就会立即返回，不会阻塞线程，并且将permit设置为0.这就是说与Thread.suspend()和resume()由于先后顺序而产生的死锁的区别。</p><h2 id="LockSupport-方法概要"><a href="#LockSupport-方法概要" class="headerlink" title="LockSupport 方法概要"></a>LockSupport 方法概要</h2><table><thead><tr><th>methed</th><th>description</th></tr></thead><tbody><tr><td>park()</td><td>在许可可用之前阻塞当前线程。</td></tr><tr><td>park(0bject blocker)</td><td>“在许可可用之前禁用当前线程,并指定阻塞对象。”</td></tr><tr><td>parkNanos (long nanos)</td><td>“阻塞当前线程,最长不超过nanos纳秒。parkNanos (Object blocker, long nanos),为了线程调度禁用当前线程,最多等待指定的等待时间,除非许可可用,同时指定阻塞对象。”</td></tr><tr><td>parkUntil(long deadline)</td><td>“阻塞当前线程直到deadline时间(绝对时间)。”</td></tr><tr><td>“parkUntil(Object blocker, long deadline)”</td><td>“阻塞当前线程直到deadline时间,同时阻塞前记录当前线程等待对象的操作。”</td></tr><tr><td>unpark(Thread thread)</td><td>“唤醒处于阻塞状态的线程Thread.”</td></tr><tr><td>getBlocker(Thread t)</td><td>“获取阻塞线程的Blocker对象。”</td></tr></tbody></table><h2 id="LockSupport的用途"><a href="#LockSupport的用途" class="headerlink" title="LockSupport的用途"></a>LockSupport的用途</h2><h3 id="LockSupport的主要方法"><a href="#LockSupport的主要方法" class="headerlink" title="LockSupport的主要方法"></a>LockSupport的主要方法</h3><p>接下面我来看看LockSupport有哪些常用的方法。主要有两类方法：park（阻塞线程）和unpark（解除阻塞）。</p><pre><code class="line-numbers language-java">public static void park(Object blocker); // 暂停当前线程public static void parkNanos(Object blocker, long nanos); // 暂停当前线程，不过有超时时间的限制public static void parkUntil(Object blocker, long deadline); // 暂停当前线程，直到某个时间public static void park(); // 无期限暂停当前线程public static void parkNanos(long nanos); // 暂停当前线程，不过有超时时间的限制public static void parkUntil(long deadline); // 暂停当前线程，直到某个时间public static void unpark(Thread thread); // 恢复当前线程public static Object getBlocker(Thread t); // 获取线程的Blocker对象</code></pre><p>为什么叫park呢，park英文意思为停车。我们如果把Thread看成一辆车的话，park就是让车停下，unpark就是让车启动然后跑起来。</p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>我们写一个例子来看看这个工具类怎么用的。</p><pre><code class="line-numbers language-java">public class LockSupportDemo {    public static Object u = new Object();    static ChangeObjectThread t1 = new ChangeObjectThread("t1");    static ChangeObjectThread t2 = new ChangeObjectThread("t2");    public static class ChangeObjectThread extends Thread {        public ChangeObjectThread(String name) {            super(name);        }        @Override public void run() {            synchronized (u) {                System.out.println("in " + getName());                LockSupport.park();                if (Thread.currentThread().isInterrupted()) {                    System.out.println("被中断了");                }                System.out.println("继续执行");            }        }    }    public static void main(String[] args) throws InterruptedException {        t1.start();        Thread.sleep(1000L);        t2.start();        Thread.sleep(3000L);        t1.interrupt();        LockSupport.unpark(t2);        t1.join();        t2.join();    }}</code></pre><p>运行的结果如下：</p><p>这儿park和unpark其实实现了wait和notify的功能，不过还是有一些差别的。</p><ol><li>park不需要获取某个对象的锁。</li><li>因为中断的时候park不会抛出InterruptedException异常，所以需要在park之后自行判断中断状态，然后做额外的处理。</li></ol><p>我们再来看看Object blocker对象，这是个什么东西呢？这其实就是方便在线程dump的时候看到具体的阻塞对象的信息。</p><pre><code class="line-numbers language-java">"t1" #10 prio=5 os_prio=31 tid=0x00007f95030cc800 nid=0x4e03 waiting on condition [0x00007000011c9000]   java.lang.Thread.State: WAITING (parking)    at sun.misc.Unsafe.park(Native Method)    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)    // `下面的这个信息`    at com.wtuoblist.beyond.concurrent.demo.chapter3.LockSupportDemo$ChangeObjectThread.run(LockSupportDemo.java:23) //     - locked &lt;0x0000000795830950&gt; (a java.lang.Object)</code></pre><p> blocker对象通过LockSupport.getBlocker方法获得。blocker对象只有在线程阻塞的时候才会被赋值，blocker对象是Thread线程类中的成员属性。</p><p>还有一个地方需要注意，相对于线程的stop和resume，park和unpark的先后顺序并不是那么严格。stop和resume如果顺序反了，会出现死锁现象。而park和unpark却不会。这又是为什么呢？还是看一个例子</p><pre><code class="line-numbers language-java">public class LockSupportDemo {    public static Object u = new Object();    static ChangeObjectThread t1 = new ChangeObjectThread("t1");    public static class ChangeObjectThread extends Thread {        public ChangeObjectThread(String name) {            super(name);        }        @Override public void run() {            synchronized (u) {                System.out.println("in " + getName());                try {                    Thread.sleep(1000L);                } catch (InterruptedException e) {                    e.printStackTrace();                }                LockSupport.park();                if (Thread.currentThread().isInterrupted()) {                    System.out.println("被中断了");                }                System.out.println("继续执行");            }        }    }    public static void main(String[] args) {        t1.start();        LockSupport.unpark(t1);        System.out.println("unpark invoked");    }}</code></pre><p>t1内部有休眠1s的操作，所以unpark肯定先于park的调用，但是t1最终仍然可以完结。这是因为park和unpark会对每个线程维持一个许可（boolean值）</p><ol><li>unpark调用时，如果当前线程还未进入park，则许可为true，并且不会去执行unpark。</li><li>park调用时，判断许可是否为true，如果是true，则继续往下执行；如果是false，则等待，直到许可为true。</li></ol><p>意思就是如果新执行unpark，如果发现当前线程还没有执行park呢，那么unpark就会停在那等待，等到真的去执行了park之后，才会继续向下执行unpark。这个功能是通过两个方法共同维护的一个boolean类型的许可变量实现的。</p><p><img src="/attachment/f98573fb46c159f53b683df975a17386.png"></p><p><img src="/attachment/ed3bc92b2d3f9a72a5de4f79a4d38e05.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>park和unpark可以实现类似wait和notify的功能，但是并不和wait和notify交叉，也就是说unpark不会对wait起作用，notify也不会对park起作用。</li><li>park和unpark的使用不会出现死锁的情况.</li><li>blocker的作用是在dump线程的时候看到阻塞对象的信息。</li></ol><h2 id="LockSupport-源码分析-前置知识"><a href="#LockSupport-源码分析-前置知识" class="headerlink" title="LockSupport 源码分析 前置知识"></a>LockSupport 源码分析 前置知识</h2><h3 id="Unsafe-park-和Unsafe-unpark"><a href="#Unsafe-park-和Unsafe-unpark" class="headerlink" title="Unsafe.park()和Unsafe.unpark()"></a>Unsafe.park()和Unsafe.unpark()</h3><p>在分析 LockSupport函数之前，先引入 sun.misc.Unsafe类中的 park和 unpark函数，因为 LockSupport的核心函数都是基于Unsafe类中定义的 park和 unpark函数，下面给出两个函数的定义：</p><pre><code class="line-numbers language-java">public native void park(boolean isAbsolute, long time);public native void unpark(Thread thread);</code></pre><p>对两个函数的说明如下：</p><p>Unsafe.park函数：阻塞线程，并且该线程在下列情况发生之前都会被阻塞：</p><ol><li>调用 unpark函数，释放该线程的许可之前。</li><li>该线程被中断之前。</li><li>设置的时间到之前。并且，当 time为绝对时间时，isAbsolute为 true，否则，isAbsolute为 false。当time为0时，表示无限等待，直到 unpark发生。</li></ol><p>Unsafe.unpark函数：释放线程的许可，激活调用 park后阻塞的线程。该函数不是安全的，调用该函数时要确保线程依旧存活。</p><h3 id="wait和notify-x2F-notifyAll"><a href="#wait和notify-x2F-notifyAll" class="headerlink" title="wait和notify/notifyAll"></a>wait和notify/notifyAll</h3><p>在看park()和unpark()之前，不妨来看下在没有LockSupport之前，是怎么实现让线程等待/唤醒的。</p><p>在没有LockSupport之前，线程的挂起和唤醒都是通过Object的wait和notify/notifyAll方法实现。</p><p>写一段例子代码，线程A执行一段业务逻辑后调用wait阻塞住自己。主线程调用notify方法唤醒线程A，线程A然后打印自己执行的结果。</p><pre><code class="line-numbers language-java">public static void main(String[] args) throws Exception {    final Object obj = new Object();    Thread A = new Thread(() -&gt; {        int sum = 0;        for (int i = 0; i &lt; 10; i++) {            sum += i;        }        try {            obj.wait();        } catch (Exception e) {            e.printStackTrace();        }        System.out.println(sum);    });    A.start();    //睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法    Thread.sleep(1000);    obj.notify();}</code></pre><p>执行这段代码，不难发现这个错误：</p><p>原因很简单，wait和notify/notifyAll方法只能在同步代码块里用(这个有的面试官也会考察)。所以将代码修改为如下就可正常运行了：</p><pre><code class="line-numbers language-java">public static void main(String[] args) throws Exception {    final Object obj = new Object();    Thread A = new Thread(() -&gt; {        int sum = 0;        for (int i = 0; i &lt; 10; i++) {            sum += i;        }        try {            synchronized (obj) {                obj.wait();            }        } catch (Exception e) {            e.printStackTrace();        }        System.out.println(sum);    });    A.start();    // 睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法    Thread.sleep(1000);    synchronized (obj) {        obj.notify();    }}</code></pre><p>那如果咱们换成LockSupport呢？简单得很，看代码：</p><pre><code class="line-numbers language-java">public static void main(String[] args) throws Exception {    Thread A = new Thread(() -&gt; {        int sum = 0;        for (int i = 0; i &lt; 10; i++) {            sum += i;        }        LockSupport.park();        System.out.println(sum);    });    A.start();    // 睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法    Thread.sleep(1000);    LockSupport.unpark(A);}</code></pre><h3 id="LockSupport灵活性"><a href="#LockSupport灵活性" class="headerlink" title="LockSupport灵活性"></a>LockSupport灵活性</h3><p>通过上面的例子，我们就能明白LockSupport类就是为了提供与wait和notify/notifyAll方法相同的功能，并且使用起来更加简单方便而创造的工具类。</p><p>如果只是LockSupport在使用起来比Object的wait/notify简单，那还真没必要专门讲解下LockSupport。最主要的是灵活性。</p><p>上边的例子代码中，主线程调用了Thread.sleep(1000)方法来等待线程A计算完成进入wait状态。如果去掉Thread.sleep()调用：</p><pre><code class="line-numbers language-java">public static void main(String[] args) throws Exception {    final Object obj = new Object();    Thread A = new Thread(() -&gt; {        int sum = 0;        for (int i = 0; i &lt; 10; i++) {            sum += i;        }        try {            synchronized (obj) {                obj.wait();            }        } catch (Exception e) {            e.printStackTrace();        }        System.out.println(sum);    });    A.start();    // 睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法    //Thread.sleep(1000);    synchronized (obj) {        obj.notify();    }}</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>小结一下，LockSupport比Object的wait/notify有两大优势：</p><ol><li>LockSupport不需要在同步代码块里 。所以线程间也不需要维护一个共享的同步对象了，实现了线程间的解耦。</li><li>unpark函数可以先于park调用，所以不需要担心线程间的执行的先后顺序。</li></ol><h2 id="LockSupport-源码分析"><a href="#LockSupport-源码分析" class="headerlink" title="LockSupport 源码分析"></a>LockSupport 源码分析</h2><h3 id="LockSupport中的主要成员及其加载时的初始化"><a href="#LockSupport中的主要成员及其加载时的初始化" class="headerlink" title="LockSupport中的主要成员及其加载时的初始化"></a>LockSupport中的主要成员及其加载时的初始化</h3><pre><code class="line-numbers language-java">public class LockSupport {    // Hotspot implementation via intrinsics API    // UNSAFE字段表示 sun.misc.Unsafe类    // 一般程序中不允许直接调用    private static final sun.misc.Unsafe UNSAFE;    // 而 long型的表示Thread实例对象相应字段在内存中的偏移地址，可以通过该偏移地址获取或者设置该字段的值。    // 表示Thread类中的parkBlocker对象的内存偏移地址    private static final long parkBlockerOffset;    // 表示Thread类中的threadLocalRandomSeed对象的内存偏移地址    private static final long SEED;    // 表示Thread类中的threadLocalRandomProbe对象的内存偏移地址    private static final long PROBE;    // 表示Thread类中的threadLocalRandomSecondarySeed对象的内存偏移地址    private static final long SECONDARY;    // 静态代码块，会在加载时自动执行    static {        try {            // 获取Unsafe实例            UNSAFE = sun.misc.Unsafe.getUnsafe();            // 线程类类型            Class&lt;?&gt; tk = Thread.class;            // 获取Thread的parkBlocker字段的内存偏移地址            parkBlockerOffset = UNSAFE.objectFieldOffset                (tk.getDeclaredField("parkBlocker"));            // 获取Thread的threadLocalRandomSeed字段的内存偏移地址            SEED = UNSAFE.objectFieldOffset                (tk.getDeclaredField("threadLocalRandomSeed"));            // 获取Thread的threadLocalRandomProbe字段的内存偏移地址            PROBE = UNSAFE.objectFieldOffset                (tk.getDeclaredField("threadLocalRandomProbe"));            // 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址            SECONDARY = UNSAFE.objectFieldOffset                (tk.getDeclaredField("threadLocalRandomSecondarySeed"));        } catch (Exception ex) { throw new Error(ex); }    }}</code></pre><p>下面讲一下这几个成员属性。</p><h4 id="parkBlockerOffset"><a href="#parkBlockerOffset" class="headerlink" title="parkBlockerOffset"></a>parkBlockerOffset</h4><p>表示Thread类中的parkBlocker对象的内存偏移地址，提供给setBlocker和getBlocker使用。</p><pre><code class="line-numbers language-java">private static void setBlocker(Thread t, Object arg) {    // Even though volatile, hotspot doesn't need a write barrier here.    UNSAFE.putObject(t, parkBlockerOffset, arg);} public static Object getBlocker(Thread t) {    if (t == null)        throw new NullPointerException();    return UNSAFE.getObjectVolatile(t, parkBlockerOffset);}</code></pre><p>上面方法中的参数t是Thread线程对象，parkBlocker对象就是Thread类的成员属性</p><pre><code class="line-numbers language-java">// Thread类的成员属性volatile Object parkBlocker;</code></pre><p>上面的setBlocker和getBlocker方法，就是利用偏移地址parkBlockerOffset操作Thread对象中的parkBlocker。</p><p>由于Unsafe.putObject是无视Java访问限制，直接修改目标内存地址的值。即使对象被volatile修饰，也是不需要写屏障的。</p><p><strong>这边的偏移量就算Thread这个类里面变量parkBlocker在内存中的偏移量:</strong></p><p>JVM的实现可以自由选择如何实现Java对象的“布局“，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p><p><strong>为什么要用偏移量来获取对象？干吗不要直接写个get、set方法?</strong></p><p>parkBlocker就是在线程处于阻塞的情况下才被赋值。线程都已经被阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p><h4 id="SEED-PROBE-SECONDARY"><a href="#SEED-PROBE-SECONDARY" class="headerlink" title="SEED, PROBE, SECONDARY"></a>SEED, PROBE, SECONDARY</h4><p>LockSupport中的这三个成员属性，就是下面这三个Thread类中的成员属性相对应Thread对象的偏移地址。</p><pre><code class="line-numbers language-java">@sun.misc.Contended("tlr")long threadLocalRandomSeed;/** Probe hash value; nonzero if threadLocalRandomSeed initialized */@sun.misc.Contended("tlr")int threadLocalRandomProbe;/** Secondary seed isolated from public ThreadLocalRandom sequence */@sun.misc.Contended("tlr")int threadLocalRandomSecondarySeed;</code></pre><p>都是Thread类中的内存偏移地址，主要用于ThreadLocalRandom类进行随机数生成，它要比Random性能好很多，可以看jdk源码ThreadLocalRandom.java了解详情，这儿就不贴了。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>LockSupport 只有一个私有构造函数，无法被实例化。</p><pre><code class="line-numbers language-java">// 私有构造函数，无法被实例化private LockSupport() {}</code></pre><p>因为LockSupport中定义的都是static静态方法，所以在使用LockSupport时并不需要实例化出一个对象，直接调用类的静态方法即可。</p><p>下面我们分析一下LockSupport最常用的几个方法的源码。</p><h3 id="park方法"><a href="#park方法" class="headerlink" title="park方法"></a>park方法</h3><p>park 函数有两个重载版本，方法摘要如下：</p><pre><code class="line-numbers language-java">public static void park();public static void park(Object blocker);</code></pre><p>两个函数的区别在于 park()函数有没有 blocker，即没有设置线程的 parkBlocker字段。</p><h4 id="park-Object-型函数"><a href="#park-Object-型函数" class="headerlink" title="park(Object)型函数"></a>park(Object)型函数</h4><p>park(Object)型函数如下：</p><pre><code class="line-numbers language-java">public static void park(Object blocker) {    // 获取当前线程    Thread t = Thread.currentThread();    // 设置Blocker    setBlocker(t, blocker);    // 获取许可    UNSAFE.park(false, 0L);    // 重新可运行后再此设置Blocker    setBlocker(t, null);}</code></pre><p>调用 park函数时，首先获取当前线程，然后设置当前线程的 parkBlocker字段，即调用 setBlocker函数，之后调用 Unsafe类的park函数，之后再调用 setBlocker函数。那么问题来了，为什么要在此 park函数中调用两次 setBlocker函数呢? </p><p>原因其实很简单，调用 park函数时，当前线程<strong>首先设置好 parkBlocker字段</strong>，然后再调用 Unsafe的 park函数，此后，当前线程就已经阻塞了，等待该线程的 unpark函数被调用，所以后面的一个 setBlocker函数无法运行，unpark函数被调用，该线程获得许可后，就可以继续运行了，也就运行第二个 setBlocker，把该线程的 parkBlocker字段设置为null，这样就完成了整个 park函数的逻辑。如果没有第二个 setBlocker，那么之后没有调用 park(Object blocker)，而直接调用 getBlocker函数，得到的还是前一个 park(Object blocker)设置的 blocker，显然是不符合逻辑的。总之，必须要保证在 park(Object blocker)整个函数执行完后，该线程的parkBlocker字段又恢复为 null。所以，park(Object)型函数里必须要调用 setBlocker函数两次。</p><p>setBlocker方法如下：此方法用于设置线程t 的 parkBlocker字段的值为 arg。</p><pre><code class="line-numbers language-java">private static void setBlocker(Thread t, Object arg) {    // 设置线程t的parkBlocker字段的值为arg    UNSAFE.putObject(t, parkBlockerOffset, arg);}</code></pre><h4 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h4><p>另外一个无参重载版本，park()函数如下。</p><pre><code class="line-numbers language-java">public static void park() {    // 获取许可，设置时间为无限长，直到可以获取许可    UNSAFE.park(false, 0L);}</code></pre><p>调用了park函数后，会禁用当前线程，除非许可可用。在以下三种情况之一发生之前，当前线程都将处于休眠状态，即下列情况发生时，当前线程会获取许可，可以继续运行。</p><ul><li>其他某个线程将当前线程作为目标调用 unpark；</li><li>其他某个线程中断当前线程；</li><li>该调用不合逻辑地(即毫无理由地)返回；</li></ul><h4 id="两个重载方法对比"><a href="#两个重载方法对比" class="headerlink" title="两个重载方法对比"></a>两个重载方法对比</h4><p>LockSupport 类的 park() 方法有两个重载版本：</p><ul><li>park()：使当前线程进入等待状态，直到被其他线程调用 unpark(Thread thread) 方法唤醒，或者被中断。</li><li>park(Object blocker)：使当前线程进入等待状态，并将 blocker 对象传递给底层的线程调度器，用于监视和诊断工具。<br>这两个版本的区别在于第二个版本的 park(Object blocker) 可以提供额外的信息，用于线程监视和诊断。当线程进入等待状态时，可以通过监视和诊断工具查看线程的状态，并了解线程被阻塞的原因。</li></ul><p>在第二个版本的 park(Object blocker) 中，blocker 对象可以是任何对象，用于标识线程被阻塞的原因。这个对象在<strong>监视和诊断工具</strong>中可以被用来识别线程的阻塞点。如果不需要额外的监视和诊断信息，可以使用第一个版本的 park</p><h3 id="parkNanos-方法"><a href="#parkNanos-方法" class="headerlink" title="parkNanos 方法"></a>parkNanos 方法</h3><p>此函数表示在许可可用前禁用当前线程，并最多等待指定的等待时间。具体函数如下。该函数也是调用了两次 setBlocker函数，nanos参数表示相对时间，表示等待多长时间。</p><pre><code class="line-numbers language-java">    public static void parkNanos(Object blocker, long nanos) {        if (nanos &gt; 0) {            Thread t = Thread.currentThread();            setBlocker(t, blocker);            UNSAFE.park(false, nanos);            setBlocker(t, null);        }    }</code></pre><h3 id="parkUntil-方法"><a href="#parkUntil-方法" class="headerlink" title="parkUntil 方法"></a>parkUntil 方法</h3><p>此函数表示在指定的时限前禁用当前线程，除非许可可用，具体函数如下：该函数也调用了两次 setBlocker函数，deadline参数表示绝对时间，表示指定的时间。</p><pre><code class="line-numbers language-java">public static void parkUntil(Object blocker, long deadline) {    // 获取当前线程    Thread t = Thread.currentThread();    // 设置Blocker    setBlocker(t, blocker);    UNSAFE.park(true, deadline);    // 设置Blocker为null    setBlocker(t, null);}</code></pre><h3 id="unpark-方法"><a href="#unpark-方法" class="headerlink" title="unpark 方法"></a>unpark 方法</h3><p>此函数表示如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果。具体函数如下：释放许可，指定线程可以继续运行。</p><pre><code class="line-numbers language-java">    public static void unpark(Thread thread) {        if (thread != null)            UNSAFE.unpark(thread);    }</code></pre><h3 id="LockSupport原理总结"><a href="#LockSupport原理总结" class="headerlink" title="LockSupport原理总结"></a>LockSupport原理总结</h3><p>通过学习上面几个方法的源码，我们就发现LockSupport的底层实现都是基于Unsafe.park()和Unsafe.unpark()。</p><p>Unsafe源码也相对简单，看下就行了：</p><pre><code class="line-numbers language-c++">voidsun::misc::Unsafe::unpark (::java::lang::Thread *thread){  natThread *nt = (natThread *) thread-&gt;data;  nt-&gt;park_helper.unpark();} voidsun::misc::Unsafe::park (jboolean isAbsolute, jlong time){  using namespace ::java::lang;  Thread *thread = Thread::currentThread();  natThread *nt = (natThread *) thread-&gt;data;  nt-&gt;park_helper.park(isAbsolute, time);}</code></pre><p>总之使用park和unpark进行线程的阻塞和唤醒操作，LockSuport.park和LockSuport.unpark是基于Unsafe类中的park()和unpark()方法来实现的，而再往底层看，Unsafe又是借助系统层（C语言）方法pthread_cond_wait和pthread_cond_signal来操作pthread_u和pthread_cond实现的，通过pthread_cond_wait函数可以对一个线程进行阻塞操作，在这之前，必须先获取pthread_mutex，通过pthread_cond_signal函数对一个线程进行唤醒操作。</p><p>pthread_mutex和pthread_cond使用示例如下：</p><pre><code class="line-numbers language-java">void *r1(void *arg){    pthread_mutex_t* mutex = (pthread_mutex_t *)arg;    static int cnt = 10;    while(cnt--)    {        printf("r1: I am wait.\n");        pthread_mutex_lock(mutex);        /* mutex参数用来保护条件变量的互斥锁，调用pthread_cond_wait前mutex必须加锁 */        pthread_cond_wait(&amp;cond, mutex);         pthread_mutex_unlock(mutex);    }    return "r1 over";} void *r2(void *arg){    pthread_mutex_t* mutex = (pthread_mutex_t *)arg;    static int cnt = 10;    while(cnt--)    {        pthread_mutex_lock(mutex);        printf("r2: I am send the cond signal.\n");        pthread_cond_signal(&amp;cond);        pthread_mutex_unlock(mutex);        sleep(1);    }    return "r2 over";}</code></pre><p>注意，Linux下使用pthread_cond_signal的时候，会产生“惊群”问题的，但是Java中是不会存在这个“惊群”问题的，那么Java是如何处理的呢？</p><p>实际上，Java只会对一个线程调用pthread_cond_signal操作，这样肯定只会唤醒一个线程，也就不存在所谓的惊群问题。Java在语言层面实现了自己的线程管理机制（阻塞、唤醒、排队等），每个Thread实例都有一个独立的pthread_u和pthread_cond（系统层面的/C语言层面），在Java语言层面上对单个线程进行独立唤醒操作。（Java中线程只能在Java线程库的指挥下作战，无法直接获取同一个pthread_mutex或者pthread_cond。Java这种实现线程机制的实现实在太巧妙了，虽然底层都是使用pthread_mutex和pthread_cond这些方法，但是貌似C/C++还没这么强大易用的线程库）</p><p>具体LockSuuport.park和LockSuuport.unpark的底层实现可以参考对应JDK源码，下面看一下gdb打印处于LockSuuport.park时的线程状态信息：</p><p><img src="/attachment/1da3eb470b43997a3d1c20a41e79a161.png"></p><p>由上图可知底层确实是基于pthread_cond函数来实现的。</p><p>我们在使用LockSupport过程中，多次调用unpark方法和调用一次unpark方法效果一样，因为都是直接将_counter赋值为1，而不是加1。简单说就是：线程A连续调用两次LockSupport.unpark(B)方法唤醒线程B，然后线程B调用两次LockSupport.park()方法， 线程B依旧会被阻塞。因为两次unpark调用效果跟一次调用一样，只能让线程B的第一次调用park方法不被阻塞，第二次调用依旧会阻塞。</p><h2 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h2><pre><code class="line-numbers language-java">import java.util.concurrent.locks.LockSupport;class MyThread extends Thread {    private Object object;    public MyThread(Object object) {        this.object = object;    }    public void run() {        System.out.println("before interrupt");        try {            // 休眠3s  为了让主线程先执行park()            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        Thread thread = (Thread) object;        // 3、执行完park之后，执行中断线程        thread.interrupt();        System.out.println("after interrupt");    }}public class InterruptDemo {    public static void main(String[] args) {        MyThread myThread = new MyThread(Thread.currentThread());        // 1、执行线程        myThread.start();        System.out.println("before park");        // 2、执行park,获取许可        LockSupport.park("ParkAndUnparkDemo");        // 4、线程被成功唤醒了        System.out.println("after park");    }}</code></pre><p>运行结果：</p><pre><code class="line-numbers language-java">before parkbefore interruptafter interruptafter park</code></pre><p>可以看到，在主线程调用 park阻塞后，在 myThread线程中发出了中断信号，此时主线程会继续运行，也就是说明此时 interrupt起到的作用与 unpark一样。</p><p>总之，线程使用LockSupport.park方法被阻塞后，然后被interrupt()方法唤醒之后，该线程就再也不会被 LockSupport.park方法阻塞了，会被直接唤醒。但是被interrupt()方法唤醒之后，该线程仍然可以再次被LockSupport.park方法阻塞。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>native层的JavaThread通过Parker的<mark style="background: #FF5582A6;">_counter</mark>来表示通行证，&gt;0表示可以通行，如果_counter=0，调用park线程会等待，直到被unpark唤醒，如果先调用unpack，再调用park会直接返回，并消费掉_counter（设置为0）。</li><li>Linux平台，线程等待和唤醒，加锁用的pthread_mutex_lock，解锁是pthread_mutex_unlock，唤醒是pthread_cond_signal，了解到这些心里就有数了，知其然知其所以然，何其快哉！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 锁</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-suo/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-锁"><a href="#【Java-多线程并发】-锁" class="headerlink" title="【Java 多线程并发】 锁"></a>【Java 多线程并发】 锁</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 锁date: 2023-07-03 15:36tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 锁</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>相关结论</strong></p><ul><li>对于普通同步方法，锁的是当前实例对象，通常指this，所有的同步方法用的都是同一把锁—&gt;实例对象本身</li><li>对于静态同步方法，锁的是当前类的Class对象</li><li>对于同步方法块，锁的是synchronized括号内的对象</li></ul><p><strong>悲观锁</strong></p><p>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改</p><p><strong>乐观锁</strong></p><p>认为自己在使用数据的时候不会有别的线程修改数据或资源，不会添加锁，Java中使用无锁编程来实现，只是在更新的时候去判断，之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果已经被其他线程更新，则根据不同的实现方式执行不同的操作</p><p><strong>公平锁</strong></p><p>多个线程按照申请锁的顺序来获取锁</p><p><strong>非公平锁</strong></p><p>多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁<br>有可能造成优先级反转或者饥饿的状态</p><p><strong>可重入锁（递归锁）</strong></p><p>在同一线程在外层方法获取到锁的时侯，在进入该线程的内层方法会自动获取锁</p><p><strong>写锁（独占锁）</strong></p><p>该锁一次只能被一个线程所持有。</p><p><strong>读锁（共享锁）</strong></p><p>该锁可被多个线程所持有。</p><p><strong>分段锁</strong></p><p>内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock</p><p><strong>自旋锁</strong></p><p>指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</p><p><strong>可中断锁</strong></p><p>阻塞等待中断</p><h2 id="锁的相关结论"><a href="#锁的相关结论" class="headerlink" title="锁的相关结论"></a>锁的相关结论</h2><ul><li>对于普通同步方法，锁的是当前实例对象，通常指this，所有的同步方法用的都是同一把锁—&gt;实例对象本身</li><li>对于静态同步方法，锁的是当前类的Class对象</li><li>对于同步方法块，锁的是synchronized括号内的对象</li></ul><h2 id="类锁和对象锁的区别"><a href="#类锁和对象锁的区别" class="headerlink" title="类锁和对象锁的区别"></a>类锁和对象锁的区别</h2><ul><li>对象锁是当前对象实例的锁，只有是同一个对象才会涉及是否做同步</li><li>类锁故名思议就是这个class的锁，只要是同类，即使不同的对象也必须同步</li></ul><p>当synchronized(Person.class)时会发现，即使是不同的两个person对象也会按照顺序来同步执行。它会保证只要是Person类的实例对象，那么在同一时间只有一个线程对其访问，其他线程只能等待该线程操作完将锁释放后才能进行操作。即相同类的不同的实例共用一个锁，当一个线程执行完后才能执行另一个线程。这里线程0是操作的p1对象，线程1操作的是p2对象，p1和p2都是Person类的两个不同对象，但是因为这里synchronized获取的是类锁，也就是说只要是这个Person类的对象，同一时间就只能有一个线程对其进行操作，所以虽然两个线程操作的是不同的Person对象，但是还是会对两个线程进行同步操作。</p><p>当synchronized(o1)的时候会发现只有同一个person对象才会同步，不同的person对象不会发生同步的行为。它只会保证同一个Person类的实例对象在同一时间只能有一个线程对其进行访问，但是如果是Person类的不同对象，是不会进行同步操作的。即不同对象对应不同的锁。这里线程0是操作的p1对象，线程1操作的是p2对象，p1和p2都是Person类的两个不同对象，synchronized获取的是对象锁，也就是说只有相同的Person类对象才会进行同步操作，不同的对象各自是独立的，不会进行同步操作，所以两个线程可以同时对各自的p1,p2对象进行操作，互不冲突。</p><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，<mark style="background: #FFB8EBA6;">synchronized</mark>和<mark style="background: #FFB8EBA6;">Lock</mark>的实现类都是悲观锁，适合写操作多的场景，先加锁可以保证写操作时数据正确，显示的锁定之后再操作同步资源—–狼性锁</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>认为自己在使用数据的时候不会有别的线程修改数据或资源，不会添加锁，Java中使用无锁编程来实现，只是在更新的时候去判断，之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果已经被其他线程更新，则根据不同的实现方式执行不同的操作，比如：放弃修改、重试抢锁等等。判断规则有：版本号机制Version，最常采用的是<mark style="background: #FFB8EBA6;">CAS算法</mark>，Java原子类中的递增操作就通过CAS自旋实现的。—–适合读操作多的场景，不加锁的特性能够使其读操作的性能大幅提升，乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命—佛系锁</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>是指多个线程按照申请锁的顺序来获取锁，这里类似于排队买票，先来的人先买，后来的人再队尾排着，这是公平的—– Lock lock = new ReentrantLock(true)—表示公平锁，先来先得。</p><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>是指多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）—- Lock lock = new  ReentrantLock(false)—表示非公平锁，后来的也可能先获得锁，默认为非公平锁。</p><h2 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h2><h3 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h3><p>是指在同一线程在外层方法获取到锁的时侯，在进入该线程的内层方法会自动获取锁（前提，锁对象的是同一个对象），不会因为之前已经获取过还没释放而阻塞———优点之一就是可一定程度避免死锁。</p><h3 id="可重入锁种类"><a href="#可重入锁种类" class="headerlink" title="可重入锁种类"></a>可重入锁种类</h3><ul><li>隐式锁（即synchronized关键字使用的锁），默认是可重入锁<ul><li>在一个synchronized修饰的方法或者代码块的内部调用本类的其他synchronized修饰的方法或者代码块时，是永远可以得到锁。</li></ul></li><li>显式锁（即Lock）也有ReentrantLock这样的可重入锁</li></ul><h2 id="写锁（独占锁）-x2F-读锁（共享锁）"><a href="#写锁（独占锁）-x2F-读锁（共享锁）" class="headerlink" title="写锁（独占锁）/读锁（共享锁）"></a>写锁（独占锁）/读锁（共享锁）</h2><p>独享锁是指该锁一次只能被一个线程所持有。<br>共享锁是指该锁可被多个线程所持有。</p><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><ul><li>互斥锁在Java中的具体实现就是ReentrantLock</li><li>读写锁在Java中的具体实现就是ReadWriteLock</li><li>Synchronized也是互斥锁</li></ul><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。</p><p>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</p><p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2 id="自旋锁-x2F-可中断锁"><a href="#自旋锁-x2F-可中断锁" class="headerlink" title="自旋锁/可中断锁"></a>自旋锁/可中断锁</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁（即当循环的条件被其他线程改变时 才能进入临界区），这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><h3 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h3><p>synchronized 是不可中断的，Lock 是可中断的，这里的可中断建立在阻塞等待中断，运行中是无法中断的。</p><h2 id="无锁-gt-偏向锁-gt-轻量锁-gt-重量锁"><a href="#无锁-gt-偏向锁-gt-轻量锁-gt-重量锁" class="headerlink" title="无锁->偏向锁->轻量锁->重量锁"></a>无锁-&gt;偏向锁-&gt;轻量锁-&gt;重量锁</h2><p>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。锁是在资源中的，是要访问资源（如对象实例，Class类实例，属性变量，代码块等）的一部分，线程是要取得资源中的锁。</p><ul><li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li><li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li><li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li></ul><h2 id="死锁及排查"><a href="#死锁及排查" class="headerlink" title="死锁及排查"></a>死锁及排查</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>死锁是指两个或两个以上的线程在执行过程中，因抢夺资源而造成的一种互相等待的现象，若无外力干涉，则它们无法再继续推进下去。<br>产生原因：</p><ul><li>系统资源不足</li><li>进程运行推进顺序不合适</li><li>系统资源分配不当</li></ul><p><img src="/attachment/171bb8f6d6274bd5fe74d778a3f10000.png"></p><h3 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h3><ul><li>纯命令<ul><li>jps -l</li><li>jstack 进程编号</li></ul></li><li>图形化<ul><li>jconsole</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 volatile</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-volatile/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-volatile"><a href="#【Java-多线程并发】-volatile" class="headerlink" title="【Java 多线程并发】 volatile"></a>【Java 多线程并发】 volatile</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 volatiledate: 2023-07-03 14:46tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 volatile</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>volatile的原理</strong></p><p>抽象上是 Load 屏障 和 Store 屏障</p><p>volatile实现是靠lock指令（汇编语言的LOCK指令） + 缓存一致性协议<br>JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存</p><ul><li>可见性<ul><li>JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</li><li>每个处理会通过嗅探在总线上传播的数据来检查自己的缓存是否过期</li></ul></li><li>有序性<ul><li>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏）</li><li>执行到内存屏障这句指令时，在它前面的操作已经全部完成。</li></ul></li></ul><p><strong>lock 指令</strong></p><p>lock指令的几个作用</p><ol><li>锁总线</li><li>lock后的写操作会向主内存中回写已修改的数据，同时让其它CPU相关缓存行（Cache Line）失效，从而重新从主存中加载最新的数据</li><li>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两边的指令重排序。</li></ol><p><strong>缓存一致性协议 MESI协议</strong></p><p>只有当缓存行处于E或者M状态时，处理器才能去写它</p><p><img src="/attachment/f11fb769b8aa060cd06c13d4ced9bcd8.png"></p><ul><li>读操作：不做任何事情，把Cache中的数据读到寄存器</li><li>写操作：发出信号通知其他的CPU<mark style="background: #FFB8EBA6;">将该变量的Cache line置为无效</mark>，其他的CPU要访问这个变量的时候，只能从主内存中获取。</li></ul><p><strong>内存屏障(Memory Barrier)</strong></p><ul><li>在每个volatile写操作<strong>前</strong>插入StoreStore屏障，在写操作<strong>后</strong>插入StoreLoad屏障；</li><li>在每个volatile读操作<strong>后</strong>插入LoadLoad屏障，在读操作<strong>后</strong>插入LoadStore屏障；</li></ul><p><strong>volatile特性</strong></p><ul><li>保证可见性</li><li>保证有序性</li><li>volatile不能保证原子性</li></ul><p><strong>适用条件</strong><br>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。<br>2.该变量没有包含在具有其他变量的不变式中</p><p><strong>相关场景</strong></p><ul><li>状态标记量（开关模式）</li><li>一次性安全发布.双重检查锁定问题</li></ul><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="可见性问题："><a href="#可见性问题：" class="headerlink" title="可见性问题："></a>可见性问题：</h3><pre><code class="line-numbers language-java">public class ReaderAndUpdater {    final static int MAX=5;    static int init_value=0;    public static void main(String[] args) {        new Thread(()-&gt;{            int localValue=init_value;            while(localValue&lt;MAX){                if(localValue!=init_value){                    System.out.println("Reader:"+init_value);                    localValue=init_value;                }            }        },"Reader").start();         new Thread(()-&gt;{            int localValue=init_value;            while(localValue&lt;MAX){                System.out.println("updater:"+(++localValue));                init_value=localValue;                try {                    TimeUnit.SECONDS.sleep(2);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        },"Updater").start();    }}</code></pre><p>一个读线程，一个写线程。有一个全局静态变量init_value，每一个线程还有一个自己的局部变量localValue。写线程将自己的局部变量localValue自增，然后赋值给全局静态变量init_value。读线程当发现自己的本地局部变量与全局静态变量值不相同，则读入最新的全局静态变量init_value，然后更新自己的本地局部变量。</p><p>运行结果：</p><pre><code class="line-numbers language-text">updater:1Reader:1updater:2updater:3updater:4updater:5</code></pre><p>由结果可发现读线程感知不到写线程对init_value变量的更新，写线程读取到的全局静态变量一直没有被更新，还是旧值。这就出现了并发编程的可见性问题，读线程对写线程的数据修改结果不可见，使程序出现了问题。</p><h3 id="重排序问题："><a href="#重排序问题：" class="headerlink" title="重排序问题："></a>重排序问题：</h3><pre><code class="line-numbers language-java">public class NoVisibility {    private static boolean ready;    private static int number;    private static class ReaderThread extends Thread {        @Override        public void run() {            while(!ready) {                Thread.yield();            }            System.out.println(number);        }    }    public static void main(String[] args) {        new ReaderThread().start();        number = 42;        ready = true;    }}</code></pre><p>NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值，这就是上面讲到的可见性问题。也有可能NoVisibility可能会输出0，因为读线程虽然看到了写入ready的值，但却没有看到之后写入number的值，<mark style="background: #FFB8EBA6;">在主线程对number和ready的赋值给颠倒了</mark>，这种现象被称为“<strong>重排序</strong>”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p><p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，无法得到正确的结论。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以上就是在并发编程中可能出现的问题，今天我们就在讲解一下使用volatile关键字来解决这些问题。</p><p>我们知道volatile关键字的作用是保证变量在多线程之间的可见性，它是java.util.concurrent包的核心，没有volatile就没有这么多的并发类给我们使用。</p><p>本文详细解读一下volatile关键字如何保证变量在多线程之间的可见性，在此之前，有必要讲解一下CPU缓存的相关知识，掌握这部分知识一定会让我们更好地理解volatile的原理，从而更好、更正确地地使用volatile关键字。</p><h3 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h3><h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>在Java内存模型那一章我们介绍了JMM有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。</p><p>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。</p><h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。</p><h4 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h4><p>是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。</p><h3 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h3><h4 id="CPU多级缓存架构"><a href="#CPU多级缓存架构" class="headerlink" title="CPU多级缓存架构"></a>CPU多级缓存架构</h4><p>CPU缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快得多，举个例子：</p><ul><li>一次主内存的访问通常在几十到几百个时钟周期</li><li>一次L1高速缓存的读写只需要1~2个时钟周期</li><li>一次L2高速缓存的读写也只需要数十个时钟周期<br>这种访问速度的显著差异，导致CPU可能会花费很长时间等待数据到来或把数据写入内存。</li></ul><p>基于此，现在CPU大多数情况下读写都不会直接访问内存（CPU都没有连接到内存的管脚），取而代之的是CPU缓存（cache），CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。</p><p>按照读取顺序与CPU结合的紧密程度，CPU缓存可分为：</p><ul><li>一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存</li><li>二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半</li><li>三级缓存：简称L3 Cache，部分高端CPU才有<br>每一级缓存中所存储的数据全部都是下一级缓存中的一部分，这三种缓存的技术难度和制造成本是相对递减的，所以其容量也相对递增。</li></ul><p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有再从二级缓存中查找，如果还是没有再从三级缓存中或内存中查找。一般来说每级缓存的命中率大概都有80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取。</p><h4 id="使用CPU缓存带来的问题"><a href="#使用CPU缓存带来的问题" class="headerlink" title="使用CPU缓存带来的问题"></a>使用CPU缓存带来的问题</h4><p><img src="/attachment/f7bcbc8390069369d10342cb9e31614f.png"></p><p>当系统运行时，CPU执行计算的过程如下：</p><ul><li>程序以及数据被加载到主内存</li><li>指令和数据被加载到CPU缓存</li><li>CPU执行指令，把结果写到高速缓存</li><li>高速缓存中的数据写回主内存</li></ul><p>如果服务器是单核CPU，那么这些步骤不会有任何的问题，但是如果服务器是多核CPU，每个CPU都有自己独享的Cache，那么问题来了，以Intel Core i7处理器的高速缓存概念模型为例（图片摘自《深入理解计算机系统》）：</p><p><img src="/attachment/93c2f68a041ae60709e5a4cbc36e7956.png"></p><p>试想下面一种情况：</p><ul><li>核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存</li><li>核3做了上面同样的工作，这样核0与核3的缓存拥有同样的数据</li><li>核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存</li><li>核3访问该字节，由于核0并未将数据写回主存，数据不同步</li></ul><p>为了解决这个问题，CPU制造商制定了一个<mark style="background: #FF5582A6;">规则(MESI)</mark>：<br>当一个CPU修改缓存中的字节时，服务器中其他CPU会被通知，它们的缓存将视为无效，即将数据所对应的Cache Line置为无效。于是，在上面的情况下，核3发现自己的缓存中数据已无效，核0将立即把自己的数据写回主存，然后核3重新读取该数据。</p><p><strong>反汇编Java字节码，查看汇编层面对volatile关键字做了什么</strong></p><pre><code class="line-numbers language-java">public class LazySingleton {    private static volatile LazySingleton instance = null;    public static LazySingleton getInstance() {        if (instance == null) {            instance = new LazySingleton();        }        return instance;    }    public static void main(String[] args) {        LazySingleton.getInstance();    }}</code></pre><p>代码生成的汇编指令为：</p><pre><code class="line-numbers language-d">0x0000000002931351: lock add dword ptr [rsp],0h  ;*putstatic instance; - org.xrq.test.design.singleton.LazySingleton::getInstance@13 (line 14)</code></pre><p>之所以定位到这两行是因为这里结尾写明了line 14，line 14即volatile变量instance赋值的地方。后面的add dword ptr [rsp],0h都是正常的汇编语句，意思是将双字节的栈指针寄存器+0，这里的关键就是add前面的lock指令，lock是汇编语言的命令，后面详细分析一下lock指令的作用和为什么加上lock指令后就能保证volatile关键字的内存可见性。</p><p><strong>lock指令做了什么</strong></p><p>这里的Lock是汇编语言指令，不是之前写过的Java内存模型指定的8中操作中的lock</p><p>lock指令的几个作用：</p><ol><li>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线（降低粒度，以前锁了总线，使总线只能被一个CPU独享，所有的CPU公用一条总线，那么所有的CPU就都不能使用，这样大大降低了吞吐量，影响效率。锁缓存行只是将该数据的缓存行锁住，让对其操作的CPU独占，其他的缓存行不受影响，其他CPU还能对别的数据进行操作），因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存。（计算机组成原理中学的总线结构）（不管是锁总线还是锁缓存行，其根本目的就是使CPU对内存中某个数据的操作是独占的，在CPU1对一个数据操作时lock指令会锁总线或者通过缓存一致性协议来锁缓存行来使其他的CPU无法对该数据进行操作，使CPU1能独享给数据的操作权）</li><li>lock后的写操作会向主内存中回写已修改的数据，同时让其它CPU相关缓存行（Cache Line）失效，从而重新从主存中加载最新的数据</li><li>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两边的指令重排序。</li></ol><p>以上可以看出lock指令就可以实现可见性和有序性。</p><p>第一条中写了由于效率问题，实际后来的处理器都采用锁缓存来替代锁总线，这种场景下多缓存的数据一致是通过缓存一致性协议来保证的，我们来看一下什么是缓存一致性协议。</p><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><h4 id="缓存行（Cache-Line）的概念"><a href="#缓存行（Cache-Line）的概念" class="headerlink" title="缓存行（Cache Line）的概念"></a>缓存行（Cache Line）的概念</h4><p>缓存是分段（line）的，一个段对应一块存储空间，我们称之为缓存行（Cache Line），它是CPU缓存中可分配的最小存储单元，大小32字节、64字节、128字节不等，这与CPU架构有关，通常来说是64字节。当CPU看到一条读取内存的指令时，它会把内存地址传递给一级数据缓存，一级数据缓存会检查它是否有这个内存地址对应的缓存段，如果没有就把整个缓存段从内存（或更高一级的缓存）中加载进来。注意，这里说的是一次加载整个缓存段，这就是上面提过的局部性原理</p><p>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于”<strong>嗅探（snooping）</strong>“协议，它的基本思想是：</p><ul><li>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个CPU缓存可以读写内存）。</li><li>CPU缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其它处理器马上知道这块内存在它们的缓存段中已失效。</li></ul><p>MESI协议是当前最主流的<strong>缓存一致性</strong>协议，在MESI协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是：</p><p><img src="/attachment/f11fb769b8aa060cd06c13d4ced9bcd8.png"></p><p>这里的I、S和M状态已经有了对应的概念：失效/未载入、干净以及脏的缓存段。所以这里新的知识点只有E状态，代表独占式访问，这个状态解决了”在我们开始修改某块内存之前，我们需要告诉其它处理器”这一问题：<mark style="background: #FFB86CA6;">只有当缓存行处于E或者M状态时，处理器才能去写它</mark>，也就是说只有在这两种状态下，处理器是独占这个缓存行的。当处理器想写某个缓存行时，如果它没有独占权，它必须先发送一条”我要独占权”的请求给总线，这会通知其它处理器把它们拥有的同一缓存段的拷贝失效（如果有）。只有在获得独占权后，处理器才能开始修改数据—-并且此时这个处理器知道，这个缓存行只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。</p><p>反之，如果有其它处理器想读取这个缓存行（马上能知道，因为一直在嗅探总线），独占或已修改的缓存行必须先回到”共享”状态。如果是已修改的缓存行，那么还要先把内容回写到内存中。</p><p>简单来说，MESI协议就是：</p><ul><li>读操作：不做任何事情，把Cache中的数据读到寄存器</li><li>写操作：发出信号通知其他的CPU<mark style="background: #FFB8EBA6;">将该变量的Cache line置为无效</mark>，其他的CPU要访问这个变量的时候，只能从主内存中获取。</li></ul><h3 id="内存屏障-Memory-Barrier"><a href="#内存屏障-Memory-Barrier" class="headerlink" title="内存屏障(Memory Barrier)"></a>内存屏障(Memory Barrier)</h3><p>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于Memory barrier之后的操作完成。</p><p>Memory barrier是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p><p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。</p><p>Memory Barrier可以被分为以下几种类型：</p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><h4 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h4><ul><li><p>在每个volatile写操作<strong>前</strong>插入StoreStore屏障，在写操作<strong>后</strong>插入StoreLoad屏障；</p></li><li><p>在每个volatile读操作<strong>后</strong>插入LoadLoad屏障，在读操作<strong>后</strong>插入LoadStore屏障；</p></li><li><p>volatile读：在每个volatile读后面分别插入LoadLoad屏障及LoadStore屏障（根据volatile重排序规则第一条），如下图所示<br><img src="/attachment/78aa887b5f481c4d1bd54e8ac9dd0169.png"></p></li></ul><p>​ LoadLoad屏障的作用：禁止上面的所有普通读操作和上面的volatile读操作进行重排序。<br> LoadStore屏障的作用：禁止下面的普通写和上面的volatile读进行重排序。</p><ul><li>volatile写：在每个volatile写前面插入一个StoreStore屏障（为满足volatile重排序规则第二条），在每个volatile写后面插入一个StoreLoad屏障（为满足volatile重排序规则第三条），如下图所示</li></ul><p><img src="/attachment/70f296e8770c588cf23a506d2d61ccc1.png"></p><p>StoreStore屏障的作用：禁止上面的普通写和下面的volatile写重排序<br>StoreLoad屏障的作用：防止上面的volatile写与下面可能出现的volatile读/写重排序</p><h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><ul><li>新建对象过程中，构造体中对final域的初始化写入(StoreStore屏障)和这个对象赋值给其他引用变量，这两个操作不能重排序；</li><li>初次读包含final域的对象引用和读取这个final域（LoadLoad屏障），这两个操作不能重排序；</li></ul><h4 id="汇编指令LOCK与内存屏障之间的关系？"><a href="#汇编指令LOCK与内存屏障之间的关系？" class="headerlink" title="汇编指令LOCK与内存屏障之间的关系？"></a>汇编指令LOCK与内存屏障之间的关系？</h4><p>LOCK汇编命令使相应的机器码指令中添加了相关内存屏障指令，也就是说汇编层面LOCK指令的功能是通过CPU层面的内存屏障机器码实现的。</p><h2 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a>volatile的原理</h2><p>由lock指令回看volatile变量读写。可以知道volatile实际是靠lock指令（这是汇编语言的LOCK指令，不是JMM中的lock操作，JMM中的lock操作是加锁，它是synchronized的实现基础）为基础来实现的。</p><p>相信有了上面对于lock的解释，以及对CPU多级缓存架构以及JAVA内存模型的理解，volatile关键字的实现原理应该是一目了然了。由上面JMM的结构图可知，工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。</p><p>那么当写两条线程Thread-A与Threab-B同时操作主存中的一个volatile变量i时</p><ul><li>Thread-A写了变量i，那么：<ol><li>Thread-A发出LOCK#指令</li><li>发出的LOCK#指令锁总线（或锁缓存行），同时让Thread-B高速缓存中的缓存行内容失效</li><li>Thread-A向主存回写最新修改的i</li></ol></li><li>Thread-B读取变量i，那么：<ol><li>Thread-B发现对应地址的缓存行被锁了，等待锁的释放，缓存一致性协议会保证它读取到最新的值，也就是当锁释放之后Thread-B发现对应的Cache Line已经失效了，只能去主内存中读取最新的值。</li></ol></li></ul><p>由此可以看出，volatile关键字的读和普通变量的读取相比基本没差别，差别主要还是在变量的写操作上。</p><p>当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p><p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现上面所讲的缓存一致性协议</p><p><strong>缓存一致性协议</strong>：每个处理器通过<mark style="background: #FF5582A6;">嗅探</mark>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><p>所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</p><p><strong>总结：</strong></p><p>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障会提供3个功能：</p><ul><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；（保证有序性）</li><li>它会强制将对缓存的修改操作立即写入主存；（保证可见性）</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效。（保证可见性）</li></ul><h2 id="源码溯源"><a href="#源码溯源" class="headerlink" title="源码溯源"></a>源码溯源</h2><p>JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p><h3 id="Java代码层面"><a href="#Java代码层面" class="headerlink" title="Java代码层面"></a>Java代码层面</h3><p>volatile用来修饰Java变量 的代码示例</p><pre><code class="line-numbers language-java">public class TestVolatile {    public static volatile int counter = 1;    public static void main(String[] args){        counter = 2;        System.out.println(counter);    }}</code></pre><h3 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h3><p>通过javac TestVolatile.java将类编译为class文件，再通过javap -v TestVolatile.class命令反编译查看字节码文件。</p><p><img src="/attachment/7932fcba3d15c2c77b1a803e96f11aa1.png"></p><p>可以看到，修饰counter字段的public、static、volatile关键字，在字节码层面分别是以下访问标志： ACC_PUBLIC, ACC_STATIC, ACC_VOLATILE</p><p>volatile在字节码层面，就是使用访问标志：<strong>ACC_VOLATILE来表示</strong>，供后续操作此变量时判断访问标志是否为ACC_VOLATILE，来决定是否遵循volatile的语义处理。</p><h3 id="JVM源码层面"><a href="#JVM源码层面" class="headerlink" title="JVM源码层面"></a>JVM源码层面</h3><ol><li>openjdk8根路径/hotspot/src/share/vm/interpreter路径下的bytecodeInterpreter.cpp文件中，处理putstatic和putfield指令的代码：</li></ol><pre><code class="line-numbers language-c">CASE(_putfield):CASE(_putstatic):    {          // .... 省略若干行           // ....          // Now store the result 现在要开始存储结果了          // ConstantPoolCacheEntry* cache;     -- cache是常量池缓存实例          // cache-&gt;is_volatile()               -- 判断是否有volatile访问标志修饰          int field_offset = cache-&gt;f2_as_index();          if (cache-&gt;is_volatile()) { // ****重点判断逻辑****             // volatile变量的赋值逻辑            if (tos_type == itos) {              obj-&gt;release_int_field_put(field_offset, STACK_INT(-1));            } else if (tos_type == atos) {// 对象类型赋值              VERIFY_OOP(STACK_OBJECT(-1));              obj-&gt;release_obj_field_put(field_offset, STACK_OBJECT(-1));              OrderAccess::release_store(&amp;BYTE_MAP_BASE[(uintptr_t)obj &gt;&gt; CardTableModRefBS::card_shift], 0);            } else if (tos_type == btos) {// byte类型赋值              obj-&gt;release_byte_field_put(field_offset, STACK_INT(-1));            } else if (tos_type == ltos) {// long类型赋值              obj-&gt;release_long_field_put(field_offset, STACK_LONG(-1));            } else if (tos_type == ctos) {// char类型赋值              obj-&gt;release_char_field_put(field_offset, STACK_INT(-1));            } else if (tos_type == stos) {// short类型赋值              obj-&gt;release_short_field_put(field_offset, STACK_INT(-1));            } else if (tos_type == ftos) {// float类型赋值              obj-&gt;release_float_field_put(field_offset, STACK_FLOAT(-1));            } else {// double类型赋值              obj-&gt;release_double_field_put(field_offset, STACK_DOUBLE(-1));            }            // *** 写完值后的storeload屏障 ***            OrderAccess::storeload();          } else {            // 非volatile变量的赋值逻辑            if (tos_type == itos) {              obj-&gt;int_field_put(field_offset, STACK_INT(-1));            } else if (tos_type == atos) {              VERIFY_OOP(STACK_OBJECT(-1));              obj-&gt;obj_field_put(field_offset, STACK_OBJECT(-1));              OrderAccess::release_store(&amp;BYTE_MAP_BASE[(uintptr_t)obj &gt;&gt; CardTableModRefBS::card_shift], 0);            } else if (tos_type == btos) {              obj-&gt;byte_field_put(field_offset, STACK_INT(-1));            } else if (tos_type == ltos) {              obj-&gt;long_field_put(field_offset, STACK_LONG(-1));            } else if (tos_type == ctos) {              obj-&gt;char_field_put(field_offset, STACK_INT(-1));            } else if (tos_type == stos) {              obj-&gt;short_field_put(field_offset, STACK_INT(-1));            } else if (tos_type == ftos) {              obj-&gt;float_field_put(field_offset, STACK_FLOAT(-1));            } else {              obj-&gt;double_field_put(field_offset, STACK_DOUBLE(-1));            }          }          UPDATE_PC_AND_TOS_AND_CONTINUE(3, count);  }</code></pre><ol start="2"><li>重点判断逻辑cache-&gt;is_volatile()方法，调用的是openjdk8根路径/hotspot/src/share/vm/utilities路径下的accessFlags.hpp文件中的方法，<strong>用来判断访问标记是否为volatile修饰</strong>。</li></ol><pre><code class="line-numbers language-c">// Java access flags  bool is_public      () const         { return (_flags &amp; JVM_ACC_PUBLIC      ) != 0; }  bool is_private     () const         { return (_flags &amp; JVM_ACC_PRIVATE     ) != 0; }  bool is_protected   () const         { return (_flags &amp; JVM_ACC_PROTECTED   ) != 0; }  bool is_static      () const         { return (_flags &amp; JVM_ACC_STATIC      ) != 0; }  bool is_final       () const         { return (_flags &amp; JVM_ACC_FINAL       ) != 0; }  bool is_synchronized() const         { return (_flags &amp; JVM_ACC_SYNCHRONIZED) != 0; }  bool is_super       () const         { return (_flags &amp; JVM_ACC_SUPER       ) != 0; }  // 是否volatile修饰  bool is_volatile    () const         { return (_flags &amp; JVM_ACC_VOLATILE    ) != 0; }  bool is_transient   () const         { return (_flags &amp; JVM_ACC_TRANSIENT   ) != 0; }  bool is_native      () const         { return (_flags &amp; JVM_ACC_NATIVE      ) != 0; }  bool is_interface   () const         { return (_flags &amp; JVM_ACC_INTERFACE   ) != 0; }  bool is_abstract    () const         { return (_flags &amp; JVM_ACC_ABSTRACT    ) != 0; }  bool is_strict      () const         { return (_flags &amp; JVM_ACC_STRICT      ) != 0; }</code></pre><ol start="3"><li>下面一系列的 if…else… 对<code>tos_type</code>字段的判断处理，是针对 java 基本类型和引用类型的赋值处理。如：</li></ol><pre><code class="line-numbers language-c">obj-&gt;release_byte_field_put(field_offset, STACK_INT(-1));</code></pre><p>对 byte 类型的赋值处理，调用的是<code>openjdk8根路径/hotspot/src/share/vm/oops</code>路径下的<code>oop.inline.hpp</code>文件中的方法：</p><pre><code class="line-numbers language-c">// load操作调用的方法inline jbyte oopDesc::byte_field_acquire(int offset) const                  { return OrderAccess::load_acquire(byte_field_addr(offset));     }// store操作调用的方法inline void oopDesc::release_byte_field_put(int offset, jbyte contents)     { OrderAccess::release_store(byte_field_addr(offset), contents); }</code></pre><p>赋值的操作又被包装了一层，又调用的 <strong>OrderAccess::release_store</strong> 方法。</p><ol start="4"><li>OrderAccess 是定义在<code>openjdk8根路径/hotspot/src/share/vm/runtime</code>路径下的<code>orderAccess.hpp</code>头文件下的方法，具体的实现是根据不同的操作系统和不同的 cpu 架构，有不同的实现。</li></ol><p><strong>强烈建议大家读一遍<code>orderAccess.hpp</code>文件中 30-240 行的注释！！！</strong>你就会发现本文 1.2 章所介绍内容的来源，也是网上各种雷同文章的来源。</p><p><code>orderAccess_linux_x86.inline.hpp</code>是 linux 系统下 x86 架构的实现：</p><p><img src="/attachment/b67d2ab46a60f224477f01630cbc5e03.png"></p><p>可以从上面看到，到 c++ 的实现层面，又使用 c++ 中的 volatile 关键字，用来修饰变量，通常用于建立语言级别的 memory barrier。在《C++ Programming Language》一书中对 volatile 修饰词的解释：</p><p>A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</p><p>含义就是：</p><ul><li>volatile 修饰的类型变量表示可以被某些编译器未知的因素更改（如：操作系统，硬件或者其他线程等）</li><li>使用 volatile 变量时，避免激进的优化。即：系统总是重新从内存读取数据，即使它前面的指令刚从内存中读取被缓存，防止出现未知更改和主内存中不一致</li></ul><ol start="5"><li>步骤 3 中对变量赋完值后，程序又回到了 2.3.1 小章中第一段代码中一系列的 if…else… 对<code>tos_type</code>字段的判断处理之后。有一行关键的代码：<strong>OrderAccess::storeload();</strong> 即：只要 volatile 变量赋值完成后，都会走这段代码逻辑。</li></ol><p>它依然是声明在<code>orderAccess.hpp</code>头文件中，在不同操作系统或 cpu 架构下有不同的实现。<code>orderAccess_linux_x86.inline.hpp</code>是 linux 系统下 x86 架构的实现：</p><p><img src="/attachment/15e70d6be28898e69c72b203490d4d6e.png"></p><p>代码<code>lock; addl $0,0(%%rsp)</code> 其中的 <code>addl $0,0(%%rsp)</code> 是把寄存器的值加 0，相当于一个空操作（之所以用它，不用空操作专用指令 nop，是因为 lock 前缀不允许配合 nop 指令使用）</p><p><strong>lock 前缀，会保证某个处理器对共享内存（一般是缓存行 cacheline，这里记住缓存行概念，后续重点介绍）的独占使用。它将本处理器缓存写入内存，该写入操作会引起其他处理器或内核对应的缓存失效。通过独占内存、使其他处理器缓存失效，达到了 “指令重排序无法越过内存屏障” 的作用</strong></p><h3 id="汇编层面"><a href="#汇编层面" class="headerlink" title="汇编层面"></a>汇编层面</h3><p><img src="/attachment/c511c8c9ad6bde14440cc0f0d3a9e13c.png"></p><p>又看到了<code>lock addl $0x0,(%rsp)</code>指令，熟悉的配方熟悉的味道，和上面 2.3 章中的<strong>步骤 5</strong> 一摸一样，其实这里就是步骤 5 中代码的体现。</p><h2 id="volatile的用法"><a href="#volatile的用法" class="headerlink" title="volatile的用法"></a>volatile的用法</h2><p>volatile通常被比喻成”轻量级的synchronized”，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p><p>volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。</p><h2 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h2><p>让其他线程能够马上感知到某一线程多某个变量的修改（两种作用对应的实现原理见总结）：</p><ul><li>保证可见性</li><li>保证有序性</li><li>volatile不能保证原子性</li></ul><p><strong>线程写volatile变量的过程：</strong></p><ol><li>改变线程工作内存中volatile变量副本的值</li><li>将改变的副本的值从工作内存中刷新到主内存中</li></ol><p><strong>线程读volatile变量的过程：</strong></p><ol><li>从主内存中读取volatile变量的最新值到工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ol><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><p>保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见</p><ul><li>Code<ul><li>不加volatile，没有可见性，程序无法停止</li><li>加了volatile，保证可见性，程序可以停止</li></ul></li></ul><pre><code class="line-numbers language-java">public class VolatileSeeDemo {    /**     * t1-------come in     * main 修改完成     * t1-------flag被设置为false，程序停止     */    static volatile boolean flag = true;    public static void main(String[] args) {        new Thread(() -&gt; {            System.out.println(Thread.currentThread().getName() + "\t-------come in");            while (flag) {            }            System.out.println(Thread.currentThread().getName() + "\t-------flag被设置为false，程序停止");        }, "t1").start();        try {            TimeUnit.SECONDS.sleep(2);        } catch (InterruptedException e) {            e.printStackTrace();        }        //更新flag值        flag = false;        System.out.println(Thread.currentThread().getName() + "\t 修改完成");    }}</code></pre><ul><li>volatile变量的读写过程（了解即可）</li></ul><p><img src="/attachment/8afe66257f86117f1b0744842bc6c0f5.png"></p><h3 id="没有原子性"><a href="#没有原子性" class="headerlink" title="没有原子性"></a>没有原子性</h3><p>volatile变量的符合操作不具有原子性</p><ul><li>对于voaltile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，也仅仅是数据加载时是最新的。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存的操作将会作废去读主内存最新值，操作出现写丢失问题。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步。</li><li>至于怎么去理解这个写丢失的问题，就是再将数据读取到本地内存到写回主内存中有三个步骤：数据加载—-&gt;数据计算—-&gt;数据赋值，如果第二个线程在第一个线程读取旧值与写回新值期间读取共享变量的值，那么第二个线程将会与第一个线程一起看到同一个值，并执行自己的操作，一旦其中一个线程对volatile修饰的变量先行完成操作刷回主内存后，另一个线程会作废自己的操作，然后重新去读取最新的值再进行操作，这样的话，它自身的那一次操作就丢失了，这就造成了 线程安全失败，因此，这个问题需要使用synchronized修饰以保证线程安全性。</li><li>结论：volatile变量不适合参与到依赖当前值的运算，如i++，i=i+1之类的，通常用来保存某个状态的boolean值或者int值，也正是由于volatile变量只能保证可见性，在不符合以下规则的运算场景中，我们仍然要通过加锁来保证原子性：<ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul></li><li>面试回答为什么不具备原子性：举例i++的例子，在字节码文件中，i++分为三部，间隙期间不同步非原子操作<ul><li>对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，也就造成了线程安全问题。</li></ul></li></ul><p><img src="/attachment/e6280f56a76c62887b789f069b499d2d.png"></p><h3 id="指令禁重排"><a href="#指令禁重排" class="headerlink" title="指令禁重排"></a>指令禁重排</h3><ul><li>在每一个volatile写操作前面插入一个StoreStore屏障—&gt;StoreStore屏障可以保证在volatile写之前，其前面所有的普通写操作都已经刷新到主内存中。</li><li>在每一个volatile写操作后面插入一个StoreLoad屏障—&gt;StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序</li><li>在每一个volatile读操作后面插入一个LoadLoad屏障—&gt;LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序</li><li>在每一个volatile读操作后面插入一个LoadStore屏障—&gt;LoadTore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序</li><li>案例说明（volatile读写前或后加了屏障保证有序性）：</li></ul><p><img src="/attachment/28cc869d1729448c9e9acc0d250ed018.png"></p><p><img src="/attachment/c8c126ed739bad63ce7dca1d6fa09c3c.png"></p><h3 id="如何正确使用volatile"><a href="#如何正确使用volatile" class="headerlink" title="如何正确使用volatile"></a>如何正确使用volatile</h3><ul><li>单一赋值可以，但是含复合运算赋值不可以（i++之类的）<ul><li>volatile int a = 10;</li><li>volatile boolean flag = true;</li></ul></li><li>状态标志，判断业务是否结束<ul><li>作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束</li></ul></li></ul><p><img src="/attachment/001e924264490fe1654ccc3c698e92b3.png"></p><ul><li>开销较低的读，写锁策略<ul><li>当读远多于写，结合使用内部锁和volatile变量来减少同步的开销</li><li>原理是：利用volatile保证读操作的可见性，利用synchronized保证符合操作的原子性</li></ul></li></ul><p><img src="/attachment/ddc8d085f7bae921d44e2f5a13ced119.png"></p><ul><li>DCL双端锁的发布<ul><li>问题描述：首先设定一个加锁的单例模式场景<br>  <img src="/attachment/dcdfca62edf442eb5bf9992ad5bea278.png"></li><li>在单线程环境下（或者说正常情况下），在“问题代码处”，会执行以下操作，保证能获取到已完成初始化的实例：<br>  <img src="/attachment/626a9420f3778cfa7f92bdb23cfac17e.png"></li><li>隐患：在多线程环境下，在“问题代码处”，会执行以下操作，由于重排序导致2，3乱序，后果就是其他线程得到的是null而不是完成初始化的对象，其中第3步中实例化分多步执行（分配内存空间、初始化对象、将对象指向分配的内存空间），某些编译器为了性能原因，会将第二步和第三步重排序，这样某个线程肯能会获得一个未完全初始化的实例：<br>  <img src="/attachment/377af1e539a4ed353aba82589f43a8bb.png"></li><li>多线程下的解决方案：加volatile修饰<br><img src="/attachment/5ce1cc04a61c92e6172c0fba8f94efd8.png"></li></ul></li></ul><h2 id="Volatile的适用场景"><a href="#Volatile的适用场景" class="headerlink" title="Volatile的适用场景"></a>Volatile的适用场景</h2><p>使用volatile修饰的变量最好满足以下条件:</p><p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。</p><ul><li>不满足：num++、count = count * 5</li><li>满足：boolean值变量，记录温度变化的变量等等</li></ul><p>2.该变量没有包含在具有其他变量的不变式中</p><ul><li>不满足：low &lt; up</li></ul><p>如果满足以上的条件的任意一个，就可以不用synchronized，用volatile就可以。一般的应用场景很多会不满足其中一个，所以volatile的使用没有synchronized这么广泛。</p><h3 id="这里举几个比较经典的场景"><a href="#这里举几个比较经典的场景" class="headerlink" title="这里举几个比较经典的场景:"></a>这里举几个比较经典的场景:</h3><h4 id="状态标记量（开关模式）-就是前面引入中重排序问题的例子"><a href="#状态标记量（开关模式）-就是前面引入中重排序问题的例子" class="headerlink" title="状态标记量（开关模式）,就是前面引入中重排序问题的例子."></a>状态标记量（开关模式）,就是前面引入中重排序问题的例子.</h4><pre><code class="line-numbers language-java">public class ShutDowsnDemmo extends Thread{    private volatile boolean started=false;    @Override    void run() {        while(started){             dowork();        }    }     public void shutdown(){        started=false;    }} </code></pre><p>状态标记两可以用作某种操作的开关，一个作业线程在关闭状态无法执行，它的开关标记是一个volatile修饰的变量，另一个线程修改该变量值，作业线程就能立刻感知到开关被修改，就能进入运行状态。</p><h4 id="一次性安全发布-双重检查锁定问题-单例模式的双重检查-double-checked-locking-DCL"><a href="#一次性安全发布-双重检查锁定问题-单例模式的双重检查-double-checked-locking-DCL" class="headerlink" title="一次性安全发布.双重检查锁定问题(单例模式的双重检查  double-checked-locking  DCL)."></a>一次性安全发布.双重检查锁定问题(单例模式的双重检查  double-checked-locking  DCL).</h4><pre><code class="line-numbers language-java">public class Singleton {    private volatile static Singleton instance;    public static Singleton getInstance(){         if(instance==null){            synchronized (Singleton.class){                instance=new Singleton();            }         }        return instance;    }}</code></pre><ul><li>独立观察.如果系统需要使用最后登录的人员的名字,这个场景就很适合.</li><li>开销较低的“读－写锁”策略.当读操作远远大于写操作,可以结合使用锁和volatile来提升性能.</li></ul><h2 id="Volatile不适用的场景"><a href="#Volatile不适用的场景" class="headerlink" title="Volatile不适用的场景"></a>Volatile不适用的场景</h2><p>不满足前面所讲的Volatile适用场景的条件的话，就说明需要保证原子性，就需要加锁（使用synchronized、lock或者java.util.concurrent中的Atomic原子类）来保证并发中的原子性。</p><h4 id="volatile不适合复合操作"><a href="#volatile不适合复合操作" class="headerlink" title="volatile不适合复合操作"></a>volatile不适合复合操作</h4><p>例如，inc++不是一个原子性操作，可以由读取、加、赋值3步组成，所以结果并不能达到10000。</p><pre><code class="line-numbers language-java">public class Test {    public volatile int inc = 0;    public void increase() {        inc++;    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p><strong>解决方法:</strong></p><ol><li>采用synchronized</li><li>采用Lock</li><li>采用java并发包中的原子操作类，原子操作类是通过CAS循环的方式来保证其原子性的</li></ol><h2 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别"></a>volatile与synchronized的区别</h2><h3 id="使用上的区别"><a href="#使用上的区别" class="headerlink" title="使用上的区别"></a>使用上的区别</h3><p>Volatile只能修饰变量，使用范围较小；synchronized可以修饰方法和语句块，作用域可以是对象或者类，适用范围更广</p><h3 id="对原子性的保证"><a href="#对原子性的保证" class="headerlink" title="对原子性的保证"></a>对原子性的保证</h3><p>synchronized可以保证原子性，Volatile不能保证原子性</p><h3 id="对可见性的保证"><a href="#对可见性的保证" class="headerlink" title="对可见性的保证"></a>对可见性的保证</h3><p>都可以保证可见性，但实现原理不同</p><p>Volatile对变量加了lock，synchronized使用monitorEnter和monitorexit  monitor  JVM</p><h3 id="对有序性的保证"><a href="#对有序性的保证" class="headerlink" title="对有序性的保证"></a>对有序性的保证</h3><p>Volatile能保证有序，synchronized可以保证有序性，但是代价（重量级）并发退化到串行</p><h3 id="性能上的区别"><a href="#性能上的区别" class="headerlink" title="性能上的区别"></a>性能上的区别</h3><p>synchronized是靠加锁实现的，引起阻塞</p><p>volatile是靠Lock指令实现的，不需要加锁，不会引起阻塞</p><p>性能上volatile比synchronized要好，volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。但是volatile的性能比synchronized加锁好很多。</p><h2 id="本章最后的小总结"><a href="#本章最后的小总结" class="headerlink" title="本章最后的小总结"></a>本章最后的小总结</h2><p>volatile是轻量级同步机制,与synchronized相比,他的开销更小一些,同时安全性也有所降低,在一些特定的场景下使用它可以在完成并发目标的基础上有一些性能上的优势.但是同时也会带来一些安全上的问题,且比较难以排查,使用时需要谨慎.volatile并不能保证操作的原子性,想要保证原子性请使用synchronized关键字加锁.</p><h3 id="volatile可见性"><a href="#volatile可见性" class="headerlink" title="volatile可见性"></a>volatile可见性</h3><p>volatile关键字保证可见性：对一个被volatile关键字修饰的变量<br>1写操作的话，这个变量的最新值会立即刷新回到主内存中<br>2读操作的话，总是能够读取到这个变量的最新值，也就是这个变量最后被修改的值<br>3当某个线程收到通知，去读取volatile修饰的变量的值的时候，线程私有工作内存的数据失效，需要重新回到主内存中去读取最新的数据。</p><h3 id="volatile没有原子性"><a href="#volatile没有原子性" class="headerlink" title="volatile没有原子性"></a>volatile没有原子性</h3><h3 id="volatile禁重排"><a href="#volatile禁重排" class="headerlink" title="volatile禁重排"></a>volatile禁重排</h3><p><img src="/attachment/f7798e274e55d71b905932b3553c0fdd.png"></p><p><img src="/attachment/897c5ce8e3d6e8f55286c61692e56369.png"></p><h3 id="凭什么我们Java写了一个volatile关键字，系统底层加入内存屏障？两者的关系如何勾搭？"><a href="#凭什么我们Java写了一个volatile关键字，系统底层加入内存屏障？两者的关系如何勾搭？" class="headerlink" title="凭什么我们Java写了一个volatile关键字，系统底层加入内存屏障？两者的关系如何勾搭？"></a>凭什么我们Java写了一个volatile关键字，系统底层加入内存屏障？两者的关系如何勾搭？</h3><p><img src="/attachment/905ef6901a4fa9f1399ba9e0f522cfda.png"></p><h3 id="内存屏障是什么？"><a href="#内存屏障是什么？" class="headerlink" title="内存屏障是什么？"></a>内存屏障是什么？</h3><p>内存屏障能干吗？</p><ul><li>阻止屏障两边的指令重排序</li><li>写操作时加入屏障，强制将线程私有工作内存的数据刷回主物理内存</li><li>读操作时加入屏障，线程私有工作内存的数据失效，重新回到主物理内存中获取最新值</li></ul><h3 id="内存屏障四大指令"><a href="#内存屏障四大指令" class="headerlink" title="内存屏障四大指令"></a>内存屏障四大指令</h3><p><img src="/attachment/b3b40de918a933c5db700df2b302b2a6.png"></p><h3 id="3句话总结"><a href="#3句话总结" class="headerlink" title="3句话总结"></a>3句话总结</h3><ul><li>volatile写之前的操作，都禁止重排序到volatile之后</li><li>volatile读之后的操作，都禁止重排序到volatile之前</li><li>volatile写之后volatile读，禁止重排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Java内存模型基础知识</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-java-nei-cun-mo-xing-ji-chu-zhi-shi/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-yuan-li/java-duo-xian-cheng-bing-fa-java-nei-cun-mo-xing-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Java内存模型基础知识"><a href="#【Java-多线程并发】-Java内存模型基础知识" class="headerlink" title="【Java 多线程并发】 Java内存模型基础知识"></a>【Java 多线程并发】 Java内存模型基础知识</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Java内存模型基础知识date: 2023-07-03 13:55tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 Java内存模型基础知识</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有两种并发模型可以解决这两个问题：</p><ul><li>消息传递并发模型</li><li>共享内存并发模型</li></ul><p><strong>JMM</strong><br>JMM（Java内存模型Java Memory Model）本身是一种抽象的概念</p><p><img src="/attachment/523f614869c81dd1d6ee5e4cae416e22.png"></p><p><strong>JMM 的组成</strong></p><ol><li>主内存：共享的信息，也就是图中的内存区域，它也就对应着JVM内存区域中的堆</li><li>工作内存：私有信息，也就是图中的工作空间，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中。局部变量，主内存数据的副本都会被存到工作内存。它对应JVM中的Java栈，每一个线程都有一个私有的工作空间，工作空间的空间大小分配和Java栈是一起的，都是根据需要代码需要在编译期间就确定好的，</li><li>工作方式：<ul><li>A线程修改私有数据，直接在工作空间修改</li><li>B线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据</li></ul></li></ol><p><strong>JMM 的 八种同步操作</strong></p><p><img src="/attachment/0426300d65655309f09e8f9a73ff9029.png"></p><p><strong>happens-before</strong></p><p>判断数据是否存在竞争、线程是否安全的依据</p><ul><li>次序规则</li><li>锁定规则</li><li>volatile变量规则</li><li>传递规则</li><li>线程启动规则</li><li>线程终止规则</li><li>对象终结规则</li></ul><p><strong>三大特性</strong></p><ul><li>可见性<ul><li>volatile</li><li>synchronized</li><li>JUC中Lock的lock</li></ul></li><li>原子性<ul><li>Synchronized：同步代码块</li><li>JUC中Lock的lock：加锁</li></ul></li><li>有序性<ul><li>volatile之前的代码不能调整到它的后面</li><li>volatile之后的代码不能调整到它的前面</li><li>霸道（位置不变化）volatile实现可见性的硬件基础就是cache line</li></ul></li></ul><h2 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h2><ul><li>线程间如何通信？即：线程之间以何种机制来交换信息</li><li>线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序</li></ul><p>有两种并发模型可以解决这两个问题：</p><ul><li>消息传递并发模型</li><li>共享内存并发模型</li></ul><p>这两种模型之间的区别如下表所示：</p><table><thead><tr><th></th><th>如何通信</th><th>如何同步</th></tr></thead><tbody><tr><td>消息传递并发模型</td><td>线程之间没有公共状态,线程间的通信必须通过发送消息来显示进行通信。</td><td>发送消息天然同步,因为发送消息总是在接受消息之前,因此同步是隐式的。</td></tr><tr><td>共享内存并发模型</td><td>线程之间共享程序的公共状态,通过写-读内存中的公共状态进行隐式通信。</td><td>必须显式指定某段代码需要在线程之间互斥执行,同步是显式的。</td></tr></tbody></table><p>在Java中，使用的是共享内存并发模型。</p><h2 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h2><p><img src="/attachment/523f614869c81dd1d6ee5e4cae416e22.png"></p><h3 id="什么是JMM（JMM的作用）"><a href="#什么是JMM（JMM的作用）" class="headerlink" title="什么是JMM（JMM的作用）"></a>什么是JMM（JMM的作用）</h3><p>JMM（Java内存模型Java Memory Model）本身是一种抽象的概念并不真实存在，它仅仅描述的是一组约定或规范，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</p><p>能干吗？</p><ul><li>通过JMM来实现线程和主内存之间的抽象关系</li><li>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序再各种平台下都能达到一致性的内存访问效果。</li></ul><h3 id="JMM的组成"><a href="#JMM的组成" class="headerlink" title="JMM的组成"></a>JMM的组成</h3><ol><li>主内存：共享的信息，也就是图中的内存区域，它也就对应着JVM内存区域中的堆</li><li>工作内存：私有信息，也就是图中的工作空间，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中。局部变量，主内存数据的副本都会被存到工作内存。它对应JVM中的Java栈，每一个线程都有一个私有的工作空间，工作空间的空间大小分配和Java栈是一起的，都是根据需要代码需要在编译期间就确定好的，</li><li>工作方式：<ul><li>A线程修改私有数据，直接在工作空间修改</li><li>B线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据</li></ul></li></ol><h3 id="运行时内存的划分"><a href="#运行时内存的划分" class="headerlink" title="运行时内存的划分"></a>运行时内存的划分</h3><p>先谈一下运行时数据区，下面这张图相信大家一点都不陌生：</p><p><img src="/attachment/d38f379fe4e7647c6952a31b31936a78.png"></p><p>对于每一个线程来说，栈都是私有的，而堆是共有的。<br>也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量。<br>所以，内存可见性是针对的共享变量。</p><h3 id="既然堆是共享的，为什么在堆中会有内存不可见问题？"><a href="#既然堆是共享的，为什么在堆中会有内存不可见问题？" class="headerlink" title="既然堆是共享的，为什么在堆中会有内存不可见问题？"></a>既然堆是共享的，为什么在堆中会有内存不可见问题？</h3><p>这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。</p><p>线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。</p><p>Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。JMM的抽象示意图如图所示：</p><p><img src="/attachment/4232c4babc83339d326ebad6e16cde6e.png"></p><p>从图中可以看出： </p><ol><li>所有的共享变量都存在主内存中。 </li><li>每个线程都保存了一份该线程使用到的共享变量的副本。 </li><li>如果线程A与线程B之间要通信的话，</li></ol><p>必须经历下面2个步骤：</p><ol><li>线程A将本地内存A中更新过的共享变量刷新到主内存中去。</li><li>线程B到主内存中去读取线程A之前已经更新过的共享变量。</li></ol><p>所以，线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。<br>注意，根据JMM的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。</p><p>所以线程B并不是直接去主内存中读取共享变量的值，而是先在本地内存B中找到这个共享变量，发现这个共享变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B再读取本地内存B中的新值。</p><p>那么怎么知道这个共享变量的被其他线程更新了呢？这就是JMM的功劳了，也是JMM存在的必要性之一。JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。</p><h3 id="JMM与Java内存区域划分的区别与联系"><a href="#JMM与Java内存区域划分的区别与联系" class="headerlink" title="JMM与Java内存区域划分的区别与联系"></a>JMM与Java内存区域划分的区别与联系</h3><p>上面两小节分别提到了JMM和Java运行时内存区域的划分，这两者既有差别又有联系：<br><strong>区别</strong><br>两者是不同的概念层次。JMM是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。<br><strong>联系</strong><br>都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</p><h2 id="硬件内存架构与java内存模型"><a href="#硬件内存架构与java内存模型" class="headerlink" title="硬件内存架构与java内存模型"></a>硬件内存架构与java内存模型</h2><h3 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h3><p><img src="/attachment/112a4f07cf8a52beeeb4595092eaa727.png"></p><p>像上面这种图就是多核的机器，每一个CPU都对应着一个cache，cache中的数据是对应CPU私有的，内存中的数据是所有CPU共享的。</p><p>在说明Java并发特性之前，先简单了解一下物理计算机中的并发问题，这二者有不少相似之处。物理机对并发的处理方案对于虚拟机也有很大的参考意义。</p><p>“并发”在计算机领域内，一直是比较头疼。因为并发不仅仅是计算的事情，也是存储的事情。我们在处理并发时，不可能只靠CPU就能完成，也需要与内存交互，比如读取运算数据，存储运算结果等。</p><p>但是，由于CPU的处理效率和内存的处理效率差了几个数量级，计算机不得不引入高速缓存作为内存和CPU之间的缓冲，将运算需要使用的数据复制到缓存中，减少I/O瓶颈，加速运算，当运算完成之后，再将数据从缓存同步回内存中，这样能够提升不少处理的效率。</p><p>不过，在引入高速缓存的同时，也带来了另外一个问题——缓存一致性。每个处理器都有自己的高速缓存，而他们又共享同一主内存，当多个处理器任务都是涉及到同一块主内存区域时，就会出现缓存数据不一致的问题。</p><p>同时，为了解决一致性的问题，高速缓存就需要遵守一些一致性协议（MSI等协议）来规范对数据的读写。</p><p><strong>具体示意图，如下：</strong></p><p><img src="/attachment/dd471e976dc3d44d327229c996aae596.png"></p><blockquote><p>注：引入物理计算机并发的概念，主要是为了提供一种思路，实际上的实现远比描述的要复杂。</p></blockquote><p>CPU缓存的一致性问题：并发处理的不同步。比如CPU1将共享数据1改成2，如果CPU1修改完了CPU2再去读取就会读取到2，如果CPU1没有修改完CPU2读取到的就是1，有可能造成脏读的问题，这就是并发处理不同步。</p><p><strong>解决方案</strong>：</p><ol><li>总线加锁，直接在总线上锁定该资源只能同时被一个CPU使用，这样就解决了CPU数据同步问题。但是这会降低CPU的吞吐量，降低计算机效率缓存上的一致性协议（MESI协议，用来保证Cache一致性）</li><li>当CPU在cache中操作数据时，如果该数据是共享变量，数据从cache读到寄存器中，进行新修改，同时将该数据的cache line标志位置为无效，然后更新内存数据。因为修改完数据之后，该数据以前在其他CPU的cache中就失效了，不能再读取了，将标志置为无效是为了让其他CPU直接去内存中读取最新的该数据，然后再更新自己的cache数据，这样就解决了不同步问题。</li></ol><p>JMM和硬件内存结构的工作方式很相似，JMM中的工作空间对应的就是cache和寄存器，JMM中的主内存对应的就是硬件中的内存。</p><h3 id="Java线程与硬件处理器"><a href="#Java线程与硬件处理器" class="headerlink" title="Java线程与硬件处理器"></a>Java线程与硬件处理器</h3><p><img src="/attachment/a29df0096012b749b6ec4877e926177b.png"></p><p>整个流程就是用户指定任务交给线程池，由线程池去分配进程用来执行这些任务，一个任务也就对应着一个线程，每一个Java线程是需要映射到一个真实的操作系统线程，通过操作系统线程完成任务的，将Java线程映射到操作系统线程，对线程的挂起或唤醒，这些操作都需要操作系统线程来完成，这就需要请求OS内核的帮助，需要操作系统由用户态转变成内核态，给每一个线程分配一个内核线程，然后内核线程被交给CPU进行操作。</p><p>模型分为主内存和工作内存，所有的变量（局部变量除外，局部变量都是线程私有的，不存在并发问题）都存储在主内存中。每条线程具有自己的工作内存，其中工作内存中保存了线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接操作主内存中的变量。不同线程之间是无法访问对方的工作内存，线程间变量值的传递均需要通过主内存来完成，示意图如下：</p><p><img src="/attachment/ad94fbe3d9a07c2c0b489f6148f56d1b.png"></p><h3 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h3><p><img src="/attachment/0a0e81cf686fbffe669a6ae55aa9a6fb.png"></p><p>由上面的讲解可知，工作空间和内存都对应着硬件系统的寄存器，cache和内存。这种交叉的关系也就造成了在多线程并发的环境下很容易出现数据不同步的问题。</p><p>注：这里提到的主内存和工作内存，实际上和我们常说的Java内存分为堆、栈、方法区等并不是同一层次的划分，二者基本上没有直接联系。如果一定要勉强对应的话，那主内存主要对应于Java堆中的对象实例部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存直接对应于物理硬件的内存，而工作内存可能优先存储于高速缓存中。</p><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从 工作内存同步回主内存这一类的实现细节，Java内存模型中定义了8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说， load、store、read和write操作在某些平台上允许有例外。</p><h3 id="Java内存模型的必要性"><a href="#Java内存模型的必要性" class="headerlink" title="Java内存模型的必要性"></a>Java内存模型的必要性</h3><p>Java内存模型（JMM）的作用：规范内存数据和工作空间数据的交互。来解决数据不同步的问题</p><p>关于主内存与工作内存之间具体的交互协议，也就是说，一个变量如何从主内存拷贝到工作内存，又是如何从工作内存同步回到主内存的。Java定义了8种操作来实现的，并且虚拟机保证每一种操作都是原子的。</p><p>8种操作分别是lock、unlock、read、load、use、assign、store、write.</p><p><img src="/attachment/64976041e7c27bebebabb0661925dc44.png"></p><p>上图所示，是两组操作，一组是读取，一组是写入。<br>值得注意的是，Java模型只要求这两个操作必须是顺序执行，但并没有保证是连续执行，这点区别是非常大的。<br>也就是说，read和load之间、store和write之间是可以插入其他指令的。</p><h2 id="JMM-的-八种同步操作"><a href="#JMM-的-八种同步操作" class="headerlink" title="JMM 的 八种同步操作"></a>JMM 的 八种同步操作</h2><p><img src="/attachment/0426300d65655309f09e8f9a73ff9029.png"></p><ul><li>锁定（lock）: 作用于主内存中的变量，将他标记为一个线程独享变量。</li><li>解锁（unlock）: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li><li>load(载入)：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li><li>use(使用)：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li><li>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>Java内存模型还规定了执行上述8种基本操作时必须满足如下规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</li></ul><h2 id="JMM规范下多线程先行发生原则之happens-before"><a href="#JMM规范下多线程先行发生原则之happens-before" class="headerlink" title="JMM规范下多线程先行发生原则之happens-before"></a>JMM规范下多线程先行发生原则之happens-before</h2><p>在JVM中，如果一个操作执行的结果需要对另一个操作可见或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则，逻辑上的先后关系。</p><h3 id="先行并发原则说明"><a href="#先行并发原则说明" class="headerlink" title="先行并发原则说明"></a>先行并发原则说明</h3><p>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将变得非常罗嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。<br>我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为<strong>Java语言中JMM原则下，有一个“先行发生”（happens-before）的原则限制和规矩</strong>，给你理好了规矩！<br>这个原则非常重要：它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型晦涩难懂的底层编译原理之中。</p><h3 id="happens-before总原则"><a href="#happens-before总原则" class="headerlink" title="happens-before总原则"></a>happens-before总原则</h3><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li><li>如果两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><h3 id="happens-before之8条"><a href="#happens-before之8条" class="headerlink" title="happens-before之8条"></a>happens-before之8条</h3><p>从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：</p><ol><li><mark style="background: #FFB8EBA6;">次序规则</mark>：一个线程内，按照代码的顺序，写在前面的操作先行发生于写在后面的操作，也就是说前一个操作的结果可以被后续的操作获取（保证语义串行性，按照代码顺序执行）。比如前一个操作把变量x赋值为1，那后面一个操作肯定能知道x已经变成了1</li><li><mark style="background: #FFB8EBA6;">锁定规则</mark>：一个unLock操作先行发生于后面对同一个锁的lock操作（后面指时间上的先后）。</li><li><mark style="background: #FFB8EBA6;">volatile变量规则</mark>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的后面同样指时间上的先后</li><li><mark style="background: #FFB8EBA6;">传递规则</mark>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</li><li><mark style="background: #FFB8EBA6;">线程启动规则</mark>（Thread start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作</li><li><mark style="background: #FFB8EBA6;">线程中断规则</mark>（Thread Interruption Rule）：<br>  a. 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>  b. 可以通过Thread.interrupted()检测到是否发生中断<br>  c. 也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发生</li><li><mark style="background: #FFB8EBA6;">线程终止规则</mark>（Thread Termination Rule）：线程中的所有操作都优先发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</li><li><mark style="background: #FFB8EBA6;">对象终结规则</mark>（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize(）方法的开始——-&gt;对象没有完成初始化之前，是不能调用finalized()方法的</li></ol><h3 id="happens-before小总结"><a href="#happens-before小总结" class="headerlink" title="happens-before小总结"></a>happens-before小总结</h3><ul><li>在Java语言里面，Happens-before的语义本质上是一种可见性</li><li>A happens-before B ,意味着A发生过的事情对B而言是可见的，无论A事件和B事件是否发生在同一线程里</li><li>JVM的设计分为两部分：<ul><li>一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了</li><li>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提升性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序，我们只要关注前者就好了，也就是理解happens-before规则即可，其他繁杂的内容由JMM规范结合操作系统给我们搞定，我们只写好代码即可。</li></ul></li></ul><h2 id="JMM规范下三大特性"><a href="#JMM规范下三大特性" class="headerlink" title="JMM规范下三大特性"></a>JMM规范下三大特性</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内存中。</p><p><img src="/attachment/cf370572af5bfa52acdff59826767757.png"></p><p>系统中主内存<mark style="background: #FFB8EBA6;">共享变量</mark>数据修改被写入的时机是不确定的，<mark style="background: #ADCCFFA6;">多线程并发下很可能出现“脏读”</mark>，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的<mark style="background: #FFB8EBA6;">主内存副本拷贝</mark>，线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行，而不能够直接写入主内存中的变量，不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p>线程只能操作自己工作空间中的数据，对其他线程的工作空间不可见。但是并发编程中一个线程对共享变量进行了修改，另一个线程要能立刻看到被改后的最新值。</p><p>线程1对共享变量的修改如果要被线程2及时看到，需要经过2个步骤：</p><ol><li>把工作内存1中更新过的共享变量值刷新到主内存中</li><li>把主内存中最新的共享变量的值更新打工作内存2中</li></ol><p><strong>线程脏读</strong></p><ol><li>主内存中有变量X，初始值为0</li><li>线程A要将X加1，先将X=0拷贝到自己的私有内存中，然后更新X的值</li><li>线程A将更新后的X值回刷到主内存的时间是不固定的</li><li>刚好在线程A没有回刷x到主内存时，线程B同样从主内存中读取X，此时为0，和线程A一样的操作，最后期盼的X=2就会变成X=1</li></ol><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>所谓原子性，是指在一次操作或多次操作中，要么所有的操作全部执行，并不会受到人任何元素的干扰而中断，要么所有的操作都不执行，中间不会有任何上下文切换（context switch）。比如：A给B转账100，A账户扣除100，B账户账户收入100，这两个操作必须符合原子性，要么都成功，要么都失败。所以并发编程就需要将应该是原子操作的一系列操作封装成一个原子操作。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>对于一个线程的执行代码而言，我们总是习惯性地认为代码的执行总是从上到下，有序执行。但为了提升性能，<mark style="background: #FFB8EBA6;">编译器和处理器通常会对指令序列进行重新排序</mark>。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序话执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫<mark style="background: #FFB8EBA6;">指令的重排序</mark>。</p><p>程序中的顺序不一定就是执行的顺序,因为系统会对代码进行一次重排序，重排序的作用就是提高效率。但是虽然指令重排不会影响单线程的执行结果，但是会影响多线程并发执行的结果正确性，所以并发编程就要保证重排序之后的有序性，执行结果不能因为重排序而出错。重排序有三种：</p><ol><li>编译器优化的重排序（编译期间）：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序（运行期间）：现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><h4 id="JMM在保证有序性时所使用的两个原则："><a href="#JMM在保证有序性时所使用的两个原则：" class="headerlink" title="JMM在保证有序性时所使用的两个原则："></a>JMM在保证有序性时所使用的两个原则：</h4><ul><li>as-if-seria（单线程遵循）:在单线程中，无论如何重排序，程序执行的结果都应该与代码顺序执行的结果一致（java编译器和处理器运行时都会保证在单线程中遵循as-if-serial规则，多线程存在程序交错执行时，则不遵守）</li><li>happens-before（多线程遵循）：在发生操作B之前，操作A产生的影响都能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等，它与时间上的先后发生基本没有太大关系。这个是多线程中程序运行遵守的原则，保证在多线程环境下程序运行结果不会出错，后面有对其的详细讲解。重排序也就是遵守这个原则。</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令更符合CPU的执行特性，最大限度的发挥机器性能。</p></li><li><p>但是指令重排可以保证串行语义一致，但没有义务保证多线程的语义也一致（即可能产生“脏读”），简单而言就是两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。</p><p>从源码到最终执行示例图：</p></li></ul><p><img src="/attachment/1a0f00d848a90c2d0d3842dba9c61696.png"></p><ul><li>单线程环境里确实能够保证程序最终执行结果和代码顺序执行的结果一致</li><li>处理器在进行重排序时必须考虑到指令之间的数据依赖性</li><li>多线程环境中线程交替执行，由于编译器优化重排的存在，可能出现乱序现象，两个线程使用的变量能否保证一致性是无法确定的，结果无法预测。</li></ul><h2 id="JMM对三个特征的保证"><a href="#JMM对三个特征的保证" class="headerlink" title="JMM对三个特征的保证"></a>JMM对三个特征的保证</h2><p>一个正确执行的并发程序，必须具备原子性、可见性、有序性。否则就有可能导致程序运行结果不正确，甚至引起死循环。</p><h3 id="JMM与原子性"><a href="#JMM与原子性" class="headerlink" title="JMM与原子性"></a>JMM与原子性</h3><ul><li>y=x  没有原子性<ul><li>把数据X读到工作空间（原子性）</li><li>把X的值写到Y（原子性）</li></ul></li><li>i++ 没有原子性<ul><li>读i到工作空间</li><li>+1；</li><li>刷新结果到内存</li></ul></li><li>z=z+1 没有原子性<ul><li>读z到工作空间</li><li>+1；</li><li>刷新结果到内存<br>由上面的这些例子可知多个原子性的操作合并到一起没有原子性</li></ul></li></ul><h4 id="JMM对原子性的保证方式："><a href="#JMM对原子性的保证方式：" class="headerlink" title="JMM对原子性的保证方式："></a>JMM对原子性的保证方式：</h4><ol><li>Synchronized：同步代码块</li><li>JUC中Lock的lock：加锁</li></ol><h3 id="JMM与可见性"><a href="#JMM与可见性" class="headerlink" title="JMM与可见性"></a>JMM与可见性</h3><h4 id="JMM对可见性的保证方式："><a href="#JMM对可见性的保证方式：" class="headerlink" title="JMM对可见性的保证方式："></a>JMM对可见性的保证方式：</h4><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>在JMM模型上实现MESI协议，也就是在变量使用volatile关键字，一个线程将内存中的有volatile关键字标识的变量拿到工作空间进行修改后，就会通知其他线程再访问这个变量的话直接到内存中去找，就不要在自己的工作空间找了，因为数据已经被修改了。</p><p>深入来说，是通过加入内存屏障和禁止重排序优化来实现的：</p><ul><li>对volatile变量执行写操作时，会在写操作后加入一条store屏障指令，会将cpu数据强制刷新到主内存中去</li><li>对volatile变量执行读操作时，会在读操作前加入一条load屏障指令，强制缓存器中的缓存失效，每次使用都要去主内存中重新获取数据</li></ul><p>通俗地讲，volatile变量在每次被访问的时候，都强迫从主内存中读取该变量的值，而当该变量在发生变化时，又会强迫变量讲最新的值刷新到主内存中，这样，任意时刻，不同的线程总能看到该变量的最新值。</p><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>使用synchronized加锁来保证可见性，它会保证两条原则：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新值（注意：加锁与解锁需要是同一把锁）</li></ul><h5 id="JUC中Lock的lock"><a href="#JUC中Lock的lock" class="headerlink" title="JUC中Lock的lock"></a>JUC中Lock的lock</h5><h3 id="JMM与有序性"><a href="#JMM与有序性" class="headerlink" title="JMM与有序性"></a>JMM与有序性</h3><h4 id="JMM对有序性的保证方式："><a href="#JMM对有序性的保证方式：" class="headerlink" title="JMM对有序性的保证方式："></a>JMM对有序性的保证方式：</h4><h5 id="volatile-1"><a href="#volatile-1" class="headerlink" title="volatile"></a>volatile</h5><p>被加了volatile关键字的变量不会被重排序。</p><p>对于volatile修饰的变量：</p><ul><li>volatile之前的代码不能调整到它的后面</li><li>volatile之后的代码不能调整到它的前面</li><li>霸道（位置不变化）volatile实现可见性的硬件基础就是cache line</li></ul><h5 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h5><p>被它括起来的代码块内部会进行重排序，但是同步代码块整体在所有代码中的顺序不会改变。</p><p>对synchronized同步代码块：</p><ul><li>同步代码块之前的代码不能调到它后面</li><li>同步代码块之后的代码不能调到它前面</li></ul><h4 id="JMM对有序保证按照Happens-before原则"><a href="#JMM对有序保证按照Happens-before原则" class="headerlink" title="JMM对有序保证按照Happens-before原则"></a>JMM对有序保证按照Happens-before原则</h4><h4 id="时间上的先后与happens-before的关系"><a href="#时间上的先后与happens-before的关系" class="headerlink" title="时间上的先后与happens-before的关系"></a>时间上的先后与happens-before的关系</h4><p>一个操作时间上先发生于另一个操作“并不代表”一个操作happen—before另一个操作。<br>一个操作happen—before另一个操作“并不代表”一个操作时间上先发生于另一个操作。</p><h2 id="JMM规范下多线程对变量的读写过程"><a href="#JMM规范下多线程对变量的读写过程" class="headerlink" title="JMM规范下多线程对变量的读写过程"></a>JMM规范下多线程对变量的读写过程</h2><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有的地方成为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读写赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存存储着主内存中的变量副本拷贝，因此不同的线程无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：</p><p><img src="/attachment/49ba82d7ded516013887259e45370677.png"></p><p>JMM定义了线程和主内存之间的抽象关系：</p><ul><li>线程之间的共享变量存储在主内存中（从硬件角度讲就是内存条）</li><li>每个线程都有一个自己的本地工作内存，本地工作内存中存储了该线程用来读写共享变量的副本（从硬件角度来说就是CPU的缓存）</li></ul><p>小总结：</p><ul><li>我们定义的所有共享变量都储存在物理主内存中</li><li>每个线程都有自己独立的工作内存，里面保证该线程使用到的共享变量的副本（主内存中该变量的一份拷贝）</li><li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存在读写（不能越级）</li><li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能互相访问）。</li></ul><h2 id="JMM与多线程通信"><a href="#JMM与多线程通信" class="headerlink" title="JMM与多线程通信"></a>JMM与多线程通信</h2><p>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p><p><img src="/attachment/09ff9972fe7865f954779084f2596ef7.png"></p><p>线程间通信的步骤：</p><p>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</p><p><img src="/attachment/8ecd0f1dfdf3afecfa20e5a4c6a10f62.png"></p><p>本地内存A和B有主内存中共享变量x的副本。</p><ul><li>假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。</li><li>当线程A和线程B需要通信时（如何激发？–隐式），线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。</li><li>随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</li></ul><p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Java线程间的通信</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-java-xian-cheng-jian-de-tong-xin/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-java-xian-cheng-jian-de-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Java线程间的通信"><a href="#【Java-多线程并发】-Java线程间的通信" class="headerlink" title="【Java 多线程并发】 Java线程间的通信"></a>【Java 多线程并发】 Java线程间的通信</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Java线程间的通信date: 2023-07-03 13:25tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 Java线程间的通信</code></pre><h2 id="【Java-多线程并发】-Java线程间的通信-1"><a href="#【Java-多线程并发】-Java线程间的通信-1" class="headerlink" title="【Java 多线程并发】 Java线程间的通信"></a>【Java 多线程并发】 Java线程间的通信</h2><p>合理的使用Java多线程可以更好地利用服务器资源。一般来讲，线程内部有自己私有的线程上下文，互不干扰。但是当我们需要多个线程之间相互协作的时候，就需要我们掌握Java线程的通信方式。本文将介绍Java线程之间的几种通信原理。</p><h2 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h2><p>在Java中，锁的概念都是基于对象的，所以我们又经常称它为对象锁。线程和锁的关系，我们可以用婚姻关系来理解。一个锁同一时间只能被一个线程持有。也就是说，一个锁如果和一个线程“结婚”（持有），那其他线程如果需要得到这个锁，就得等这个线程和这个锁“离婚”（释放）。</p><p>在我们的线程之间，有一个同步的概念。什么是同步呢，假如我们现在有2位正在抄暑假作业答案的同学：线程A和线程B。当他们正在抄的时候，老师突然来修改了一些答案，可能A和B最后写出的暑假作业就不一样。我们为了A,B能写出2本相同的暑假作业，我们就需要让老师先修改答案，然后A，B同学再抄。或者A，B同学先抄完，老师再修改答案。这就是线程A，线程B的线程同步。</p><p>可以以解释为：线程同步是线程之间按照一定的顺序执行。</p><p>为了达到线程同步，我们可以使用锁来实现它。</p><p>我们先来看看一个无锁的程序：</p><pre><code class="line-numbers language-java">public class NoneLock {    static class ThreadA implements Runnable {        @Override        public void run() {            for (int i = 0; i &lt; 100; i++) {                System.out.println("Thread A " + i);            }        }    }    static class ThreadB implements Runnable {        @Override        public void run() {            for (int i = 0; i &lt; 100; i++) {                System.out.println("Thread B " + i);            }        }    }    public static void main(String[] args) {        new Thread(new ThreadA()).start();        new Thread(new ThreadB()).start();    }}</code></pre><p>那我现在有一个需求，我想等A先执行完之后，再由B去执行，怎么办呢？最简单的方式就是使用一个“对象锁”：</p><pre><code class="line-numbers language-java">public class ObjectLock {    private static Object lock = new Object();    static class ThreadA implements Runnable {        @Override        public void run() {            synchronized (lock) {                for (int i = 0; i &lt; 100; i++) {                    System.out.println("Thread A " + i);                }            }        }    }    static class ThreadB implements Runnable {        @Override        public void run() {            synchronized (lock) {                for (int i = 0; i &lt; 100; i++) {                    System.out.println("Thread B " + i);                }            }        }    }    public static void main(String[] args) throws InterruptedException {        new Thread(new ThreadA()).start();        Thread.sleep(10);        new Thread(new ThreadB()).start();    }}</code></pre><p>这里声明了一个名字为lock的对象锁。我们在ThreadA和ThreadB内需要同步的代码块里，都是用synchronized关键字加上了同一个对象锁lock。</p><p>上文我们说到了，根据线程和锁的关系，同一时间只有一个线程持有一个锁，那么线程B就会等线程A执行完成后释放lock，线程B才能获得锁lock。</p><blockquote><p>这里在主线程里使用sleep方法睡眠了10毫秒，是为了防止线程B先得到锁。因为如果同时start，线程A和线程B都是出于就绪状态，操作系统可能会先让B运行。这样就会先输出B的内容，然后B执行完成之后自动释放锁，线程A再执行。</p></blockquote><h2 id="等待-x2F-通知机制"><a href="#等待-x2F-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>上面一种基于“锁”的方式，线程需要不断地去尝试获得锁，如果失败了，再继续尝试。这可能会耗费服务器资源。</p><p>而等待/通知机制是另一种方式。</p><p>Java多线程的等待/通知机制是基于Object类的wait()方法和notify(), notifyAll()方法来实现的。</p><blockquote><p>notify()方法会随机叫醒一个正在等待的线程，而notifyAll()会叫醒所有正在等待的线程。</p></blockquote><p>前面我们讲到，一个锁同一时刻只能被一个线程持有。而假如线程A现在持有了一个锁lock并开始执行，它可以使用lock.wait()让自己进入等待状态。这个时候，lock这个锁是被释放了的。</p><p>这时，线程B获得了lock这个锁并开始执行，它可以在某一时刻，使用lock.notify()，通知之前持有lock锁并进入等待状态的线程A，说“线程A你不用等了，可以往下执行了”。</p><blockquote><p>需要注意的是，这个时候线程B并没有释放锁lock，除非线程B这个时候使用lock.wait()释放锁，或者线程B执行结束自行释放锁，线程A才能得到lock锁。</p></blockquote><p>我们用代码来实现一下：</p><pre><code class="line-numbers language-java">public class WaitAndNotify {    private static Object lock = new Object();    static class ThreadA implements Runnable {        @Override        public void run() {            synchronized (lock) {                for (int i = 0; i &lt; 5; i++) {                    try {                        System.out.println("ThreadA: " + i);                        lock.notify();                        lock.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                lock.notify();            }        }    }    static class ThreadB implements Runnable {        @Override        public void run() {            synchronized (lock) {                for (int i = 0; i &lt; 5; i++) {                    try {                        System.out.println("ThreadB: " + i);                        lock.notify();                        lock.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                lock.notify();            }        }    }    public static void main(String[] args) throws InterruptedException {        new Thread(new ThreadA()).start();        Thread.sleep(1000);        new Thread(new ThreadB()).start();    }}// 输出：ThreadA: 0ThreadB: 0ThreadA: 1ThreadB: 1ThreadA: 2ThreadB: 2ThreadA: 3ThreadB: 3ThreadA: 4ThreadB: 4</code></pre><p>在这个Demo里，线程A和线程B首先打印出自己需要的东西，然后使用notify()方法叫醒另一个正在等待的线程，然后自己使用wait()方法陷入等待并释放lock锁。</p><blockquote><p>需要注意的是等待/通知机制使用的是使用同一个对象锁，如果你两个线程使用的是不同的对象锁，那它们之间是不能用等待/通知机制通信的。</p></blockquote><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>JDK提供了一个类似于“信号量”功能的类Semaphore。但本文不是要介绍这个类，而是介绍一种基于volatile关键字的自己实现的信号量通信。<br>后面会有专门的章节介绍volatile关键字，这里只是做一个简单的介绍。</p><blockquote><p>volitile关键字能够保证内存的可见性，如果用volitile关键字声明了一个变量，在一个线程里面改变了这个变量的值，那其它线程是立马可见更改后的值的。</p></blockquote><p>比如我现在有一个需求，我想让线程A输出0，然后线程B输出1，再然后线程A输出2…以此类推。我应该怎样实现呢？</p><p>代码：</p><pre><code class="line-numbers language-java">public class Signal {    private static volatile int signal = 0;    static class ThreadA implements Runnable {        @Override        public void run() {            while (signal &lt; 5) {                if (signal % 2 == 0) {                    System.out.println("threadA: " + signal);                    synchronized (this) {                        signal++;                    }                }            }        }    }    static class ThreadB implements Runnable {        @Override        public void run() {            while (signal &lt; 5) {                if (signal % 2 == 1) {                    System.out.println("threadB: " + signal);                    synchronized (this) {                        signal = signal + 1;                    }                }            }        }    }    public static void main(String[] args) throws InterruptedException {        new Thread(new ThreadA()).start();        Thread.sleep(1000);        new Thread(new ThreadB()).start();    }}// 输出：threadA: 0threadB: 1threadA: 2threadB: 3threadA: 4</code></pre><p>我们可以看到，使用了一个volatile变量signal来实现了“信号量”的模型。这里需要注意的是，volatile变量需要进行原子操作。signal++并不是一个原子操作，所以我们需要使用synchronized给它“上锁”。</p><blockquote><p>这种实现方式并不一定高效，本例只是演示信号量</p></blockquote><p>信号量的应用场景：</p><p>假如在一个停车场中，车位是我们的公共资源，线程就如同车辆，而看门的管理员就是起的“信号量”的作用。</p><p>因为在这种场景下，多个线程（超过2个）需要相互合作，我们用简单的“锁”和“等待通知机制”就不那么方便了。这个时候就可以用到信号量。</p><p>其实JDK中提供的很多多线程通信工具类都是基于信号量模型的。我们会在后面第三篇的文章中介绍一些常用的通信工具类。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是基于“管道流”的通信方式。JDK提供了PipedWriter、 PipedReader、 PipedOutputStream、 PipedInputStream。其中，前面两个是基于字符的，后面两个是基于字节流的。</p><p>这里的示例代码使用的是基于字符的：</p><pre><code class="line-numbers language-java">public class Pipe {    static class ReaderThread implements Runnable {        private PipedReader reader;        public ReaderThread(PipedReader reader) {            this.reader = reader;        }        @Override        public void run() {            System.out.println("this is reader");            int receive = 0;            try {                while ((receive = reader.read()) != -1) {                    System.out.print((char)receive);                }            } catch (IOException e) {                e.printStackTrace();            }        }    }    static class WriterThread implements Runnable {        private PipedWriter writer;        public WriterThread(PipedWriter writer) {            this.writer = writer;        }        @Override        public void run() {            System.out.println("this is writer");            int receive = 0;            try {                writer.write("test");            } catch (IOException e) {                e.printStackTrace();            } finally {                try {                    writer.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }    public static void main(String[] args) throws IOException, InterruptedException {        PipedWriter writer = new PipedWriter();        PipedReader reader = new PipedReader();        writer.connect(reader); // 这里注意一定要连接，才能通信        new Thread(new ReaderThread(reader)).start();        Thread.sleep(1000);        new Thread(new WriterThread(writer)).start();    }}// 输出：this is readerthis is writertest</code></pre><p>我们通过线程的构造函数，传入了PipedWrite和PipedReader对象。可以简单分析一下这个示例代码的执行流程：</p><ol><li>线程ReaderThread开始执行，</li><li>线程ReaderThread使用管道reader.read()进入”阻塞“，</li><li>线程WriterThread开始执行，</li><li>线程WriterThread用writer.write(“test”)往管道写入字符串，</li><li>线程WriterThread使用writer.close()结束管道写入，并执行完毕，</li><li>线程ReaderThread接受到管道输出的字符串并打印，</li><li>线程ReaderThread执行完毕。</li><li>管道通信的应用场景：</li></ol><p>这个很好理解。使用管道多半与I/O流相关。当我们一个线程需要先另一个线程发送一个信息（比如字符串）或者文件等等时，就需要使用管道通信了。</p><h2 id="其它通信相关"><a href="#其它通信相关" class="headerlink" title="其它通信相关"></a>其它通信相关</h2><p>以上介绍了一些线程间通信的基本原理和方法。除此以外，还有一些与线程通信相关的知识点，这里一并介绍。</p><h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>join()方法是Thread类的一个实例方法。它的作用是让当前线程陷入“等待”状态，等join的这个线程执行完成后，再继续执行当前线程。</p><p>有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。</p><p>如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法了。</p><p>示例代码：</p><pre><code class="line-numbers language-java">public class Join {    static class ThreadA implements Runnable {        @Override        public void run() {            try {                System.out.println("我是子线程，我先睡一秒");                Thread.sleep(1000);                System.out.println("我是子线程，我睡完了一秒");            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new ThreadA());        thread.start();        thread.join();        System.out.println("如果不加join方法，我会先被打出来，加了就不一样了");    }}</code></pre><blockquote><p>注意join()方法有两个重载方法，一个是join(long)， 一个是join(long, int)。<br>实际上，通过源码你会发现，join()方法及其重载方法底层都是利用了wait(long)这个方法。<br>对于join(long, int)，通过查看源码(JDK 1.8)发现，底层并没有精确到纳秒，而是对第二个参数做了简单的判断和处理。</p></blockquote><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>sleep方法是Thread类的一个静态方法。它的作用是让当前线程睡眠一段时间。它有这样两个方法：</p><ol><li>Thread.sleep(long)</li><li>Thread.sleep(long, int)</li></ol><p>同样，查看源码(JDK 1.8)发现，第二个方法貌似只对第二个参数做了简单的处理，没有精确到纳秒。实际上还是调用的第一个方法。</p><p>这里需要强调一下：sleep方法是不会释放当前的锁的，而wait方法会。这也是最常见的一个多线程面试题。</p><p>它们还有这些区别：</p><ol><li>wait可以指定时间，也可以不指定；而sleep必须指定时间。</li><li>wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。</li><li>wait必须放在同步块或同步方法中，而sleep可以再任意位置</li></ol><h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>ThreadLocal是一个本地线程副本变量工具类。内部是一个弱引用的Map来维护。这里不详细介绍它的原理，而是只是介绍它的使用，以后有独立章节来介绍ThreadLocal类的原理。</p><p>有些朋友称ThreadLocal为线程本地变量或线程本地存储。严格来说，ThreadLocal类并不属于多线程间的通信，而是让每个线程有自己”独立“的变量，线程之间互不影响。它为每个线程都创建一个副本，每个线程可以访问自己内部的副本变量。</p><p>ThreadLocal类最常用的就是set方法和get方法。示例代码：</p><pre><code class="line-numbers language-java">public class ThreadLocalDemo {    static class ThreadA implements Runnable {        private ThreadLocal&lt;String&gt; threadLocal;        public ThreadA(ThreadLocal&lt;String&gt; threadLocal) {            this.threadLocal = threadLocal;        }        @Override        public void run() {            threadLocal.set("A");            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println("ThreadA输出：" + threadLocal.get());        }        static class ThreadB implements Runnable {            private ThreadLocal&lt;String&gt; threadLocal;            public ThreadB(ThreadLocal&lt;String&gt; threadLocal) {                this.threadLocal = threadLocal;            }            @Override            public void run() {                threadLocal.set("B");                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println("ThreadB输出：" + threadLocal.get());            }        }        public static void main(String[] args) {            ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();            new Thread(new ThreadA(threadLocal)).start();            new Thread(new ThreadB(threadLocal)).start();        }    }}// 输出：ThreadA输出：AThreadB输出：B</code></pre><p>可以看到，虽然两个线程使用的同一个ThreadLocal实例（通过构造方法传入），但是它们各自可以存取自己当前线程的一个值。</p><p>那ThreadLocal有什么作用呢？如果只是单纯的想要线程隔离，在每个线程中声明一个私有变量就好了呀，为什么要使用ThreadLocal？</p><p>如果开发者希望将类的某个静态变量（user ID或者transaction ID）与线程状态关联，则可以考虑使用ThreadLocal。</p><p>最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。数据库连接和Session管理涉及多个复杂对象的初始化和关闭。如果在每个线程中声明一些私有变量来进行操作，那这个线程就变得不那么“轻量”了，需要频繁的创建和关闭连接。</p><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>InheritableThreadLocal类与ThreadLocal类稍有不同，Inheritable是继承的意思。它不仅仅是当前线程可以存取副本值，而且它的子线程也可以存取这个副本值。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Runnable</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-runnable/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-runnable/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Runnable"><a href="#【Java-多线程并发】-Runnable" class="headerlink" title="【Java 多线程并发】 Runnable"></a>【Java 多线程并发】 Runnable</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Runnabledate: 2023-07-03 10:17tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Runnable接口是Java中用于表示可执行任务的接口，通过实现该接口并实现run()方法，可以在单独的线程中执行代码逻辑。它是多线程编程中常用的一种方式，可以提高代码的灵活性和可维护性。</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Runnable是Java中的一个接口，位于java.lang包中。<br>它是一个函数式接口，用于表示可以被线程执行的任务。</p><h2 id="【Java-多线程并发】-Runnable-1"><a href="#【Java-多线程并发】-Runnable-1" class="headerlink" title="【Java 多线程并发】 Runnable"></a>【Java 多线程并发】 Runnable</h2><p>Runnable是Java中的一个接口，位于java.lang包中。它是一个函数式接口，用于表示可以被线程执行的任务。实现了Runnable接口的类可以在单独的线程中执行代码逻辑，而不需要继承Thread类。</p><p>Runnable接口只有一个抽象方法run()，该方法没有参数和返回值。当一个线程启动时，会调用Runnable接口实现类的run()方法，在独立的执行线程中执行具体的任务逻辑。</p><p>使用Runnable接口的优势在于，代码逻辑与线程的执行逻辑分离，提高了代码的可维护性和复用性。此外，使用Runnable接口还可以避免单继承的限制，因为一个类可以同时实现多个接口。</p><p>总之，Runnable接口是Java中用于表示可执行任务的接口，通过实现该接口并实现run()方法，可以在单独的线程中执行代码逻辑。它是多线程编程中常用的一种方式，可以提高代码的灵活性和可维护性。</p><h2 id="Runnable-源码"><a href="#Runnable-源码" class="headerlink" title="Runnable 源码"></a>Runnable 源码</h2><h3 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h3><pre><code class="line-numbers language-java">@FunctionalInterfacepublic interface Runnable {    public abstract void run();}</code></pre><h3 id="中文注释版"><a href="#中文注释版" class="headerlink" title="中文注释版"></a>中文注释版</h3><pre><code class="line-numbers language-java">/** * &lt;code&gt;Runnable&lt;/code&gt;接口应该被任何希望被线程执行的类实现。该类必须定义一个无参数的名为&lt;code&gt;run&lt;/code&gt;的方法。 * &lt;p&gt; * 该接口旨在为希望在活动状态下执行代码的对象提供一个常见的协议。例如，&lt;code&gt;Runnable&lt;/code&gt;由&lt;code&gt;Thread&lt;/code&gt;类实现。 * 活动状态意味着线程已经启动但尚未停止。 * &lt;p&gt; * 此外，&lt;code&gt;Runnable&lt;/code&gt;提供了一种方式，使得一个类在不继承&lt;code&gt;Thread&lt;/code&gt;的情况下也可以保持活动状态。 * 实现&lt;code&gt;Runnable&lt;/code&gt;的类可以通过实例化一个&lt;code&gt;Thread&lt;/code&gt;实例并将自身作为目标传递进去来运行。 * 在大多数情况下，如果只打算重写&lt;code&gt;run()&lt;/code&gt;方法而不是其他&lt;code&gt;Thread&lt;/code&gt;方法，应该使用&lt;code&gt;Runnable&lt;/code&gt;接口。 * 这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应该对类进行子类化。 * * @author  Arthur van Hoff * @see     java.lang.Thread * @see     java.util.concurrent.Callable * @since   JDK1.0 */@FunctionalInterfacepublic interface Runnable {    /**     * 当使用实现&lt;code&gt;Runnable&lt;/code&gt;接口的对象创建一个线程时，启动线程会导致该对象的&lt;code&gt;run&lt;/code&gt;方法在单独的执行线程中被调用。     * &lt;p&gt;     * 方法&lt;code&gt;run&lt;/code&gt;的一般约定是它可以执行任何操作。     *     * @see     java.lang.Thread#run()     */    public abstract void run();}</code></pre><h2 id="使用说明及注意点"><a href="#使用说明及注意点" class="headerlink" title="使用说明及注意点"></a>使用说明及注意点</h2><p>根据上述代码的注释，可以总结出以下关于Runnable接口的使用说明和注意点：</p><ol><li>Runnable接口应该被希望在单独的线程中执行的类实现。</li><li>实现Runnable接口的类必须定义一个无参数的run()方法，该方法将在单独的执行线程中被调用。</li><li>Runnable接口为希望在活动状态下执行代码的对象提供了一个常见的协议。</li><li>通过实例化一个Thread对象并将实现了Runnable接口的对象作为目标传递进去，可以使实现了Runnable接口的类在不继承Thread类的情况下保持活动状态。</li><li>在大多数情况下，如果只打算重写run()方法而不是其他Thread方法，应该使用Runnable接口。</li><li>子类化类应该是有意修改或增强类的基本行为才进行的，所以不应该轻易对类进行子类化。</li><li>Runnable接口是一个函数式接口，可以使用lambda表达式或方法引用来实现。</li><li>run()方法的一般约定是可以执行任何操作，根据具体需求编写逻辑。</li></ol><p>总之，通过实现Runnable接口，可以将代码逻辑与线程分离，提高代码的复用性和可维护性。同时，需要注意在run()方法中编写线程执行的具体逻辑，并确保线程安全性。</p><h2 id="Runnable-异常处理"><a href="#Runnable-异常处理" class="headerlink" title="Runnable 异常处理"></a>Runnable 异常处理</h2><p>当Runnable接口的实现类中的run()方法抛出异常时，可以通过以下几种方式来处理异常：</p><h3 id="直接捕获"><a href="#直接捕获" class="headerlink" title="直接捕获"></a>直接捕获</h3><p>在run()方法内部捕获异常：在run()方法的实现中使用try-catch语句来捕获异常并进行处理。这种方式可以在run()方法内部处理异常，但需要确保异常不会被抛出到run()方法之外。</p><pre><code class="line-numbers language-java">public class MyRunnable implements Runnable {    @Override    public void run() {        try {            // 执行可能会抛出异常的代码        } catch (Exception e) {            // 处理异常        }    }}</code></pre><h3 id="声明抛出异常"><a href="#声明抛出异常" class="headerlink" title="声明抛出异常"></a>声明抛出异常</h3><p>在run()方法上使用throws关键字声明异常：在run()方法的声明中使用throws关键字声明可能抛出的异常。这样做可以将异常传递给调用方处理。</p><pre><code class="line-numbers language-java">public class MyRunnable implements Runnable {    @Override    public void run() throws Exception {        // 执行可能会抛出异常的代码    }}</code></pre><h2 id="Thread-UncaughtExceptionHandler"><a href="#Thread-UncaughtExceptionHandler" class="headerlink" title="Thread.UncaughtExceptionHandler"></a>Thread.UncaughtExceptionHandler</h2><p>在run()方法内部使用UncaughtExceptionHandler处理未捕获的异常：可以通过实现Thread.UncaughtExceptionHandler接口，并将其设置为线程的未捕获异常处理程序来处理未捕获的异常。这样做可以在异常未被捕获时进行处理，例如记录日志或进行其他操作。</p><pre><code class="line-numbers language-java">public class MyRunnable implements Runnable {    @Override    public void run() {        // 执行可能会抛出异常的代码    }}public class Main {    public static void main(String[] args) {        Thread thread = new Thread(new MyRunnable());        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                // 处理未捕获的异常            }        });        thread.start();    }}</code></pre><p>根据具体的需求和场景，选择适合的异常处理方式。无论使用哪种方式，都应该确保异常能够得到适当的处理，以避免程序出现不可预料的错误或异常终止。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Thread</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-thread/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-thread/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Thread"><a href="#【Java-多线程并发】-Thread" class="headerlink" title="【Java 多线程并发】 Thread"></a>【Java 多线程并发】 Thread</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Threaddate: 2023-07-03 09:54tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Thread类是Java多线程编程的核心类，通过它可以创建和管理线程，实现多任务并发执行。合理使用Thread类可以提高程序的性能和效率，但也需要注意线程安全问题。</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Thread类是Java中用于创建和管理线程的类。</p><p><strong>Thread类的继承关系</strong></p><p><img src="/attachment/8f7f9535d47c5d3cdd338e4ae25ab51d.png"></p><p><strong>Thread 数据结构</strong></p><pre><code class="line-numbers language-java">//当前线程的名称private volatile String name;//线程的优先级private int            priority;private Thread threadQ;private long eetop;//当前线程是否是单步线程private boolean single_step;//当前线程是否在后台运行private boolean     daemon = false;//Java虚拟机的状态private boolean     stillborn = false;//真正在线程中执行的任务private Runnable target;//当前线程所在的线程组private ThreadGroup group;//当前线程的类加载器private ClassLoader contextClassLoader;//访问控制上下文private AccessControlContext inheritedAccessControlContext;//为匿名线程生成名称的编号private static int threadInitNumber;//与此线程相关的ThreadLocal,这个Map维护的是ThreadLocal类ThreadLocal.ThreadLocalMap threadLocals = null;//与此线程相关的ThreadLocalThreadLocal.ThreadLocalMap inheritableThreadLocals = null;//当前线程请求的堆栈大小，如果未指定堆栈大小，则会交给JVM来处理private long stackSize;//线程终止后存在的JVM私有状态private long nativeParkEventPointer;//线程的idprivate long tid;//用于生成线程idprivate static long threadSeqNumber;//当前线程的状态，初始化为0，代表当前线程还未启动private volatile int threadStatus = 0;//由（私有）java.util.concurrent.locks.LockSupport.setBlocker设置//使用java.util.concurrent.locks.LockSupport.getBlocker访问volatile Object parkBlocker;//Interruptible接口中定义了interrupt方法，用来中断指定的线程private volatile Interruptible blocker;//当前线程的内部锁private final Object blockerLock = new Object();//线程拥有的最小优先级public final static int MIN_PRIORITY = 1;//线程拥有的默认优先级public final static int NORM_PRIORITY = 5;//线程拥有的最大优先级public final static int MAX_PRIORITY = 10;</code></pre><p><strong>线程的状态定义</strong></p><pre><code class="line-numbers language-java">public enum State { //初始化状态    NEW, //可运行状态，此时的可运行包括运行中的状态和就绪状态    RUNNABLE, //线程阻塞状态    BLOCKED, //等待状态    WAITING, //超时等待状态    TIMED_WAITING, //线程终止状态    TERMINATED;}</code></pre><p><img src="/attachment/94009ea1cc8988a6eaf4b421c2f1fb8f.png"></p><p><strong>init()方法</strong></p><ol><li>设置线程名</li><li>父线程设置</li><li>安全校验</li><li>设置操作</li></ol><p><strong>run()方法</strong></p><p>调用了Runnable对象的run()方法</p><p><strong>start()方法</strong></p><p><strong>start()方法使用synchronized关键字修饰</strong>，说明start()方法是同步的，它会<strong>在启动线程前检查线程的状态</strong>，如果不是初始化状态，则直接抛出异常。<br><strong>一个线程只能启动一次，多次启动是会抛出异常的。</strong></p><p><strong>sleep()方法</strong></p><p>使当前线程休眠</p><p><strong>join()方法</strong></p><p>一直等待线程超时或者终止</p><ol><li>首先，代码检查传入的等待时间<strong>是否为负数</strong>，如果是负数则抛出IllegalArgumentException异常。</li><li>然后，代码<strong>根据传入的等待时间进行不同的处理</strong>。</li><li>如果等待时间不为0，代码进入另一个循环，该循环会在给定的时间内等待当前线程终止。</li><li>最后，当当前线程终止时，代码退出循环，方法执行结束。</li></ol><p><strong>interrupt()方法</strong></p><p>中断当前线程的方法</p><p>这段代码实现了中断线程的功能。当线程被中断时，如果线程正在阻塞状态，则会通过 blocker 对象来中断线程；如果线程没有被阻塞，则直接设置中断标志。</p><ol><li><strong>代码检查当前线程是否是自身</strong>。</li><li>代码使用 synchronized 关键字来同步访问 blockerLock 对象</li><li>接下来，代码获取 blocker 对象的引用。</li><li>如果 blocker 对象不为空，说明线程正在被阻塞。此时，代码调用 interrupt0() 方法来设置中断标志，并调用 blocker.interrupt(this) 方法来通知 blocker 对象中断当前线程。然后，方法返回。</li><li>如果 blocker 对象为空，说明线程没有被阻塞。此时，代码直接调用 interrupt0() 方法来设置中断标志。</li></ol><h2 id="【Java-多线程并发】-Thread-1"><a href="#【Java-多线程并发】-Thread-1" class="headerlink" title="【Java 多线程并发】 Thread"></a>【Java 多线程并发】 Thread</h2><p>Thread类是Java中用于创建和管理线程的类。它提供了一系列方法来操作线程，包括线程的启动、暂停、恢复、中断等。通过使用Thread类，可以实现多线程的并发执行，提高程序的性能和效率。</p><p>Thread类可以通过两种方式来创建线程：继承Thread类并重写run()方法，或者实现Runnable接口。通过重写run()方法，可以定义线程的执行逻辑。线程的启动通过调用start()方法来实现，该方法会启动一个新的线程，并自动调用run()方法。</p><p>Thread类还提供了其他一些方法来管理和控制线程的行为。例如，可以使用sleep()方法让线程暂停执行一段时间，使用join()方法等待线程执行完成，使用interrupt()方法中断线程的执行，使用isAlive()方法判断线程是否处于活动状态等。</p><p>总结来说，Thread类是Java多线程编程的核心类，通过它可以创建和管理线程，实现多任务并发执行。合理使用Thread类可以提高程序的性能和效率，但也需要注意线程安全问题。</p><h2 id="Thread类的继承关系"><a href="#Thread类的继承关系" class="headerlink" title="Thread类的继承关系"></a>Thread类的继承关系</h2><p><img src="/attachment/8f7f9535d47c5d3cdd338e4ae25ab51d.png"></p><p>由上图我们可以看出，Thread类实现了Runnable接口，而Runnable在JDK 1.8中被@FunctionalInterface注解标记为函数式接口，Runnable接口在JDK 1.8中的源代码如下所示。</p><p>undefined</p><h2 id="Thread类的源码剖析"><a href="#Thread类的源码剖析" class="headerlink" title="Thread类的源码剖析"></a>Thread类的源码剖析</h2><h3 id="Thread类定义"><a href="#Thread类定义" class="headerlink" title="Thread类定义"></a>Thread类定义</h3><p>Thread在java.lang包下，Thread类的定义如下所示。</p><pre><code class="line-numbers language-java">public class Thread implements Runnable {    ...}</code></pre><h3 id="加载本地资源"><a href="#加载本地资源" class="headerlink" title="加载本地资源"></a>加载本地资源</h3><p>打开Thread类后，首先，我们会看到在Thread类的最开始部分，定义了一个静态本地方法registerNatives()，这个方法主要用来注册一些本地系统的资源。并在静态代码块中调用这个本地方法，如下所示。</p><pre><code class="line-numbers language-java">//定义registerNatives()本地方法注册系统资源private static native void registerNatives();static { //在静态代码块中调用注册本地系统资源的方法 registerNatives();}</code></pre><h3 id="Thread中的成员变量"><a href="#Thread中的成员变量" class="headerlink" title="Thread中的成员变量"></a>Thread中的成员变量</h3><p>Thread类中的成员变量如下所示。</p><pre><code class="line-numbers language-java">//当前线程的名称private volatile String name;//线程的优先级private int            priority;private Thread threadQ;private long eetop;//当前线程是否是单步线程private boolean single_step;//当前线程是否在后台运行private boolean     daemon = false;//Java虚拟机的状态private boolean     stillborn = false;//真正在线程中执行的任务private Runnable target;//当前线程所在的线程组private ThreadGroup group;//当前线程的类加载器private ClassLoader contextClassLoader;//访问控制上下文private AccessControlContext inheritedAccessControlContext;//为匿名线程生成名称的编号private static int threadInitNumber;//与此线程相关的ThreadLocal,这个Map维护的是ThreadLocal类ThreadLocal.ThreadLocalMap threadLocals = null;//与此线程相关的ThreadLocalThreadLocal.ThreadLocalMap inheritableThreadLocals = null;//当前线程请求的堆栈大小，如果未指定堆栈大小，则会交给JVM来处理private long stackSize;//线程终止后存在的JVM私有状态private long nativeParkEventPointer;//线程的idprivate long tid;//用于生成线程idprivate static long threadSeqNumber;//当前线程的状态，初始化为0，代表当前线程还未启动private volatile int threadStatus = 0;//由（私有）java.util.concurrent.locks.LockSupport.setBlocker设置//使用java.util.concurrent.locks.LockSupport.getBlocker访问volatile Object parkBlocker;//Interruptible接口中定义了interrupt方法，用来中断指定的线程private volatile Interruptible blocker;//当前线程的内部锁private final Object blockerLock = new Object();//线程拥有的最小优先级public final static int MIN_PRIORITY = 1;//线程拥有的默认优先级public final static int NORM_PRIORITY = 5;//线程拥有的最大优先级public final static int MAX_PRIORITY = 10;</code></pre><p>从Thread类的成员变量，我们可以看出，Thread类本质上不是一个任务，它是一个实实在在的线程对象，在Thread类中拥有一个Runnable类型的成员变量target，而这个target成员变量就是需要在Thread线程对象中执行的任务。</p><h3 id="线程的状态定义"><a href="#线程的状态定义" class="headerlink" title="线程的状态定义"></a>线程的状态定义</h3><p>在Thread类的内部，定义了一个枚举State，如下所示。</p><pre><code class="line-numbers language-java">public enum State { //初始化状态    NEW, //可运行状态，此时的可运行包括运行中的状态和就绪状态    RUNNABLE, //线程阻塞状态    BLOCKED, //等待状态    WAITING, //超时等待状态    TIMED_WAITING, //线程终止状态    TERMINATED;}</code></pre><p>这个枚举类中的状态就代表了线程生命周期的各状态。我们可以使用下图来表示线程各个状态之间的转化关系。</p><p><img src="/attachment/94009ea1cc8988a6eaf4b421c2f1fb8f.png"></p><ul><li>NEW：初始状态，线程被构建，但是还没有调用start()方法。</li><li>RUNNABLE：可运行状态，可运行状态可以包括：运行中状态和就绪状态。</li><li>BLOCKED：阻塞状态，处于这个状态的线程需要等待其他线程释放锁或者等待进入synchronized。</li><li>WAITING：表示等待状态，处于该状态的线程需要等待其他线程对其进行通知或中断等操作，进而进入下一个状态。</li><li>TIME_WAITING：超时等待状态。可以在一定的时间自行返回。</li><li>TERMINATED：终止状态，当前线程执行完毕。</li></ul><h3 id="Thread类的构造方法"><a href="#Thread类的构造方法" class="headerlink" title="Thread类的构造方法"></a>Thread类的构造方法</h3><h4 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h4><pre><code class="line-numbers language-java">public Thread() { init(null, null, "Thread-" + nextThreadNum(), 0);}public Thread(Runnable target) { init(null, target, "Thread-" + nextThreadNum(), 0);}Thread(Runnable target, AccessControlContext acc) { init(null, target, "Thread-" + nextThreadNum(), 0, acc, false);}public Thread(ThreadGroup group, Runnable target) { init(group, target, "Thread-" + nextThreadNum(), 0);}public Thread(String name) { init(null, null, name, 0);}public Thread(ThreadGroup group, String name) { init(group, null, name, 0);}public Thread(Runnable target, String name) { init(null, target, name, 0);}public Thread(ThreadGroup group, Runnable target, String name) { init(group, target, name, 0);}public Thread(ThreadGroup group, Runnable target, String name, long stackSize) { init(group, target, name, stackSize);}</code></pre><h4 id="中文注释版"><a href="#中文注释版" class="headerlink" title="中文注释版"></a>中文注释版</h4><pre><code class="line-numbers language-java">/** * 分配一个新的{@code Thread}对象。这个构造函数与{@linkplain #Thread(ThreadGroup,Runnable,String) Thread} {@code (null, null, gname)}具有相同的效果，其中{@code gname}是一个新生成的名称。自动生成的名称的格式为{@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;，其中&lt;i&gt;n&lt;/i&gt;是一个整数。 */public Thread() {    init(null, null, "Thread-" + nextThreadNum(), 0);}/** * 分配一个新的{@code Thread}对象。这个构造函数与{@linkplain #Thread(ThreadGroup,Runnable,String) Thread} {@code (null, target, gname)}具有相同的效果，其中{@code gname}是一个新生成的名称。自动生成的名称的格式为{@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;，其中&lt;i&gt;n&lt;/i&gt;是一个整数。 * * @param  target *         当线程启动时，调用此线程的对象的{@code run}方法。如果为{@code null}，则此类的{@code run}方法不执行任何操作。 */public Thread(Runnable target) {    init(null, target, "Thread-" + nextThreadNum(), 0);}/** * 创建一个继承给定AccessControlContext的新线程。这不是一个公共构造函数。 */Thread(Runnable target, AccessControlContext acc) {    init(null, target, "Thread-" + nextThreadNum(), 0, acc, false);}/** * 分配一个新的{@code Thread}对象。这个构造函数与{@linkplain #Thread(ThreadGroup,Runnable,String) Thread} {@code (group, target, gname)}具有相同的效果，其中{@code gname}是一个新生成的名称。自动生成的名称的格式为{@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;，其中&lt;i&gt;n&lt;/i&gt;是一个整数。 * * @param  group *         线程组。如果为{@code null}并且存在安全管理器，则线程组由{@linkplain SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}确定。如果没有安全管理器或{@code SecurityManager.getThreadGroup()}返回{@code null}，则线程组设置为当前线程的线程组。 * * @param  target *         当线程启动时，调用此线程的对象的{@code run}方法。如果为{@code null}，则调用此线程的run方法。 * * @throws  SecurityException *          如果当前线程无法在指定的线程组中创建线程 */public Thread(ThreadGroup group, Runnable target) {    init(group, target, "Thread-" + nextThreadNum(), 0);}/** * 分配一个新的{@code Thread}对象。这个构造函数与{@linkplain #Thread(ThreadGroup,Runnable,String) Thread} {@code (null, null, name)}具有相同的效果。 * * @param   name *          新线程的名称 */public Thread(String name) {    init(null, null, name, 0);}/** * 分配一个新的{@code Thread}对象。这个构造函数与{@linkplain #Thread(ThreadGroup,Runnable,String) Thread} {@code (group, null, name)}具有相同的效果。 * * @param  group *         线程组。如果为{@code null}并且存在安全管理器，则线程组由{@linkplain SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}确定。如果没有安全管理器或{@code SecurityManager.getThreadGroup()}返回{@code null}，则线程组设置为当前线程的线程组。 * * @param  name *         新线程的名称 * * @throws  SecurityException *          如果当前线程无法在指定的线程组中创建线程 */public Thread(ThreadGroup group, String name) {    init(group, null, name, 0);}/** * 分配一个新的{@code Thread}对象。这个构造函数与{@linkplain #Thread(ThreadGroup,Runnable,String) Thread} {@code (null, target, name)}具有相同的效果。 * * @param  target *         当线程启动时，调用此线程的对象的{@code run}方法。如果为{@code null}，则调用此线程的run方法。 * * @param  name *         新线程的名称 */public Thread(Runnable target, String name) {    init(null, target, name, 0);}/** * 分配一个新的{@code Thread}对象，使其具有{@code target}作为其运行对象，具有指定的{@code name}作为其名称，并属于由{@code group}引用的线程组。 * * &lt;p&gt;如果有安全管理器，则使用线程组作为参数调用其{@link SecurityManager#checkAccess(ThreadGroup) checkAccess}方法。 * * &lt;p&gt;此外，当直接或间接由覆盖{@code getContextClassLoader}或{@code setContextClassLoader}方法的子类的构造函数调用时，将使用{@code RuntimePermission("enableContextClassLoaderOverride")}权限调用其{@code checkPermission}方法。 * * &lt;p&gt;新创建的线程的优先级设置为创建它的线程的优先级，即当前运行的线程。可以使用{@linkplain #setPriority setPriority}方法将优先级更改为新值。 * * &lt;p&gt;新创建的线程最初被标记为守护线程，当且仅当创建它的线程当前被标记为守护线程。可以使用{@linkplain #setDaemon setDaemon}方法更改线程是否为守护线程。 * * @param  group *         线程组。如果为{@code null}并且存在安全管理器，则线程组由{@linkplain SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}确定。如果没有安全管理器或{@code SecurityManager.getThreadGroup()}返回{@code null}，则线程组设置为当前线程的线程组。 * * @param  target *         当线程启动时，调用此线程的对象的{@code run}方法。如果为{@code null}，则调用此线程的run方法。 * * @param  name *         新线程的名称 * * @throws  SecurityException *          如果当前线程无法在指定的线程组中创建线程或无法覆盖上下文类加载器方法。 */public Thread(ThreadGroup group, Runnable target, String name) {    init(group, target, name, 0);}</code></pre><p>其中，我们最经常使用的就是如下几个构造方法了。</p><pre><code class="line-numbers language-java">public Thread() { init(null, null, "Thread-" + nextThreadNum(), 0);}public Thread(Runnable target) { init(null, target, "Thread-" + nextThreadNum(), 0);}public Thread(String name) { init(null, null, name, 0);}public Thread(ThreadGroup group, String name) { init(group, null, name, 0);}public Thread(Runnable target, String name) { init(null, target, name, 0);}public Thread(ThreadGroup group, Runnable target, String name) { init(group, target, name, 0);}</code></pre><p>通过Thread类的源码，我们可以看出，Thread类在进行初始化的时候，都是调用的init()方法，接下来，我们看看init()方法是个啥。</p><h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init()方法"></a>init()方法</h3><p>Thread类中的构造方法是被创建Thread线程的线程调用的，此时，调用Thread的构造方法创建线程的线程就是父线程，在init()方法中，新创建的Thread线程会继承父线程的部分属性。</p><pre><code class="line-numbers language-java">    /**     * 初始化一个线程。     *     * @param g 线程组     * @param target 被调用run()方法的对象     * @param name 新线程的名称     * @param stackSize 新线程的期望堆栈大小，或者为零表示忽略此参数。     * @param acc 继承的AccessControlContext，如果为null，则使用AccessController.getContext()     * @param inheritThreadLocals 如果为{@code true}，则从构造线程继承可继承线程本地变量的初始值     */    private void init(ThreadGroup g, Runnable target, String name,                      long stackSize, AccessControlContext acc,                      boolean inheritThreadLocals) {        if (name == null) {            throw new NullPointerException("name cannot be null");        }        this.name = name;        Thread parent = currentThread();        SecurityManager security = System.getSecurityManager();        if (g == null) {            // 判断是否为applet            // 如果有安全管理器，询问安全管理器该怎么办            if (security != null) {                g = security.getThreadGroup();            }            // 如果安全管理器对此没有明确意见，则使用父线程组            if (g == null) {                g = parent.getThreadGroup();            }        }        // 无论是否显式传递了threadgroup，都要检查访问权限        g.checkAccess();        /*         * 是否具有所需的权限？         */        if (security != null) {            if (isCCLOverridden(getClass())) {                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);            }        }        g.addUnstarted();        this.group = g;        this.daemon = parent.isDaemon();        this.priority = parent.getPriority();        if (security == null || isCCLOverridden(parent.getClass()))            this.contextClassLoader = parent.getContextClassLoader();        else            this.contextClassLoader = parent.contextClassLoader;        this.inheritedAccessControlContext =                acc != null ? acc : AccessController.getContext();        this.target = target;        setPriority(priority);        if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)            this.inheritableThreadLocals =                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);        // 将指定的堆栈大小存储起来以备VM使用        this.stackSize = stackSize;        // 设置线程ID        tid = nextThreadID();    }</code></pre><p>这个方法主要用于初始化Thread对象。下面是对代码的详细解释：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码详细解释</p><ol><li>设置线程名称<ol><li>检查传入的name是否为null，如果是null，则抛出NullPointerException异常。</li><li>设置Thread对象的name为传入的name。</li></ol></li><li>父线程设置<ol><li>获取当前线程对象作为父线程。</li></ol></li><li>安全校验<ol><li>获取系统的安全管理器。</li><li>如果传入的线程组为null，则判断是否为applet。如果有安全管理器，则使用安全管理器的线程组。如果安全管理器对此没有明确意见，则使用父线程的线程组。</li><li>检查是否具有访问线程组的权限。</li><li>检查是否具有创建Thread子类对象的权限。</li></ol></li><li>设置操作<ol><li>将线程组设置为未启动状态。</li><li>设置线程的group为传入的线程组。</li><li>设置线程的daemon属性为父线程的daemon属性。</li><li>设置线程的priority为父线程的priority。</li><li>如果没有安全管理器或者父线程的contextClassLoader被子类覆盖，则将线程的contextClassLoader设置为父线程的contextClassLoader。否则，将线程的contextClassLoader设置为父线程的contextClassLoader。</li><li>设置线程的inheritedAccessControlContext为传入的AccessControlContext，如果为null，则设置为当前线程的AccessControlContext。</li><li>设置线程的target为传入的Runnable对象。</li><li>设置线程的priority为父线程的priority。</li><li>如果需要继承父线程的ThreadLocal变量，并且父线程的inheritableThreadLocals不为null，则创建一个继承父线程inheritableThreadLocals的map，并将其赋值给线程的inheritableThreadLocals。</li><li>将指定的堆栈大小存储起来以备VM使用。</li><li>设置线程的ID为下一个可用的线程ID。</li></ol></li></ol></div><h3 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h3><p>既然Thread类实现了Runnable接口，则Thread类就需要实现Runnable接口的run()方法，如下所示。</p><pre><code class="line-numbers language-java">/**     * 如果此线程是使用单独的Runnable运行对象构造的，则调用该Runnable对象的run方法；     * 否则，此方法不执行任何操作并返回。     * &lt;p&gt;     * Thread的子类应该重写此方法。     *     * @see     #start()     * @see     #stop()     * @see     #Thread(ThreadGroup, Runnable, String)     */    @Override    public void run() {        if (target != null) {            target.run();        }    }</code></pre><p>可以看到，Thread类中的run()方法实现非常简单，只是调用了Runnable对象的run()方法。所以，真正的任务是运行在run()方法中的。另外，需要注意的是：<strong>直接调用Runnable接口的run()方法不会创建新线程来执行任务，如果需要创建新线程执行任务，则需要调用Thread类的start()方法。</strong></p><h3 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h3><pre><code class="line-numbers language-java">/**     * 使此线程开始执行；Java虚拟机调用此线程的run方法。     * &lt;p&gt;     * 结果是两个线程同时运行：当前线程（从调用start方法返回）和另一个线程（执行其run方法）。     * &lt;p&gt;     * 不允许多次启动一个线程。     * 特别是，一旦线程完成执行，就不能重新启动它。     *     * @exception  IllegalThreadStateException  如果线程已经启动。     * @see        #run()     * @see        #stop()     */    public synchronized void start() {        /**         * 对于由VM创建/设置的主线程或“系统”组线程，不会调用此方法。         * 将来对此方法添加的任何新功能可能也必须添加到VM中。         *         * 零状态值对应于状态“NEW”。         */        if (threadStatus != 0)            throw new IllegalThreadStateException();        /* 通知组，此线程即将启动，         * 以便将其添加到组的线程列表中，         * 并将组的未启动计数减一。 */        group.add(this);        boolean started = false;        try {            start0();            started = true;        } finally {            try {                if (!started) {                    group.threadStartFailed(this);                }            } catch (Throwable ignore) {                /* 什么都不做。如果start0抛出了Throwable，                  它将被传递到调用堆栈上 */            }        }    }</code></pre><p>从start()方法的源代码，我们可以看出：<strong>start()方法使用synchronized关键字修饰</strong>，说明start()方法是同步的，它会<strong>在启动线程前检查线程的状态</strong>，如果不是初始化状态，则直接抛出异常。所以，<strong>一个线程只能启动一次，多次启动是会抛出异常的。</strong></p><p>这里，也是面试的一个坑：面试官：【问题一】能不能多次调用Thread类的start()方法来启动线程吗？【问题二】多次调用Thread线程的start()方法会发生什么？【问题三】为什么会抛出异常？</p><p>调用start()方法后，新创建的线程就会处于就绪状态（如果没有分配到CPU执行），当有空闲的CPU时，这个线程就会被分配CPU来执行，此时线程的状态为运行状态，JVM会调用线程的run()方法执行任务。</p><h3 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h3><p>sleep()方法可以使当前线程休眠，其代码如下所示。</p><pre><code class="line-numbers language-java">    /**     * 使当前正在执行的线程休眠（临时停止执行）指定的毫秒数加上指定的纳秒数，取决于系统计时器和调度程序的精度和准确性。线程不会失去任何监视器的所有权。     *     * @param  millis     *         以毫秒为单位的休眠时间长度     *     * @param  nanos     *         {@code 0-999999} 补充的纳秒数     *     * @throws  IllegalArgumentException     *          如果{@code millis}的值为负数，或者{@code nanos}的值不在范围{@code 0-999999}内     *     * @throws  InterruptedException     *          如果任何线程中断了当前线程。抛出此异常时，当前线程的&lt;i&gt;中断状态&lt;/i&gt;将被清除。     */    public static void sleep(long millis, int nanos)    throws InterruptedException {        if (millis &lt; 0) {            throw new IllegalArgumentException("timeout value is negative");        }        if (nanos &lt; 0 || nanos &gt; 999999) {            throw new IllegalArgumentException(                                "nanosecond timeout value out of range");        }        if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) {            millis++;        }        sleep(millis);    }</code></pre><p>sleep()方法会让当前线程休眠一定的时间，这个时间通常是毫秒值，这里需要注意的是：调用sleep()方法使线程休眠后，线程不会释放相应的锁。</p><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><p>join()方法会一直等待线程超时或者终止，代码如下所示。</p><pre><code class="line-numbers language-java">/** * 等待最多{@code millis}毫秒，直到该线程终止。超时时间为{@code 0}表示永久等待。 * * &lt;p&gt; 这个实现使用了一个基于{@code this.wait}调用和{@code this.isAlive}条件的循环。当一个线程终止时，会调用{@code this.notifyAll}方法。建议应用程序不要在{@code Thread}实例上使用{@code wait}、{@code notify}或{@code notifyAll}。 * * @param  millis *         等待的时间（以毫秒为单位） * * @throws  IllegalArgumentException *          如果{@code millis}的值为负数 * * @throws  InterruptedException *          如果任何线程中断了当前线程。抛出此异常时，当前线程的“中断状态”将被清除。 */public final synchronized void join(long millis)throws InterruptedException {    long base = System.currentTimeMillis();    long now = 0;    if (millis &lt; 0) {        throw new IllegalArgumentException("超时值为负数");    }    if (millis == 0) {        while (isAlive()) {            wait(0);        }    } else {        while (isAlive()) {            long delay = millis - now;            if (delay &lt;= 0) {                break;            }            wait(delay);            now = System.currentTimeMillis() - base;        }    }}</code></pre><ol><li>首先，代码检查传入的等待时间是否为负数，如果是负数则抛出IllegalArgumentException异常。</li><li>然后，代码根据传入的等待时间进行不同的处理。如果等待时间为0，表示永久等待，代码会进入一个循环，只有当当前线程终止时才会退出循环。在循环中，使用wait(0)方法使线程等待，直到被唤醒。</li><li>如果等待时间不为0，代码进入另一个循环，该循环会在给定的时间内等待当前线程终止。在循环中，代码计算剩余的等待时间，并使用wait(delay)方法使线程等待指定的时间。然后，代码更新当前时间，直到等待时间超过给定的时间或当前线程终止。</li><li>最后，当当前线程终止时，代码退出循环，方法执行结束。</li></ol><p>join()方法的使用场景往往是启动线程执行任务的线程，调用执行线程的join()方法，等待执行线程执行任务，直到超时或者执行线程终止。</p><h2 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt()方法"></a>interrupt()方法</h2><p>interrupt()方法是中断当前线程的方法，它通过设置线程的中断标志位来中断当前线程。此时，如果为线程设置了中断标志位，可能会抛出InteruptedExeption异常，同时，会清除当前线程的中断状态。这种方式中断线程比较安全，它能使正在执行的任务执行能够继续执行完毕，而不像stop()方法那样强制线程关闭。代码如下所示。</p><pre><code class="line-numbers language-java">/** * 中断这个线程。 * * &lt;p&gt; 除非当前线程中断自己，这是始终允许的，否则将调用此线程的 {@link #checkAccess() checkAccess} 方法， * 这可能会导致抛出 {@link SecurityException}。 * * &lt;p&gt; 如果此线程在 {@link Object} 类的 {@link Object#wait() wait()}、{@link Object#wait(long) wait(long)} 或 * {@link Object#wait(long, int) wait(long, int)} 方法的调用中被阻塞，或者在此类的 {@link #join()}、{@link #join(long)}、 * {@link #join(long, int)}、{@link #sleep(long)} 或 {@link #sleep(long, int)} 方法的调用中被阻塞， * 则它的中断状态将被清除，并且它将接收到一个 {@link InterruptedException}。 * * &lt;p&gt; 如果此线程在对 {@link java.nio.channels.InterruptibleChannel InterruptibleChannel} 的 I/O 操作中被阻塞， * 则通道将被关闭，线程的中断状态将被设置，并且线程将接收到一个 {@link java.nio.channels.ClosedByInterruptException}。 * * &lt;p&gt; 如果此线程在 {@link java.nio.channels.Selector} 中被阻塞，则线程的中断状态将被设置，并且它将立即从选择操作中返回， * 可能带有非零值，就像调用选择器的 {@link java.nio.channels.Selector#wakeup wakeup} 方法一样。 * * &lt;p&gt; 如果不满足前面的任何条件，则将设置此线程的中断状态。 * * &lt;p&gt; 中断一个不是活动状态的线程可能不会产生任何效果。 * * @throws  SecurityException *          如果当前线程无法修改此线程 * * @revised 6.0 * @spec JSR-51 */public void interrupt() {    if (this != Thread.currentThread())        checkAccess();    synchronized (blockerLock) {        Interruptible b = blocker;        if (b != null) {            interrupt0();           // 仅设置中断标志            b.interrupt(this);            return;        }    }    interrupt0();}</code></pre><p>这段代码实现了Java线程的中断功能。下面是其具体的实现流程：</p><ol><li>首先，代码检查当前线程是否是自身。如果不是，就调用 checkAccess() 方法来检查当前线程是否有权限修改该线程。如果没有权限，则会抛出 SecurityException 异常。</li><li>然后，代码使用 synchronized 关键字来同步访问 blockerLock 对象。这是为了确保在中断线程时不会与其他线程发生冲突。</li><li>接下来，代码获取 blocker 对象的引用。blocker 对象是一个实现了 Interruptible 接口的对象，用于在线程被阻塞时执行特定的操作。</li><li>如果 blocker 对象不为空，说明线程正在被阻塞。此时，代码调用 interrupt0() 方法来设置中断标志，并调用 blocker.interrupt(this) 方法来通知 blocker 对象中断当前线程。然后，方法返回。</li><li>如果 blocker 对象为空，说明线程没有被阻塞。此时，代码直接调用 interrupt0() 方法来设置中断标志。</li></ol><p>总之，这段代码实现了中断线程的功能。当线程被中断时，如果线程正在阻塞状态，则会通过 blocker 对象来中断线程；如果线程没有被阻塞，则直接设置中断标志。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Java线程的状态及主要转化方法</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-java-xian-cheng-de-zhuang-tai-ji-zhu-yao-zhuan-hua-fang-fa/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-java-xian-cheng-de-zhuang-tai-ji-zhu-yao-zhuan-hua-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Java线程的状态及主要转化方法"><a href="#【Java-多线程并发】-Java线程的状态及主要转化方法" class="headerlink" title="【Java 多线程并发】 Java线程的状态及主要转化方法"></a>【Java 多线程并发】 Java线程的状态及主要转化方法</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Java线程的状态及主要转化方法date: 2023-07-03 09:42tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 Java线程的状态及主要转化方法</code></pre><h2 id="操作系统中的线程状态转换"><a href="#操作系统中的线程状态转换" class="headerlink" title="操作系统中的线程状态转换"></a>操作系统中的线程状态转换</h2><p>首先我们来看看操作系统中的线程状态转换。</p><blockquote><p>在现在的操作系统中，线程是被视为轻量级进程的，所以操作系统线程的状态其实和操作系统进程的状态是一致的。</p></blockquote><p><img src="/attachment/aa1ff103b0b048211068f952db628197.png"></p><p>操作系统线程主要有以下三个状态：</p><ul><li>就绪状态(ready)：线程正在等待使用CPU，经调度程序调用之后可进入running状态。</li><li>执行状态(running)：线程正在使用CPU。</li><li>等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如I/O）。</li></ul><h2 id="Java线程的6个状态"><a href="#Java线程的6个状态" class="headerlink" title="Java线程的6个状态"></a>Java线程的6个状态</h2><pre><code class="line-numbers language-java">// Thread.State 源码public enum State {    NEW,    RUNNABLE,    BLOCKED,    WAITING,    TIMED_WAITING,    TERMINATED;}</code></pre><h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><p>处于NEW状态的线程此时尚未启动。这里的尚未启动指的是还没调用Thread实例的start()方法。</p><pre><code class="line-numbers language-java">private void testStateNew() {    Thread thread = new Thread(() -&gt; {});    System.out.println(thread.getState()); // 输出 NEW }</code></pre><p>从上面可以看出，只是创建了线程而并没有调用start()方法，此时线程处于NEW状态。</p><p>关于start()的两个引申问题</p><ul><li>反复调用同一个线程的start()方法是否可行？</li><li>假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？</li></ul><p>要分析这两个问题，我们先来看看start()的源码：</p><pre><code class="line-numbers language-java">public synchronized void start() {    if (threadStatus != 0)        throw new IllegalThreadStateException();    group.add(this);    boolean started = false;    try {        start0();        started = true;    } finally {        try {            if (!started) {                group.threadStartFailed(this);            }        } catch (Throwable ignore) {        }    }}</code></pre><p>我们可以看到，在start()内部，这里有一个threadStatus的变量。如果它不等于0，调用start()是会直接抛出异常的。<br>在 native 的 start0() 方法中 将 threadStatus 设置 成 <code>Runnable</code><br>我们接着往下看，有一个native的start0()方法。这个方法里并没有对threadStatus的处理。到了这里我们仿佛就拿这个threadStatus没辙了，我们通过debug的方式再看一下:</p><pre><code class="line-numbers language-java">@Testpublic void testStartMethod() {    Thread thread = new Thread(() -&gt; {});    thread.start(); // 第一次调用    thread.start(); // 第二次调用}</code></pre><p>我是在start()方法内部的最开始打的断点，叙述下在我这里打断点看到的结果：</p><ul><li>第一次调用时threadStatus的值是0。</li><li>第二次调用时threadStatus的值不为0。<br>查看当前线程状态的源码：</li></ul><pre><code class="line-numbers language-java">// Thread.getState方法源码：public State getState() {    // get current thread state    return sun.misc.VM.toThreadState(threadStatus);}// sun.misc.VM 源码：public static State toThreadState(int var0) {    if ((var0 &amp; 4) != 0) {        return State.RUNNABLE;    } else if ((var0 &amp; 1024) != 0) {        return State.BLOCKED;    } else if ((var0 &amp; 16) != 0) {        return State.WAITING;    } else if ((var0 &amp; 32) != 0) {        return State.TIMED_WAITING;    } else if ((var0 &amp; 2) != 0) {        return State.TERMINATED;    } else {        return (var0 &amp; 1) == 0 ? State.NEW : State.RUNNABLE;    }}</code></pre><h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待其他系统资源（比如I/O）。</p><p>Java中线程的RUNNABLE状态</p><p>看了操作系统线程的几个状态之后我们来看看Thread源码里对RUNNABLE状态的定义：</p><pre><code class="line-numbers language-java">/** * Thread state for a runnable thread.  A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */</code></pre><blockquote><p>Java线程的RUNNABLE状态其实是包括了传统操作系统线程的ready和running两个状态的。</p></blockquote><h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区。<br>我们用BLOCKED状态举个生活中的例子：</p><blockquote><p>假如今天你下班后准备去食堂吃饭。你来到食堂仅有的一个窗口，发现前面已经有个人在窗口前了，此时你必须得等前面的人从窗口离开才行。<br>假设你是线程t2，你前面的那个人是线程t1。此时t1占有了锁（食堂唯一的窗口），t2正在等待锁的释放，所以此时t2就处于BLOCKED状态。</p></blockquote><h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>等待状态。处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。<br>调用如下3个方法会使线程进入等待状态：</p><ul><li>Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；</li><li>Thread.join()：等待线程执行完毕，底层调用的是Object实例的wait方法；</li><li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。</li></ul><p>我们延续上面的例子继续解释一下WAITING状态</p><blockquote><p>你等了好几分钟现在终于轮到你了，突然你们有一个“不懂事”的经理突然来了。你看到他你就有一种不祥的预感，果然，他是来找你的。<br>他把你拉到一旁叫你待会儿再吃饭，说他下午要去作报告，赶紧来找你了解一下项目的情况。你心里虽然有一万个不愿意但是你还是从食堂窗口走开了。<br>此时，假设你还是线程t2，你的经理是线程t1。虽然你此时都占有锁（窗口）了，“不速之客”来了你还是得释放掉锁。此时你t2的状态就是WAITING。然后经理t1获得锁，进入RUNNABLE状态。<br>要是经理t1不主动唤醒你t2（notify、notifyAll..），可以说你t2只能一直等待了。</p></blockquote><h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。<br>调用如下方法会使线程进入超时等待状态：</p><ul><li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li><li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</li><li>Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li><li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li><li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；<br>我们继续延续上面的例子来解释一下TIMED_WAITING状态：</li></ul><blockquote><p>到了第二天中午，又到了饭点，你还是到了窗口前。<br>突然间想起你的同事叫你等他一起，他说让你等他十分钟他改个bug。<br>好吧，你说那你就等等吧，你就离开了窗口。很快十分钟过去了，你见他还没来，你想都等了这么久了还不来，那你还是先去吃饭好了。<br>这时你还是线程t1，你改bug的同事是线程t2。t2让t1等待了指定时间，t1先主动释放了锁。此时t1等待期间就属于TIMED_WATING状态。<br>t1等待10分钟后，就自动唤醒，拥有了去争夺锁的资格。</p></blockquote><h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>终止状态。此时线程已执行完毕。</p><h2 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="线程状态的转换"></a>线程状态的转换</h2><p>根据上面关于线程状态的介绍我们可以得到下面的线程状态转换图： </p><p><img src="/attachment/eea4db4a63c70d5ef686105e2d7fd516.png"></p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>简单介绍下Thread类里提供的关于线程中断的几个方法：</p><ul><li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是false）；</li><li>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li><li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li></ul><h3 id="什么是中断机制"><a href="#什么是中断机制" class="headerlink" title="什么是中断机制"></a>什么是中断机制</h3><ul><li>首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，自己来决定自己的命运，所以，Thread.stop,Thread.suspend,Thread.resume都已经被废弃了</li><li>其次，在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的协商机制—-中断，也即中断标识协商机制<ul><li>中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自行实现。若要中断一个线程，你需要手动调用该线程interrupt方法，该方法也仅仅是将该线程对象的中断标识设置为true，接着你需要自己写代码不断检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，此时究竟应该做什么需要你自己写代码实现。</li><li>每个线程对象都有一个中断标识位，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设置为true；可以在别的线程中调用，也可以在自己的线程中调用。</li></ul></li></ul><h3 id="中断的相关API方法之三大方法说明"><a href="#中断的相关API方法之三大方法说明" class="headerlink" title="中断的相关API方法之三大方法说明"></a>中断的相关API方法之三大方法说明</h3><ul><li>public void interrupt()<ul><li>实例方法 Just to set the interrupt flag</li><li>实例方法仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程</li></ul></li><li>public static boolean interrupted()<ul><li>静态方法 Thread.interrupted();</li><li>判断线程是否被中断并清除当前中断状态（做了两件事情）<ul><li>1.返回当前线程的中断状态，测试当前线程是否已被中断</li><li>2.将当前线程的中断状态清零并重新设置为false，清除线程的中断状态</li></ul></li><li>3.这个方法有点不好理解在于如果连续两次调用此方法，则第二次返回false，因为连续调用两次的结果可能不一样</li></ul></li><li>public boolean isInterrupted()<ul><li>实例方法</li><li>判断当前线程是否被中断（通过检查中断标志位)</li></ul></li></ul><h3 id="当前线程的中断标识为true，是不是线程就立刻停止？"><a href="#当前线程的中断标识为true，是不是线程就立刻停止？" class="headerlink" title="当前线程的中断标识为true，是不是线程就立刻停止？"></a>当前线程的中断标识为true，是不是线程就立刻停止？</h3><p>答案是不立刻停止，具体来说，当对一个线程，调用interrupt时：</p><ul><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响，所以interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行，对于不活动的线程没有任何影响。</li><li>如果线程处于阻塞状态（例如sleep,wait,join状态等），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（interrupt状态也将被清除），并抛出一个InterruptedException异常。</li></ul><p>总之，需要记住的是中断只是一种协商机制，修改中断标识位仅此而已，不是立刻stop打断</p><h3 id="静态方法Thread-interrupted-，谈谈你的理解？"><a href="#静态方法Thread-interrupted-，谈谈你的理解？" class="headerlink" title="静态方法Thread.interrupted()，谈谈你的理解？"></a>静态方法Thread.interrupted()，谈谈你的理解？</h3><p>对于静态方法Thread.interrupted()和实例方法isInterrupted()区别在于：</p><ul><li>静态方法interrupted将会清除中断状态（传入的参数ClearInterrupted为true）</li><li>实例方法isInterrupted则不会（传入的参数ClearInterrupted为false）</li></ul><p><img src="/attachment/1317fbe9f43e2a8cbff7eb5cf2915b5c.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>public void interrupt() 是一个实例方法，它通知目标线程中断，也仅仅是设置目标线程的中断标志位为true</li><li>public boolean isInterrupted() 是一个实例方法，它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志</li><li>public static boolean interrupted() 是一个静态方法，返回当前线程的中断真实状态（boolean类型）后会将当前线程的中断状态设为false，此方法调用之后会清楚当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置为false。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 线程组和线程优先级</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-xian-cheng-zu-he-xian-cheng-you-xian-ji/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-xian-cheng-zu-he-xian-cheng-you-xian-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-线程组和线程优先级"><a href="#【Java-多线程并发】-线程组和线程优先级" class="headerlink" title="【Java 多线程并发】 线程组和线程优先级"></a>【Java 多线程并发】 线程组和线程优先级</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 线程组和线程优先级date: 2023-07-03 09:19tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 线程组和线程优先级</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>线程组(ThreadGroup)</strong></p><p>线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。</p><p><strong>线程的优先级</strong><br>Java中线程优先级可以指定，范围是1~10。</p><p><strong>线程组的数据结构</strong></p><pre><code class="line-numbers language-java">public class ThreadGroup implements Thread.UncaughtExceptionHandler {    private final ThreadGroup parent; // 父亲ThreadGroup    String name; // ThreadGroupr 的名称    int maxPriority; // 线程最大优先级    boolean destroyed; // 是否被销毁    boolean daemon; // 是否守护线程    boolean vmAllowSuspension; // 是否可以中断    int nUnstartedThreads = 0; // 还未启动的线程    int nthreads; // ThreadGroup中线程数目    Thread threads[]; // ThreadGroup中的线程    int ngroups; // 线程组数目    ThreadGroup groups[]; // 线程组数组}</code></pre><h2 id="线程组-ThreadGroup"><a href="#线程组-ThreadGroup" class="headerlink" title="线程组(ThreadGroup)"></a>线程组(ThreadGroup)</h2><p>Java中用ThreadGroup来表示线程组，我们可以使用线程组对线程进行批量控制。<br>ThreadGroup和Thread的关系就如同他们的字面意思一样简单粗暴，每个Thread必然存在于一个ThreadGroup中，Thread不能独立于ThreadGroup存在。执行main()方法线程的名字是main，如果在new Thread时没有显式指定，那么默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。</p><pre><code class="line-numbers language-java">public class Demo {    public static void main(String[] args) {        Thread testThread = new Thread(() -&gt; {            System.out.println("testThread当前线程组名字：" +                    Thread.currentThread().getThreadGroup().getName());            System.out.println("testThread线程名字：" +                    Thread.currentThread().getName());        });        testThread.start();        System.out.println("执行main方法线程名字：" + Thread.currentThread().getName());    }}</code></pre><p>ThreadGroup管理着它下面的Thread，ThreadGroup是一个标准的向下引用的树状结构，这样设计的原因是防止”上级”线程被”下级”线程引用而无法有效地被GC回收。</p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>Java中线程优先级可以指定，范围是1~10。但是并不是所有的操作系统都支持10级优先级的划分（比如有些操作系统只支持3级划分：低，中，高），Java只是给操作系统一个优先级的参考值，线程最终在操作系统的优先级是多少还是由操作系统决定。</p><p>Java默认的线程优先级为5，线程的执行顺序由调度程序来决定，线程的优先级会在线程被调用之前设定。</p><p>通常情况下，高优先级的线程将会比低优先级的线程有更高的几率得到执行。我们使用方法Thread类的setPriority()实例方法来设定线程的优先级。</p><pre><code class="line-numbers language-java">public class Demo {    public static void main(String[] args) {        Thread a = new Thread();        System.out.println("我是默认线程优先级："+a.getPriority());        Thread b = new Thread();        b.setPriority(10);        System.out.println("我是设置过的线程优先级："+b.getPriority());    }}</code></pre><p>输出结果</p><pre><code class="line-numbers language-console">我是默认线程优先级：5我是设置过的线程优先级：10</code></pre><p>既然有1-10的级别来设定了线程的优先级，这时候可能有些读者会问，那么我是不是可以在业务实现的时候，采用这种方法来指定一些线程执行的先后顺序？<br>对于这个问题，我们的答案是:No!</p><p>Java中的优先级来说不是特别的可靠，Java程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的。</p><p>Java提供一个线程调度器来监视和控制处于RUNNABLE状态的线程。线程的调度策略采用抢占式，优先级高的线程比优先级低的线程会有更大的几率优先执行。在优先级相同的情况下，按照“先到先得”的原则。每个Java程序都有一个默认的主线程，就是通过JVM启动的第一个线程main线程。</p><p>还有一种线程称为守护线程（Daemon），守护线程默认的优先级比较低。</p><blockquote><p>如果某线程是守护线程，那如果所以的非守护线程结束，这个守护线程也会自动结束。<br>应用场景是：当所有非守护线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。<br>一个线程默认是非守护线程，可以通过Thread类的setDaemon(boolean on)来设置。</p></blockquote><p>如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。</p><h2 id="线程组的常用方法及数据结构"><a href="#线程组的常用方法及数据结构" class="headerlink" title="线程组的常用方法及数据结构"></a>线程组的常用方法及数据结构</h2><h3 id="线程组的常用方法"><a href="#线程组的常用方法" class="headerlink" title="线程组的常用方法"></a>线程组的常用方法</h3><h4 id="获取当前的线程组名字"><a href="#获取当前的线程组名字" class="headerlink" title="获取当前的线程组名字"></a>获取当前的线程组名字</h4><pre><code class="line-numbers language-java">Thread.currentThread().getThreadGroup().getName()</code></pre><h4 id="复制线程组"><a href="#复制线程组" class="headerlink" title="复制线程组"></a>复制线程组</h4><pre><code class="line-numbers language-java">// 复制一个线程数组到一个线程组Thread[] threads = new Thread[threadGroup.activeCount()];TheadGroup threadGroup = new ThreadGroup();threadGroup.enumerate(threads);</code></pre><h4 id="线程组统一异常处理"><a href="#线程组统一异常处理" class="headerlink" title="线程组统一异常处理"></a>线程组统一异常处理</h4><pre><code class="line-numbers language-java">package com.func.axc.threadgroup;public class ThreadGroupDemo {    public static void main(String[] args) {        ThreadGroup threadGroup1 = new ThreadGroup("group1") {            // 继承ThreadGroup并重新定义以下方法            // 在线程成员抛出unchecked exception            // 会执行此方法            public void uncaughtException(Thread t, Throwable e) {                System.out.println(t.getName() + ": " + e.getMessage());            }        };        // 这个线程是threadGroup1的一员        Thread thread1 = new Thread(threadGroup1, new Runnable() {            public void run() {                // 抛出unchecked异常                throw new RuntimeException("测试异常");            }        });        thread1.start();    }}</code></pre><h3 id="线程组的数据结构"><a href="#线程组的数据结构" class="headerlink" title="线程组的数据结构"></a>线程组的数据结构</h3><p>线程组还可以包含其他的线程组，不仅仅是线程。<br>首先看看 ThreadGroup源码中的成员变量</p><pre><code class="line-numbers language-java">public class ThreadGroup implements Thread.UncaughtExceptionHandler {    private final ThreadGroup parent; // 父亲ThreadGroup    String name; // ThreadGroupr 的名称    int maxPriority; // 线程最大优先级    boolean destroyed; // 是否被销毁    boolean daemon; // 是否守护线程    boolean vmAllowSuspension; // 是否可以中断    int nUnstartedThreads = 0; // 还未启动的线程    int nthreads; // ThreadGroup中线程数目    Thread threads[]; // ThreadGroup中的线程    int ngroups; // 线程组数目    ThreadGroup groups[]; // 线程组数组}</code></pre><p>然后看看构造函数：</p><pre><code class="line-numbers language-java">// 私有构造函数private ThreadGroup() {     this.name = "system";    this.maxPriority = Thread.MAX_PRIORITY;    this.parent = null;}// 默认是以当前ThreadGroup传入作为parent  ThreadGroup，新线程组的父线程组是目前正在运行线程的线程组。public ThreadGroup(String name) {    this(Thread.currentThread().getThreadGroup(), name);}// 构造函数public ThreadGroup(ThreadGroup parent, String name) {    this(checkParentAccess(parent), parent, name);}// 私有构造函数，主要的构造函数private ThreadGroup(Void unused, ThreadGroup parent, String name) {    this.name = name;    this.maxPriority = parent.maxPriority;    this.daemon = parent.daemon;    this.vmAllowSuspension = parent.vmAllowSuspension;    this.parent = parent;    parent.add(this);}</code></pre><p>第三个构造函数里调用了checkParentAccess方法，这里看看这个方法的源码：</p><pre><code class="line-numbers language-java">// 检查parent ThreadGroupprivate static Void checkParentAccess(ThreadGroup parent) {    parent.checkAccess();    return null;}// 判断当前运行的线程是否具有修改线程组的权限public final void checkAccess() {    SecurityManager security = System.getSecurityManager();    if (security != null) {        security.checkAccess(this);    }}</code></pre><blockquote><p>这里涉及到SecurityManager这个类，它是Java的安全管理器，它允许应用程序在执行一个可能不安全或敏感的操作前确定该操作是什么，以及是否是在允许执行该操作的安全上下文中执行它。应用程序可以允许或不允许该操作。<br>比如引入了第三方类库，但是并不能保证它的安全性。<br>其实Thread类也有一个checkAccess()方法，不过是用来当前运行的线程是否有权限修改被调用的这个线程实例。（Determines if the currently running thread has permission to modify this thread.）</p></blockquote><p>总结来说，线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 Java多线程入门类和接口</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-java-duo-xian-cheng-ru-men-lei-he-jie-kou/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-java-duo-xian-cheng-ru-men-lei-he-jie-kou/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-Java多线程入门类和接口"><a href="#【Java-多线程并发】-Java多线程入门类和接口" class="headerlink" title="【Java 多线程并发】 Java多线程入门类和接口"></a>【Java 多线程并发】 Java多线程入门类和接口</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Java多线程入门类和接口date: 2023-07-03 08:57tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 Java多线程入门类和接口</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Thread类的几个常用方法</strong></p><ul><li>currentThread()：静态方法，返回对当前正在执行的线程对象的引用；</li><li>start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；</li><li>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；</li><li>sleep()：静态方法，使当前线程睡眠一段时间；</li><li>join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</li></ul><p><strong>Thread类与Runnable接口的比较</strong></p><ul><li>由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread<strong>更灵活</strong>。</li><li>Runnable接口出现<strong>更符合面向对象</strong>，将线程单独进行对象的封装。</li><li>Runnable接口出现，降低了线程对象和线程任务的<strong>耦合性</strong>。</li><li>如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为<strong>轻量</strong>。<br>所以，我们通常优先使用“实现Runnable接口”这种方式来<strong>自定义</strong>线程类。</li></ul><h2 id="Thread类和Runnable接口"><a href="#Thread类和Runnable接口" class="headerlink" title="Thread类和Runnable接口"></a>Thread类和Runnable接口</h2><p>首先，我们需要有一个“线程”类。JDK提供了Thread类和Runnalble接口来让我们实现自己的“线程”类。</p><ul><li>继承Thread类，并重写run方法；</li><li>实现Runnable接口的run方法；</li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>先学会怎么用，再学原理。首先我们来看看怎么用Thread和Runnable来写一个Java多线程程序。<br>首先是继承Thread类：</p><pre><code class="line-numbers language-java">public class Demo {    public static class MyThread extends Thread {        @Override        public void run() {            System.out.println("MyThread");        }    }    public static void main(String[] args) {        Thread myThread = new MyThread();        myThread.start();    }}</code></pre><p>注意要调用start()方法后，该线程才算启动！</p><blockquote><p>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。<br>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出异常。</p></blockquote><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>接着我们来看一下Runnable接口(JDK 1.8 +)：</p><pre><code class="line-numbers language-java">@FunctionalInterfacepublic interface Runnable {    public abstract void run();}</code></pre><p>可以看到Runnable是一个函数式接口，这意味着我们可以使用Java 8的<strong>函数式编程</strong>来简化代码。</p><pre><code class="line-numbers language-java">public class Demo {    public static class MyThread implements Runnable {        @Override        public void run() {            System.out.println("MyThread");        }    }    public static void main(String[] args) {        new MyThread().start();        // Java 8 函数式编程，可以省略MyThread类        new Thread(() -&gt; {            System.out.println("Java 8 匿名内部类");        }).start();    }}</code></pre><h3 id="Thread类构造方法"><a href="#Thread类构造方法" class="headerlink" title="Thread类构造方法"></a>Thread类构造方法</h3><p>Thread类是一个Runnable接口的实现类，我们来看看Thread类的源码。<br>查看Thread类的构造方法，发现其实是简单调用一个私有的init方法来实现初始化。init的方法签名：</p><pre><code class="line-numbers language-java">// Thread类源码 // 片段1 - init方法private void init(ThreadGroup g, Runnable target, String name,                      long stackSize, AccessControlContext acc,                      boolean inheritThreadLocals)// 片段2 - 构造函数调用init方法public Thread(Runnable target) {    init(null, target, "Thread-" + nextThreadNum(), 0);}// 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性this.inheritedAccessControlContext =     acc != null ? acc : AccessController.getContext();// 片段4 - 两个对用于支持ThreadLocal的私有属性ThreadLocal.ThreadLocalMap threadLocals = null;ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</code></pre><p>我们挨个来解释一下init方法的这些参数：</p><ul><li>g：线程组，指定这个线程是在哪个线程组下；</li><li>target：指定要执行的任务；</li><li>name：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；</li><li>acc：见片段3，用于初始化私有变量inheritedAccessControlContext。<blockquote><p>这个变量有点神奇。它是一个私有变量，但是在Thread类里只有init方法对它进行初始化，在exit方法把它设为null。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：Restrict permissions to threads which execute third party software；</p></blockquote></li><li>inheritThreadLocals：可继承的ThreadLocal，见片段4，Thread类里面有两个私有属性来支持ThreadLocal，我们会在后面的章节介绍ThreadLocal的概念。</li></ul><p>实际情况下，我们大多是直接调用下面两个构造方法：</p><pre><code class="line-numbers language-java">Thread(Runnable target)Thread(Runnable target, String name)</code></pre><h3 id="Thread类的几个常用方法"><a href="#Thread类的几个常用方法" class="headerlink" title="Thread类的几个常用方法"></a>Thread类的几个常用方法</h3><p>这里介绍一下Thread类的几个常用的方法：</p><ul><li>currentThread()：静态方法，返回对当前正在执行的线程对象的引用；</li><li>start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；</li><li>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；</li><li>sleep()：静态方法，使当前线程睡眠一段时间；</li><li>join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</li></ul><h3 id="Thread类与Runnable接口的比较："><a href="#Thread类与Runnable接口的比较：" class="headerlink" title="Thread类与Runnable接口的比较："></a>Thread类与Runnable接口的比较：</h3><p>实现一个自定义的线程类，可以有继承Thread类或者实现Runnable接口这两种方式，它们之间有什么优劣呢？</p><ul><li>由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。</li><li>Runnable接口出现更符合面向对象，将线程单独进行对象的封装。</li><li>Runnable接口出现，降低了线程对象和线程任务的耦合性。</li><li>如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。<br>所以，我们通常优先使用“实现Runnable接口”这种方式来自定义线程类。</li></ul><h2 id="Callable、Future与FutureTask"><a href="#Callable、Future与FutureTask" class="headerlink" title="Callable、Future与FutureTask"></a>Callable、Future与FutureTask</h2><p>通常来说，我们使用Runnable和Thread来创建一个新的线程。但是它们有一个弊端，就是run方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p><p>JDK提供了Callable接口与Future类为我们解决这个问题，这也是所谓的“异步”模型。</p><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>Callable与Runnable类似，同样是只有一个抽象方法的函数式接口。不同的是，Callable提供的方法是有返回值的，而且支持泛型。</p><pre><code class="line-numbers language-java">@FunctionalInterfacepublic interface Callable&lt;V&gt; {    V call() throws Exception;}</code></pre><p>那一般是怎么使用Callable的呢？Callable一般是配合线程池工具ExecutorService来使用的。我们会在后续章节解释线程池的使用。这里只介绍ExecutorService可以使用submit方法来让一个Callable接口执行。它会返回一个Future，我们后续的程序可以通过这个Future的get方法得到结果。</p><p>这里可以看一个简单的使用demo：</p><pre><code class="line-numbers language-java">// 自定义Callableclass Task implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        // 模拟计算需要一秒        Thread.sleep(1000);        return 2;    }    public static void main(String args[]){        // 使用        ExecutorService executor = Executors.newCachedThreadPool();        Task task = new Task();        Future&lt;Integer&gt; result = executor.submit(task);        // 注意调用get方法会阻塞当前线程，直到得到结果。        // 所以实际编码中建议使用可以设置超时时间的重载get方法。        System.out.println(result.get());     }}</code></pre><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>Future接口只有几个比较简单的方法：</p><pre><code class="line-numbers language-java">public abstract interface Future&lt;V&gt; {    public abstract boolean cancel(boolean paramBoolean);    public abstract boolean isCancelled();    public abstract boolean isDone();    public abstract V get() throws InterruptedException, ExecutionException;    public abstract V get(long paramLong, TimeUnit paramTimeUnit)            throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><p>cancel方法是试图取消一个线程的执行。<br>注意是试图取消，并不一定能取消成功。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。boolean类型的返回值是“是否取消成功”的意思。参数paramBoolean表示是否采用中断的方式取消线程执行。<br>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。</p><h2 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h2><p>上面介绍了Future接口。这个接口有一个实现类叫FutureTask。FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口</p><pre><code class="line-numbers language-java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {    /**     * Sets this Future to the result of its computation     * unless it has been cancelled.     */    void run();}</code></pre><p>那FutureTask类有什么用？为什么要有一个FutureTask类？前面说到了Future只是一个接口，而它里面的cancel，get，isDone等方法要自己实现起来都是非常复杂的。所以JDK提供了一个FutureTask类来供我们使用。</p><p>示例代码：</p><pre><code class="line-numbers language-java">// 自定义Callable，与上面一样class Task implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        // 模拟计算需要一秒        Thread.sleep(1000);        return 2;    }    public static void main(String args[]){        // 使用        ExecutorService executor = Executors.newCachedThreadPool();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Task());        executor.submit(futureTask);        System.out.println(futureTask.get());    }}</code></pre><p>使用上与第一个Demo有一点小的区别。首先，调用submit方法是没有返回值的。这里实际上是调用的submit(Runnable task)方法，而上面的Demo，调用的是submit(Callable&lt;T&gt; task)方法。</p><p>然后，这里是使用FutureTask直接取get取值，而上面的Demo是通过submit方法返回的Future去取值。</p><p>在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。这块有兴趣的同学可以参看FutureTask源码。</p><h3 id="FutureTask的几个状态"><a href="#FutureTask的几个状态" class="headerlink" title="FutureTask的几个状态"></a>FutureTask的几个状态</h3><pre><code class="line-numbers language-java">/**  *  * state可能的状态转变路径如下：  * NEW -&gt; COMPLETING -&gt; NORMAL  * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL  * NEW -&gt; CANCELLED  * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED  */private volatile int state;private static final int NEW          = 0;private static final int COMPLETING   = 1;private static final int NORMAL       = 2;private static final int EXCEPTIONAL  = 3;private static final int CANCELLED    = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED  = 6;</code></pre><blockquote><p>state表示任务的运行状态，初始状态为NEW。运行状态只会在set、setException、cancel方法中终止。COMPLETING、INTERRUPTING是任务完成后的瞬时状态。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 进程与线程基本概念</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-jin-cheng-yu-xian-cheng-ji-ben-gai-nian/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-ji-chu/java-duo-xian-cheng-bing-fa-jin-cheng-yu-xian-cheng-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-进程与线程基本概念"><a href="#【Java-多线程并发】-进程与线程基本概念" class="headerlink" title="【Java 多线程并发】 进程与线程基本概念"></a>【Java 多线程并发】 进程与线程基本概念</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 进程与线程基本概念date: 2023-07-03 08:50tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 【Java 多线程并发】 进程与线程基本概念</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>进程和线程的区别</strong></p><p>本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）<br>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位 。</p><p><strong>上下文切换</strong></p><p>指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指==某一时间点 CPU 寄存器和程序计数器的内容==。</p><h2 id="进程产生的背景"><a href="#进程产生的背景" class="headerlink" title="进程产生的背景"></a>进程产生的背景</h2><p><strong>批处理操作系统</strong></p><p>批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行<br>批处理操作效率也不高</p><p><strong>进程的提出</strong></p><p>进程就是应用程序在内存中分配的空间，也就是正在运行的程序</p><p>使用进程+CPU时间片轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务</p><p><strong>线程的提出</strong></p><p>让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</p><p>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</p><pre><code class="line-numbers language-ad-question">title: 多进程的方式也可以实现并发，为什么我们要使用多线程？多进程方式确实可以实现并发，但使用多线程，有以下几个好处：- 进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。- 进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</code></pre><p><strong>进程和线程的区别</strong></p><p>本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）：</p><ul><li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li><li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li><li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li></ul><p>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位 。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指==某一时间点 CPU 寄存器和程序计数器的内容==。</p><blockquote><p>寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。<br>程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。<br>举例说明 线程A - B<br>1.先挂起线程A，将其在cpu中的状态保存在内存中。<br>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。<br>3.当B执行完，根据程序计数器中指向的位置恢复线程A。</p></blockquote><p>上下文切换通常是计算密集型的，意味着此操作会消耗大量的 CPU 时间，故线程也不是越多越好。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java jVM】 内存管理</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-nei-cun-guan-li/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-jVM】-内存管理"><a href="#【Java-jVM】-内存管理" class="headerlink" title="【Java jVM】 内存管理"></a>【Java jVM】 内存管理</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java jVM】 内存管理date: 2023-07-01 22:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java jVM】 内存管理</code></pre><h2 id="【Java-JVM】-JVM与Java体系结构"><a href="#【Java-JVM】-JVM与Java体系结构" class="headerlink" title="【Java JVM】 JVM与Java体系结构"></a>【Java JVM】 JVM与Java体系结构</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-类加载子系统"><a href="#【Java-JVM】-类加载子系统" class="headerlink" title="【Java JVM】 类加载子系统"></a>【Java JVM】 类加载子系统</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-对象实例化"><a href="#【Java-JVM】-对象实例化" class="headerlink" title="【Java JVM】 对象实例化"></a>【Java JVM】 对象实例化</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-运行时数据区"><a href="#【Java-JVM】-运行时数据区" class="headerlink" title="【Java JVM】 运行时数据区"></a>【Java JVM】 运行时数据区</h2><p>undefined</p><h2 id="【Java-JVM】-执行引擎"><a href="#【Java-JVM】-执行引擎" class="headerlink" title="【Java JVM】 执行引擎"></a>【Java JVM】 执行引擎</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-StringTable"><a href="#【Java-JVM】-StringTable" class="headerlink" title="【Java JVM】 StringTable"></a>【Java JVM】 StringTable</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-直接内存"><a href="#【Java-JVM】-直接内存" class="headerlink" title="【Java JVM】 直接内存"></a>【Java JVM】 直接内存</h2><p>undefined</p><h2 id="【Java-JVM】-垃圾收集"><a href="#【Java-JVM】-垃圾收集" class="headerlink" title="【Java JVM】 垃圾收集"></a>【Java JVM】 垃圾收集</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 垃圾收集</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-la-ji-shou-ji/java-jvm-la-ji-shou-ji/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-la-ji-shou-ji/java-jvm-la-ji-shou-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-垃圾收集"><a href="#【Java-JVM】-垃圾收集" class="headerlink" title="【Java JVM】 垃圾收集"></a>【Java JVM】 垃圾收集</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 垃圾收集date: 2023-07-01 22:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 垃圾收集</code></pre><h2 id="【Java-JVM】-垃圾回收概述及算法"><a href="#【Java-JVM】-垃圾回收概述及算法" class="headerlink" title="【Java JVM】 垃圾回收概述及算法"></a>【Java JVM】 垃圾回收概述及算法</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-垃圾回收相关概念"><a href="#【Java-JVM】-垃圾回收相关概念" class="headerlink" title="【Java JVM】 垃圾回收相关概念"></a>【Java JVM】 垃圾回收相关概念</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-垃圾回收器"><a href="#【Java-JVM】-垃圾回收器" class="headerlink" title="【Java JVM】 垃圾回收器"></a>【Java JVM】 垃圾回收器</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 分析 GC 日志</title>
      <link href="/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-fen-xi-gc-ri-zhi/"/>
      <url>/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-fen-xi-gc-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-分析-GC-日志"><a href="#【Java-JVM】-分析-GC-日志" class="headerlink" title="【Java JVM】 分析 GC 日志"></a>【Java JVM】 分析 GC 日志</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 分析 GC 日志date: 2023-07-01 11:22tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 分析 GC 日志</code></pre><h2 id="GC-分类"><a href="#GC-分类" class="headerlink" title="GC 分类"></a>GC 分类</h2><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li><p>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0, S1）的垃圾收集</li><li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。目前，只有 CMS GC 会有单独收集老年代的行为。<mark>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li></ul></li><li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有 G1 GC 会有这种行为</p></li><li><p>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</p></li></ul><h2 id="GC-日志分类"><a href="#GC-日志分类" class="headerlink" title="GC 日志分类"></a>GC 日志分类</h2><p><strong>MinorGC</strong></p><p>MinorGC（或 young GC 或 YGC）日志：</p><pre><code class="line-numbers language-java">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</code></pre><p><img src="/attachment/9aaa3f3e8c30bb5f11eb152fc3569b9b.png"></p><p><img src="/attachment/dec55d04e424287f277756a5ff552ba2.png"></p><p><strong>FullGC</strong></p><pre><code class="line-numbers language-java">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], 0.0245883 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]</code></pre><p><img src="/attachment/16b946b44bce27ae634f4e5fa75c1055.png"></p><p><img src="/attachment/bdf64e5d93942bccbcf2ce519e51e4da.png"></p><h2 id="GC-日志结构剖析"><a href="#GC-日志结构剖析" class="headerlink" title="GC 日志结构剖析"></a>GC 日志结构剖析</h2><p><strong>透过日志看垃圾收集器</strong></p><ul><li>Serial 收集器：新生代显示 “[DefNew”，即 Default New Generation</li><li>ParNew 收集器：新生代显示 “[ParNew”，即 Parallel New Generation</li><li>Parallel Scavenge 收集器：新生代显示”[PSYoungGen”，JDK1.7 使用的即 PSYoungGen</li><li>Parallel Old 收集器：老年代显示”[ParoldGen”</li><li>G1 收集器：显示”garbage-first heap“</li></ul><p><strong>透过日志看 GC 原因</strong></p><ul><li>Allocation Failure：表明本次引起 GC 的原因是因为新生代中没有足够的区域存放需要分配的数据</li><li>Metadata GCThreshold：Metaspace 区不够用了</li><li>FErgonomics：JVM 自适应调整导致的 GC</li><li>System：调用了 System.gc()方法</li></ul><p><strong>透过日志看 GC 前后情况</strong></p><p>通过图示，我们可以发现 GC 日志格式的规律一般都是：GC 前内存占用-＞ GC 后内存占用（该区域内存总大小）</p><pre><code class="line-numbers language-java">[PSYoungGen: 5986K-&gt;696K (8704K) ] 5986K-&gt;704K (9216K)</code></pre><ul><li><p>中括号内：GC 回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</p></li><li><p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p></li></ul><p><mark>注意</mark>：Minor GC 堆内存总容量 = 9/10 年轻代 + 老年代。原因是 Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系，Eden:S0:S1=8:1:1。</p><p><strong>透过日志看 GC 时间</strong></p><p>GC 日志中有三个时间：user，sys 和 real</p><ul><li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</li><li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的 CPU 时间</li><li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行 gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核的原因，一般的 GC 事件中，real time 是小于 sys time ＋ user time 的，因为一般是多个线程并发的去做 GC，所以 real time 是要小于 sys ＋ user time 的。如果 real ＞ sys ＋ user 的话，则你的应用可能存在下列问题：IO 负载非常重或 CPU 不够用。</p><h2 id="GC-日志分析工具"><a href="#GC-日志分析工具" class="headerlink" title="GC 日志分析工具"></a>GC 日志分析工具</h2><p><strong>GCEasy</strong></p><p>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的。</p><p>官网地址：<a href="https://gceasy.io/">https://gceasy.io/</a></p><p><strong>GCViewer</strong></p><p>GCViewer 是一款离线的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:&lt;file&gt;。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p><p>源码下载：<a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></p><p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p><p><strong>GChisto</strong></p><ul><li>官网上没有下载的地方，需要自己从 SVN 上拉下来编译</li><li>不过这个工具似乎没怎么维护了，存在不少 bug</li></ul><p><strong>HPjmeter</strong></p><ul><li>工具很强大，但是只能打开由以下参数生成的 GC log，-verbose:gc -Xloggc:gc.log。添加其他参数生成的 gc.log 无法打开</li><li>HPjmeter 集成了以前的 HPjtune 功能，可以分析在 HP 机器上产生的垃圾回收日志文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 JVM 运行时参数</title>
      <link href="/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-jvm-yun-xing-shi-can-shu/"/>
      <url>/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-jvm-yun-xing-shi-can-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-JVM-运行时参数"><a href="#【Java-JVM】-JVM-运行时参数" class="headerlink" title="【Java JVM】 JVM 运行时参数"></a>【Java JVM】 JVM 运行时参数</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 JVM 运行时参数date: 2023-07-01 11:14tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 JVM 运行时参数</code></pre><h2 id="【Java-JVM】-JVM-运行时参数-1"><a href="#【Java-JVM】-JVM-运行时参数-1" class="headerlink" title="【Java JVM】 JVM 运行时参数"></a>【Java JVM】 JVM 运行时参数</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p><h3 id="类型一：标准参数选项"><a href="#类型一：标准参数选项" class="headerlink" title="类型一：标准参数选项"></a>类型一：标准参数选项</h3><pre><code class="line-numbers language-shell">&gt; java -help用法: java [-options] class [args...]           (执行类)   或  java [-options] -jar jarfile [args...]           (执行 jar 文件)其中选项包括:    -d32          使用 32 位数据模型 (如果可用)    -d64          使用 64 位数据模型 (如果可用)    -server       选择 "server" VM                  默认 VM 是 server.    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;                  用 ; 分隔的目录, JAR 档案                  和 ZIP 档案列表, 用于搜索类文件。    -D&lt;名称&gt;=&lt;值&gt;                  设置系统属性    -verbose:[class|gc|jni]                  启用详细输出    -version      输出产品版本并退出    -version:&lt;值&gt;                  警告: 此功能已过时, 将在                  未来发行版中删除。                  需要指定的版本才能运行    -showversion  输出产品版本并继续    -jre-restrict-search | -no-jre-restrict-search                  警告: 此功能已过时, 将在                  未来发行版中删除。                  在版本搜索中包括/排除用户专用 JRE    -? -help      输出此帮助消息    -X            输出非标准选项的帮助    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  按指定的粒度启用断言    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  禁用具有指定粒度的断言    -esa | -enablesystemassertions                  启用系统断言    -dsa | -disablesystemassertions                  禁用系统断言    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]                  按完整路径名加载本机代理库    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]                  加载 Java 编程语言代理, 请参阅 java.lang.instrument    -splash:&lt;imagepath&gt;                  使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</code></pre><p><strong>Server 模式和 Client 模式</strong></p><p>Hotspot JVM 有两种模式，分别是 server 和 client，分别通过-server 和-client 模式设置</p><ul><li>32 位系统上，默认使用 Client 类型的 JVM。要想使用 Server 模式，机器配置至少有 2 个以上的 CPU 和 2G 以上的物理内存。client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器</li><li>64 位系统上，只支持 server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</li></ul><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html</a></p><p>如何知道系统默认使用的是那种模式呢？</p><p>通过 java -version 命令：可以看到 Server VM 字样，代表当前系统使用是 Server 模式</p><pre><code class="line-numbers language-shell">&gt; java -versionjava version "1.8.0_201"Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</code></pre><h3 id="类型二：-X-参数选项"><a href="#类型二：-X-参数选项" class="headerlink" title="类型二：-X 参数选项"></a>类型二：-X 参数选项</h3><pre><code class="line-numbers language-shell">&gt; java -X    -Xmixed           混合模式执行 (默认)    -Xint             仅解释模式执行    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      设置搜索路径以引导类和资源    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      附加在引导类路径末尾    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      置于引导类路径之前    -Xdiag            显示附加诊断消息    -Xnoclassgc       禁用类垃圾收集    -Xincgc           启用增量垃圾收集    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)    -Xbatch           禁用后台编译    -Xms&lt;size&gt;        设置初始 Java 堆大小    -Xmx&lt;size&gt;        设置最大 Java 堆大小    -Xss&lt;size&gt;        设置 Java 线程堆栈大小    -Xprof            输出 cpu 配置文件数据    -Xfuture          启用最严格的检查, 预期将来的默认值    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)    -Xcheck:jni       对 JNI 函数执行其他检查    -Xshare:off       不尝试使用共享类数据    -Xshare:auto      在可能的情况下使用共享类数据 (默认)    -Xshare:on        要求使用共享类数据, 否则将失败。    -XshowSettings    显示所有设置并继续    -XshowSettings:all                      显示所有设置并继续    -XshowSettings:vm 显示所有与 vm 相关的设置并继续    -XshowSettings:properties                      显示所有属性设置并继续    -XshowSettings:locale                      显示所有与区域设置相关的设置并继续-X 选项是非标准选项, 如有更改, 恕不另行通知。</code></pre><p>如何知道 JVM 默认使用的是混合模式呢？</p><p>同样地，通过 java -version 命令：可以看到 mixed mode 字样，代表当前系统使用的是混合模式</p><h3 id="类型三：-XX-参数选项"><a href="#类型三：-XX-参数选项" class="headerlink" title="类型三：-XX 参数选项"></a>类型三：-XX 参数选项</h3><p><strong>Boolean 类型格式</strong></p><pre><code class="line-numbers language-shell">-XX:+&lt;option&gt;  启用option属性-XX:-&lt;option&gt;  禁用option属性</code></pre><p><strong>非 Boolean 类型格式</strong></p><pre><code class="line-numbers language-shell">-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值</code></pre><h2 id="添加-JVM-参数选项"><a href="#添加-JVM-参数选项" class="headerlink" title="添加 JVM 参数选项"></a>添加 JVM 参数选项</h2><p>eclipse 和 idea 中配置不必多说，在 Run Configurations 中 VM Options 中配置即可，大同小异</p><p><strong>运行 jar 包</strong></p><pre><code class="line-numbers language-shell">java -Xms100m -Xmx100m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -jar demo.jar</code></pre><p><strong>Tomcat 运行 war 包</strong></p><pre><code class="line-numbers language-shell"># linux下catalina.sh添加JAVA_OPTS="-Xms512M -Xmx1024M"# windows下catalina.bat添加set "JAVA_OPTS=-Xms512M -Xmx1024M"</code></pre><p><strong>程序运行中</strong></p><pre><code class="line-numbers language-shell"># 设置Boolean类型参数jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;# 设置非Boolean类型参数jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</code></pre><h2 id="常用的-JVM-参数选项"><a href="#常用的-JVM-参数选项" class="headerlink" title="常用的 JVM 参数选项"></a>常用的 JVM 参数选项</h2><h3 id="打印设置的-XX-选项及值"><a href="#打印设置的-XX-选项及值" class="headerlink" title="打印设置的 XX 选项及值"></a>打印设置的 XX 选项及值</h3><pre><code class="line-numbers language-shell">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项-XX:+PrintFlagsInitial 打印所有XX选项的默认值-XX:+PrintFlagsFinal 打印所有XX选项的实际值-XX:+PrintVMOptions 打印JVM的参数</code></pre><h3 id="堆、栈、方法区等内存大小设置"><a href="#堆、栈、方法区等内存大小设置" class="headerlink" title="堆、栈、方法区等内存大小设置"></a>堆、栈、方法区等内存大小设置</h3><pre><code class="line-numbers language-shell"># 栈-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K# 堆-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例# 方法区-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M-XX:+UseCompressedOops 使用压缩对象-XX:+UseCompressedClassPointers 使用压缩类指针-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G# 直接内存-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值</code></pre><h3 id="OutOfMemory-相关的选项"><a href="#OutOfMemory-相关的选项" class="headerlink" title="OutOfMemory 相关的选项"></a>OutOfMemory 相关的选项</h3><pre><code class="line-numbers language-shell">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本</code></pre><h3 id="垃圾收集器相关选项"><a href="#垃圾收集器相关选项" class="headerlink" title="垃圾收集器相关选项"></a>垃圾收集器相关选项</h3><p>首先需了解垃圾收集器之间的搭配使用关系</p><ul><li>红色虚线表示在 jdk8 时被 Deprecate，jdk9 时被删除</li><li>绿色虚线表示在 jdk14 时被 Deprecate</li><li>绿色虚框表示在 jdk9 时被 Deprecate，jdk14 时被删除</li></ul><p><img src="/attachment/c37e1103b3016512d2e8ebb93a40da1c.png"></p><pre><code class="line-numbers language-shell"># Serial回收器-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC# ParNew回收器-XX:+UseParNewGC  年轻代使用ParNew GC-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。    一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</code></pre><p>$$<br>ParallelGCThreads =<br>\begin{cases}<br>CPU_Count &amp; \text (CPU_Count &lt;= 8) \<br>3 + (5 * CPU＿Count / 8) &amp; \text (CPU_Count &gt; 8)<br>\end{cases}<br>$$</p><pre><code class="line-numbers language-shell"># Parallel回收器-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活-XX:ParallelGCThreads-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。    为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。    对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。    所以服务器端适合Parallel，进行控制。该参数使用需谨慎。-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小    取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。    与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。    在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。    在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</code></pre><pre><code class="line-numbers language-shell"># CMS回收器-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。    开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。    如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。    反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。    因此通过该选项便可以有效降低Fu1l GC的执行次数。-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理    以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。-XX:ParallelCMSThreads  设置CMS的线程数量。    CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。    当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记    用于提高标记速度，在Java8开始已经默认开启-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启-XX:+ExplicitGCInvokesConcurrent-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses    这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段</code></pre><pre><code class="line-numbers language-shell"># G1回收器-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。-XX:G1HeapRegionSize 设置每个Region的大小。    值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 JVM监控及诊断工具-GUI篇</title>
      <link href="/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-jvm-jian-kong-ji-zhen-duan-gong-ju-gui-pian/"/>
      <url>/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-jvm-jian-kong-ji-zhen-duan-gong-ju-gui-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-JVM监控及诊断工具-GUI篇"><a href="#【Java-JVM】-JVM监控及诊断工具-GUI篇" class="headerlink" title="【Java JVM】 JVM监控及诊断工具-GUI篇"></a>【Java JVM】 JVM监控及诊断工具-GUI篇</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 JVM监控及诊断工具-GUI篇date: 2023-07-01 10:59tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 JVM监控及诊断工具-GUI篇</code></pre><h2 id="【Java-JVM】-JVM监控及诊断工具-GUI篇-1"><a href="#【Java-JVM】-JVM监控及诊断工具-GUI篇-1" class="headerlink" title="【Java JVM】 JVM监控及诊断工具-GUI篇"></a>【Java JVM】 JVM监控及诊断工具-GUI篇</h2><p>使用上一章命令行工具或组合能帮您获取目标 Java 应用性能相关的基础信息，但它们存在下列局限：</p><ul><li>1．无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li><li>2．要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li><li>3．分析数据通过终端输出，结果展示不够直观。</li></ul><p>为此，JDK 提供了一些内存泄漏的分析工具，如 jconsole，jvisualvm 等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p><p><strong>JDK 自带的工具</strong></p><ul><li>jconsole：JDK 自带的可视化监控工具。查看 Java 应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等</li><li>Visual VM：Visual VM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机上运行的基于 Java 技术的应用程序的详细信息。</li><li>JMC：Java Mission Control，内置 Java Flight Recorder。能够以极低的性能开销收集 Java 虚拟机的性能数据。</li></ul><p><strong>第三方工具</strong></p><ul><li>MAT：MAT（Memory Analyzer Tool）是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>JProfiler：商业软件，需要付费。功能强大。</li></ul><h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>jconsole：从 Java5 开始，在 JDK 中自带的 java 监控和管理控制台。用于对 JVM 中内存、线程和类等的监控，是一个基于 JMX（java management extensions）的 GUI 性能监控工具。</p><p>官方地址：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></p><p><img src="/attachment/db3bf6852e907910fc5921981a93ed31.png"></p><p><img src="/attachment/964d9b0082eaf0e2fa8169c7830ac30c.png"></p><p><img src="/attachment/31d323c7ed7db0f24f4db1cc020e2ba2.png"></p><p><img src="/attachment/10f9b4bc64623bb0edc1f8561e9399a1.png"></p><p><img src="/attachment/a0410a009133aa882dd5c2636eae6dcd.png"></p><h2 id="Visual-VM"><a href="#Visual-VM" class="headerlink" title="Visual VM"></a>Visual VM</h2><p>Visual VM 是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个 JDK 命令行工具，使用 Visual VM 可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的 CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替 JConsole。在 JDK 6 Update 7 以后，Visual VM 便作为 JDK 的一部分发布（VisualVM 在 JDK／bin 目录下）即：它完全免费。</p><p><strong>主要功能：</strong></p><ul><li>1.生成/读取堆内存/线程快照</li><li>2.查看 JVM 参数和系统属性</li><li>3.查看运行中的虚拟机进程</li><li>4.程序资源的实时监控</li><li>5.JMX 代理连接、远程环境监控、CPU 分析和内存分析</li></ul><p>官方地址：<a href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a></p><p><img src="/attachment/966f6daa585730c638ded68a11266167.png"></p><p><img src="/attachment/c2acc1ad21832ac2b3f554e6022b5fa1.png"></p><p><img src="/attachment/11f6757ba20d8d69951054971127a78d.png"></p><h2 id="Eclipse-MAT"><a href="#Eclipse-MAT" class="headerlink" title="Eclipse MAT"></a>Eclipse MAT</h2><p>MAT（Memory Analyzer Tool）工具是一款功能强大的 Java 堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。MAT 是基于 Eclipse 开发的，不仅可以单独使用，还可以作为插件的形式嵌入在 Eclipse 中使用。是一款免费的性能分析工具，使用起来非常方便。</p><p>MAT 可以分析 heap dump 文件。在进行内存分析时，只要获得了反映当前设备内存映像的 hprof 文件，通过 MAT 打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：</p><ul><li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li><li>所有的类信息，包括 classloader、类名称、父类、静态变量等</li><li>GCRoot 到所有的这些对象的引用路径</li><li>线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）</li></ul><p>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM 的 PHD 堆存储文件等都能被很好的解析。</p><p>最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然 MAT 有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从 MAT 展现给我们的信息当中通过经验和直觉来判断才能发现。</p><p>官方地址： [<a href="https://www.eclipse.org/mat/downloads.php]">https://www.eclipse.org/mat/downloads.php]</a>(</p><p><img src="/attachment/11b6e878d227756798b94fa189a7ba50.png"></p><p><img src="/attachment/8b9542c0c27f981dea9fd8fdd4cf5815.png"></p><p><img src="/attachment/91e994eb5f8d6c9cecd3a7a6b1e8bc94.png"></p><p><img src="/attachment/f3b2a7e2986abbc98f9c19ecbec7cb40.png"></p><h2 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h2><p>在运行 Java 的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在 eclipse 里面有 Eclipse Memory Analyzer tool（MAT）插件可以测试，而在 IDEA 中也有这么一个插件，就是 JProfiler。JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p><p><strong>特点：</strong></p><ul><li>使用方便、界面操作友好（简单且强大）</li><li>对被分析的应用影响小（提供模板）</li><li>CPU，Thread，Memory 分析功能尤其强大</li><li>支持对 jdbc，noSql，jsp，servlet，socket 等进行分析</li><li>支持多种模式（离线，在线）的分析</li><li>支持监控本地、远程的 JVM</li><li>跨平台，拥有多种操作系统的安装版本</li></ul><p><strong>主要功能：</strong></p><ul><li>1-方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li><li>2-内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li><li>3-线程和锁：JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题</li><li>4-高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于 JDBC 调用，您可能希望找出执行最慢的 SQL 语句。JProfiler 支持对这些子系统进行集成分析</li></ul><p>官网地址：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><p><strong>数据采集方式：</strong></p><p>JProfier 数据采集方式分为两种：Sampling（样本采集）和 Instrumentation（重构模式）</p><p><strong>Instrumentation</strong>：这是 JProfiler 全功能模式。在 class 加载之前，JProfier 把相关功能代码写入到需要分析的 class 的 bytecode 中，对正在运行的 jvm 有一定影响。</p><ul><li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li><li>缺点：若要分析的 class 较多，则对应用的性能影响较大，CPU 开销可能很高（取决于 Filter 的控制）。因此使用此模式一般配合 Filter 使用，只对特定的类或包进行分析</li></ul><p><strong>Sampling</strong>：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。</p><ul><li>优点：对 CPU 的开销非常低，对应用影响小（即使你不配置任何 Filter）</li><li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li></ul><p>注：JProfiler 本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为 JProfiler 的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是 JProfiler 的数据采集类型。</p><p><strong>遥感监测 Telemetries</strong></p><p><img src="/attachment/62a1fa4244891ca69c88a99dd962f898.png"></p><p><img src="/attachment/42970ef6bf80ea4892bc912ffe78e6c1.png"></p><p><img src="/attachment/01a275acf00501de351e6e34ae69345e.png"></p><p><img src="/attachment/da776acf77d6ae56abb092c10c43bb9e.png"></p><p><img src="/attachment/4a679a24f58c2637307d96d619e58a15.png"></p><p><img src="/attachment/d2b6de1b4a8a7b4b8eac62e951dd76bb.png"></p><p><img src="/attachment/f1ea6e666d1d6f01d72c3bb7e57f4c77.png"></p><p><strong>内存视图 Live Memory</strong></p><p>Live memory 内存剖析：class／class instance 的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p><ul><li><strong>所有对象 All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有 Java 1.5（JVMTI）才会显示此视图。</li><li><strong>记录对象 Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</li><li><strong>分配访问树 Allocation Call Tree</strong>：显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的 J2EE 组件。</li><li><strong>分配热点 Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的 J2EE 组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</li><li><strong>类追踪器 Class Tracker</strong>：类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</li></ul><p><img src="/attachment/6bf4c4ac6bcfe143d57268462c0c38a0.png"></p><p><img src="/attachment/b1fb69411a6ad0a1b5ca8035522b180b.png"></p><p><strong>堆遍历 heap walker</strong></p><p><img src="/attachment/74fa611f15324051150396d6432e6272.png"></p><p><img src="/attachment/d2c42560812053deb0e04fab7d5f48f0.png"></p><p><strong>cpu 视图 cpu views</strong></p><p>JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或 J2EE 组件等不同层上。</p><ul><li><strong>访问树 Call Tree</strong>：显示一个积累的自顶向下的树，树中包含所有在 JVM 中已记录的访问队列。JDBC，JMS 和 JNDI 服务请求都被注释在请求树中。请求树可以根据 Servlet 和 JSP 对 URL 的不同需要进行拆分。</li><li><strong>热点 Hot Spots</strong>：显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS 和 JNDI 服务请求以及按照 URL 请求来进行计算。</li><li><strong>访问图 Call Graph</strong>：显示一个从已选方法、类、包或 J2EE 组件开始的访问队列的图。</li><li><strong>方法统计 Method Statistis</strong>：显示一段时间内记录的方法的调用时间细节。</li></ul><p><img src="/attachment/c0defaa34e880b3779fd8a28a171b128.png"></p><p><img src="/attachment/b670d108a3227b7fdc43f9a055c2c388.png"></p><p><strong>线程视图 threads</strong></p><p>JProfiler 通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p><ul><li><strong>线程历史 Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li><li><strong>线程监控 Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li><li><strong>线程转储 Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li></ul><p>线程分析主要关心三个方面：</p><ul><li>1．web 容器的线程最大数。比如：Tomcat 的线程容量应该略大于最大并发数。</li><li>2．线程阻塞</li><li>3．线程死锁</li></ul><p><img src="/attachment/361a3f72fab42815d51e086f66bb5ee2.png"></p><p><strong>监控和锁 Monitors ＆Locks</strong></p><p>所有线程持有锁的情况以及锁的信息。观察 JVM 的内部线程并查看状态：</p><ul><li><strong>死锁探测图表 Current Locking Graph</strong>：显示 JVM 中的当前死锁图表。</li><li><strong>目前使用的监测器 Current Monitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li><li><strong>锁定历史图表 Locking History Graph</strong>：显示记录在 JVM 中的锁定历史。</li><li><strong>历史检测记录 Monitor History</strong>：显示重大的等待事件和阻塞事件的历史记录。</li><li><strong>监控器使用统计 Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li></ul><h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p>上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于 Jprofiler 这样的商业工具，是需要付费的。</p><p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？</p><p>阿里巴巴开源的性能分析神器 Arthas 应运而生。</p><p>Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪 Java 代码；实时监控 JVM 状态。Arthas 支持 JDK 6 ＋，支持 Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到 JVM 的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>官方地址：<a href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p><p>安装方式：如果速度较慢，可以尝试国内的码云 Gitee 下载。</p><pre><code class="line-numbers language-shell">wget https://io/arthas/arthas-boot.jarwget https://arthas/gitee/io/arthas-boot.jar</code></pre><p>Arthas 只是一个 java 程序，所以可以直接用 java -jar 运行。</p><p>除了在命令行查看外，Arthas 目前还支持 Web Console。在成功启动连接进程之后就已经自动启动,可以直接访问 <a href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p><p><strong>基础指令</strong></p><pre><code class="line-numbers language-shell">quit/exit 退出当前 Arthas客户端，其他 Arthas喜户端不受影响stop/shutdown 关闭 Arthas服务端，所有 Arthas客户端全部退出help 查看命令帮助信息cat 打印文件内容，和linux里的cat命令类似echo 打印参数，和linux里的echo命令类似grep 匹配查找，和linux里的gep命令类似tee 复制标隹输入到标准输出和指定的文件，和linux里的tee命令类似pwd 返回当前的工作目录，和linux命令类似cls 清空当前屏幕区域session 查看当前会话的信息reset 重置增强类，将被 Arthas增强过的类全部还原, Arthas服务端关闭时会重置所有增强过的类version 输出当前目标Java进程所加载的 Arthas版本号history 打印命令历史keymap Arthas快捷键列表及自定义快捷键</code></pre><p><strong>jvm 相关</strong></p><pre><code class="line-numbers language-shell">dashboard 当前系统的实时数据面板thread 查看当前JVM的线程堆栈信息jvm 查看当前JVM的信息sysprop 查看和修改JVM的系统属性sysem 查看JVM的环境变量vmoption 查看和修改JVM里诊断相关的optionperfcounter 查看当前JVM的 Perf Counter信息logger 查看和修改loggergetstatic 查看类的静态属性ognl 执行ognl表达式mbean 查看 Mbean的信息heapdump dump java heap，类似jmap命令的 heap dump功能</code></pre><p><strong>class/classloader 相关</strong></p><pre><code class="line-numbers language-java">sc 查看JVM已加载的类信息    -d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的Classloader等详细信息。如果一个类被多个Classloader所加载，则会出现多次    -E 开启正则表达式匹配，默认为通配符匹配    -f 输出当前类的成员变量信息（需要配合参数-d一起使用）    -X 指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出sm 查看已加载类的方法信息    -d 展示每个方法的详细信息    -E 开启正则表达式匹配,默认为通配符匹配jad 反编译指定已加载类的源码mc 内存编译器，内存编译.java文件为.class文件retransform 加载外部的.class文件, retransform到JVM里redefine 加载外部的.class文件，redefine到JVM里dump dump已加载类的byte code到特定目录classloader 查看classloader的继承树，urts，类加载信息，使用classloader去getResource    -t 查看classloader的继承树    -l 按类加载实例查看统计信息    -c 用classloader对应的hashcode来查看对应的 Jar urls</code></pre><p><strong>monitor/watch/trace 相关</strong></p><pre><code class="line-numbers language-java">monitor 方法执行监控，调用次数、执行时间、失败率    -c 统计周期，默认值为120秒watch 方法执行观测，能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看    -b 在方法调用之前观察(默认关闭)    -e 在方法异常之后观察(默认关闭)    -s 在方法返回之后观察(默认关闭)    -f 在方法结束之后(正常返回和异常返回)观察(默认开启)    -x 指定输岀结果的属性遍历深度,默认为0trace 方法内部调用路径,并输出方法路径上的每个节点上耗时    -n 执行次数限制stack 输出当前方法被调用的调用路径tt 方法执行数据的时空隧道,记录下指定方法每次调用的入参和返回信息,并能对这些不同的时间下调用进行观测</code></pre><p><strong>其他</strong></p><pre><code class="line-numbers language-java">jobs 列出所有jobkill 强制终止任务fg 将暂停的任务拉到前台执行bg 将暂停的任务放到后台执行grep 搜索满足条件的结果plaintext 将命令的结果去除ANSI颜色wc 按行统计输出结果options 查看或设置Arthas全局开关profiler 使用async-profiler对应用采样，生成火焰图</code></pre><h2 id="Java-Misssion-Control"><a href="#Java-Misssion-Control" class="headerlink" title="Java Misssion Control"></a>Java Misssion Control</h2><p>在 Oracle 收购 Sun 之前，Oracle 的 JRockit 虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p><p>在 Oracle 收购 sun 之后，Oracle 公司同时拥有了 Hotspot 和 JRockit 两款虚拟机。根据 Oracle 对于 Java 的战略，在今后的发展中，会将 JRokit 的优秀特性移植到 Hotspot 上。其中一个重要的改进就是在 Sun 的 JDK 中加入了 JRockit 的支持。</p><p>在 Oracle JDK 7u40 之后，Mission Control 这款工具己经绑定在 Oracle JDK 中发布。</p><p>自 Java11 开始，本节介绍的 JFR 己经开源。但在之前的 Java 版本，JFR 属于 Commercial Feature 通过 Java 虚拟机参数-XX:+UnlockCommercialFeatures 开启。</p><p>Java Mission Control（简称 JMC) ， Java 官方提供的性能强劲的工具，是一个用于对 Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。它包含一个 GUI 客户端以及众多用来收集 Java 虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机齐个于系统运行数据的 MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p><p>JMC 的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着 JMC 来做压测（唯一影响可能是 full gc 多了）。</p><p>官方地址：<a href="https://github.com/JDKMissionControl/jmc">https://github.com/JDKMissionControl/jmc</a></p><p><img src="/attachment/6ea57f1efa6da5bb3cbea506b004a741.png"></p><p><strong>Java Flight Recorder</strong></p><p>Java Flight Recorder 是 JMC 的其中一个组件，能够以极低的性能开销收集 Java 虚拟机的性能数据。与其他工具相比，JFR 的性能开销很小，在默认配置下平均低于 1%。JFR 能够直接访问虚拟机内的敌据并且不会影响虚拟机的优化。因此它非常适用于生产环境下满负荷运行的 Java 程序。</p><p>Java Flight Recorder 和 JDK Mission Control 共同创建了一个完整的工具链。JDK Mission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效、详细的分析。</p><p>当启用时 JFR 将记录运行过程中发生的一系列事件。其中包括 Java 层面的事件如线程事件、锁事件，以及 Java 虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。按照发生时机以及持续时间来划分，JFR 的事件共有四种类型，它们分别为以下四种：</p><ul><li><p>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</p></li><li><p>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</p></li><li><p>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</p></li><li><p>取样事件（Sample Event)，是周期性取样的事件。</p></li></ul><p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法</p><p><img src="/attachment/a3131d4a4d9b912cccd271476ac2c0ae.png"></p><p><img src="/attachment/5c598d9e75a4a51ce6244d26d81f5764.png"></p><p><img src="/attachment/ebebf1e369b36c6ee07280caabf08e04.png"></p><p><img src="/attachment/759f3f73b41b548c7d235183b11a7ccb.png"></p><p><img src="/attachment/54f4bdc10da086c4ef2f513a8d3e8aa3.png"></p><p><img src="/attachment/ddcc3463ba419a1294cd17367ceb1901.png"></p><p><img src="/attachment/a581fc9e21b8894a0c155c9494a140d7.png"></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p><strong>Flame Graphs（火焰图）</strong></p><p>在追求极致性能的场景下，了解你的程序运行过程中 cpu 在干什么很重要，火焰图就是一种非常直观的展示 CPU 在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的 CPU 消耗瓶颈。</p><p>网上的关于 Java 火焰图的讲解大部分来自于 Brenden Gregg 的博客 <a href="http://new.brendangregg.com/flamegraphs.html">http://new.brendangregg.com/flamegraphs.html </a></p><p><img src="/attachment/b4112eff5ce149e491a4c791977d30ac.png"></p><p><strong>Tprofiler</strong></p><p>案例： 使用 JDK 自身提供的工具进行 JVM 调优可以将下 TPS 由 2.5 提升到 20（提升了 7 倍），并准确 定位系统瓶颈。</p><p>系统瓶颈有：应用里释态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p><p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了 GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了 4 倍，即提升到 100。</p><ul><li>Tprofiler 配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够 起到一针见血、立竿见影的效果，帮我们解决了 GC 过于频繁的性能瓶预。</li><li>Tprofiler 最重要的特性就是能够统汁出你指定时间段内 JVM 的 top method 这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出 JRMC 井不支持 TOP 方法的统计。</li></ul><p>官方地址：<a href="http://github.com/alibaba/Tprofiler">http://github.com/alibaba/Tprofiler</a></p><p><strong>Btrace</strong></p><p>常见的动态追踪工具有 BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss 出品），注意 Java 运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。</p><p>BTrace 是 SUN Kenai 云计算开发平台下的一个开源项目，旨在为 java 提供安全可靠的动态跟踪分析工具。先看一卜日 Trace 的官方定义：</p><p><img src="/attachment/6329d391ec78fe2dbd8dc247850c5a15.png"></p><p>大概意思是一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace 动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p><p><strong>YourKit</strong></p><p><strong>JProbe</strong></p><p><strong>Spring Insight</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 JVM 监控及诊断工具-命令行篇</title>
      <link href="/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-jvm-jian-kong-ji-zhen-duan-gong-ju-ming-ling-xing-pian/"/>
      <url>/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-jvm-jian-kong-ji-zhen-duan-gong-ju-ming-ling-xing-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-JVM-监控及诊断工具-命令行篇"><a href="#【Java-JVM】-JVM-监控及诊断工具-命令行篇" class="headerlink" title="【Java JVM】 JVM 监控及诊断工具-命令行篇"></a>【Java JVM】 JVM 监控及诊断工具-命令行篇</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 JVM 监控及诊断工具-命令行篇date: 2023-07-01 10:36tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 JVM 监控及诊断工具-命令行篇</code></pre><h2 id="【Java-JVM】-JVM-监控及诊断工具-命令行篇-1"><a href="#【Java-JVM】-JVM-监控及诊断工具-命令行篇-1" class="headerlink" title="【Java JVM】 JVM 监控及诊断工具-命令行篇"></a>【Java JVM】 JVM 监控及诊断工具-命令行篇</h2><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p><p>Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络 I/O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p><p>体会 1：使用数据说明问题，使用知识分析问题，使用工具处理问题。</p><p>体会 2：无监控、不调优！</p><p><strong>简单命令行工具</strong></p><p>在我们刚接触 java 学习的时候，大家肯定最先了解的两个命令就是 javac，java，那么除此之外，还有没有其他的命令可以供我们使用呢？</p><p>我们进入到安装 jdk 的 bin 目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决 Java 应用程序的一些疑难杂症。</p><p><img src="/attachment/8d69ecda60cbd2cf160432da5b840287.png"></p><p><img src="/attachment/c01f204d27dbf48970f437aee8feab64.png"></p><p>官方源码地址：<a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools">http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p><h2 id="jps：查看正在运行的-Java-进程"><a href="#jps：查看正在运行的-Java-进程" class="headerlink" title="jps：查看正在运行的 Java 进程"></a>jps：查看正在运行的 Java 进程</h2><p>jps(Java Process Status)：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p><p>说明：对于本地虚拟机进程来说，进程的本地虚拟机 ID 与操作系统的进程 ID 是一致的，是唯一的。</p><p>基本使用语法为：jps [options] [hostid]</p><p>我们还可以通过追加参数，来打印额外的信息。</p><p><strong>options 参数</strong></p><ul><li>-q：仅仅显示 LVMID（local virtual machine id），即本地虚拟机唯一 id。不显示主类的名称等</li><li>-l：输出应用程序主类的全类名 或 如果进程执行的是 jar 包，则输出 jar 完整路径</li><li>-m：输出虚拟机进程启动时传递给主类 main()的参数</li><li>-v：列出虚拟机进程启动时的 JVM 参数。比如：-Xms20m -Xmx50m 是启动程序指定的 jvm 参数。</li></ul><p>说明：以上参数可以综合使用。</p><p>补充：如果某 Java 进程关闭了默认开启的 UsePerfData 参数（即使用参数-XX：-UsePerfData），那么 jps 命令（以及下面介绍的 jstat）将无法探知该 Java 进程。</p><p><strong>hostid 参数</strong></p><p>RMI 注册表中注册的主机名。如果想要远程监控主机上的 java 程序，需要安装 jstatd。</p><p>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到 IP 地址欺诈攻击。</p><p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行 jstatd 服务器，而是在本地使用 jstat 和 jps 工具。</p><h2 id="jstat：查看-JVM-统计信息"><a href="#jstat：查看-JVM-统计信息" class="headerlink" title="jstat：查看 JVM 统计信息"></a>jstat：查看 JVM 统计信息</h2><p>jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。在没有 GUI 图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p><p>基本使用语法为：jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</p><p>查看命令相关参数：jstat-h 或 jstat-help</p><p>其中 vmid 是进程 id 号，也就是 jps 之后看到的前面的号码，如下：</p><p><img src="/attachment/de7e790f6dd20bc6a458627881943296.png"></p><p><strong>option 参数</strong></p><p>选项 option 可以由以下值构成。</p><p><mark>类装载相关的：</mark></p><ul><li>-class：显示 ClassLoader 的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul><p><mark>垃圾回收相关的：</mark></p><ul><li>-gc：显示与 GC 相关的堆信息。包括 Eden 区、两个 Survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息。</li><li>-gccapacity：显示内容与-gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间。</li><li>-gcutil：显示内容与-gc 基本相同，但输出主要关注已使用空间占总空间的百分比。</li><li>-gccause：与-gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因。</li><li>-gcnew：显示新生代 GC 状况</li><li>-gcnewcapacity：显示内容与-gcnew 基本相同，输出主要关注使用到的最大、最小空间</li><li>-geold：显示老年代 GC 状况</li><li>-gcoldcapacity：显示内容与-gcold 基本相同，输出主要关注使用到的最大、最小空间</li><li>-gcpermcapacity：显示永久代使用到的最大、最小空间。</li></ul><p><mark>JIT 相关的：</mark></p><ul><li>-compiler：显示 JIT 编译器编译过的方法、耗时等信息</li><li>-printcompilation：输出已经被 JIT 编译的方法</li></ul><p><strong>jstat -class</strong></p><p><img src="/attachment/d50bfa2e7fbbe08a87194018889bd73d.png"></p><p><strong>jstat -compiler</strong></p><p><img src="/attachment/2094e939fb032c2c3cb827bb5511ca8d.png"></p><p><strong>jstat -printcompilation</strong></p><p><img src="/attachment/6111cb1c4d0c60edf850b71e9f02ed58.png"></p><p><strong>jstat -gc</strong></p><p><img src="/attachment/70dc5ead779d72e273aa3c4c065c9e5c.png"></p><p><strong>jstat -gccapacity</strong></p><p><img src="/attachment/734690ff3980d5bcffecf998cb0570d6.png"></p><p><strong>jstat -gcutil</strong></p><p><img src="/attachment/5e0b13a2a9f5a9214de1ad091f9d012a.png"></p><p><strong>jstat -gccause</strong></p><p><img src="/attachment/3712963a766720571cc7b20010d0ca39.png"></p><p><strong>jstat -gcnew</strong></p><p><img src="/attachment/113f935c8c373b2f8ad55574ae82a674.png"></p><p><strong>jstat -gcnewcapacity</strong></p><p><img src="/attachment/3ecdf538c0843efbbe5d7976519912da.png"></p><p><strong>jstat -gcold</strong></p><p><img src="/attachment/6db9ad9ae0d500bad957401b65617726.png"></p><p><strong>jstat -gcoldcapacity</strong></p><p><img src="/attachment/6517cfc75a09e6c702dd264068a45a05.png"></p><p><strong>jstat -t</strong></p><p><img src="/attachment/98574781464b55058b0b233321237f3a.png"></p><p><strong>jstat -t -h</strong></p><p><img src="/attachment/e632331c9117d4dd5ecae470efdb8a79.png"></p><table><thead><tr><th align="left">表头</th><th align="left">含义（字节）</th></tr></thead><tbody><tr><td align="left">EC</td><td align="left">Eden 区的大小</td></tr><tr><td align="left">EU</td><td align="left">Eden 区已使用的大小</td></tr><tr><td align="left">S0C</td><td align="left">幸存者 0 区的大小</td></tr><tr><td align="left">S1C</td><td align="left">幸存者 1 区的大小</td></tr><tr><td align="left">S0U</td><td align="left">幸存者 0 区已使用的大小</td></tr><tr><td align="left">S1U</td><td align="left">幸存者 1 区已使用的大小</td></tr><tr><td align="left">MC</td><td align="left">元空间的大小</td></tr><tr><td align="left">MU</td><td align="left">元空间已使用的大小</td></tr><tr><td align="left">OC</td><td align="left">老年代的大小</td></tr><tr><td align="left">OU</td><td align="left">老年代已使用的大小</td></tr><tr><td align="left">CCSC</td><td align="left">压缩类空间的大小</td></tr><tr><td align="left">CCSU</td><td align="left">压缩类空间已使用的大小</td></tr><tr><td align="left">YGC</td><td align="left">从应用程序启动到采样时 young gc 的次数</td></tr><tr><td align="left">YGCT</td><td align="left">从应用程序启动到采样时 young gc 消耗时间（秒）</td></tr><tr><td align="left">FGC</td><td align="left">从应用程序启动到采样时 full gc 的次数</td></tr><tr><td align="left">FGCT</td><td align="left">从应用程序启动到采样时的 full gc 的消耗时间（秒）</td></tr><tr><td align="left">GCT</td><td align="left">从应用程序启动到采样时 gc 的总时间</td></tr></tbody></table><p><strong>interval 参数：</strong> 用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p><p><strong>count 参数：</strong> 用于指定查询的总次数</p><p><strong>-t 参数：</strong> 可以在输出信息前加上一个 Timestamp 列，显示程序的运行时间。单位：秒</p><p><strong>-h 参数：</strong> 可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p><p><strong>补充：</strong> jstat 还可以用来判断是否出现内存泄漏。</p><p>第 1 步：在长时间运行的 Java 程序中，我们可以运行 jstat 命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p><p>第 2 步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p><h2 id="jinfo：实时查看和修改-JVM-配置参数"><a href="#jinfo：实时查看和修改-JVM-配置参数" class="headerlink" title="jinfo：实时查看和修改 JVM 配置参数"></a>jinfo：实时查看和修改 JVM 配置参数</h2><p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。在很多情况卡，Java 应用程序不会指定所有的 Java 虚拟机参数。而此时，开发人员可能不知道某一个具体的 Java 虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了 jinfo 工具，开发人员可以很方便地找到 Java 虚拟机参数的当前值。</p><p>基本使用语法为：jinfo [options] pid</p><p>说明：java 进程 ID 必须要加上</p><table><thead><tr><th>选项</th><th>选项说明</th></tr></thead><tbody><tr><td>no option</td><td>输出全部的参数和系统属性</td></tr><tr><td>-flag name</td><td>输出对应名称的参数</td></tr><tr><td>-flag [+-]name</td><td>开启或者关闭对应名称的参数 只有被标记为 manageable 的参数才可以被动态修改</td></tr><tr><td>-flag name=value</td><td>设定对应名称的参数</td></tr><tr><td>-flags</td><td>输出全部的参数</td></tr><tr><td>-sysprops</td><td>输出系统属性</td></tr></tbody></table><p><strong>jinfo -sysprops</strong></p><pre><code class="line-numbers language-properties">&gt; jinfo -syspropsjboss.modules.system.pkgs = com.intellij.rtjava.vendor = Oracle Corporationsun.java.launcher = SUN_STANDARDsun.management.compiler = HotSpot 64-Bit Tiered Compilerscatalina.useNaming = trueos.name = Windows 10...</code></pre><p><strong>jinfo -flags</strong></p><pre><code class="line-numbers language-java">&gt; jinfo -flags 25592Non-default VM flags: -XX:CICompilerCount=4 -XX:InitialHeapSize=333447168 -XX:MaxHeapSize=5324668928 -XX:MaxNewSize=1774714880 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=111149056 -XX:OldSize=222298112 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCCommand line:  -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:8040,suspend=y,server=n -Drebel.base=C:\Users\Vector\.jrebel -Drebel.env.ide.plugin.version=2021.1.2 -Drebel.env.ide.version=2020.3.3 -Drebel.env.ide.product=IU -Drebel.env.ide=intellij -Drebel.notification.url=http://localhost:7976 -agentpath:C:\Users\Vector\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins\jr-ide-idea\lib\jrebel6\lib\jrebel64.dll -Dmaven.home=D:\eclipse\env\maven -Didea.modules.paths.file=C:\Users\Vector\AppData\Local\JetBrains\IntelliJIdea2020.3\Maven\idea-projects-state-596682c7.properties -Dclassworlds.conf=C:\Users\Vector\AppData\Local\Temp\idea-6755-mvn.conf -Dmaven.ext.class.path=D:\IDEA\plugins\maven\lib\maven-event-listener.jar -javaagent:D:\IDEA\plugins\java\lib\rt\debugger-agent.jar -Dfile.encoding=UTF-8</code></pre><p><strong>jinfo -flag</strong></p><pre><code class="line-numbers language-shell">&gt; jinfo -flag UseParallelGC 25592-XX:+UseParallelGC&gt; jinfo -flag UseG1GC 25592-XX:-UseG1GC</code></pre><p><strong>jinfo -flag name</strong></p><pre><code class="line-numbers language-shell">&gt; jinfo -flag UseParallelGC 25592-XX:+UseParallelGC&gt; jinfo -flag UseG1GC 25592-XX:-UseG1GC</code></pre><p><strong>jinfo -flag [+-]name</strong></p><pre><code class="line-numbers language-shell">&gt; jinfo -flag +PrintGCDetails 25592&gt; jinfo -flag PrintGCDetails 25592-XX:+PrintGCDetails&gt; jinfo -flag -PrintGCDetails 25592&gt; jinfo -flag PrintGCDetails 25592-XX:-PrintGCDetails</code></pre><p>拓展：</p><ul><li>java -XX:+PrintFlagsInitial 查看所有 JVM 参数启动的初始值</li></ul><pre><code class="line-numbers language-properties">- [Global flags]     intx ActiveProcessorCount                      = -1                                  {product}    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   {product}    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  {product}    uintx AdaptiveSizePausePolicy                   = 0                                   {product}...</code></pre><ul><li>java -XX:+PrintFlagsFinal 查看所有 JVM 参数的最终值</li></ul><pre><code class="line-numbers language-properties">&gt;[Global flags]     intx ActiveProcessorCount                      = -1                                  {product}...     intx CICompilerCount                          := 4                                   {product}    uintx InitialHeapSize                          := 333447168                           {product}    uintx MaxHeapSize                              := 1029701632                          {product}    uintx MaxNewSize                               := 1774714880                          {product}</code></pre><ul><li>java -XX:+PrintCommandLineFlags 查看哪些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值</li></ul><pre><code class="line-numbers language-java">-XX:InitialHeapSize=332790016 -XX:MaxHeapSize=5324640256 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre><h2 id="jmap：导出内存映像文件-amp-内存使用情况"><a href="#jmap：导出内存映像文件-amp-内存使用情况" class="headerlink" title="jmap：导出内存映像文件&amp;内存使用情况"></a>jmap：导出内存映像文件&amp;内存使用情况</h2><p>jmap（JVM Memory Map）：作用一方面是获取 dump 文件（堆转储快照文件，二进制文件），它还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“jmap -help”查阅 jmap 工具的具体使用方式和一些标准选项配置。</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">https://docs.oracle.com/en/java/javase/11/tools/jmap.html</a></p><p>基本使用语法为：</p><ul><li>jmap [option] &lt;pid&gt;</li><li>jmap [option] &lt;executable &lt;core&gt;&gt;</li><li>jmap [option] [server_id@] &lt;remote server IP or hostname&gt;</li></ul><table><thead><tr><th align="left">选项</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-dump</td><td align="left">生成 dump 文件（Java 堆转储快照），-dump:live 只保存堆中的存活对象</td></tr><tr><td align="left">-heap</td><td align="left">输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等</td></tr><tr><td align="left">-histo</td><td align="left">输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live 只统计堆中的存活对象</td></tr><tr><td align="left">-J &lt;flag&gt;</td><td align="left">传递参数给 jmap 启动的 jvm</td></tr><tr><td align="left">-finalizerinfo</td><td align="left">显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 linux/solaris 平台有效</td></tr><tr><td align="left">-permstat</td><td align="left">以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 linux/solaris 平台有效</td></tr><tr><td align="left">-F</td><td align="left">当虚拟机进程对-dump 选项没有任何响应时，强制执行生成 dump 文件，仅 linux/solaris 平台有效</td></tr></tbody></table><h2 id="jstack：打印-JVM-中线程快照"><a href="#jstack：打印-JVM-中线程快照" class="headerlink" title="jstack：打印 JVM 中线程快照"></a>jstack：打印 JVM 中线程快照</h2><p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p><p>生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用 jstack 显示各个线程调用的堆栈情况。</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">https://docs.oracle.com/en/java/javase/11/tools/jstack.html</a></p><p>在 thread dump 中，要留意下面几种状态</p><ul><li><mark>死锁，Deadlock（重点关注）</mark></li><li><mark>等待资源，Waiting on condition（重点关注）</mark></li><li><mark>等待获取监视器，Waiting on monitor entry（重点关注）</mark></li><li><mark>阻塞，Blocked（重点关注）</mark></li><li>执行中，Runnable</li><li>暂停，Suspended</li><li>对象等待中，Object.wait() 或 TIMED＿WAITING</li><li>停止，Parked</li></ul><table><thead><tr><th align="left">option 参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-F</td><td align="left">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="left">-l</td><td align="left">除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="left">-m</td><td align="left">如果调用本地方法的话，可以显示 C/C++的堆栈</td></tr></tbody></table><h2 id="jcmd：多功能命令行"><a href="#jcmd：多功能命令行" class="headerlink" title="jcmd：多功能命令行"></a>jcmd：多功能命令行</h2><p>在 JDK 1.7 以后，新增了一个命令行工具 jcmd。它是一个多功能的工具，可以用来实现前面除了 jstat 之外所有命令的功能。比如：用它来导出堆、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等。</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">https://docs.oracle.com/en/java/javase/11/tools/jcmd.html</a></p><p>jcmd 拥有 jmap 的大部分功能，并且在 Oracle 的官方网站上也推荐使用 jcmd 命令代 jmap 命令</p><p><strong>jcmd -l：</strong>列出所有的 JVM 进程</p><p><strong>jcmd 进程号 help：</strong>针对指定的进程，列出支持的所有具体命令</p><p><img src="/attachment/35450b65f4422c02f902c0b58f37ebde.png"></p><p><strong>jcmd 进程号 具体命令：</strong>显示指定进程的指令命令的数据</p><ul><li>Thread.print 可以替换 jstack 指令</li><li>GC.class_histogram 可以替换 jmap 中的-histo 操作</li><li>GC.heap_dump 可以替换 jmap 中的-dump 操作</li><li>GC.run 可以查看 GC 的执行情况</li><li>VM.uptime 可以查看程序的总执行时间，可以替换 jstat 指令中的-t 操作</li><li>VM.system_properties 可以替换 jinfo -sysprops 进程 id</li><li>VM.flags 可以获取 JVM 的配置参数信息</li></ul><h2 id="jstatd：远程主机信息收集"><a href="#jstatd：远程主机信息收集" class="headerlink" title="jstatd：远程主机信息收集"></a>jstatd：远程主机信息收集</h2><p>之前的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat）。为了启用远程监控，则需要配合使用 jstatd 工具。命令 jstatd 是一个 RMI 服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机。</p><p><img src="/attachment/894009749d14f11d7b547ce7d8c9e002.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 字节码与类加载</title>
      <link href="/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-zi-jie-ma-yu-lei-jia-zai/"/>
      <url>/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-zi-jie-ma-yu-lei-jia-zai/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-字节码与类加载"><a href="#【Java-JVM】-字节码与类加载" class="headerlink" title="【Java JVM】 字节码与类加载"></a>【Java JVM】 字节码与类加载</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 字节码与类加载date: 2023-06-30 19:33tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 字节码与类加载</code></pre><h2 id="【Java-JVM】-字节码指令集"><a href="#【Java-JVM】-字节码指令集" class="headerlink" title="【Java JVM】 字节码指令集"></a>【Java JVM】 字节码指令集</h2><p>undefined</p><h2 id="【Java-JVM】-Class-文件结构"><a href="#【Java-JVM】-Class-文件结构" class="headerlink" title="【Java JVM】 Class 文件结构"></a>【Java JVM】 Class 文件结构</h2><p>undefined</p><h2 id="【Java-JVM】-类的加载过程（类的生命周期）详解"><a href="#【Java-JVM】-类的加载过程（类的生命周期）详解" class="headerlink" title="【Java JVM】 类的加载过程（类的生命周期）详解"></a>【Java JVM】 类的加载过程（类的生命周期）详解</h2><p>undefined</p><h2 id="【Java-JVM】-再谈类的加载器"><a href="#【Java-JVM】-再谈类的加载器" class="headerlink" title="【Java JVM】 再谈类的加载器"></a>【Java JVM】 再谈类的加载器</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 性能监控与调优</title>
      <link href="/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-xing-neng-jian-kong-yu-diao-you/"/>
      <url>/java/java-jvm/java-jvm-xing-neng-jian-kong-yu-diao-you/java-jvm-xing-neng-jian-kong-yu-diao-you/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-性能监控与调优"><a href="#【Java-JVM】-性能监控与调优" class="headerlink" title="【Java JVM】 性能监控与调优"></a>【Java JVM】 性能监控与调优</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 性能监控与调优date: 2023-06-30 19:33tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 性能监控与调优</code></pre><h2 id="【Java-JVM】-性能监控与调优-1"><a href="#【Java-JVM】-性能监控与调优-1" class="headerlink" title="【Java JVM】 性能监控与调优"></a>【Java JVM】 性能监控与调优</h2><h3 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h3><p><strong>生产环境中的问题</strong></p><ul><li>生产环境发生了内存溢出该如何处理？</li><li>生产环境应该给服务器分配多少内存合适？</li><li>如何对垃圾回收器的性能进行调优？</li><li>生产环境 CPU 负载飙高该如何处理？</li><li>生产环境应该给应用分配多少线程合适？</li><li>不加 log，如何确定请求是否执行了某一行代码？</li><li>不加 log，如何实时查看某个方法的入参与返回值？</li></ul><p><strong>为什么要调优</strong></p><ul><li>防止出现 OOM</li><li>解决 OOM</li><li>减少 Full GC 出现的频率</li></ul><p><strong>不同阶段的考虑</strong></p><ul><li>上线前</li><li>项目运行阶段</li><li>线上出现 OOM</li></ul><h3 id="调优概述"><a href="#调优概述" class="headerlink" title="调优概述"></a>调优概述</h3><p><strong>监控的依据</strong></p><ul><li>运行日志</li><li>异常堆栈</li><li>GC 日志</li><li>线程快照</li><li>堆转储快照</li></ul><p><strong>调优的大方向</strong></p><ul><li>合理地编写代码</li><li>充分并合理的使用硬件资源</li><li>合理地进行 JVM 调优</li></ul><h3 id="性能优化的步骤"><a href="#性能优化的步骤" class="headerlink" title="性能优化的步骤"></a>性能优化的步骤</h3><p><strong>第 1 步：性能监控</strong></p><ul><li>GC 频繁</li><li>cpu load 过高</li><li>OOM</li><li>内存泄露</li><li>死锁</li><li>程序响应时间较长</li></ul><p><strong>第 2 步：性能分析</strong></p><ul><li>打印 GC 日志，通过 GCviewer 或者 <a href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</li><li>灵活运用命令行工具、jstack、jmap、jinfo 等</li><li>dump 出堆文件，使用内存分析工具分析文件</li><li>使用阿里 Arthas、jconsole、JVisualVM 来实时查看 JVM 状态</li><li>jstack 查看堆栈信息</li></ul><p><strong>第 3 步：性能调优</strong></p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>增加机器，分散节点压力</li><li>合理设置线程池线程数量</li><li>使用中间件提高程序效率，比如缓存、消息队列等</li><li>其他……</li></ul><h3 id="性能评价-x2F-测试指标"><a href="#性能评价-x2F-测试指标" class="headerlink" title="性能评价/测试指标"></a>性能评价/测试指标</h3><p><strong>停顿时间（或响应时间）</strong></p><p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p><table><thead><tr><th align="left">操作</th><th align="left">响应时间</th></tr></thead><tbody><tr><td align="left">打开一个站点</td><td align="left">几秒</td></tr><tr><td align="left">数据库查询一条记录（有索引）</td><td align="left">十几毫秒</td></tr><tr><td align="left">机械磁盘一次寻址定位</td><td align="left">4 毫秒</td></tr><tr><td align="left">从机械磁盘顺序读取 1M 数据</td><td align="left">2 毫秒</td></tr><tr><td align="left">从 SSD 磁盘顺序读取 1M 数据</td><td align="left">0.3 毫秒</td></tr><tr><td align="left">从远程分布式换成 Redis 读取一个数据</td><td align="left">0.5 毫秒</td></tr><tr><td align="left">从内存读取 1M 数据</td><td align="left">十几微妙</td></tr><tr><td align="left">Java 程序本地方法调用</td><td align="left">几微妙</td></tr><tr><td align="left">网络传输 2Kb 数据</td><td align="left">1 微妙</td></tr></tbody></table><p>在垃圾回收环节中：</p><ul><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>-XX:MaxGCPauseMillis</li></ul><p><strong>吞吐量</strong></p><ul><li>对单位时间内完成的工作量（请求）的量度</li><li>在 GC 中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li><li>吞吐量为 1-1/(1+n)，其中-XX::GCTimeRatio=n</li></ul><p><strong>并发数</strong></p><ul><li>同一时刻，对服务器有实际交互的请求数</li></ul><p><strong>内存占用</strong></p><ul><li>Java 堆区所占的内存大小</li></ul><p><strong>相互间的关系</strong></p><p>以高速公路通行状况为例</p><ul><li>吞吐量：每天通过高速公路收费站的车辆的数据</li><li>并发数：高速公路上正在行驶的车辆的数目</li><li>响应时间：车速</li></ul><h2 id="【Java-JVM】-JVM-监控及诊断工具-命令行篇"><a href="#【Java-JVM】-JVM-监控及诊断工具-命令行篇" class="headerlink" title="【Java JVM】 JVM 监控及诊断工具-命令行篇"></a>【Java JVM】 JVM 监控及诊断工具-命令行篇</h2><p>undefined</p><h2 id="【Java-JVM】-JVM监控及诊断工具-GUI篇"><a href="#【Java-JVM】-JVM监控及诊断工具-GUI篇" class="headerlink" title="【Java JVM】 JVM监控及诊断工具-GUI篇"></a>【Java JVM】 JVM监控及诊断工具-GUI篇</h2><p>undefined</p><h2 id="【Java-JVM】-JVM-运行时参数"><a href="#【Java-JVM】-JVM-运行时参数" class="headerlink" title="【Java JVM】 JVM 运行时参数"></a>【Java JVM】 JVM 运行时参数</h2><p>undefined</p><h2 id="【Java-JVM】-分析-GC-日志"><a href="#【Java-JVM】-分析-GC-日志" class="headerlink" title="【Java JVM】 分析 GC 日志"></a>【Java JVM】 分析 GC 日志</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 再谈类的加载器</title>
      <link href="/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-zai-tan-lei-de-jia-zai-qi/"/>
      <url>/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-zai-tan-lei-de-jia-zai-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-再谈类的加载器"><a href="#【Java-JVM】-再谈类的加载器" class="headerlink" title="【Java JVM】 再谈类的加载器"></a>【Java JVM】 再谈类的加载器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 再谈类的加载器date: 2023-06-30 19:12tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 再谈类的加载器</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类加载器是JVM执行类加载机制的前提。</p><p><strong>ClassLoader的作用：</strong></p><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p><p><img src="/attachment/39af665fcf577e7f53f22216e915893a.png"></p><h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><blockquote><p><mark>蚂蚁金服：</mark></p><p>深入分析ClassLoader，双亲委派机制<br>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因</p><p><mark>百度：</mark></p><p>都有哪些类加载器，这些类加载器都加载哪些文件？<br>手写一个类加载器Demo<br>Class的forName（“java.lang.String”）和Class的getClassLoader（）的Loadclass（“java.lang.String”）有什么区别？</p><p><mark>腾讯：</mark></p><p>什么是双亲委派模型？<br>类加载器有哪些？</p><p><mark>小米：</mark><br>双亲委派模型介绍一下</p><p><mark>滴滴：</mark></p><p>简单说说你了解的类加载器一面：讲一下双亲委派模型，以及其优点</p><p><mark>字节跳动：</mark></p><p>什么是类加载器，类加载器有哪些？</p><p><mark>京东：</mark></p><p>类加载器的双亲委派模型是什么？<br>双亲委派机制可以打破吗？为什么</p></blockquote><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>类的加载分类：显式加载 vs 隐式加载</p><p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p><ul><li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</li><li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><p>在日常开发以上两种方式一般会混合使用。</p><pre><code class="line-numbers language-java">//隐式加载User user=new User();//显式加载，并初始化Class clazz=Class.forName("com.test.java.User");//显式加载，但不初始化ClassLoader.getSystemClassLoader().loadClass("com.test.java.Parent"); </code></pre><h3 id="类加载器的必要性"><a href="#类加载器的必要性" class="headerlink" title="类加载器的必要性"></a>类加载器的必要性</h3><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p><ul><li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li><li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li><li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>何为类的唯一性？</strong></p><p><mark style="background: #FFB8EBA6;">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。</mark>每一个类加载器，都拥有一个独立的类名称空间：<mark style="background: #FFB8EBA6;">比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</mark>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p><strong>命名空间</strong></p><ul><li><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</p></li><li><p>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</p></li><li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</p></li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><h3 id="类加载机制的基本特征"><a href="#类加载机制的基本特征" class="headerlink" title="类加载机制的基本特征"></a>类加载机制的基本特征</h3><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</p><h3 id="类加载器之间的关系"><a href="#类加载器之间的关系" class="headerlink" title="类加载器之间的关系"></a>类加载器之间的关系</h3><p>Launcher类核心代码</p><pre><code class="line-numbers language-java">Launcher.ExtClassLoader var1;try {    var1 = Launcher.ExtClassLoader.getExtClassLoader();} catch (IOException var10) {    throw new InternalError("Could not create extension class loader", var10);}try {    this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);} catch (IOException var9) {    throw new InternalError("Could not create application class loader", var9);}Thread.currentThread().setContextClassLoader(this.loader);</code></pre><ul><li><p><strong>ExtClassLoader的Parent类是null</strong></p></li><li><p><strong>AppClassLoader的Parent类是ExtClassLoader</strong></p></li><li><p><strong>当前线程的ClassLoader是AppClassLoader</strong></p></li></ul><p><mark style="background: #FFB8EBA6;">注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</mark></p><h2 id="类的加载器分类"><a href="#类的加载器分类" class="headerlink" title="类的加载器分类"></a>类的加载器分类</h2><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p><p><img src="/attachment/81c5b7c0fcea72d247dfeb93db08ed39.png"></p><ul><li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加戟器。</li><li>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li></ul><p>父类加载器和子类加载器的关系：</p><pre><code class="line-numbers language-java">class ClassLoader{    ClassLoader parent;//父类加载器        public ClassLoader(ClassLoader parent){        this.parent = parent;    }}class ParentClassLoader extends ClassLoader{    public ParentClassLoader(ClassLoader parent){        super(parent);    }}class ChildClassLoader extends ClassLoader{    public ChildClassLoader(ClassLoader parent){ //parent = new ParentClassLoader();        super(parent);    }}</code></pre><p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p><p><strong>注意：</strong></p><p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p><mark>启动类加载器（引导类加载器，Bootstrap ClassLoader）</mark></p><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</li><li>并不继承自java.lang.ClassLoader，没有父加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li></ul><p><img src="/attachment/ae402d91dcfa3eaec6a402be539a93d5.png"></p><p><img src="/attachment/e41dbd9d7eda002b3fb87cca331a81aa.png"></p><ul><li>使用-XX:+TraceClassLoading参数得到。</li></ul><p>启动类加载器使用C++编写的？Yes！</p><ul><li>C/C++：指针函数&amp;函数指针、C++支持多继承、更加高效</li><li>Java：由C++演变而来，（C++）–版，单继承</li></ul><pre><code class="line-numbers language-java">System.out.println("＊＊＊＊＊＊＊＊＊＊启动类加载器＊＊＊＊＊＊＊＊＊＊");// 获取BootstrapclassLoader能够加载的api的路径URL[] urLs = sun.misc.Launcher.getBootstrapcLassPath().getURLs();for (URL element : urLs) {    System.out.println(element.toExternalForm());}// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：引导类加载器ClassLoader classLoader = java.security.Provider.class.getClassLoader();System.out.println(classLoader);</code></pre><p><strong>执行结果：</strong></p><p><img src="/attachment/2a131a2880d3a05c6941cb7bfa922232.png"></p><h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p><mark>扩展类加载器（Extension ClassLoader）</mark></p><ul><li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p></li><li><p>继承于ClassLoader类</p></li><li><p>父类加载器为启动类加载器</p></li><li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p></li></ul><p><img src="/attachment/b0775638f64b7ed947507533d9e11acf.png"></p><pre><code class="line-numbers language-java">System.out.println("＊＊＊＊＊＊＊＊＊＊＊扩展类加载器＊＊＊＊＊＊＊＊＊＊＊");String extDirs =System.getProperty("java.ext.dirs");for (String path :extDirs.split( regex:";")){    System.out.println(path);}// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：扩展类加载器lassLoader classLoader1 = sun.security.ec.CurveDB.class.getClassLoader();System.out.print1n(classLoader1); //sun.misc. Launcher$ExtCLassLoader@1540e19d</code></pre><p><strong>执行结果：</strong></p><p><img src="/attachment/008e85a61d850bab736815aa48f87192.png"></p><h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p><mark>应用程序类加载器（系统类加载器，AppClassLoader）</mark></p><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>继承于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li><li><mark style="background: #FFB8EBA6;">应用程序中的类加载器默认是系统类加载器。</mark></li><li>它是用户自定义类加载器的默认父加载器</li><li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li></ul><p><img src="/attachment/4198b9b6c7e0fae33b7fe42a4603ecef.png"></p><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p><mark>用户自定义类加载器</mark></p><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li><li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li><li><mark style="background: #FFB8EBA6;">通过类加载器可以实现非常绝妙的插件机制</mark>，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li><li>同时，<mark style="background: #FFB8EBA6;">自定义加载器能够实现应用隔离</mark>，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li><li>自定义类加载器通常需要继承于ClassLoader。</li></ul><h2 id="测试不同的类的加载器"><a href="#测试不同的类的加载器" class="headerlink" title="测试不同的类的加载器"></a>测试不同的类的加载器</h2><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。<br><strong>获取ClassLoader的途径</strong></p><pre><code class="line-numbers language-java">// 获得当前类的ClassLoaderclazz.getClassLoader()// 获得当前线程上下文的ClassLoaderThread.currentThread().getContextClassLoader()// 获得系统的ClassLoaderClassLoader.getSystemClassLoader()</code></pre><p><strong>说明：</strong></p><ul><li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li><li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的。</li></ul><pre><code class="line-numbers language-java">// 运行结果：nullString[] strArr = new String[6];System.out.println(strArr.getClass().getClassLoader());// 运行结果：sun．misc．Launcher＄AppCLassLoader＠18b4aac2ClassLoaderTest[] test=new ClassLoaderTest[1];System.out.println(test.getClass().getClassLoader());// 运行结果：nullint[]ints =new int[2];System.out.println(ints.getClass().getClassLoader());</code></pre><p><strong>代码：</strong></p><pre><code class="line-numbers language-java">public class ClassLoaderTest1{    public static void main(String[] args) {        //获取系统该类加载器        ClassLoader systemClassLoader=ClassLoader.getSystemCLassLoader();        System.out.print1n(systemClassLoader);//sun.misc.Launcher$AppCLassLoader@18b4aac2        //获取扩展类加载器        ClassLoader extClassLoader =systemClassLoader.getParent();        System.out.println(extClassLoader);//sun.misc. Launcher$ExtCLassLoader@1540e19d        //试图获取引导类加载器：失败        ClassLoader bootstrapClassLoader =extClassLoader.getParent();        System.out.print1n(bootstrapClassLoader);//null        //##################################        try{            ClassLoader classLoader =Class.forName("java.lang.String").getClassLoader();            System.out.println(classLoader);            //自定义的类默认使用系统类加载器            ClassLoader classLoader1=Class.forName("com.atguigu.java.ClassLoaderTest1").getClassLoader();            System.out.println(classLoader1);                        //关于数组类型的加载：使用的类的加载器与数组元素的类的加载器相同            String[] arrstr = new String[10];            System.out.println(arrstr.getClass().getClassLoader());//null：表示使用的是引导类加载器                            ClassLoaderTest1[] arr1 =new ClassLoaderTest1[10];            System.out.println(arr1.getClass().getClassLoader());//sun.misc. Launcher$AppcLassLoader@18b4aac2                        int[] arr2 = new int[10];            System.out.println(arr2.getClass().getClassLoader());//null:        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><h2 id="4-ClassLoader源码解析"><a href="#4-ClassLoader源码解析" class="headerlink" title="4. ClassLoader源码解析"></a>4. ClassLoader源码解析</h2><p><strong>ClassLoader与现有类的关系：</strong></p><p><img src="/attachment/00ae74f19d748e008d2c4a824ee9d23b.png"></p><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><h3 id="ClassLoader的主要方法"><a href="#ClassLoader的主要方法" class="headerlink" title="ClassLoader的主要方法"></a>ClassLoader的主要方法</h3><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p><pre><code class="line-numbers language-java">public final ClassLoader getParent()</code></pre><p>返回该类加载器的超类加载器</p><pre><code class="line-numbers language-java">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code></pre><p>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException异常。该方法中的逻辑就是双亲委派模式的实现。</p><pre><code class="line-numbers language-java">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code></pre><p>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p><ul><li><p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</p></li><li><p>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。</p></li></ul><p><mark style="background: #FFB8EBA6;">一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</mark></p><pre><code class="line-numbers language-java">protected final Class&lt;?&gt; defineClass(String name, byte[] b,int off,int len)</code></pre><p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p><ul><li><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</p></li><li><p><mark style="background: #FFB8EBA6;">defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</mark></p></li></ul><p><strong>简单举例：</strong></p><pre><code class="line-numbers language-java">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {    // 获取类的字节数组    byte[] classData =getClassData(name);    if (classData == null) {        throw new ClassNotFoundException();    } else{        //使用defineClass生成class对象        return defineClass(name,classData,θ,classData.length);    }}</code></pre><pre><code class="line-numbers language-java">protected final void resolveClass(Class&lt;?&gt; c)</code></pre><p>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><pre><code class="line-numbers language-java">protected final Class&lt;?&gt; findLoadedClass(String name)</code></pre><p>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p><pre><code class="line-numbers language-java">private final ClassLoader parent;</code></pre><p>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p><h3 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h3><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p><p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<mark style="background: #FFB8EBA6;">在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</mark>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p><img src="/attachment/3696e2a00d0148d5a0367381d6b53a71.png"></p><h3 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h3><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。</p><p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p><p><img src="/attachment/d786533f1b1a8f8223de00d230e800ef.png"></p><p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</p><h3 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h3><p><strong>Class.forName()</strong></p><ul><li><p>Class.forName()：是一个静态方法，最常用的是Class.forName(String className);</p></li><li><p>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化。</p></li></ul><pre><code class="line-numbers language-java">Class.forName("com.atguigu.java.Helloworld");</code></pre><p><strong>ClassLoader.loadClass()</strong></p><ul><li>ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。</li><li>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</li></ul><pre><code class="line-numbers language-java">Classloader cl = ......; cl.loadClass("com.atguigu.java.Helloworld");</code></pre><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义与本质"><a href="#定义与本质" class="headerlink" title="定义与本质"></a>定义与本质</h3><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p><p><strong>定义</strong></p><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><p><strong>本质</strong></p><p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p><p><img src="/attachment/1ac72535947514cf6a76b9a45d0313ef.png"></p><p><img src="/attachment/02eafbc1763ad8aaab446f48b192c1d6.png"></p><h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><p><strong>双亲委派机制优势</strong></p><ul><li>避免类的重复加载，确保一个类的全局唯一性</li></ul><p><mark style="background: #FFB8EBA6;">  Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</mark></p><ul><li>保护程序安全，防止核心API被随意篡改</li></ul><p><strong>代码支持</strong></p><p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p><p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p><p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p><p>（3）反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</p><p>（4）如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</p><p>双亲委派的模型就隐藏在这第2和第3步中。</p><p><strong>举例</strong></p><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p><p><strong>思考</strong></p><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p><p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p><p><strong>弊端</strong></p><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><p><strong>结论</strong></p><p><mark style="background: #FFB8EBA6;">由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</mark>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p><h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p><p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p><p><strong>第一次破坏双亲委派机制</strong></p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一—即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<mark style="background: #FFB8EBA6;">为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</mark>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<mark style="background: #FFB8EBA6;">越基础的类由越上层的加载器进行加载</mark>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有$\color{red}{基础类型又要调用回用户的代码，那该怎么办呢？}$</p><p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，<mark style="background: #FFB8EBA6;">启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</mark><u>（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</u></p><p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<mark style="background: #FFB8EBA6;">线程上下文类加载器（Thread Context ClassLoader）</mark>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<mark style="background: #FFB8EBA6;">这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</mark>，但也是无可奈何的事情。 例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p><p><img src="/attachment/9597d9aa4fcd86be668174e0a6d92900.png"></p><p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><p><strong>第三次破坏双亲委派机制</strong></p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p><p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><p>1）<mark style="background: #FFB8EBA6;">将以java.*开头的类，委派给父类加载器加载。</mark><br>2）<mark style="background: #FFB8EBA6;">否则，将委派列表名单内的类，委派给父类加载器加载。</mark><br>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。<br>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。<br>7）否则，类查找失败。</p><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p><p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p><h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。<mark style="background: #FFB8EBA6;">热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。</mark>基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p><p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p><p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p><p><img src="/attachment/02e634d5b0bf04e1a2f769c725a1486d.png"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>沙箱安全机制</p><ul><li>保证程序安全</li><li>保护Java原生的JDK代码</li></ul><p><mark style="background: #FFB8EBA6;">Java安全模型的核心就是Java沙箱（sandbox）</mark>。什么是沙箱？沙箱是一个限制程序运行的环境。</p><p>沙箱机制就是<mark style="background: #FFB8EBA6;">将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问</mark>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p><p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><h3 id="JDK1-0时期"><a href="#JDK1-0时期" class="headerlink" title="JDK1.0时期"></a>JDK1.0时期</h3><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK1.0安全模型</p><p><img src="/attachment/c90932a250db5c9998240b2501b64411.png"></p><h3 id="JDK1-1时期"><a href="#JDK1-1时期" class="headerlink" title="JDK1.1时期"></a>JDK1.1时期</h3><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p><p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p><p>如下图所示JDK1.1安全模型</p><p><img src="/attachment/9d2c71db2e0197a5e4274d4106286f1a.png"></p><h3 id="JDK1-2时期"><a href="#JDK1-2时期" class="headerlink" title="JDK1.2时期"></a>JDK1.2时期</h3><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p><p><img src="/attachment/2778a26bd08e30dd0be7870eb704edcb.png"></p><h2 id="JDK1-6时期"><a href="#JDK1-6时期" class="headerlink" title="JDK1.6时期"></a>JDK1.6时期</h2><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p><p>虚拟机会把所有代码加载到不同的系统域和应用域。<mark style="background: #FFB8EBA6;">系统域部分专门负责与关键资源进行交互</mark>，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p><p><img src="/attachment/3b875df537df55af4ec8e48cce3f56d9.png"></p><h2 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h2><h3 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h3><ul><li><p><strong>隔离加载类</strong></p><p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</p></li><li><p><strong>修改类加载的方式</strong></p><p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p></li><li><p><strong>扩展加载源</strong></p><p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p></li><li><p><strong>防止源码泄漏</strong></p><p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p></li></ul><p><strong>常见的场景</strong></p><ul><li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</li><li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li></ul><p><strong>注意</strong></p><p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><p>在自定义ClassLoader的子类时候，我们常见的会有两种做法:</p><ul><li>方式一:重写loadClass()方法</li><li>方式二:重写findclass()方法</li></ul><p><strong>对比</strong></p><ul><li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li><li>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<strong>因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</strong>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li><li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li></ul><p><strong>说明</strong></p><ul><li>其父类加载器是系统类加载器</li><li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 类的加载过程（类的生命周期）详解</title>
      <link href="/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-lei-de-jia-zai-guo-cheng-lei-de-sheng-ming-zhou-qi-xiang-jie/"/>
      <url>/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-lei-de-jia-zai-guo-cheng-lei-de-sheng-ming-zhou-qi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-类的加载过程（类的生命周期）详解"><a href="#【Java-JVM】-类的加载过程（类的生命周期）详解" class="headerlink" title="【Java JVM】 类的加载过程（类的生命周期）详解"></a>【Java JVM】 类的加载过程（类的生命周期）详解</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 类的加载过程（类的生命周期）详解date: 2023-06-30 18:54tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 03-类的加载过程（类的生命周期）详解</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Java 中数据类型分为基本数据类型和引用数据类型。<mark>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</mark></p><p>按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下 7 个阶段：</p><p><img src="/attachment/aafaa94a46493ef715453df5e4b5a2c9.png"></p><p>其中，验证、准备、解析 3 个部分统称为链接（Linking）</p><p>从程序中类的使用过程看</p><p><img src="/attachment/8f32786806816a64dcb6dfd795f7b880.png"></p><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><blockquote><p><mark>蚂蚁金服：</mark></p><p>描述一下 JVM 加载 Class 文件的原理机制？</p><p>一面：类加载过程</p><p><mark>百度：</mark></p><p>类加载的时机</p><p>java 类加载过程？</p><p>简述 java 类加载机制？</p><p><mark>腾讯：</mark></p><p>JVM 中类加载机制，类加载过程？</p><p><mark>滴滴：</mark></p><p>JVM 类加载机制</p><p><mark>美团：</mark></p><p>Java 类加载过程</p><p>描述一下 jvm 加载 class 文件的原理机制</p><p><mark>京东：</mark></p><p>什么是类的加载？</p><p>哪些情况会触发类的加载？</p><p>讲一下 JVM 加载一个类的过程 JVM 的类加载机制是什么？</p></blockquote><h2 id="过程一：Loading（加载）阶段"><a href="#过程一：Loading（加载）阶段" class="headerlink" title="过程一：Loading（加载）阶段"></a>过程一：Loading（加载）阶段</h2><h3 id="加载完成的操作"><a href="#加载完成的操作" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h3><p><strong>加载的理解</strong></p><p><mark style="background: #FFB8EBA6;">所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。</mark>所谓类模板对象，其实就是 Java 类在]VM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p><p>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p><p><strong>加载完成的操作</strong></p><p><mark style="background: #FFB8EBA6;">加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。</mark></p><p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p><ul><li><p>通过类的全名，获取类的二进制数据流。</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</p></li><li><p>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li></ul><h3 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。<mark>（只要所读取的字节码符合 JVM 规范即可）</mark></p><ul><li>虚拟机可能通过文件系统读入一个 class 后缀的文件<mark style="background: #FFB8EBA6;">（最常见）</mark></li><li>读入 jar、zip 等归档数据包，提取类文件。</li><li>事先存放在数据库中的类的二进制数据</li><li>使用类似于 HTTP 之类的协议通过网络进行加载</li><li>在运行时生成一段 class 的二进制信息等</li><li>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。</li></ul><p>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><h3 id="类模型与-Class-实例的位置"><a href="#类模型与-Class-实例的位置" class="headerlink" title="类模型与 Class 实例的位置"></a>类模型与 Class 实例的位置</h3><p><strong>类模型的位置</strong></p><p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDKl.8 之前：永久代；J0Kl.8 及之后：元空间）。</p><p><strong>Class 实例的位置</strong></p><p>类将.class 文件加载至元空间后，会在堆中创建一个 Java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p><p><img src="/attachment/3e3b61e38ff5e5ed8f07b6834e43ee77.png"></p><pre><code class="line-numbers language-java">Class clazz = Class.forName("java.lang.String");//获取当前运行时类声明的所有方法Method[] ms = clazz.getDecla#FF0000Methods();for (Method m : ms) {    //获取方法的修饰符    String mod = Modifier.toString(m.getModifiers());    System.out.print(mod + "");    //获取方法的返回值类型    String returnType = (m.getReturnType()).getSimpleName();    System.out.print(returnType + "");    //获取方法名    System.out.print(m.getName() + "(");    //获取方法的参数列表    Class&lt;?&gt;[] ps = m.getParameterTypes();    if (ps.length == 0) {        System.out.print(')');    }    for (int i = 0; i &lt; ps.length; i++) {        char end = (i == ps.length - 1) ? ')' : ',';        //获取参教的类型        System.out.print(ps[i].getSimpleName() + end);    }}</code></pre><h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>创建数组类的情况稍微有些特殊，因为<mark>数组类本身并不是由类加载器负责创建</mark>，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p><ul><li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li></ul><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public。</p><h2 id="过程二：Linking（链接）阶段"><a href="#过程二：Linking（链接）阶段" class="headerlink" title="过程二：Linking（链接）阶段"></a>过程二：Linking（链接）阶段</h2><h3 id="环节-1：链接阶段之-Verification（验证）"><a href="#环节-1：链接阶段之-Verification（验证）" class="headerlink" title="环节 1：链接阶段之 Verification（验证）"></a>环节 1：链接阶段之 Verification（验证）</h3><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p><p><mark style="background: #FFB8EBA6;">它的目的是保证加载的字节码是合法、合理并符合规范的。</mark></p><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示。</p><p><img src="/attachment/5a1087219efa30bb9562ffc9a842db70.png"></p><p><strong>整体说明：</strong></p><p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p><ul><li><mark style="background: #FFB8EBA6;">其中格式验证会和加载阶段一起执行</mark>。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li><li><mark style="background: #FFB8EBA6;">格式验证之外的验证操作将会在方法区中进行</mark>。</li></ul><p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p><p><strong>具体说明：</strong></p><ol><li><p><mark>格式验证</mark>：是否以魔数 0XCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p></li><li><p><mark>语义检查</mark>：Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p><ul><li>是否所有的类都有父类的存在（在 Java 里，除了 object 外，其他类都应该有父类）</li><li>是否一些被定义为 final 的方法或者类被重写或继承了</li><li>非抽象类是否实现了所有抽象方法或者接口方法</li></ul></li><li><p><mark>字节码验证</mark>：Java 虚拟机还会进行字节码验证，<mark style="background: #FFB8EBA6;">字节码验证也是验证过程中最为复杂的一个过程</mark>。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型等</li></ul><p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p></li></ol><p> <mark style="background: #FFB8EBA6;">在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</mark></p><ol start="4"><li><mark>符号引用的验证</mark>：校验器还将进符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<mark style="background: #FFB8EBA6;">虚拟机就会检查这些类或者方法确实是存在的</mark>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。此阶段在解析环节才会执行。</li></ol><h3 id="环节-2：链接阶段之-Preparation（准备）"><a href="#环节-2：链接阶段之-Preparation（准备）" class="headerlink" title="环节 2：链接阶段之 Preparation（准备）"></a>环节 2：链接阶段之 Preparation（准备）</h3><p><mark style="background: #FFB8EBA6;">准备阶段（Preparation），简言之，为类的静态变分配内存，并将其初始化为默认值。</mark></p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p><table><thead><tr><th align="left">类型</th><th align="left">默认初始值</th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">(byte)0</td></tr><tr><td align="left">short</td><td align="left">(short)0</td></tr><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">0L</td></tr><tr><td align="left">float</td><td align="left">0.0f</td></tr><tr><td align="left">double</td><td align="left">0.0</td></tr><tr><td align="left">char</td><td align="left">\u0000</td></tr><tr><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">reference</td><td align="left">null</td></tr></tbody></table><p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故对应的，boolean 的默认值就是 false。</p><p><strong>注意</strong></p><ul><li><mark style="background: #FFB8EBA6;">这里不包含基本数据类型的字段用static final修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</mark></li></ul><pre><code class="line-numbers language-java">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值private static final String str = "Hello world";// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值private static final String str = new String("Hello world");</code></pre><ul><li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li><li>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</li></ul><h3 id="环节-3：链接阶段之-Resolution（解析）"><a href="#环节-3：链接阶段之-Resolution（解析）" class="headerlink" title="环节 3：链接阶段之 Resolution（解析）"></a>环节 3：链接阶段之 Resolution（解析）</h3><p>在准备阶段完成后，就进入了解析阶段。解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</p><p><strong>具体描述</strong>：</p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 println()方法被调用时，系统需要明确知道该方法的位置。</p><p><strong>举例</strong>：</p><p>输出操作 System.out.println()对应的字节码：</p><pre><code class="line-numbers language-java">invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code></pre><p><img src="/attachment/ffe38ac6256ea89c7f3cf0bf7bdf1b5b.png"></p><p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<mark style="background: #FFB8EBA6;">通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</mark></p><h2 id="过程三：Initialization（初始化）阶段"><a href="#过程三：Initialization（初始化）阶段" class="headerlink" title="过程三：Initialization（初始化）阶段"></a>过程三：Initialization（初始化）阶段</h2><h3 id="static-与-final-的搭配问题"><a href="#static-与-final-的搭配问题" class="headerlink" title="static 与 final 的搭配问题"></a>static 与 final 的搭配问题</h3><p><strong>说明</strong>：使用 static+ final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p><ul><li>情况 1：在链接阶段的准备环节赋值</li><li>情况 2：在初始化阶段&lt;clinit&gt;()中赋值</li></ul><p><strong>结论</strong>： 在链接阶段的准备环节赋值的情况：</p><ul><li><p>对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值(直接赋值常量，而非调用方法通常是在链接阶段的准备环节进行</p></li><li><p>对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行</p></li><li><p>在初始化阶段&lt;clinit&gt;()中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</p></li></ul><p><strong>最终结论</strong>：使用 static+final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类到或 String 类型的显式财值，是在链接阶段的准备环节进行。</p><pre><code class="line-numbers language-java">public static final int INT_CONSTANT = 10;                                // 在链接阶段的准备环节赋值public static final int NUM1 = new Random().nextInt(10);                  // 在初始化阶段clinit&gt;()中赋值public static int a = 1;                                                  // 在初始化阶段&lt;clinit&gt;()中赋值public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);     // 在初始化阶段&lt;clinit&gt;()中赋值public static Integer INTEGER_CONSTANT2 = Integer.valueOf(100);           // 在初始化阶段&lt;clinit&gt;()中概值public static final String s0 = "helloworld0";                            // 在链接阶段的准备环节赋值public static final String s1 = new String("helloworld1");                // 在初始化阶段&lt;clinit&gt;()中赋值public static String s2 = "hellowrold2";                                  // 在初始化阶段&lt;clinit&gt;()中赋值</code></pre><h3 id="lt-clinit-gt-的线程安全性"><a href="#lt-clinit-gt-的线程安全性" class="headerlink" title="<clinit>()的线程安全性"></a>&lt;clinit&gt;()的线程安全性</h3><p>对于&lt;clinit&gt;()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p><p>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行$<clinit>()$方法完毕。</clinit></p><p>正是因为 函数&lt;clinit&gt;()带锁线程安全的，因此，如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行&lt;clinit&gt;()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p><h3 id="类的初始化情况：主动使用-vs-被动使用"><a href="#类的初始化情况：主动使用-vs-被动使用" class="headerlink" title="类的初始化情况：主动使用 vs 被动使用"></a>类的初始化情况：主动使用 vs 被动使用</h3><p>Java 程序对类的使用分为两种：主动使用和被动使用。</p><p><strong>主动使用</strong></p><p>Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p><ol><li><mark>实例化</mark>：当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化。</li></ol><pre><code class="line-numbers language-java">/** * 反序列化 */Class Order implements Serializable {    static {        System.out.println("Order类的初始化");    }}public void test() {    ObjectOutputStream oos = null;    ObjectInputStream ois = null;    try {        // 序列化        oos = new ObjectOutputStream(new FileOutputStream("order.dat"));        oos.writeObject(new Order());        // 反序列化        ois = new ObjectInputStream(new FileOutputStream("order.dat"));        Order order = ois.readObject();    }    catch (IOException e){        e.printStackTrace();    }    catch (ClassNotFoundException e){        e.printStackTrace();    }    finally {        try {            if (oos != null) {                oos.close();            }            if (ois != null) {                ois.close();            }        }        catch (IOException e){            e.printStackTrace();        }    }}</code></pre><ol start="2"><li><p><mark>静态方法</mark>：当调用类的静态方法时，即当使用了字节码 invokestatic 指令。</p></li><li><p><mark>静态字段</mark>：当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量、赋值变量操作）</p></li></ol><pre><code class="line-numbers language-java">public class ActiveUse {    @Test    public void test() {        System.out.println(User.num);    }}class User {    static {        System.out.println("User类的初始化");    }    public static final int num = 1;}</code></pre><ol start="4"><li><p><mark>反射</mark>：当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</p></li><li><p><mark>继承</mark>：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p><blockquote><p>当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li><li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</li></ul></blockquote></li><li><p><mark>default 方法</mark>：如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p></li></ol><pre><code class="line-numbers language-java">interface Compare {    public static final Thread t = new Thread() {        {            System.out.println("Compare接口的初始化");        }    }}</code></pre><ol start="7"><li><mark>main 方法</mark>：当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。</li></ol><blockquote><p>VM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p></blockquote><ol start="8"><li><mark style="background: #FFB8EBA6;">MethodHandle</mark>：当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析 REF getStatic、REF_putStatic、REF invokeStatic 方法句柄对应的类）</li></ol><p><strong>被动使用</strong></p><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<mark style="background: #FFB8EBA6;">被动使用不会引起类的初始化。</mark></p><p>也就是说：<mark style="background: #FFB8EBA6;">并不是在代码中出现的类，就一定会被加载或者初始化。</mark>如果不符合主动使用的条件，类就不会初始化。</p><ol><li><mark>静态字段</mark>：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。</li></ol><pre><code class="line-numbers language-java">public class PassiveUse {     @Test    public void test() {        System.out.println(Child.num);    }}class Child extends Parent {    static {        System.out.println("Child类的初始化");    }}class Parent {    static {        System.out.println("Parent类的初始化");    }    public static int num = 1;}</code></pre><ol start="2"><li><mark>数组定义</mark>：通过数组定义类引用，不会触发此类的初始化</li></ol><pre><code class="line-numbers language-java">Parent[] parents= new Parent[10];System.out.println(parents.getClass());// new的话才会初始化parents[0] = new Parent();</code></pre><ol start="3"><li><mark>引用常量</mark>：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</li></ol><pre><code class="line-numbers language-java">public class PassiveUse {    public static void main(String[] args) {        System.out.println(Serival.num);        // 但引用其他类的话还是会初始化        System.out.println(Serival.num2);    }}interface Serival {    public static final Thread t = new Thread() {        {            System.out.println("Serival初始化");        }    };    public static int num = 10;    public static final int num2 = new Random().nextInt(10);}</code></pre><ol start="4"><li><mark>loadClass 方法</mark>：调用 ClassLoader 类的 loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li></ol><pre><code class="line-numbers language-java">Class clazz = ClassLoader.getSystemClassLoader().loadClass("com.test.java.Person");</code></pre><p><strong>扩展</strong></p><blockquote><p>-XX:+TraceClassLoading：追踪打印类的加载信息</p></blockquote><h2 id="过程四：类的-Using（使用）"><a href="#过程四：类的-Using（使用）" class="headerlink" title="过程四：类的 Using（使用）"></a>过程四：类的 Using（使用）</h2><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化 3 个类加载步骤。一旦一个类型成功经历过这 3 个步骤之后，便“厉事俱备只欠东风”，就等着开发者使用了。</p><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例。</p><h2 id="过程五：类的-Unloading（卸载）"><a href="#过程五：类的-Unloading（卸载）" class="headerlink" title="过程五：类的 Unloading（卸载）"></a>过程五：类的 Unloading（卸载）</h2><h3 id="类、类的加载器、类的实例之间的引用关系"><a href="#类、类的加载器、类的实例之间的引用关系" class="headerlink" title="类、类的加载器、类的实例之间的引用关系"></a>类、类的加载器、类的实例之间的引用关系</h3><p>在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系。</p><p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass()方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p><p><mark style="background: #FFB8EBA6;">一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</mark></p><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p><img src="/attachment/86e14377f40a49f5acebfec50e98364b.png"></p><p>loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载。</p><p>当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例（可以通过哈希码查看是否是同一个实例）</p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>（1）启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm 和 jls 规范）</p><p>（2）被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小。</p><p>（3）被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</p><p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p><h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><mark style="background: #FFB8EBA6;">该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</mark></li><li><mark style="background: #FFB8EBA6;">加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</mark></li><li><mark style="background: #FFB8EBA6;">该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</mark></li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 字节码指令集</title>
      <link href="/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-zi-jie-ma-zhi-ling-ji/"/>
      <url>/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-zi-jie-ma-zhi-ling-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-字节码指令集"><a href="#【Java-JVM】-字节码指令集" class="headerlink" title="【Java JVM】 字节码指令集"></a>【Java JVM】 字节码指令集</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 字节码指令集date: 2023-06-29 23:00tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 字节码指令集</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/8198f00777860bb611b21a598ed772b1.png"></p><p><img src="/attachment/c4a54b10553b984f8fd1084cfb226d4a.png"></p><p><img src="/attachment/76aa49b20f3b115d266bb7c616472f89.png"></p><h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><p><img src="/attachment/79971a953d281d28f2182172483a66d4.png"></p><p><img src="/attachment/171ee2fd5c43ca0952b074702223d404.png"></p><h3 id="局部变量压栈指令"><a href="#局部变量压栈指令" class="headerlink" title="局部变量压栈指令"></a>局部变量压栈指令</h3><blockquote><p>iload 从局部变量中装载int类型值</p><p>lload 从局部变量中装载long类型值</p><p>fload 从局部变量中装载float类型值</p><p>dload 从局部变量中装载double类型值</p><p>aload 从局部变量中装载引用类型值（refernce）</p><p>iload_0 从局部变量0中装载int类型值</p><p>iload_1 从局部变量1中装载int类型值</p><p>iload_2 从局部变量2中装载int类型值</p><p>iload_3 从局部变量3中装载int类型值</p><p>lload_0 从局部变量0中装载long类型值</p><p>lload_1 从局部变量1中装载long类型值</p><p>lload_2 从局部变量2中装载long类型值</p><p>lload_3 从局部变量3中装载long类型值</p><p>fload_0 从局部变量0中装载float类型值</p><p>fload_1 从局部变量1中装载float类型值</p><p>fload_2 从局部变量2中装载float类型值</p><p>fload_3 从局部变量3中装载float类型值</p><p>dload_0 从局部变量0中装载double类型值</p><p>dload_1 从局部变量1中装载double类型值</p><p>dload_2 从局部变量2中装载double类型值</p><p>dload_3 从局部变量3中装载double类型值</p><p>aload_0 从局部变量0中装载引用类型值</p><p>aload_1 从局部变量1中装载引用类型值</p><p>aload_2 从局部变量2中装载引用类型值</p><p>aload_3 从局部变量3中装载引用类型值</p><p>iaload 从数组中装载int类型值</p><p>laload 从数组中装载long类型值</p><p>faload 从数组中装载float类型值</p><p>daload 从数组中装载double类型值</p><p>aaload 从数组中装载引用类型值</p><p>baload 从数组中装载byte类型或boolean类型值</p><p>caload 从数组中装载char类型值</p><p>saload 从数组中装载short类型值</p></blockquote><h4 id="局部变量压栈常用指令集"><a href="#局部变量压栈常用指令集" class="headerlink" title="局部变量压栈常用指令集"></a>局部变量压栈常用指令集</h4><table><thead><tr><th>xload_n</th><th>xload_0</th><th>xload_1</th><th>xload_2</th><th>xload_3</th></tr></thead><tbody><tr><td><b>iload_n</b></td><td>iload_0</td><td>iload_1</td><td>iload_2</td><td>iload_3</td></tr><tr><td><b>lload_n</b></td><td>lload_0</td><td>lload_1</td><td>lload_2</td><td>lload_3</td></tr><tr><td><b>fload_n</b></td><td>fload_0</td><td>fload_1</td><td>fload_2</td><td>fload_3</td></tr><tr><td><b>dload_n</b></td><td>dload_0</td><td>dload_1</td><td>dload_2</td><td>dload_3</td></tr><tr><td><b>aload_n</b></td><td>aload_0</td><td>aload_1</td><td>aload_2</td><td>aload_3</td></tr></tbody></table><h4 id="局部变量压栈指令剖析"><a href="#局部变量压栈指令剖析" class="headerlink" title="局部变量压栈指令剖析"></a>局部变量压栈指令剖析</h4><p><img src="/attachment/6451a95dc9a0842859555954d70ea95d.png"></p><pre><code class="line-numbers language-java">public void load(int num, Object obj, long count, boolean flag, short[] arr) {    System.out.println(num);    System.out.println(obj);    System.out.println(count);    System.out.println(flag);    System.out.println(arr);}</code></pre><p><img src="/attachment/6a05a18cd17c06649a9488f0e98dfeaf.png"></p><h3 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h3><blockquote><p>aconst_null 将null对象引用压入栈</p><p>iconst_m1 将int类型常量-1压入栈</p><p>iconst_0 将int类型常量0压入栈</p><p>iconst_1 将int类型常量1压入栈</p><p>iconst_2 将int类型常量2压入栈</p><p>iconst_3 将int类型常量3压入栈</p><p>iconst_4 将int类型常量4压入栈</p><p>iconst_5 将int类型常量5压入栈</p><p>lconst_0 将long类型常量0压入栈</p><p>lconst_1 将long类型常量1压入栈</p><p>fconst_0 将float类型常量0压入栈</p><p>fconst_1 将float类型常量1压入栈</p><p>dconst_0 将double类型常量0压入栈</p><p>dconst_1 将double类型常量1压入栈</p><p>bipush 将一个8位带符号整数压入栈</p><p>sipush 将16位带符号整数压入栈</p><p>ldc 把常量池中的项压入栈</p><p>ldc_w 把常量池中的项压入栈（使用宽索引）</p><p>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p></blockquote><h4 id="常量入栈常用指令集"><a href="#常量入栈常用指令集" class="headerlink" title="常量入栈常用指令集"></a>常量入栈常用指令集</h4><table><thead><tr><th align="center">xconst_n</th><th>范围</th><th>xconst_null</th><th align="center">xconst_m1</th><th align="center">xconst_0</th><th align="center">xconst_1</th><th align="center">xconst_2</th><th align="center">xconst_3</th><th align="center">xconst_4</th><th align="center">xconst_5</th></tr></thead><tbody><tr><td align="center"><strong>iconst_n</strong></td><td>[-1, 5]</td><td></td><td align="center">iconst_m1</td><td align="center">iconst_0</td><td align="center">iconst_1</td><td align="center">iconst_2</td><td align="center">iconst_3</td><td align="center">iconst_4</td><td align="center">iconst_5</td></tr><tr><td align="center"><strong>lconst_n</strong></td><td>0, 1</td><td></td><td align="center"></td><td align="center">lconst_0</td><td align="center">lconst_1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>fconst_n</strong></td><td>0, 1, 2</td><td></td><td align="center"></td><td align="center">fconst_0</td><td align="center">fconst_1</td><td align="center">fconst_2</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>dconst_n</strong></td><td>0, 1</td><td></td><td align="center"></td><td align="center">dconst_0</td><td align="center">dconst_1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>aconst_n</strong></td><td>null, String literal, Class literal</td><td>aconst_null</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>bipush</strong></td><td>一个字节，2^8^，[-2^7^, 2^7^ - 1]，即[-128, 127]</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>sipush</strong></td><td>两个字节，2^16^，[-2^15^, 2^15^ - 1]，即[-32768, 32767]</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>ldc</strong></td><td>四个字节，2^32^，[-2^31^, 2^31^ - 1]</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>ldc_w</strong></td><td>宽索引</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>ldc2_w</strong></td><td>宽索引，long或double</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="常量入栈指令剖析"><a href="#常量入栈指令剖析" class="headerlink" title="常量入栈指令剖析"></a>常量入栈指令剖析</h3><p><img src="/attachment/464c983c3cd562927347167e8441f81d.png"></p><p><img src="/attachment/2e675c86434ef16831650e0b6b0397d1.png"></p><table><thead><tr><th>类型</th><th>常数指令</th><th>范围</th></tr></thead><tbody><tr><td>int(boolean,byte,char,short)</td><td>iconst</td><td>[-1, 5]</td></tr><tr><td>bipush</td><td>[-128, 127]</td><td></td></tr><tr><td>sipush</td><td>[-32768, 32767]</td><td></td></tr><tr><td>ldc</td><td>any int value</td><td></td></tr><tr><td>long</td><td>lconst</td><td>0, 1</td></tr><tr><td>ldc</td><td>any long value</td><td></td></tr><tr><td>float</td><td>fconst</td><td>0, 1, 2</td></tr><tr><td>ldc</td><td>any float value</td><td></td></tr><tr><td>double</td><td>dconst</td><td>0, 1</td></tr><tr><td>ldc</td><td>any double value</td><td></td></tr><tr><td>reference</td><td>aconst</td><td>null</td></tr><tr><td>ldc</td><td>String literal, Class literal</td><td></td></tr></tbody></table><p><img src="/attachment/e9d96587f8f293c71b2a725425cca94a.png"></p><p><img src="/attachment/92d0354cfae700a23e27db1e8f8c97f1.png"></p><h3 id="出栈装入局部变量表指令"><a href="#出栈装入局部变量表指令" class="headerlink" title="出栈装入局部变量表指令"></a>出栈装入局部变量表指令</h3><blockquote><p>istore 将int类型值存入局部变量</p><p>lstore 将long类型值存入局部变量</p><p>fstore 将float类型值存入局部变量</p><p>dstore 将double类型值存入局部变量</p><p>astore 将将引用类型或returnAddress类型值存入局部变量</p><p>istore_0 将int类型值存入局部变量0</p><p>istore_1 将int类型值存入局部变量1</p><p>istore_2 将int类型值存入局部变量2</p><p>istore_3 将int类型值存入局部变量3</p><p>lstore_0 将long类型值存入局部变量0</p><p>lstore_1 将long类型值存入局部变量1</p><p>lstore_2 将long类型值存入局部变量2</p><p>lstore_3 将long类型值存入局部变量3</p><p>fstore_0 将float类型值存入局部变量0</p><p>fstore_1 将float类型值存入局部变量1</p><p>fstore_2 将float类型值存入局部变量2</p><p>fstore_3 将float类型值存入局部变量3</p><p>dstore_0 将double类型值存入局部变量0</p><p>dstore_1 将double类型值存入局部变量1</p><p>dstore_2 将double类型值存入局部变量2</p><p>dstore_3 将double类型值存入局部变量3</p><p>astore_0 将引用类型或returnAddress类型值存入局部变量0</p><p>astore_1 将引用类型或returnAddress类型值存入局部变量1</p><p>astore_2 将引用类型或returnAddress类型值存入局部变量2</p><p>astore_3 将引用类型或returnAddress类型值存入局部变量3</p><p>iastore 将int类型值存入数组中</p><p>lastore 将long类型值存入数组中</p><p>fastore 将float类型值存入数组中</p><p>dastore 将double类型值存入数组中</p><p>aastore 将引用类型值存入数组中</p><p>bastore 将byte类型或者boolean类型值存入数组中</p><p>castore 将char类型值存入数组中</p><p>sastore 将short类型值存入数组中</p><p>wide指令</p><p>wide 使用附加字节扩展局部变量索引</p></blockquote><h4 id="出栈装入局部变量表常用指令集"><a href="#出栈装入局部变量表常用指令集" class="headerlink" title="出栈装入局部变量表常用指令集"></a>出栈装入局部变量表常用指令集</h4><table><thead><tr><th align="center">xstore_n</th><th align="center">xstore_0</th><th align="center">xstore_1</th><th align="center">xstore_2</th><th align="center">xstore_3</th></tr></thead><tbody><tr><td align="center"><strong>istore_n</strong></td><td align="center">istore_0</td><td align="center">istore_1</td><td align="center">istore_2</td><td align="center">istore_3</td></tr><tr><td align="center"><strong>lstore_n</strong></td><td align="center">lstore_0</td><td align="center">lstore_1</td><td align="center">lstore_2</td><td align="center">lstore_3</td></tr><tr><td align="center"><strong>fstore_n</strong></td><td align="center">fstore_0</td><td align="center">fstore_1</td><td align="center">fstore_2</td><td align="center">fstore_3</td></tr><tr><td align="center"><strong>dstore_n</strong></td><td align="center">dstore_0</td><td align="center">dstore_1</td><td align="center">dstore_2</td><td align="center">dstore_3</td></tr><tr><td align="center"><strong>astore_n</strong></td><td align="center">astore_0</td><td align="center">astore_1</td><td align="center">astore_2</td><td align="center">astore_3</td></tr></tbody></table><h4 id="出栈装入局部变量表指令剖析"><a href="#出栈装入局部变量表指令剖析" class="headerlink" title="出栈装入局部变量表指令剖析"></a>出栈装入局部变量表指令剖析</h4><p><img src="/attachment/8207f491244022196c117fb6ef604432.png"></p><p><img src="/attachment/0e3ae813f0cc7160c1a9aaac37df1079.png"></p><p><img src="/attachment/a4d167bbcd8b3d23a13233c13d33c1ce.png"></p><h2 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h2><blockquote><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>iadd 执行int类型的加法</p><p>ladd 执行long类型的加法</p><p>isub 执行int类型的减法</p><p>lsub 执行long类型的减法</p><p>imul 执行int类型的乘法</p><p>lmul 执行long类型的乘法</p><p>idiv 执行int类型的除法</p><p>ldiv 执行long类型的除法</p><p>irem 计算int类型除法的余数</p><p>lrem 计算long类型除法的余数</p><p>ineg 对一个int类型值进行取反操作</p><p>lneg 对一个long类型值进行取反操作</p><p>iinc 把一个常量值加到一个int类型的局部变量上</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>ishl 执行int类型的向左移位操作</p><p>lshl 执行long类型的向左移位操作</p><p>ishr 执行int类型的向右移位操作</p><p>lshr 执行long类型的向右移位操作</p><p>iushr 执行int类型的向右逻辑移位操作</p><p>lushr 执行long类型的向右逻辑移位操作</p><h3 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h3><p>iand 对int类型值进行“逻辑与”操作</p><p>land 对long类型值进行“逻辑与”操作</p><p>ior 对int类型值进行“逻辑或”操作</p><p>lor 对long类型值进行“逻辑或”操作</p><p>ixor 对int类型值进行“逻辑异或”操作</p><p>lxor 对long类型值进行“逻辑异或”操作</p><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>fadd 执行float类型的加法</p><p>dadd 执行double类型的加法</p><p>fsub 执行float类型的减法</p><p>dsub 执行double类型的减法</p><p>fmul 执行float类型的乘法</p><p>dmul 执行double类型的乘法</p><p>fdiv 执行float类型的除法</p><p>ddiv 执行double类型的除法</p><p>frem 计算float类型除法的余数</p><p>drem 计算double类型除法的余数</p><p>fneg 将一个float类型的数值取反</p><p>dneg 将一个double类型的数值取反</p></blockquote><h3 id="算术指令集"><a href="#算术指令集" class="headerlink" title="算术指令集"></a>算术指令集</h3><table><thead><tr><th>算数指令</th><th>int(boolean,byte,char,short)</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>加法指令</td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td></tr><tr><td>减法指令</td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td></tr><tr><td>乘法指令</td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td></tr><tr><td>除法指令</td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td></tr><tr><td>求余指令</td><td>irem</td><td>lrem</td><td>frem</td><td>drem</td></tr><tr><td>取反指令</td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td></tr><tr><td>自增指令</td><td>iinc</td><td></td><td></td><td></td></tr><tr><td>位运算指令</td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td>按位或指令</td><td>ior</td><td>lor</td><td></td><td></td></tr><tr><td>按位与指令</td><td>iand</td><td>land</td><td></td><td></td></tr><tr><td>按位异或指令</td><td>ixor</td><td>lxor</td><td></td><td></td></tr><tr><td>比较指令</td><td>lcmp</td><td>fcmpg / fcmpl</td><td>dcmpg / dcmpl</td><td></td></tr></tbody></table><p><img src="/attachment/5ea93c488d3851f27871a8d8675a5a05.png"></p><blockquote><p>注意：NaN(Not a Number)表示不是一个数字</p></blockquote><h3 id="算术指令举例"><a href="#算术指令举例" class="headerlink" title="算术指令举例"></a>算术指令举例</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><pre><code class="line-numbers language-java">public static int bar(int i) {    return ((i + 1) - 2) * 3 / 4;}</code></pre><p><img src="/attachment/43791204a603516a8c3294811c163ab7.png"></p><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><pre><code class="line-numbers language-java">public void add() {    byte i = 15;    int j = 8;    int k = i + j;}</code></pre><p><img src="/attachment/a5ebbd8bc0c06c78c33167c74db1ef9a.png"></p><p><img src="/attachment/3ba46c25ce2610548ed2a693f37251da.png"></p><p><img src="/attachment/5cd82e298c559447ca62d2b188083e04.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f2edaef3312398b63decea146718f2d6.gif" alt="img"></p><h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><pre><code class="line-numbers language-java">public static void main(String[] args) {    int x = 500;    int y = 100;    int a = x / y;    int b = 50;    System.out.println(a + b);}</code></pre><p><img src="/attachment/9d72851226e40d8c432a96bd5f77c32e.png"></p><p><img src="/attachment/5d3f63030d47ad53be7d5071bf220374.png"></p><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><blockquote><h2 id="宽化类型转换"><a href="#宽化类型转换" class="headerlink" title="宽化类型转换"></a>宽化类型转换</h2><p>i2l 把int类型的数据转化为long类型</p><p>i2f 把int类型的数据转化为float类型</p><p>i2d 把int类型的数据转化为double类型</p><p>l2f 把long类型的数据转化为float类型</p><p>l2d 把long类型的数据转化为double类型</p><p>f2d 把float类型的数据转化为double类型</p><h2 id="窄化类型转换"><a href="#窄化类型转换" class="headerlink" title="窄化类型转换"></a>窄化类型转换</h2><p>i2b 把int类型的数据转化为byte类型</p><p>i2c 把int类型的数据转化为char类型</p><p>i2s 把int类型的数据转化为short类型</p><p>l2i 把long类型的数据转化为int类型</p><p>f2i 把float类型的数据转化为int类型</p><p>f2l 把float类型的数据转化为long类型</p><p>d2i 把double类型的数据转化为int类型</p><p>d2l 把double类型的数据转化为long类型</p><p>d2f 把double类型的数据转化为float类型</p></blockquote><table><thead><tr><th align="center"></th><th align="center"><strong>byte</strong></th><th align="center"><strong>char</strong></th><th align="center"><strong>short</strong></th><th align="center"><strong>int</strong></th><th align="center"><strong>long</strong></th><th align="center"><strong>float</strong></th><th align="center"><strong>double</strong></th></tr></thead><tbody><tr><td align="center"><strong>int</strong></td><td align="center">i2b</td><td align="center">i2c</td><td align="center">i2s</td><td align="center">○</td><td align="center">i2l</td><td align="center">i2f</td><td align="center">i2d</td></tr><tr><td align="center"><strong>long</strong></td><td align="center">l2i i2b</td><td align="center">l2i i2c</td><td align="center">l2i i2s</td><td align="center">l2i</td><td align="center">○</td><td align="center">l2f</td><td align="center">l2d</td></tr><tr><td align="center"><strong>float</strong></td><td align="center">f2i i2b</td><td align="center">f2i i2c</td><td align="center">f2i i2s</td><td align="center">f2i</td><td align="center">f2l</td><td align="center">○</td><td align="center">f2d</td></tr><tr><td align="center"><strong>double</strong></td><td align="center">d2i i2b</td><td align="center">d2i i2c</td><td align="center">d2i i2s</td><td align="center">d2i</td><td align="center">d2l</td><td align="center">d2f</td><td align="center">○</td></tr></tbody></table><p>类型转换指令可以将两种不同的数值类型进行相互转换。这些转换操作一般用于实现用户代码中的显式类型转換操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><h3 id="宽化类型转换剖析"><a href="#宽化类型转换剖析" class="headerlink" title="宽化类型转换剖析"></a>宽化类型转换剖析</h3><blockquote><p>宽化类型转换( Widening Numeric Conversions)</p><ol><li>转换规则</li></ol><p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion,小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括</p><blockquote><p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d</p><p>从long类型到float、 double类型。对应的指令为：i2f、i2d</p><p>从float类型到double类型。对应的指令为：f2d</p></blockquote><p>简化为：int–&gt;long–&gt;float-&gt; double</p><ol start="2"><li>精度损失问题</li></ol><blockquote><p>2.1. 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。</p><p>2.2. 从int、long类型数值转换到float,或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p></blockquote><p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常</p><ol start="3"><li>补充说明</li></ol><p>从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转为int,拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p><p>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</p><p>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p></blockquote><h3 id="窄化类型转换剖析"><a href="#窄化类型转换剖析" class="headerlink" title="窄化类型转换剖析"></a>窄化类型转换剖析</h3><blockquote><p>窄化类型转换( Narrowing Numeric Conversion)</p><ol><li>转换规则</li></ol><p>Java虚拟机也直接支持以下窄化类型转换：</p><blockquote><p>从主int类型至byte、 short或者char类型。对应的指令有：i2b、i2c、i2s</p><p>从long类型到int类型。对应的指令有：l2i</p><p>从float类型到int或者long类型。对应的指令有：f2i、f2l</p><p>从double类型到int、long或者float类型。对应的指令有：d2i、d2l、d2f</p></blockquote><ol start="2"><li>精度损失问题</li></ol><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p><ol start="3"><li>补充说明</li></ol><blockquote><p>3.1. 当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</p><blockquote><p>如果浮点值是NaN,那转换结果就是int或long类型的0.</p><p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值Vv如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p></blockquote><p>3.2. 当将一个double类型窄化转换为float类型时，将遵循以下转换规则</p><blockquote><p>通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断</p><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零</p><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。</p><p>对于double类型的NaN值将按规定转換为float类型的NaN值。</p></blockquote></blockquote></blockquote><h2 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h2><blockquote><h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><p>new 创建一个新对象</p><p>getfield 从对象中获取字段</p><p>putfield 设置对象中字段的值</p><p>getstatic 从类中获取静态字段</p><p>putstatic 设置类中静态字段的值</p><p>checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常</p><p>instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0</p><h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><p>newarray 分配数据成员类型为基本上数据类型的新数组</p><p>anewarray 分配数据成员类型为引用类型的新数组</p><p>arraylength 获取数组长度</p><p>multianewarray 分配新的多维数组</p></blockquote><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p><h3 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h3><table><thead><tr><th align="left">创建指令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">new</td><td align="left">创建类实例</td></tr><tr><td align="left">newarray</td><td align="left">创建基本类型数组</td></tr><tr><td align="left">anewarray</td><td align="left">创建引用类型数组</td></tr><tr><td align="left">multilanewarra</td><td align="left">创建多维数组</td></tr></tbody></table><p><img src="/attachment/7b4470ceb32ee545511bb9a88f69bb6f.png"></p><h3 id="字段访问指令"><a href="#字段访问指令" class="headerlink" title="字段访问指令"></a>字段访问指令</h3><table><thead><tr><th align="left">字段访问指令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">getstatic、putstatic</td><td align="left">访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td align="left">getfield、 putfield</td><td align="left">访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><p><img src="/attachment/2ea1feba3699bd4748381e59b56702b2.png"></p><p><img src="/attachment/40e371282fe57035bcf1715f25685610.png"></p><h3 id="数组操作指令-1"><a href="#数组操作指令-1" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xaload</strong></td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td><td>laload</td><td>faload</td><td>daload</td><td>aaload</td></tr><tr><td><strong>xastore</strong></td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td><td>lastore</td><td>fastore</td><td>dastore</td><td>aastore</td></tr></tbody></table><p><img src="/attachment/6d1c76f3815ae1ffc319b1a29eb16986.png"></p><p><img src="/attachment/cde7ea231324913687618694b677b298.png"></p><h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>检查类型强制转换是否可以进行</td></tr><tr><td>checkcast</td><td>判断给定对象是否是某一个类的实例</td></tr></tbody></table><p><img src="/attachment/bd299c6ba643b1381106a0804a530301.png"></p><h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><blockquote><h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><p>invokcvirtual 运行时按照对象的类来调用实例方法</p><p>invokespecial 根据编译时类型来调用实例方法</p><p>invokestatic 调用类（静态）方法</p><p>invokcinterface 调用接口方法</p><h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><p>ireturn 从方法中返回int类型的数据</p><p>lreturn 从方法中返回long类型的数据</p><p>freturn 从方法中返回float类型的数据</p><p>dreturn 从方法中返回double类型的数据</p><p>areturn 从方法中返回引用类型的数据</p><p>return 从方法中返回，返回值为void</p></blockquote><h3 id="方法调用指令-1"><a href="#方法调用指令-1" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><table><thead><tr><th>方法调用指令</th><th>含义</th></tr></thead><tbody><tr><td>invokevirtual</td><td>调用对象的实例方法</td></tr><tr><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>invokespecial</td><td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td></tr><tr><td>invokestatic</td><td>调用命名类中的类方法（static方法）</td></tr><tr><td>invokedynamic</td><td>调用动态绑定的方法</td></tr></tbody></table><p><img src="/attachment/c89d14d98f2c4d71a5ddcfcb6a8b1cc0.png"></p><h3 id="方法返回指令-1"><a href="#方法返回指令-1" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><table><thead><tr><th>方法返回指令</th><th>void</th><th>int</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xreturn</strong></td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p><img src="/attachment/42dbde702dd0ce775a9d6e0873fa30c3.png"></p><p><img src="/attachment/a76aaa3d8d32ce3f29a925d6a7824b6d.png"></p><pre><code class="line-numbers language-java">public int methodReturn() {    int i = 500;    int j = 200;    int k = 50;        return (i + j) / k;}</code></pre><p><img src="/attachment/91cdc761c4bb9320cc56ee6bb8c92c6b.png"></p><h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><blockquote><h2 id="通用-无类型）栈操作"><a href="#通用-无类型）栈操作" class="headerlink" title="通用(无类型）栈操作"></a>通用(无类型）栈操作</h2><p>nop 不做任何操作</p><p>pop 弹出栈顶端一个字长的内容</p><p>pop2 弹出栈顶端两个字长的内容</p><p>dup 复制栈顶部一个字长内容</p><p>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈</p><p>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p><p>dup2 复制栈顶部两个字长内容</p><p>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p><p>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈</p><p>swap 交换栈顶部两个字长内容</p></blockquote><p><img src="/attachment/b2ed63013704e83bdb0c4ad2e3beb127.png"></p><p><img src="/attachment/1ca51fb59e316e3ce31536d9417d91f7.png"></p><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><blockquote><h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><p>lcmp 比较long类型值</p><p>fcmpl 比较float类型值（当遇到NaN时，返回-1）</p><p>fcmpg 比较float类型值（当遇到NaN时，返回1）</p><p>dcmpl 比较double类型值（当遇到NaN时，返回-1）</p><p>dcmpg 比较double类型值（当遇到NaN时，返回1）</p><h2 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h2><p>ifeq 如果等于0，则跳转</p><p>ifne 如果不等于0，则跳转</p><p>iflt 如果小于0，则跳转</p><p>ifge 如果大于等于0，则跳转</p><p>ifgt 如果大于0，则跳转</p><p>ifle 如果小于等于0，则跳转</p><h2 id="比较条件分支指令"><a href="#比较条件分支指令" class="headerlink" title="比较条件分支指令"></a>比较条件分支指令</h2><p>if_icmpeq 如果两个int值相等，则跳转</p><p>if_icmpne 如果两个int类型值不相等，则跳转</p><p>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</p><p>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</p><p>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</p><p>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转</p><p>ifnull 如果等于null，则跳转</p><p>ifnonnull 如果不等于null，则跳转</p><p>if_acmpeq 如果两个对象引用相等，则跳转</p><p>if_acmpne 如果两个对象引用不相等，则跳转</p><h2 id="多条件分支跳转指令"><a href="#多条件分支跳转指令" class="headerlink" title="多条件分支跳转指令"></a>多条件分支跳转指令</h2><p>tableswitch 通过索引访问跳转表，并跳转</p><p>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p><h2 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h2><p>goto 无条件跳转</p><p>goto_w 无条件跳转（宽索引）</p></blockquote><h3 id="比较指令-1"><a href="#比较指令-1" class="headerlink" title="比较指令"></a>比较指令</h3><blockquote><p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栽。</p><p>比较指令有： dcmpg,dcmpl、 fcmpg、fcmpl、lcmp</p><p>与前面讲解的指令类似，首字符d表示double类型，f表示float,l表示long.</p><p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p><p>指令dcmpl和 dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</p><p>举例</p><p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2,顶顺位第2位的元素为v1,若v1=v2,则压入0:若v1&gt;v2则压入1:若v1&lt;v2则压入-1.</p><p>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</p></blockquote><h2 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h2><table><thead><tr><th>&lt;</th><th>&lt;=</th><th>==</th><th>!=</th><th>&gt;=</th><th>&gt;</th><th>null</th><th>not null</th></tr></thead><tbody><tr><td>iflt</td><td>ifle</td><td>ifeq</td><td>ifng</td><td>ifge</td><td>ifgt</td><td>ifnull</td><td>ifnonnull</td></tr></tbody></table><p><img src="/attachment/138f1cf07e515990fa7a019c05a147ef.png"></p><p><img src="/attachment/52d088bd0d8214b5ea7bdade9f54158b.png"></p><h3 id="比较条件跳转指令"><a href="#比较条件跳转指令" class="headerlink" title="比较条件跳转指令"></a>比较条件跳转指令</h3><table><thead><tr><th>&lt;</th><th>&lt;=</th><th>==</th><th>!=</th><th>&gt;=</th><th>&gt;</th></tr></thead><tbody><tr><td>if_icmplt</td><td>if_icmple</td><td>if_icmpeq、if_acmpeq</td><td>if_icmpne、if_acmpne</td><td>if_icmpge</td><td>if_icmpgt</td></tr></tbody></table><p><img src="/attachment/99a94ebca2649a7f812b29e275249543.png"></p><h3 id="多条件分支跳转"><a href="#多条件分支跳转" class="headerlink" title="多条件分支跳转"></a>多条件分支跳转</h3><p><img src="/attachment/dd670ee757941700749f1c7984205da4.png"></p><p><img src="/attachment/7a6e86ba42c493269d667ba32c202153.png"></p><h3 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h3><p><img src="/attachment/9e1be192f829c87a0307ddffcf4838fa.png"></p><h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><blockquote><h2 id="异常处理指令-1"><a href="#异常处理指令-1" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>athrow 抛出异常或错误。将栈顶异常抛出</p><p>jsr 跳转到子例程</p><p>jsr_w 跳转到子例程（宽索引）</p><p>rct 从子例程返回</p></blockquote><p><img src="/attachment/f0bb2712cbca5760b542fbec70e8890c.png"></p><p><img src="/attachment/55d30dd951ef421701d808d475f29498.png"></p><p><img src="/attachment/275ce532b72f4ac671759ea98d1991ab.png"></p><p><img src="/attachment/5cd36f1f1b5cc94c1350b045ce72a082.png"></p><h2 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h2><blockquote><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>montiorenter 进入并获取对象监视器。即：为栈顶对象加锁</p><p>monitorexit 释放并退出对象监视器。即：为栈顶对象解锁</p></blockquote><p>Java虚拟机支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor来支持的</p><h3 id="方法级的同步"><a href="#方法级的同步" class="headerlink" title="方法级的同步"></a>方法级的同步</h3><p><img src="/attachment/03d084ea5418b08794758fefa686431b.png"></p><pre><code class="line-numbers language-java">private int i = 0;public synchronized void add() {    i++;}</code></pre><p><img src="/attachment/36b8406b96b5b1721c48591fb5f1a2b4.png"></p><p><img src="/attachment/67b07f70075b6854cf495faab9231488.png"></p><h3 id="方法内指令指令序列的同步"><a href="#方法内指令指令序列的同步" class="headerlink" title="方法内指令指令序列的同步"></a>方法内指令指令序列的同步</h3><p><img src="/attachment/dd13bac4e1240422f59601b72085fcfc.png"></p><p><img src="/attachment/1bdb7bfd4b8f484a3cc381a36d776f65.png"></p><p><img src="/attachment/1b1dff86ba4b774de693fe152ac6ce7f.png"></p><p><img src="/attachment/26b9640de9d5dad250c3634f2c0d11ff.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 Class 文件结构</title>
      <link href="/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-class-wen-jian-jie-gou/"/>
      <url>/java/java-jvm/java-jvm-zi-jie-ma-yu-lei-jia-zai/java-jvm-class-wen-jian-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-Class-文件结构"><a href="#【Java-JVM】-Class-文件结构" class="headerlink" title="【Java JVM】 Class 文件结构"></a>【Java JVM】 Class 文件结构</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 Class 文件结构date: 2023-06-29 22:52tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 Class 文件结构</code></pre><h2 id="【Java-JVM】-Class-文件结构-1"><a href="#【Java-JVM】-Class-文件结构-1" class="headerlink" title="【Java JVM】 Class 文件结构"></a>【Java JVM】 Class 文件结构</h2><h2 id="Class-字节码文件结构"><a href="#Class-字节码文件结构" class="headerlink" title="Class 字节码文件结构"></a>Class 字节码文件结构</h2><table>    <tbody>          <tr>            <th></th>             <th>类型</th>             <th>名称</th>             <th>说明</th>             <th>长度</th>             <th>数量</th>        </tr>       <tr>            <td>魔数</td>            <td>u4</td>            <td>magic</td>            <td>魔数,识别Class文件格式</td>            <td>4个字节</td>                 <td>1</td>       </tr>       <tr>            <td rowspan="2">版本号</td>            <td>u2</td>            <td>minor_version</td>            <td>副版本号(小版本)</td>            <td>2个字节</td>                 <td>1</td>       </tr>       <tr>            <td>u2</td>            <td>major_version</td>            <td>主版本号(大版本)</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td rowspan="2">常量池集合</td>            <td>u2</td>            <td>constant_pool_count</td>            <td>常量池计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>cp_info</td>            <td>constant_pool</td>            <td>常量池表</td>            <td>n个字节</td>                 <td>constant_pool_count - 1</td>        </tr>        <tr>            <td>访问标识</td>            <td>u2</td>            <td>access_flags</td>            <td>访问标识</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td rowspan="4">索引集合</td>            <td>u2</td>            <td>this_class</td>            <td>类索引</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>super_class</td>            <td>父类索引</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>interfaces_count</td>            <td>接口计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>interfaces</td>            <td>接口索引集合</td>            <td>2个字节</td>                 <td>interfaces_count</td>        </tr>            <tr>            <td rowspan="2">字段表集合</td>            <td>u2</td>            <td>fields_count</td>            <td>字段计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>field_info</td>            <td>fields</td>            <td>字段表</td>            <td>n个字节</td>                 <td>fields_count</td>        </tr>        <tr>            <td rowspan="2">方法表集合</td>            <td>u2</td>            <td>methods_count</td>            <td>方法计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>method_info</td>            <td>methods</td>            <td>方法表</td>            <td>n个字节</td>                 <td>methods_count</td>        </tr>        <tr>            <td rowspan="2">属性表集合</td>            <td>u2</td>            <td>attributes_count</td>            <td>属性计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>attribute_info</td>            <td>attributes</td>            <td>属性表</td>            <td>n个字节</td>                 <td>attributes_count</td>        </tr>   </tbody><tbody> </tbody></table><h2 id="Class-文件数据类型"><a href="#Class-文件数据类型" class="headerlink" title="Class 文件数据类型"></a>Class 文件数据类型</h2><table><thead><tr><th align="left">数据类型</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">无符号数</td><td align="left">无符号数可以用来描述数字、索引引用、数量值或按照 utf-8 编码构成的字符串值。</td><td align="left">其中无符号数属于基本的数据类型。 以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节</td></tr><tr><td align="left">表</td><td align="left">表是由多个无符号数或其他表构成的复合数据结构。</td><td align="left">所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p><strong>Magic Number（魔数）</strong></p><ul><li>每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number）</li><li>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是 Class 文件的标识符。</li><li>魔数值固定为 0xCAFEBABE。不会改变。</li><li>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</li></ul><pre><code class="line-numbers language-java">Error: A JNI error has occurred, please check your installation and try againException in thread "main" java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest</code></pre><ul><li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li></ul><h2 id="文件版本号"><a href="#文件版本号" class="headerlink" title="文件版本号"></a>文件版本号</h2><p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。</p><p>它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</p><p>版本号和 Java 编译器的对应关系如下表：</p><h3 id="Class-文件版本号对应关系"><a href="#Class-文件版本号对应关系" class="headerlink" title="Class 文件版本号对应关系"></a>Class 文件版本号对应关系</h3><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p>Java 的版本号是从 45 开始的，JDK1.1 之后的每个 JDK 大版本发布主版本号向上加 1。</p><p><mark>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 java.lang.UnsupportedClassVersionError 异常。（向下兼容）</mark></p><p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境中的 JDK 版本是否一致。</p><ul><li>虚拟机 JDK 版本为 1.k（k&gt;=2）时，对应的 class 文件格式版本号的范围为 45.0 - 44+k.0（含两端）。</li></ul><h2 id="常量池集合"><a href="#常量池集合" class="headerlink" title="常量池集合"></a>常量池集合</h2><p>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</p><p>随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。</p><p><img src="/attachment/359aaf947509e4a7373e5ab2e0e037af.png"></p><p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。</p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th></tr></thead><tbody><tr><td align="left">u2（无符号数）</td><td align="left">constant_pool_count</td><td align="left">1</td></tr><tr><td align="left">cp_info（表）</td><td align="left">constant_pool</td><td align="left">constant_pool_count - 1</td></tr></tbody></table><p>由上表可见，Class 文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p><ul><li><mark>常量池表项</mark>中，用于存放编译时期生成的各种<mark>字面量</mark>和<mark>符号引用</mark>，这部分内容将在类加载后进入方法区的<mark>运行时常量池</mark>中存放</li></ul><h3 id="常量池计数器"><a href="#常量池计数器" class="headerlink" title="常量池计数器"></a>常量池计数器</h3><p><strong>constant_pool_count（常量池计数器）</strong></p><ul><li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li><li>常量池容量计数值（u2 类型）：<mark>从 1 开始</mark>，表示常量池中有多少项常量。即 constant_pool_count=1 表示常量池中有 0 个常量项。</li><li>Demo 的值为：</li></ul><p><img src="/attachment/618426a9f97b9412a534b53c4c9f875f.png"></p><p>其值为 0x0016，掐指一算，也就是 22。需要注意的是，这实际上只有 21 项常量。索引为范围是 1-21。为什么呢？</p><p>通常我们写代码时都是从 0 开始的，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值 0 来表示。</p><h3 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h3><p>constant_pool 是一种表结构，以 1 ~ constant_pool_count - 1 为索引。表明了后面有多少个常量项。</p><p>常量池主要存放两大类常量：<mark>字面量（Literal）</mark>和<mark>符号引用（Symbolic References）</mark></p><p>它包含了 class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte（标记字节、标签字节）。</p><table><thead><tr><th align="left">类型</th><th align="left">标志(或标识)</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">CONSTANT_Utf8_info</td><td align="left">1</td><td align="left">UTF-8 编码的字符串</td></tr><tr><td align="left">CONSTANT_Integer_info</td><td align="left">3</td><td align="left">整型字面量</td></tr><tr><td align="left">CONSTANT_Float_info</td><td align="left">4</td><td align="left">浮点型字面量</td></tr><tr><td align="left">CONSTANT_Long_info</td><td align="left">5</td><td align="left">长整型字面量</td></tr><tr><td align="left">CONSTANT_Double_info</td><td align="left">6</td><td align="left">双精度浮点型字面量</td></tr><tr><td align="left">CONSTANT_Class_info</td><td align="left">7</td><td align="left">类或接口的符号引用</td></tr><tr><td align="left">CONSTANT_String_info</td><td align="left">8</td><td align="left">字符串类型字面量</td></tr><tr><td align="left">CONSTANT_Fieldref_info</td><td align="left">9</td><td align="left">字段的符号引用</td></tr><tr><td align="left">CONSTANT_Methodref_info</td><td align="left">10</td><td align="left">类中方法的符号引用</td></tr><tr><td align="left">CONSTANT_InterfaceMethodref_info</td><td align="left">11</td><td align="left">接口中方法的符号引用</td></tr><tr><td align="left">CONSTANT_NameAndType_info</td><td align="left">12</td><td align="left">字段或方法的符号引用</td></tr><tr><td align="left">CONSTANT_MethodHandle_info</td><td align="left">15</td><td align="left">表示方法句柄</td></tr><tr><td align="left">CONSTANT_MethodType_info</td><td align="left">16</td><td align="left">标志方法类型</td></tr><tr><td align="left">CONSTANT_InvokeDynamic_info</td><td align="left">18</td><td align="left">表示一个动态方法调用点</td></tr></tbody></table><h4 id="Ⅰ-字面量和符号引用"><a href="#Ⅰ-字面量和符号引用" class="headerlink" title="Ⅰ. 字面量和符号引用"></a>Ⅰ. 字面量和符号引用</h4><p>在对这些常量解读前，我们需要搞清楚几个概念。</p><p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：</p><table><thead><tr><th align="left">常量</th><th align="left">具体的常量</th></tr></thead><tbody><tr><td align="left">字面量</td><td align="left">文本字符串</td></tr><tr><td align="left"></td><td align="left">声明为 final 的常量值</td></tr><tr><td align="left">符号引用</td><td align="left">类和接口的全限定名</td></tr><tr><td align="left"></td><td align="left">字段的名称和描述符</td></tr><tr><td align="left"></td><td align="left">方法的名称和描述符</td></tr></tbody></table><p><strong>全限定名</strong></p><p>com/atguigu/test/Demo 这个就是类的全限定名，仅仅是把包名的“.“替换成”/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</p><p><strong>简单名称</strong></p><p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 add()方法和 num 字段的简单名称分别是 add 和 num。</p><p><strong>描述符</strong></p><p><mark>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</mark>。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示，详见下表：</p><table><thead><tr><th align="left">标志符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">B</td><td align="left">基本数据类型 byte</td></tr><tr><td align="left">C</td><td align="left">基本数据类型 char</td></tr><tr><td align="left">D</td><td align="left">基本数据类型 double</td></tr><tr><td align="left">F</td><td align="left">基本数据类型 float</td></tr><tr><td align="left">I</td><td align="left">基本数据类型 int</td></tr><tr><td align="left">J</td><td align="left">基本数据类型 long</td></tr><tr><td align="left">S</td><td align="left">基本数据类型 short</td></tr><tr><td align="left">Z</td><td align="left">基本数据类型 boolean</td></tr><tr><td align="left">V</td><td align="left">代表 void 类型</td></tr><tr><td align="left">L</td><td align="left">对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td align="left">[</td><td align="left">数组类型，代表一维数组。比如：<code>double[] is [D</code></td></tr></tbody></table><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法 java.lang.String tostring()的描述符为()Ljava/lang/String; ，方法 int abc(int[]x, int y)的描述符为<code>([II)I</code>。</p><p><strong>补充说明：</strong></p><p>虚拟机在加载 Class 文件时才会进行动态链接，也就是说，Class 文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。<mark>当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中</mark>。</p><p>这里说明下符号引用和直接引用的区别与关联：</p><ul><li>符号引用：符号引用以<mark>一组符号</mark>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<mark>符号引用与虚拟机实现的内存布局无关</mark>，引用的目标并不一定已经加载到了内存中。</li><li>直接引用：直接引用可以是直接<mark>指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</mark>。<mark>直接引用是与虚拟机实现的内存布局相关的</mark>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li></ul><h4 id="Ⅱ-常量类型和结构"><a href="#Ⅱ-常量类型和结构" class="headerlink" title="Ⅱ. 常量类型和结构"></a>Ⅱ. 常量类型和结构</h4><p>常量池中每一项常量都是一个表，J0K1.7 之后共有 14 种不同的表结构数据。如下表格所示：</p><p><img src="/attachment/252404c9e880c49c94e45ded434ccbef.png"></p><p>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如:<br>CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息。</p><p>标志为 15、16、18 的常量项类型是用来支持动态语言调用的（jdk1.7 时才加入的）。</p><p><strong>细节说明:</strong></p><ul><li>CONSTANT_Class_info 结构用于表示类或接口</li><li>CONSTAT_Fieldref_info、CONSTAHT_Methodref_infoF 和 lCONSTANIT_InterfaceMethodref_info 结构表示字段、方汇和按口小法</li><li>CONSTANT_String_info 结构用于表示示 String 类型的常量对象</li><li>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示 4 字节（int 和 float）的数值常量</li><li>CONSTANT_Long_info 和 CONSTAT_Double_info 结构表示 8 字作（long 和 double）的数值常量<ul><li>在 class 文件的常最池表中，所行的 a 字节常借均占两个表成员（项）的空问。如果一个 CONSTAHT_Long_info 和 CNSTAHT_Double_info 结构在常量池中的索引位 n，则常量池中一个可用的索引位 n+2，此时常量池长中索引为 n+1 的项仍然有效但必须视为不可用的。</li></ul></li><li>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的 3 个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</li><li>CONSTANT_Utf8_info 用于表示字符常量的值</li><li>CONSTANT_MethodHandle_info 结构用于表示方法句柄</li><li>CONSTANT_MethodType_info 结构表示方法类型</li><li>CONSTANT_InvokeDynamic_info 结构表示 invokedynamic 指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</li></ul><p><strong>解析方法：</strong></p><ul><li><p>一个字节一个字节的解析</p></li><li><p>使用 javap 命令解析：javap-verbose Demo.class 或 jclasslib 工具会更方便。</p></li></ul><p><strong>总结 1：</strong></p><ul><li>这 14 种表（或者常量项结构）的共同点是：表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li><li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li><li>这 14 种常量项结构还有一个特点是，其中 13 个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么呢？<mark>因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定</mark>，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过 utf-8 编码，就可以知道其长度。</li></ul><p><strong>总结 2：</strong></p><ul><li>常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一。</li><li>常量池中为什么要包含这些内容？Java 代码在进行 Javac 编译的时候，并不像 C 和 C++那样有“连接”这一步骤，而是在虚拟机加载 C1ass 文件的时候进行动态链接。也就是说，<mark>在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用</mark>。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解</li></ul><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p><p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示：</p><table><thead><tr><th align="left">标志名称</th><th>标志值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td>0x0001</td><td align="left">标志为 public 类型</td></tr><tr><td align="left">ACC_FINAL</td><td>0x0010</td><td align="left">标志被声明为 final，只有类可以设置</td></tr><tr><td align="left">ACC_SUPER</td><td>0x0020</td><td align="left">标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td align="left">ACC_INTERFACE</td><td>0x0200</td><td align="left">标志这是一个接口</td></tr><tr><td align="left">ACC_ABSTRACT</td><td>0x0400</td><td align="left">是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td align="left">ACC_SYNTHETIC</td><td>0x1000</td><td align="left">标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td align="left">ACC_ANNOTATION</td><td>0x2000</td><td align="left">标志这是一个注解</td></tr><tr><td align="left">ACC_ENUM</td><td>0x4000</td><td align="left">标志这是一个枚举</td></tr></tbody></table><p>类的访问权限通常为 ACC_开头的常量。</p><p>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL。</p><p>使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</p><p><strong>补充说明：</strong></p><ol><li>带有 ACC_INTERFACE 标志的 class 文件表示的是接口而不是类，反之则表示的是类而不是接口。<ul><li>如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志。</li><li>如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。</li></ul></li><li>ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。<mark>针对 Java 虚拟机指令集的编译器都应当设置这个标志</mark>。对于 Java SE 8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。<ul><li>ACC_SUPER 标志是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access_flags 中是没有确定含义的，如果设置了该标志，那么 0racle 的 Java 虚拟机实现会将其忽略。</li></ul></li><li>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</li><li>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志。</li><li>ACC_ENUM 标志表明该类或其父类为枚举类型。</li></ol><h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p><table><thead><tr><th>长度</th><th align="left">含义</th></tr></thead><tbody><tr><td>u2</td><td align="left">this_class</td></tr><tr><td>u2</td><td align="left">super_class</td></tr><tr><td>u2</td><td align="left">interfaces_count</td></tr><tr><td>u2</td><td align="left">interfaces[interfaces_count]</td></tr></tbody></table><p>这三项数据来确定这个类的继承关系：</p><ul><li>类索引用于确定这个类的全限定名</li><li>父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.1ang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 e。</li><li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</li></ul><h3 id="this-class（类索引）"><a href="#this-class（类索引）" class="headerlink" title="this_class（类索引）"></a>this_class（类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了类的全限定名，如 com/atguigu/java1/Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 class 文件所定义的类或接口。</p><h3 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java/lang/object 类。同时，由于 Java 不支持多继承，所以其父类只有一个。</p><p>super_class 指向的父类不能是 final。</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p><p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class（当然这里就必须是接口，而不是类）。</p><h4 id="Ⅰ-interfaces-count（接口计数器）"><a href="#Ⅰ-interfaces-count（接口计数器）" class="headerlink" title="Ⅰ. interfaces_count（接口计数器）"></a>Ⅰ. interfaces_count（接口计数器）</h4><p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p><h4 id="Ⅱ-interfaces-（接口索引集合）"><a href="#Ⅱ-interfaces-（接口索引集合）" class="headerlink" title="Ⅱ. interfaces[]（接口索引集合）"></a>Ⅱ. interfaces[]（接口索引集合）</h4><p>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i]必须为 CONSTANT_Class_info 结构，其中 0 &lt;= i &lt; interfaces_count。在 interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即 interfaces[0]对应的是源代码中最左边的接口。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p><strong>fields</strong></p><p>用于描述接口或类中声明的变量。字段（field）包括<mark>类级变量以及实例级变量</mark>，但是不包括方法内部、代码块内部声明的局部变量。</p><p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p><p>它指向常量池索引集合，它描述了每个字段的完整信息。比如<mark>字段的标识符、访问修饰符（public、private 或 protected）、是类变量还是实例变量（static 修饰符）、是否是常量（final 修饰符）</mark>等。</p><p><strong>注意事项：</strong></p><ul><li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li><li>在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li></ul><h3 id="字段计数器"><a href="#字段计数器" class="headerlink" title="字段计数器"></a>字段计数器</h3><p><strong>fields_count（字段计数器）</strong></p><p>fields_count 的值表示当前 class 文件 fields 表的成员个数。使用两个字节来表示。</p><p>fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th><th align="left">数量</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">access_flags</td><td align="left">访问标志</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">name_index</td><td align="left">字段名索引</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">descriptor_index</td><td align="left">描述符索引</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">attributes_count</td><td align="left">属性计数器</td><td align="left">1</td></tr><tr><td align="left">attribute_info</td><td align="left">attributes</td><td align="left">属性集合</td><td align="left">attributes_count</td></tr></tbody></table><h3 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h3><h4 id="Ⅰ-字段表访问标识"><a href="#Ⅰ-字段表访问标识" class="headerlink" title="Ⅰ. 字段表访问标识"></a>Ⅰ. 字段表访问标识</h4><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td align="left">0x0001</td><td align="left">字段是否为 public</td></tr><tr><td align="left">ACC_PRIVATE</td><td align="left">0x0002</td><td align="left">字段是否为 private</td></tr><tr><td align="left">ACC_PROTECTED</td><td align="left">0x0004</td><td align="left">字段是否为 protected</td></tr><tr><td align="left">ACC_STATIC</td><td align="left">0x0008</td><td align="left">字段是否为 static</td></tr><tr><td align="left">ACC_FINAL</td><td align="left">0x0010</td><td align="left">字段是否为 final</td></tr><tr><td align="left">ACC_VOLATILE</td><td align="left">0x0040</td><td align="left">字段是否为 volatile</td></tr><tr><td align="left">ACC_TRANSTENT</td><td align="left">0x0080</td><td align="left">字段是否为 transient</td></tr><tr><td align="left">ACC_SYNCHETIC</td><td align="left">0x1000</td><td align="left">字段是否为由编译器自动产生</td></tr><tr><td align="left">ACC_ENUM</td><td align="left">0x4000</td><td align="left">字段是否为 enum</td></tr></tbody></table><h4 id="Ⅱ-描述符索引"><a href="#Ⅱ-描述符索引" class="headerlink" title="Ⅱ. 描述符索引"></a>Ⅱ. 描述符索引</h4><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符 L 加对象的全限定名来表示，如下所示：</p><table><thead><tr><th align="left">标志符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">B</td><td align="left">基本数据类型 byte</td></tr><tr><td align="left">C</td><td align="left">基本数据类型 char</td></tr><tr><td align="left">D</td><td align="left">基本数据类型 double</td></tr><tr><td align="left">F</td><td align="left">基本数据类型 float</td></tr><tr><td align="left">I</td><td align="left">基本数据类型 int</td></tr><tr><td align="left">J</td><td align="left">基本数据类型 long</td></tr><tr><td align="left">S</td><td align="left">基本数据类型 short</td></tr><tr><td align="left">Z</td><td align="left">基本数据类型 boolean</td></tr><tr><td align="left">V</td><td align="left">代表 void 类型</td></tr><tr><td align="left">L</td><td align="left">对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td align="left">[</td><td align="left">数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table><h4 id="Ⅲ-属性表集合"><a href="#Ⅲ-属性表集合" class="headerlink" title="Ⅲ. 属性表集合"></a>Ⅲ. 属性表集合</h4><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中。</p><pre><code class="line-numbers language-java">// 以常量属性为例，结构为：ConstantValue_attribute{    u2 attribute_name_index;    u4 attribute_length;    u2 constantvalue_index;}</code></pre><p>说明：对于常量属性而言，attribute_length 值恒为 2。</p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p><ul><li>在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li><li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li><li>一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法&lt;clinit&gt;()和实例初始化方法&lt;init&gt;()）。</li></ul><p><strong>使用注意事项：</strong></p><p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 class 文件中。</p><p>也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p><h3 id="方法计数器"><a href="#方法计数器" class="headerlink" title="方法计数器"></a>方法计数器</h3><p><strong>methods_count（方法计数器）</strong></p><p>methods_count 的值表示当前 class 文件 methods 表的成员个数。使用两个字节来表示。</p><p>methods 表中每个成员都是一个 method_info 结构。</p><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p><strong>methods[]（方法表）</strong></p><p>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的 Java 虚拟机指令。</p><p>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p><p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th><th align="left">数量</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">access_flags</td><td align="left">访问标志</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">name_index</td><td align="left">方法名索引</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">descriptor_index</td><td align="left">描述符索引</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">attributes_count</td><td align="left">属性计数器</td><td align="left">1</td></tr><tr><td align="left">attribute_info</td><td align="left">attributes</td><td align="left">属性集合</td><td align="left">attributes_count</td></tr></tbody></table><p><strong>方法表访问标志</strong></p><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td align="left">0x0001</td><td align="left">public，方法可以从包外访问</td></tr><tr><td align="left">ACC_PRIVATE</td><td align="left">0x0002</td><td align="left">private，方法只能本类访问</td></tr><tr><td align="left">ACC_PROTECTED</td><td align="left">0x0004</td><td align="left">protected，方法在自身和子类可以访问</td></tr><tr><td align="left">ACC_STATIC</td><td align="left">0x0008</td><td align="left">static，静态方法</td></tr></tbody></table><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>方法表集合之后的属性表集合，<mark>指的是 class 文件所携带的辅助信息</mark>，比如该 class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，<mark>一般无须深入了解</mark>。</p><p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p><p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</p><h3 id="属性计数器"><a href="#属性计数器" class="headerlink" title="属性计数器"></a>属性计数器</h3><p><strong>attributes_count（属性计数器）</strong></p><p>attributes_count 的值表示当前 class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构。</p><h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><p><strong>attributes[]（属性表）</strong></p><p>属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p><p><strong>属性的通用格式</strong></p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">attribute_name_index</td><td align="left">1</td><td align="left">属性名索引</td></tr><tr><td align="left">u4</td><td align="left">attribute_length</td><td align="left">1</td><td align="left">属性长度</td></tr><tr><td align="left">u1</td><td align="left">info</td><td align="left">attribute_length</td><td align="left">属性表</td></tr></tbody></table><p><strong>属性类型</strong></p><p>属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种，Java8 里面定义了 23 种属性。下面这些是虚拟机中预定义的属性：</p><table><thead><tr><th align="left">属性名称</th><th align="left">使用位置</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Code</td><td align="left">方法表</td><td align="left">Java 代码编译成的字节码指令</td></tr><tr><td align="left">ConstantValue</td><td align="left">字段表</td><td align="left">final 关键字定义的常量池</td></tr><tr><td align="left">Deprecated</td><td align="left">类，方法，字段表</td><td align="left">被声明为 deprecated 的方法和字段</td></tr><tr><td align="left">Exceptions</td><td align="left">方法表</td><td align="left">方法抛出的异常</td></tr><tr><td align="left">EnclosingMethod</td><td align="left">类文件</td><td align="left">仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td align="left">InnerClass</td><td align="left">类文件</td><td align="left">内部类列表</td></tr><tr><td align="left">LineNumberTable</td><td align="left">Code 属性</td><td align="left">Java 源码的行号与字节码指令的对应关系</td></tr><tr><td align="left">LocalVariableTable</td><td align="left">Code 属性</td><td align="left">方法的局部变量描述</td></tr><tr><td align="left">StackMapTable</td><td align="left">Code 属性</td><td align="left">JDK1.6 中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td align="left">Signature</td><td align="left">类，方法表，字段表</td><td align="left">用于支持泛型情况下的方法签名</td></tr><tr><td align="left">SourceFile</td><td align="left">类文件</td><td align="left">记录源文件名称</td></tr><tr><td align="left">SourceDebugExtension</td><td align="left">类文件</td><td align="left">用于存储额外的调试信息</td></tr><tr><td align="left">Synthetic</td><td align="left">类，方法表，字段表</td><td align="left">标志方法或字段为编译器自动生成的</td></tr><tr><td align="left">LocalVariableTypeTable</td><td align="left">类</td><td align="left">是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td align="left">RuntimeVisibleAnnotations</td><td align="left">类，方法表，字段表</td><td align="left">为动态注解提供支持</td></tr><tr><td align="left">RuntimeInvisibleAnnotations</td><td align="left">类，方法表，字段表</td><td align="left">用于指明哪些注解是运行时不可见的</td></tr><tr><td align="left">RuntimeVisibleParameterAnnotation</td><td align="left">方法表</td><td align="left">作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象或方法</td></tr><tr><td align="left">RuntimeInvisibleParameterAnnotation</td><td align="left">方法表</td><td align="left">作用与 RuntimeInvisibleAnnotations 属性类似，只不过作用对象或方法</td></tr><tr><td align="left">AnnotationDefault</td><td align="left">方法表</td><td align="left">用于记录注解类元素的默认值</td></tr><tr><td align="left">BootstrapMethods</td><td align="left">类文件</td><td align="left">用于保存 invokeddynamic 指令引用的引导方法限定符</td></tr></tbody></table><p>或者（查看官网）</p><p><img src="/attachment/501dc590c33903866a5836bdb754bcf9.png"></p><p><strong>部分属性详解</strong></p><p><strong>① ConstantValue 属性</strong></p><p>ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中。</p><pre><code class="line-numbers language-java">ConstantValue_attribute{    u2 attribute_name_index;    u4 attribute_length;    u2 constantvalue_index;//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是1ong型的，在常量池中便是CONSTANT_Long）}</code></pre><p><strong>② Deprecated 属性</strong></p><p>Deprecated 属性是在 JDK1.1 为了支持注释中的关键词@deprecated 而引入的。</p><pre><code class="line-numbers language-java">Deprecated_attribute{    u2 attribute_name_index;    u4 attribute_length;}</code></pre><p><strong>③ Code 属性</strong></p><p>Code 属性就是存放方法体里面的代码。但是，并非所有方法表都有 Code 属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了。Code 属性表的结构，如下图：</p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">attribute_name_index</td><td align="left">1</td><td align="left">属性名索引</td></tr><tr><td align="left">u4</td><td align="left">attribute_length</td><td align="left">1</td><td align="left">属性长度</td></tr><tr><td align="left">u2</td><td align="left">max_stack</td><td align="left">1</td><td align="left">操作数栈深度的最大值</td></tr><tr><td align="left">u2</td><td align="left">max_locals</td><td align="left">1</td><td align="left">局部变量表所需的存续空间</td></tr><tr><td align="left">u4</td><td align="left">code_length</td><td align="left">1</td><td align="left">字节码指令的长度</td></tr><tr><td align="left">u1</td><td align="left">code</td><td align="left">code_lenth</td><td align="left">存储字节码指令</td></tr><tr><td align="left">u2</td><td align="left">exception_table_length</td><td align="left">1</td><td align="left">异常表长度</td></tr><tr><td align="left">exception_info</td><td align="left">exception_table</td><td align="left">exception_length</td><td align="left">异常表</td></tr><tr><td align="left">u2</td><td align="left">attributes_count</td><td align="left">1</td><td align="left">属性集合计数器</td></tr><tr><td align="left">attribute_info</td><td align="left">attributes</td><td align="left">attributes_count</td><td align="left">属性集合</td></tr></tbody></table><p>可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构。</p><p><strong>④ InnerClasses 属性</strong></p><p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表。</p><p><strong>⑤ LineNumberTable 属性</strong></p><p>LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表。</p><p>LineNumberTable 属性是<mark>用来描述 Java 源码行号与字节码行号之间的对应关系</mark>。这个属性可以用来在调试的时候定位代码执行的行数。</p><ul><li>start_pc，即字节码行号；1ine_number，即 Java 源代码行号。</li></ul><p>在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。</p><pre><code class="line-numbers language-java">// LineNumberTable属性表结构：LineNumberTable_attribute{    u2 attribute_name_index;    u4 attribute_length;    u2 line_number_table_length;    {        u2 start_pc;        u2 line_number;    } line_number_table[line_number_table_length];}</code></pre><p><strong>⑥ LocalVariableTable 属性</strong></p><p>LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。</p><ul><li>start pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置（this 生命周期从头 e 到结尾 10）</li><li>index 就是这个变量在局部变量表中的槽位<mark>（槽位可复用）</mark></li><li>name 就是变量名</li><li>Descriptor 表示局部变量类型描述</li></ul><pre><code class="line-numbers language-java">// LocalVariableTable属性表结构：LocalVariableTable_attribute{    u2 attribute_name_index;    u4 attribute_length;    u2 local_variable_table_length;    {        u2 start_pc;        u2 length;        u2 name_index;        u2 descriptor_index;        u2 index;    } local_variable_table[local_variable_table_length];}</code></pre><p><strong>⑦ Signature 属性</strong></p><p>Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。</p><p><strong>⑧ SourceFile 属性</strong></p><p>SourceFile 属性结构</p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">attribute_name_index</td><td align="left">1</td><td align="left">属性名索引</td></tr><tr><td align="left">u4</td><td align="left">attribute_length</td><td align="left">1</td><td align="left">属性长度</td></tr><tr><td align="left">u2</td><td align="left">sourcefile index</td><td align="left">1</td><td align="left">源码文件素引</td></tr></tbody></table><p>可以看到，其长度总是固定的 8 个字节。</p><p><strong>⑨ 其他属性</strong></p><p>Java 虚拟机中预定义的属性有 20 多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 垃圾回收器</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-la-ji-shou-ji/java-jvm-la-ji-hui-shou-qi/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-la-ji-shou-ji/java-jvm-la-ji-hui-shou-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-垃圾回收器"><a href="#【Java-JVM】-垃圾回收器" class="headerlink" title="【Java JVM】 垃圾回收器"></a>【Java JVM】 垃圾回收器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 垃圾回收器date: 2023-06-29 11:35tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 垃圾回收器</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>按<mark>线程数</mark>分，可以分为<mark>串行垃圾回收器</mark>和<mark>并行垃圾回收器</mark>。</p><p><strong>评估 GC 的性能指标</strong></p><ul><li><mark>吞吐量</mark>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><mark>垃圾收集开销</mark>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><mark>暂停时间</mark>：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><mark>收集频率</mark>：相对于应用程序的执行，收集操作发生的频率。</li><li><mark>内存占用</mark>：Java 堆区所占的内存大小。</li><li><mark>快速</mark>：一个对象从诞生到被回收所经历的时间。</li></ul><p><img src="/attachment/40fddd144dcf61d38cfc9b3df69c58f6.png"></p><ul><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial Old、Parallel Old、CMS；</li><li>整堆收集器：G1；</li></ul><p><strong>Serial 回收器：串行回收</strong></p><p>Serial 收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p><p><img src="/attachment/91cb527944422b9885f6b7c47a1f2447.png"></p><p><strong>ParNew 回收器：并行回收</strong></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p><img src="/attachment/5d08cf7757c1c44dfdb660ec2e6f8abc.png"></p><p><strong>Parallel 回收器：吞吐量优先</strong></p><p><img src="/attachment/a3c5a70b43539c39682370ac19f7753c.png"></p><p><strong>CMS 回收器：低延迟</strong></p><p><img src="/attachment/f6a3702808f01a4546c69bb66d1feabf.png"></p><p><strong>G1 回收器：区域化分代式</strong></p><p><img src="/attachment/797257043c7e0977d1b765cbd882a4f5.png"></p><p><img src="/attachment/1483e7fcd19983cc8e9dcf69b54f58fa.png"></p><p><strong>Remembered Set</strong></p><p><img src="/attachment/910415c86ef3dcc290375fb4f3c0d32e.png"></p><p><strong>G1 回收过程一：年轻代 GC</strong></p><ol><li>第一阶段，扫描根。</li><li>第二阶段，更新 RSet</li><li>第三阶段，处理 RSet</li><li>第四阶段，复制对象</li><li>第五阶段，处理引用</li></ol><p><strong>G1 回收过程二：并发标记过程</strong></p><ol><li>初始标记阶段</li><li>根区域扫描（Root Region Scanning）</li><li>并发标记（Concurrent Marking）</li><li>再次标记（Remark）</li><li>独占清理（cleanup，STW）</li><li>并发清理阶段</li></ol><p><strong>G1 回收过程三：混合回收</strong></p><p><img src="/attachment/0f34edd20358a9d7972961780274bccf.png"></p><p><strong>G1 回收可选的过程四：Full GC</strong></p><p>导致 G1 Full GC 的原因可能有两个：</p><ul><li>Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><p><strong>7 种经典垃圾回收器总结</strong></p><table><thead><tr><th align="left">垃圾收集器</th><th align="left">分类</th><th align="left">作用位置</th><th align="left">使用算法</th><th align="left">特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">Serial</td><td align="left">串行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">适用于单 CPU 环境下的 client 模式</td></tr><tr><td align="left">ParNew</td><td align="left">并行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">多 CPU 环境 Server 模式下与 CMS 配合使用</td></tr><tr><td align="left">Parallel</td><td align="left">并行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">吞吐量优先</td><td align="left">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="left">Serial Old</td><td align="left">串行运行</td><td align="left">作用于老年代</td><td align="left">标记-压缩算法</td><td align="left">响应速度优先</td><td align="left">适用于单 CPU 环境下的 Client 模式</td></tr><tr><td align="left">Parallel Old</td><td align="left">并行运行</td><td align="left">作用于老年代</td><td align="left">标记-压缩算法</td><td align="left">吞吐量优先</td><td align="left">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="left">CMS</td><td align="left">并发运行</td><td align="left">作用于老年代</td><td align="left">标记-清除算法</td><td align="left">响应速度优先</td><td align="left">适用于互联网或 B／S 业务</td></tr><tr><td align="left">G1</td><td align="left">并发、并行运行</td><td align="left">作用于新生代、老年代</td><td align="left">标记-压缩算法、复制算法</td><td align="left">响应速度优先</td><td align="left">面向服务端应用</td></tr></tbody></table><p><strong>ZGC</strong></p><p>基于 Region 内存布局的<br>使用了读屏障、染色指针和内存多重映射等技术来实现<mark>可并发的标记-压缩算法</mark>的，以<mark>低延迟为首要目标</mark>的一款垃圾收集器。</p><p>ZGC 的工作过程可以分为 4 个阶段：<mark>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</mark> 等。</p><h2 id="GC-分类与性能指标"><a href="#GC-分类与性能指标" class="headerlink" title="GC 分类与性能指标"></a>GC 分类与性能指标</h2><h3 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h3><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p><p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p><p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p><h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><p>按<mark>线程数</mark>分，可以分为<mark>串行垃圾回收器</mark>和<mark>并行垃圾回收器</mark>。</p><p><img src="/attachment/ed398aac5c335e84ae24bd3ffabd2732.png"></p><p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<mark>串行回收默认被应用在客户端的 Client 模式下的 JVM 中</mark></li><li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p><p>按照<mark>工作模式</mark>分，可以分为<mark>并发式垃圾回收器</mark>和<mark>独占式垃圾回收器</mark>。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><p><img src="/attachment/b75939773b92fb80c27d8eca53a1954e.png"></p><p>按<mark>碎片处理方式</mark>分，可分为<mark>压缩式垃圾回收器</mark>和<mark>非压缩式垃圾回收器</mark>。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><p>按<mark>工作的内存区间</mark>分，又可分为<mark>年轻代垃圾回收器</mark>和<mark>老年代垃圾回收器</mark>。</p><h3 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h3><ul><li><mark>吞吐量</mark>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><mark>垃圾收集开销</mark>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><mark>暂停时间</mark>：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><mark>收集频率</mark>：相对于应用程序的执行，收集操作发生的频率。</li><li><mark>内存占用</mark>：Java 堆区所占的内存大小。</li><li><mark>快速</mark>：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p><p>简单来说，主要抓住两点：吞吐量、暂停时间</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</p><p><img src="/attachment/33bf1f791e9a2a2a6cdce0bae77d4b4e.png"></p><h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。</p><p>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</p><p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p><p><img src="/attachment/c2fe647f5431f23a0889bbdb2d03c1e0.png"></p><h4 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h4><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<mark>有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验</mark>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<mark>交互式应用程序</mark>。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么<mark>必然需要降低内存回收的执行频率</mark>，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<mark>只能频繁地执行内存回收</mark>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<mark>在最大吞吐量优先的情况下，降低停顿时间</mark></p><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p><ul><li>1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本</li><li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·</li><li>Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。</li><li>2012 年，在 JDK1.7u4 版本中，G1 可用。</li><li>2017 年，JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li><li>2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。·</li><li>2019 年 9 月，JDK13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li><li>2020 年 3 月，JDK14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macos 和 Windows 上的应用</li></ul><h3 id="7-种经典的垃圾收集器"><a href="#7-种经典的垃圾收集器" class="headerlink" title="7 种经典的垃圾收集器"></a>7 种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1</li></ul><p><img src="/attachment/e7f86138ae10221b1c9d67c473c786b8.png"></p><p>官方手册：<a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p><p><img src="/attachment/29ad2b2dee866f8b16ccd8cc4227bbd2.png"></p><h3 id="7-款经典收集器与垃圾分代之间的关系"><a href="#7-款经典收集器与垃圾分代之间的关系" class="headerlink" title="7 款经典收集器与垃圾分代之间的关系"></a>7 款经典收集器与垃圾分代之间的关系</h3><p><img src="/attachment/40fddd144dcf61d38cfc9b3df69c58f6.png"></p><ul><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial Old、Parallel Old、CMS；</li><li>整堆收集器：G1；</li></ul><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="/attachment/cc232c600c9d7bde6b5e5a203539bc4f.png"></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li><li>其中 Serial Old 作为 CMS 出现”<code>Concurrent Mode Failure</code>“失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）</li><li>（绿色虚框）JDK14 中：删除 CMS 垃圾回收器（JEP363）</li></ol><h3 id="不同的垃圾收集器概述"><a href="#不同的垃圾收集器概述" class="headerlink" title="不同的垃圾收集器概述"></a>不同的垃圾收集器概述</h3><p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<mark>我们选择的只是对具体应用最合适的收集器</mark>。</p><h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p><h2 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p><p>Serial 收集器作为 HotSpot 中 client 模式下的默认新生代垃圾收集器。</p><p><mark>Serial 收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</mark></p><p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<mark>Serial Old 收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</mark></p><ul><li>Serial old 是运行在 Client 模式下默认的老年代的垃圾回收器</li><li>Serial 0ld 在 Server 模式下主要有两个用途：① 与新生代的 Parallel scavenge 配合使用 ② 作为老年代 CMS 收集器的后备垃圾收集方案</li></ul><p><img src="/attachment/91cb527944422b9885f6b7c47a1f2447.png"></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会<mark>使用一个 CPU 或一条收集线程去完成垃圾收集工作</mark>，更重要的是在它进行垃圾收集时，<mark>必须暂停其他所有的工作线程</mark>，直到它收集结束（Stop The World）</p><p>优势：<mark>简单而高效</mark>（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在 Client 模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC</p><p><strong>总结</strong></p><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu 才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</p><h2 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，New：只能处理的是新生代</p><p>ParNew 收集器除了采用<mark>并行回收</mark>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用<mark>复制算法、”Stop-the-World”机制</mark>。</p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p><p><img src="/attachment/5d08cf7757c1c44dfdb660ec2e6f8abc.png"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 serial 收集器更高效？</p><ul><li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是<mark>在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效</mark>。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul><p>因为除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p><p>在程序中，开发人员可以通过选项”<code>-XX:+UseParNewGC</code>“手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和 CPU 数据相同的线程数。</p><h2 id="Parallel-回收器：吞吐量优先"><a href="#Parallel-回收器：吞吐量优先" class="headerlink" title="Parallel 回收器：吞吐量优先"></a>Parallel 回收器：吞吐量优先</h2><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<mark>复制算法、并行回收和”Stop the World”机制</mark>。</p><p>那么 Parallel 收集器的出现是否多此一举？</p><ul><li>和 ParNew 收集器不同，ParallelScavenge 收集器的目标则是达到一个<mark>可控制的吞吐量</mark>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<mark>适合在后台运算而不需要太多交互的任务</mark>。因此，常见在服务器环境中使用。<mark>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序</mark>。</p><p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p><p>Parallel Old 收集器采用了<mark>标记-压缩算法</mark>，但同样也是基于<mark>并行回收和”Stop-the-World”机制</mark>。</p><p><img src="/attachment/a3c5a70b43539c39682370ac19f7753c.png"></p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java8 中，默认是此垃圾收集器。</p><p><strong>参数配置</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</p></li><li><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认 jdk8 是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>$$ ParallelGCThreads = \begin{cases} CPU_Count &amp; \text (CPU_Count &lt;= 8) \ 3 + (5 * CPU＿Count / 8) &amp; \text (CPU_Count &gt; 8) \end{cases} $$</p></li><li><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STw 的时间）。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li><li><mark>该参数使用需谨慎</mark>。</li></ul></li><li><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p><ul><li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li><li>与前一个<code>-XX:MaxGCPauseMillis </code>参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li></ul></li><li><p><code>-XX:+UseAdaptivesizePolicy</code> 设置 Parallel Scavenge 收集器具有<mark>自适应调节策略</mark></p><ul><li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li></ul></li></ul><h2 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS 回收器：低延迟"></a>CMS 回收器：低延迟</h2><p>在 JDK1.5 时期，Hotspot 推出了一款在<mark>强交互应用</mark>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<mark>这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</mark>。</p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><ul><li><mark>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</mark>，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li></ul><p>CMS 的垃圾收集算法采用<mark>标记-清除算法</mark>，并且也会”Stop-the-World”</p><p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p><p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p><p><img src="/attachment/f6a3702808f01a4546c69bb66d1feabf.png"></p><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<mark>仅仅只是标记出 GCRoots 能直接关联到的对象</mark>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<mark>速度非常快</mark>。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 GC Roots 的<mark>直接关联对象开始遍历整个对象图的过程</mark>，这个过程耗时较长但是<mark>不需要停顿用户线程</mark>，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<mark>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</mark>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段<mark>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</mark>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管 CMS 收集器采用的是并发回收（非独占式），但是<mark>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</mark>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p><mark>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</mark></p><p>另外，由于在垃圾收集阶段用户线程没有中断，<mark>所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用</mark>。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<mark>当堆内存使用率达到某一阈值时，便开始进行回收</mark>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<mark>产生一些内存碎片</mark>。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><img src="/attachment/4de18ea61f9cb5ba6f5f470dbddebee2.png"></p><p><strong>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact？</strong></p><p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact 更适合“Stop the World” 这种场景下使用</p><h3 id="CMS-的优点"><a href="#CMS-的优点" class="headerlink" title="CMS 的优点"></a>CMS 的优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id="CMS-的弊端"><a href="#CMS-的弊端" class="headerlink" title="CMS 的弊端"></a>CMS 的弊端</h3><ul><li><mark>会产生内存碎片</mark>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC。</li><li><mark>CMS 收集器对 CPU 资源非常敏感</mark>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li><mark>CMS 收集器无法处理浮动垃圾</mark>。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<mark>在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</mark>，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li></ul><h3 id="设置的参数"><a href="#设置的参数" class="headerlink" title="设置的参数"></a>设置的参数</h3><ul><li><p><code>-XX:+UseConcMarkSweepGC </code>手动指定使用 CMS 收集器执行内存回收任务。</p><p>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young 区用）+CMS（Old 区用）+ Serial Old 的组合。</p></li><li><p><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p><ul><li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。<mark>JDK6 及以上版本默认值为 92%</mark></li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Ful1Gc 的执行次数。</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p></li><li><p><code>-XX:ParallelcMSThreads</code> 设置 CMS 的线程数量。</p><ul><li>CMS 默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 Gc 有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选 Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC；</li><li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li></ul><h3 id="JDK-后续版本中-CMS-的变化"><a href="#JDK-后续版本中-CMS-的变化" class="headerlink" title="JDK 后续版本中 CMS 的变化"></a>JDK 后续版本中 CMS 的变化</h3><p>JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p><ul><li>如果对 JDK9 及以上版本的 HotSpot 虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li></ul><p>JDK14 新特性：删除 CMS 垃圾回收器（JEP363）</p><ul><li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM 不会报错，只是给出一个 warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM</li></ul><h2 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h2><p><strong>既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？</strong></p><p>原因就在于应用程序所应对的<mark>业务越来越庞大、复杂，用户越来越多</mark>，没有 GC 就不能保证应用程序正常进行，而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。G1（Garbage-First）垃圾回收器是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在<mark>不断扩大的内存和不断增加的处理器数量</mark>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><mark>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</mark></p><p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p><p>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</p><p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<mark>主要针对配备多核 CPU 及大容量内存的机器</mark>，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在 JDK1.7 版本正式启用，移除了 Experimenta1 的标识，是<mark>JDK9 以后的默认垃圾回收器</mark>，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“<mark>全功能的垃圾收集器</mark>”。</p><p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p><h3 id="G1-回收器的特点（优势）"><a href="#G1-回收器的特点（优势）" class="headerlink" title="G1 回收器的特点（优势）"></a>G1 回收器的特点（优势）</h3><p>与其他 GC 收集器相比，G1 使用了全新的分区算法，其特点如下所示：</p><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul><li>从分代上看，<mark>G1 依然属于分代型垃圾回收器</mark>，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将<mark>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</mark>。</li><li>和之前的各类回收器不同，它同时<mark>兼顾年轻代和老年代</mark>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p><img src="/attachment/e6b9ab412785b9aa670b78a624963251.png"></p><p><img src="/attachment/797257043c7e0977d1b765cbd882a4f5.png"></p><h4 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h4><ul><li>CMS：“标记-清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理</li><li>G1 将内存划分为一个个的 region。内存的回收是以 region 作为基本单位的。<mark>Region 之间是复制算法</mark>，但整体上实际可看作是<mark>标记-压缩（Mark-Compact）算法</mark>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li></ul><h4 id="可预测的停顿时间模型（即：软实时-soft-real-time）"><a href="#可预测的停顿时间模型（即：软实时-soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即：软实时 soft real-time）"></a>可预测的停顿时间模型（即：软实时 soft real-time）</h4><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p><ul><li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于 CMSGC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id="G1-垃圾收集器的缺点"><a href="#G1-垃圾收集器的缺点" class="headerlink" title="G1 垃圾收集器的缺点"></a>G1 垃圾收集器的缺点</h3><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p><p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。</p><h3 id="G1-回收器的参数设置"><a href="#G1-回收器的参数设置" class="headerlink" title="G1 回收器的参数设置"></a>G1 回收器的参数设置</h3><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li><li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）</li><li><code>-XX:+ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8（上面说过 Parallel 回收器的线程计算公式，当 CPU_Count &gt; 8 时，ParallelGCThreads 也会大于 8）</li><li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li></ul><h3 id="G1-收集器的常见操作步骤"><a href="#G1-收集器的常见操作步骤" class="headerlink" title="G1 收集器的常见操作步骤"></a>G1 收集器的常见操作步骤</h3><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启 G1 垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p><h3 id="G1-收集器的适用场景"><a href="#G1-收集器的适用场景" class="headerlink" title="G1 收集器的适用场景"></a>G1 收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p><p>用来替换掉 JDK1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p><ul><li>超过 50%的 Java 堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC 停顿时间过长（长于 0.5 至 1 秒）</li></ul><p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="分区-Region：化整为零"><a href="#分区-Region：化整为零" class="headerlink" title="分区 Region：化整为零"></a>分区 Region：化整为零</h3><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<mark>所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</mark></p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p><p><img src="/attachment/14abfd8f447492d95e3c0cb1e00560c0.png"></p><p>一个 region 有可能属于 Eden，Survivor 或者 Old/Tenured 内存区域。但是一个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 region，就放到 H。</p><p>设置 H 的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。<mark>如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。</mark>为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p><p>每个 Region 都是通过指针碰撞来分配空间</p><p><img src="/attachment/d26be99f80c6d510cdccf31e7859437c.png"></p><h3 id="G1-垃圾回收器的回收过程"><a href="#G1-垃圾回收器的回收过程" class="headerlink" title="G1 垃圾回收器的回收过程"></a>G1 垃圾回收器的回收过程</h3><p>G1GC 的垃圾回收过程主要包括如下三个环节：</p><ul><li><p>年轻代 GC（Young GC）</p></li><li><p>老年代并发标记过程（Concurrent Marking）</p></li><li><p>混合回收（Mixed GC）</p><p>（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</p></li></ul><p><img src="/attachment/1483e7fcd19983cc8e9dcf69b54f58fa.png"></p><p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC 顺序，进行垃圾回收。</p><p>应用程序分配内存，<mark>当年轻代的 Eden 区用尽时开始年轻代回收过程</mark>；G1 的年轻代收集阶段是一个<mark>并行的独占式</mark>收集器。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<mark>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及</mark>。</p><p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，<mark>G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了</mark>。同时，这个老年代 Region 是和年轻代一起被回收的。</p><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h3><ul><li><p>一个对象被不同区域引用的问题</p></li><li><p>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</p></li><li><p>在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？</p></li><li><p>这样的话会降低 MinorGC 的效率；</p></li></ul><p><strong>解决方法：</strong></p><p>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：</p><p><mark>每个 Region 都有一个对应的 Remembered Set；</mark></p><p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p><p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；</p><p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><img src="/attachment/910415c86ef3dcc290375fb4f3c0d32e.png"></p><h3 id="G1-回收过程一：年轻代-GC"><a href="#G1-回收过程一：年轻代-GC" class="headerlink" title="G1 回收过程一：年轻代 GC"></a>G1 回收过程一：年轻代 GC</h3><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p><p>首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p><p><img src="/attachment/8ca1e0fede96335aebcb045326cf4c58.png"></p><p>然后开始如下回收过程：</p><ol><li><mark>第一阶段，扫描根</mark>。根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</li><li><mark>第二阶段，更新 RSet</mark>。处理 dirty card queue（见备注）中的 card，更新 RSet。此阶段完成后，<mark>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</mark>。</li><li><mark>第三阶段，处理 RSet</mark>。识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li><li><mark>第四阶段，复制对象</mark>。此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</li><li><mark>第五阶段，处理引用</mark>。处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ol><h3 id="G1-回收过程二：并发标记过程"><a href="#G1-回收过程二：并发标记过程" class="headerlink" title="G1 回收过程二：并发标记过程"></a>G1 回收过程二：并发标记过程</h3><ol><li><mark>初始标记阶段</mark>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li><li><mark>根区域扫描（Root Region Scanning）</mark>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 YoungGC 之前完成。</li><li><mark>并发标记（Concurrent Marking）</mark>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 YoungGC 中断。在并发标记阶段，<mark>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</mark>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><mark>再次标记（Remark）</mark>：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li><mark>独占清理（cleanup，STW）</mark>：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集</li><li><mark>并发清理阶段</mark>：识别并清理完全空闲的区域。</li></ol><h3 id="G1-回收过程三：混合回收"><a href="#G1-回收过程三：混合回收" class="headerlink" title="G1 回收过程三：混合回收"></a>G1 回收过程三：混合回收</h3><p>当越来越多的对象晋升到老年代 o1d region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：<mark>是一部分老年代，而不是全部老年代</mark>。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p><p><img src="/attachment/0f34edd20358a9d7972961780274bccf.png"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行 8 次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p><h3 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h3><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如<mark>堆内存太小</mark>，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p><p>导致 G1 Full GC 的原因可能有两个：</p><ul><li>Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而<mark>选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中</mark>。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><h3 id="G1-回收器优化建议"><a href="#G1-回收器优化建议" class="headerlink" title="G1 回收器优化建议"></a>G1 回收器优化建议</h3><p>年轻代大小</p><ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标</li></ul><p>暂停时间目标不要太过严苛</p><ul><li>G1 GC 的吞吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li><li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><h3 id="7-种经典垃圾回收器总结"><a href="#7-种经典垃圾回收器总结" class="headerlink" title="7 种经典垃圾回收器总结"></a>7 种经典垃圾回收器总结</h3><p>截止 JDK1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><table><thead><tr><th align="left">垃圾收集器</th><th align="left">分类</th><th align="left">作用位置</th><th align="left">使用算法</th><th align="left">特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">Serial</td><td align="left">串行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">适用于单 CPU 环境下的 client 模式</td></tr><tr><td align="left">ParNew</td><td align="left">并行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">多 CPU 环境 Server 模式下与 CMS 配合使用</td></tr><tr><td align="left">Parallel</td><td align="left">并行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">吞吐量优先</td><td align="left">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="left">Serial Old</td><td align="left">串行运行</td><td align="left">作用于老年代</td><td align="left">标记-压缩算法</td><td align="left">响应速度优先</td><td align="left">适用于单 CPU 环境下的 Client 模式</td></tr><tr><td align="left">Parallel Old</td><td align="left">并行运行</td><td align="left">作用于老年代</td><td align="left">标记-压缩算法</td><td align="left">吞吐量优先</td><td align="left">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="left">CMS</td><td align="left">并发运行</td><td align="left">作用于老年代</td><td align="left">标记-清除算法</td><td align="left">响应速度优先</td><td align="left">适用于互联网或 B／S 业务</td></tr><tr><td align="left">G1</td><td align="left">并发、并行运行</td><td align="left">作用于新生代、老年代</td><td align="left">标记-压缩算法、复制算法</td><td align="left">响应速度优先</td><td align="left">面向服务端应用</td></tr></tbody></table><p>GC 发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><h3 id="垃圾回收器组合"><a href="#垃圾回收器组合" class="headerlink" title="垃圾回收器组合"></a>垃圾回收器组合</h3><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7/8 后所有收集器及组合如下图</p><p><img src="/attachment/0c039ef86bc3a84ae2fba0fb382852ce.png"></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</li><li>其中 Serial Old 作为 CMS 出现＂<code>Concurrent Mode Failure</code>＂失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial ＋ CMS、ParNew ＋ Serial old 这两个组合声明为 Deprecated（JEP 173），并在 JDK 9 中<br>完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK 14 中：弃用 ParallelScavenge 和 SeriaOold GC 组合(JEP 366)</li><li>（绿色虚框）JDK 14 中：删除 CMS 垃圾回收器（JEP 363）</li></ol><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p><p>怎么选择垃圾收集器？</p><ol><li>优先调整堆的大小让 JVM 自适应完成。</li><li>如果内存小于 100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</li><li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器<br>官方推荐 G1，性能高。<mark>现在互联网的项目，基本都是使用 G1</mark>。</li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><p><strong>面试</strong></p><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p><ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>垃圾收集器工作的基本流程。<br>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li></ul><h2 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h2><p>通过阅读 Gc 日志，我们可以了解 Java 虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p><ul><li><code>-XX:+PrintGC</code> 输出 GC 日志。类似：<code>-verbose:gc</code></li><li><code>-XX:+PrintGCDetails</code> 输出 GC 的详细日志</li><li><code>-XX:+PrintGCTimestamps</code> 输出 GC 的时间戳（以基准时间的形式）</li><li><code>-XX:+PrintGCDatestamps</code> 输出 GcC 的时间戳（以日期的形式，如 2013-05-04T21：53：59.234+0800）</li><li><code>-XX:+PrintHeapAtGC</code> 在进行 GC 的前后打印出堆的信息</li><li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li></ul><p>打开 GC 日志</p><pre><code class="line-numbers language-shell">-verbose:gc</code></pre><p>这个只会显示总的 GC 堆的变化，如下：</p><pre><code class="line-numbers language-java">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),0.0084018 secs][GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),0.0184066 secs][Full GC (Metadata GC Threshold) 21465K-&gt;16716K(201728K),0.0619261 secs]</code></pre><p>参数解析</p><pre><code class="line-numbers language-java">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。Allocation Failure：GC发生的原因。80832K-&gt;19298K：堆在GC前的大小和GC后的大小。228840k：现在的堆大小。0.0084018 secs：GC持续的时间。</code></pre><p>打开 GC 日志</p><pre><code class="line-numbers language-shell">-verbose:gc -XX:+PrintGCDetails</code></pre><p>输入信息如下</p><pre><code class="line-numbers language-java">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),0.0172573 secs] [Times:user=0.03 sys=0.00,real=0.02 secs][GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),0.0151573 secs] [Times:user=0.00 sys=0.01,real=0.02 secs][Full GC (Metadata GC Threshold)[PSYoungGen:8154K-&gt;0K(142336K)][ParOldGen:13107K-&gt;16809K(62464K)] 21261K-&gt;16809K(204800K),[Metaspace:20599K-&gt;20599K(1067008K)],0.0639732 secs][Times:user=0.14 sys=0.00,real=0.06 secs]</code></pre><p>参数解析</p><pre><code class="line-numbers language-java">GC，Full FC：同样是GC的类型Allocation Failure：GC原因PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化Metaspace： 元数据区GC前后大小的变化，JDK1.8中引入了元数据区以替代永久代xxx secs：指GC花费的时间Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</code></pre><p>打开 GC 日志</p><pre><code class="line-numbers language-shell">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps</code></pre><p>输入信息如下</p><pre><code class="line-numbers language-java">2019-09-24T22:15:24.518+0800: 3.287: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),0.0248249 secs] [Times:user=0.05 sys=0.00,real=0.03 secs]2019-09-24T22:15:25.559+0800: 4.329: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),0.0094071 secs] [Times: user=0.00 sys=0.00,real=0.01 secs]2019-09-24T22:15:25.569+0800: 4.338: [Full GC (Metadata GC Threshold) [PSYoungGen:10068K-&gt;0K(274944K)][ParoldGen:12590K-&gt;13564K(56320K)] 22658K-&gt;13564K(331264K),[Metaspace:20590K-&gt;20590K(1067008K)],0.0494875 secs] [Times: user=0.17 sys=0.02,real=0.05 secs]</code></pre><p>说明：带上了日期和实践</p><p>如果想把 GC 日志存到文件的话，是下面的参数：</p><pre><code class="line-numbers language-shell">-Xloggc:/path/to/gc.log</code></pre><p><strong>日志补充说明</strong></p><ul><li><p>“<code>[GC</code>“和”<code>[Full GC</code>“说明了这次垃圾收集的停顿类型，如果有”Full”则说明 GC 发生了”Stop The World”</p></li><li><p>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是”<code>[DefNew</code>“</p></li><li><p>使用 ParNew 收集器在新生代的名字会变成”<code>[ParNew</code>“，意思是”Parallel New Generation”</p></li><li><p>使用 Parallel scavenge 收集器在新生代的名字是”<code>[PSYoungGen</code>“</p></li><li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p></li><li><p>使用 G1 收集器的话，会显示为”garbage-first heap”</p></li><li><p><mark>Allocation Failure</mark></p><p>表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p></li><li><p><mark>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)</mark></p><p>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）</p><p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p></li><li><p><mark>user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时</mark>。由于多核的原因，时间总和可能会超过 real 时间</p></li></ul><pre><code class="line-numbers language-java">Heap（堆）PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [0x00000000ff600000,0x0000000100000000,0x0000000100000000)eden space（堆中的Eden区默认占比是8）8192K，768 used [0x00000000ff600000,0x00000000ffc16b08,0x00000000ffe00000)from space（堆中的Survivor，这里是From Survivor区默认占比是1）1024K， 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)to space（堆中的Survivor，这里是to Survivor区默认占比是1，需要先了解一下堆的分配策略）1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［0x00000000fec00000,0x00000000ff600000,0x00000000ff600000)object space（显示个使用百分比）10240K，688 used [0x00000000fec00000,0x00000000ff2d6630,0x00000000ff600000)PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [0x00000000f9a00000,0x00000000faf00000,0x00000000fec00000)object space（显示个使用百分比，自己能算出来）21504K， 238 used [0x00000000f9a00000,0x00000000f9ed55e0,0x00000000faf00000)</code></pre><h3 id="Minor-GC-日志"><a href="#Minor-GC-日志" class="headerlink" title="Minor GC 日志"></a>Minor GC 日志</h3><p><img src="/attachment/45698c667f057bea2e72553d4374d719.png"></p><h3 id="Full-GC-日志"><a href="#Full-GC-日志" class="headerlink" title="Full GC 日志"></a>Full GC 日志</h3><p><img src="/attachment/bce2dee15c83bf9ad2ac970837a3c02a.png"></p><p><strong>举例</strong></p><pre><code class="line-numbers language-java">private static final int _1MB = 1024 * 1024;public static void testAllocation() {    byte [] allocation1, allocation2, allocation3, allocation4;    allocation1 = new byte[2 *_1MB];    allocation2 = new byte[2 *_1MB];    allocation3 = new byte[2 *_1MB];    allocation4 = new byte[4 *_1MB];}public static void main(String[] args) {    testAllocation();}</code></pre><p>设置 JVM 参数</p><pre><code class="line-numbers language-shell">-Xms10m -Xmx10m -XX:+PrintGCDetails</code></pre><p><strong>图示</strong></p><p><img src="/attachment/c6537670e19fcf6cf63bef05615c2d12.png"></p><p><img src="/attachment/c3314416c2ac174b0f6cac665fe158af.png"></p><p>可以用一些工具去分析这些 GC 日志</p><p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><p>GC 仍然处于飞速发展之中，目前的默认选项<mark>G1 GC 在不断的进行改进</mark>，很多我们原来认为的缺点，例如串行的 Fu11GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Fu11GC 已经是并行运行，在很多场景下，其表现还略优于 ParallelGC 的并行 Ful1GC 实现。</p><p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<mark>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台</mark>。</p><p>比较不幸的是 CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK9 中已经被标记为废弃，并在 JDK14 版本中移除</p><h3 id="JDK11-新特性"><a href="#JDK11-新特性" class="headerlink" title="JDK11 新特性"></a>JDK11 新特性</h3><p>Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/318</a></p><p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）<a href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/333</a></p><p><img src="/attachment/0b57cdbbb2c37b5886b13c92867bffd5.png"></p><p>现在 G1 回收器已成为默认回收器好几年了。</p><p>我们还看到了引入了两个新的收集器：ZGC（JDK11 出现）和 Shenandoah（Open JDK12）。主打特点：低停顿时间</p><h3 id="Open-JDK12-的-Shenandoash-GC"><a href="#Open-JDK12-的-Shenandoash-GC" class="headerlink" title="Open JDK12 的 Shenandoash GC"></a>Open JDK12 的 Shenandoash GC</h3><p><mark>Open JDK12 的 Shenandoash GC：低停顿时间的 GC（实验性）</mark></p><p><mark>Shenandoah，无疑是众多 GC 中最孤独的一个。</mark>是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的<mark>受到官方的排挤</mark>。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 OracleJDK12 中支持 Shenandoah。</p><p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，<mark>旨在针对 JVM 上的内存回收实现低停顿的需求</mark>.。在 2014 年贡献给 OpenJDK。</p><p>Red Hat 研发 Shenandoah 团队对外宣称，<mark>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。</mark>不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src="/attachment/ed751670891ca30482443ed527b5c29d.png"></p><p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 Es 对 200GB 的维基百科数据进行索引。从结果看：</p><ul><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ul><p>总结</p><ul><li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC 的强项：低延迟时间。</li><li>Shenandoah GC 的工作过程大致分为九个阶段，这里就不再赘述。在之前 Java12 新特性视频里有过介绍。</li></ul><p>【Java12 新特性地址】</p><p><a href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v=222</a></p><p>或</p><p><a href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866</a></p><h3 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h3><p>官方地址：[<a href="https://docs.oracle.com/en/java/javase/12/gctuning/]">https://docs.oracle.com/en/java/javase/12/gctuning/]</a>(</p><p><img src="/attachment/716e8ed06cb9f0c2b591960bbe4b21dc.png"></p><p>ZGC 与 Shenandoah 目标高度相似，<mark>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</mark></p><p>《深入理解 Java 虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<mark>可并发的标记-压缩算法</mark>的，以<mark>低延迟为首要目标</mark>的一款垃圾收集器。</p><p>ZGC 的工作过程可以分为 4 个阶段：<mark>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</mark> 等。</p><p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STw 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p>测试数据：</p><p><img src="/attachment/02cf299c111f88749f879f58e754e0b6.png"></p><p><img src="/attachment/c8f51184d552319d17988e999a3503a6.png"></p><p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p><p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 <mark>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</mark></p><p><img src="/attachment/a2787e840130f9b978de53c8e5b55edd.png"></p><p><mark>JEP 364：ZGC 应用在 macos 上</mark></p><p><mark>JEP 365：ZGC 应用在 Windows 上</mark></p><p>JDK14 之前，ZGC 仅 Linux 才支持。</p><p>尽管许多使用 zGc 的用户都使用类 Linux 的环境，但在 Windows 和 macos 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macos 上。</p><p>现在 mac 或 Windows 上也能使用 zGC 了，示例如下：</p><pre><code class="line-numbers language-shell">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></pre><h3 id="其他垃圾回收器：AliGC"><a href="#其他垃圾回收器：AliGC" class="headerlink" title="其他垃圾回收器：AliGC"></a>其他垃圾回收器：AliGC</h3><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="/attachment/82189c2258b4c09233a92f32393a5108.png"></p><p>当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC：Zing，有兴趣可以参考提供的链接 <a href="https://www.infoq.com/articles/azul_gc_in_detail">https://www.infoq.com/articles/azul_gc_in_detail</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 垃圾回收相关概念</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-la-ji-shou-ji/java-jvm-la-ji-hui-shou-xiang-guan-gai-nian/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-la-ji-shou-ji/java-jvm-la-ji-hui-shou-xiang-guan-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-垃圾回收相关概念"><a href="#【Java-JVM】-垃圾回收相关概念" class="headerlink" title="【Java JVM】 垃圾回收相关概念"></a>【Java JVM】 垃圾回收相关概念</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 垃圾回收相关概念date: 2023-06-29 11:29tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 垃圾回收相关概念</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>System.gc()</strong></p><p>会显式触发 Full GC</p><p><strong>内存溢出（OOM）</strong></p><ol><li>Java 虚拟机的堆内存设置不够。</li><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li></ol><p><strong>内存泄漏（Memory Leak）</strong></p><p>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏</p><p><strong>Stop The World</strong></p><p>GC 事件发生过程中，会产生应用程序的停顿。</p><p><strong>垃圾回收的并行与并发</strong></p><ul><li>并发（Concurrent）<ul><li>CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换</li></ul></li><li>并行（Parallel）<ul><li>两个进程互不抢占 CPU 资源，可以同时进行</li></ul></li></ul><p><strong>安全点</strong></p><p>特定的位置才能停顿下来开始 GC<br>主动式中断</p><p><strong>安全区域（Safe Resion）</strong></p><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 Gc 都是安全的。</p><p><strong>引用类型</strong></p><ul><li><mark>强引用（StrongReference）</mark>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>Object obj = new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><mark>软引用（SoftReference）</mark>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li><mark>弱引用（WeakReference）</mark>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li><mark>虚引用（PhantomReference）</mark>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h2 id="【Java-JVM】-垃圾回收相关概念-1"><a href="#【Java-JVM】-垃圾回收相关概念-1" class="headerlink" title="【Java JVM】 垃圾回收相关概念"></a>【Java JVM】 垃圾回收相关概念</h2><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h2><p>在默认情况下，通过 system.gc()或者 Runtime.getRuntime().gc() 的调用，<mark>会显式触发 Full GC</mark>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p><p>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，<mark>无须手动触发，否则就太过于麻烦了</mark>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</p><pre><code class="line-numbers language-java">public class SystemGCTest {    public static void main(String[] args) {        new SystemGCTest();        System.gc();// 提醒JVM的垃圾回收器执行gc，但是不确定是否马上执行gc        // 与Runtime.getRuntime().gc();的作用一样        System.runFinalization();//强制执行使用引用的对象的finalize()方法    }    @Override    protected void finalize() throws Throwable {        super.finalize();        System.out.println("SystemGCTest 重写了finalize()");    }}</code></pre><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 ooM 的情况。</p><p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>javadoc 中对 OutOfMemoryError 的解释是，<mark>没有空闲内存，并且垃圾收集器也无法提供更多内存</mark>。</p><p>首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p><ol><li><p><mark>Java 虚拟机的堆内存设置不够。</mark></p><p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code> 、<code>-Xmx</code>来调整。</p></li><li><p><mark>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</mark></p><p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“<code>java.lang.OutOfMemoryError: PermGen space</code>“。</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 ooM 有所改观，出现 OOM，异常信息则变成了：“<code>java.lang.OutofMemoryError:Metaspace</code>“。直接内存不足，也会导致 OOM。</p></li></ol><p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li><li>在<code>java.nio.BIts.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</li></ul><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</li></ul><h3 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h3><p>也称作“存储渗漏”。严格来说，<mark>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏</mark>。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 00M，也可以叫做<mark>宽泛意义上的“内存泄漏”</mark>。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><p><img src="/attachment/c9d8e14f833a6fdffa3891d90fc1d6c0.png"></p><p><strong>举例</strong></p><ol><li>单例模式</li></ol><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p><ol start="2"><li>一些提供 close 的资源未关闭导致内存泄漏</li></ol><p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</p><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>Stop-the-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。<mark>停顿产生时整个应用程序线程都会被暂停，没有任何响应</mark>，有点像卡死的感觉，这个停顿称为 STW。</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><mark>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</mark></li></ul><p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p><p>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</p><p>哪怕是 G1 也不能完全避免 Stop-the-World 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW 是 JVM 在<mark>后台自动发起和自动完成</mark>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用 System.gc() 会导致 Stop-the-World 的发生。</p><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p><p>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><p><img src="/attachment/048dfd43bd512c17f820c84fdbfba1e3.png"></p><h3 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h3><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占 CPU 资源，可以同时进行，我们称之为并行（Parallel）。</p><p>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景</p><p><img src="/attachment/a9eb67d5b607f6803cea4cdb2ec16d19.png"></p><h3 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h3><ul><li><p>并发，指的是多个事情，在<mark>同一时间段内</mark>同时发生了。</p></li><li><p>并行，指的是多个事情，在<mark>同一时间点上</mark>同时发生了。</p></li><li><p>并发的多个任务之间是互相抢占资源的。</p></li><li><p>并行的多个任务之间是不互相抢占资源的。</p></li><li><p>只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。</p></li><li><p>否则，看似同时发生的事情，其实都是并发执行的。</p></li></ul><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><h4 id="并行（Parallel）-1"><a href="#并行（Parallel）-1" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h4><p>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如 ParNew、Parallel Scavenge、Parallel Old；</p><h4 id="串行（Serial）"><a href="#串行（Serial）" class="headerlink" title="串行（Serial）"></a>串行（Serial）</h4><p>相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动 JM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p><p><img src="/attachment/4b6a2f1177b0165aba9a69b3a408d19a.png"></p><h4 id="并发（Concurrent）-1"><a href="#并发（Concurrent）-1" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h4><p>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个 CPU 上；如：CMS、G1</p><p><img src="/attachment/681c734a22fc6d01731d3c36c640a6ef.png"></p><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点（Safepoint）”。</p><p>Safe Point 的选择很重要，<mark>如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题</mark>。大部分指令的执行时间都非常短暂，通常会根据“<mark>是否具有让程序长时间执行的特征</mark>”为标准。比如：选择一些执行时间较长的指令作为 Safe Point，如<mark>方法调用、循环跳转和异常跳转等</mark>。</p><p>如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><h4 id="抢先式中断：（目前没有虚拟机采用了）"><a href="#抢先式中断：（目前没有虚拟机采用了）" class="headerlink" title="抢先式中断：（目前没有虚拟机采用了）"></a>抢先式中断：（目前没有虚拟机采用了）</h4><ul><li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li></ul><h4 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h4><p>设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</p><h3 id="安全区域（Safe-Resion）"><a href="#安全区域（Safe-Resion）" class="headerlink" title="安全区域（Safe Resion）"></a>安全区域（Safe Resion）</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p><mark>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 Gc 都是安全的。</mark>我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p><h3 id="实际执行时："><a href="#实际执行时：" class="headerlink" title="实际执行时："></a>实际执行时：</h3><ol><li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Relgion，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</li><li>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止；</li></ol><h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既<mark>偏门</mark>又非常<mark>高频</mark>的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p><p>在 JDK1.2 版之后，Java 对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这 4 种引用强度依次逐渐减弱。</p><p>除强引用外，其他 3 种引用均可以在 java.lang.ref 包中找到它们的身影。如下图，显示了这 3 种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p><img src="/attachment/226fadfbd2958fe5624e5297da3fa469.png"></p><p>Reference 子类中只有终结器引用是包内可见的，其他 3 种引用类型均为 public，可以在应用程序中直接使用</p><ul><li><mark>强引用（StrongReference）</mark>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>Object obj = new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><mark>软引用（SoftReference）</mark>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li><mark>弱引用（WeakReference）</mark>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li><mark>虚引用（PhantomReference）</mark>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h3 id="强引用（Strong-Reference）——不回收"><a href="#强引用（Strong-Reference）——不回收" class="headerlink" title="强引用（Strong Reference）——不回收"></a>强引用（Strong Reference）——不回收</h3><p>在 Java 程序中，最常见的引用类型是强引用（<mark>普通系统 99%以上都是强引用</mark>），也就是我们最常见的普通对象引用，<mark>也是默认的引用类型</mark>。</p><p>当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p><mark>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</mark></p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<mark>强引用是造成 Java 内存泄漏的主要原因之一</mark>。</p><p><strong>强引用例子</strong></p><pre><code class="line-numbers language-java">StringBuffer str = new StringBuffer("hello mogublog");</code></pre><p>局部变量 str 指向 StringBuffer 实例所在堆空间，通过 str 可以操作该实例，那么 str 就是 StringBuffer 实例的强引用</p><p><strong>对应内存结构</strong></p><p><img src="/attachment/52549e044280aee69d0fded731915212.png"></p><p>此时，如果再运行一个赋值语句</p><pre><code class="line-numbers language-java">StringBuffer str1 = str;</code></pre><p><strong>对应的内存结构</strong></p><p><img src="/attachment/fcd341a4f7ad8e75bfff3432a98bfe84.png"></p><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h2 id="再谈引用：-软引用"><a href="#再谈引用：-软引用" class="headerlink" title="再谈引用： 软引用"></a>再谈引用： 软引用</h2><h3 id="软引用（Soft-Reference）——内存不足即回收"><a href="#软引用（Soft-Reference）——内存不足即回收" class="headerlink" title="软引用（Soft Reference）——内存不足即回收"></a>软引用（Soft Reference）——内存不足即回收</h3><p>软引用是用来描述一些还有用，但非必需的对象。<mark>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</mark>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>软引用通常用来实现内存敏感的缓存。比如：<mark>高速缓存</mark>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p><p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><p>在 JDK1.2 版之后提供了 java.lang.ref.SoftReference 类来实现软引用</p><pre><code class="line-numbers language-java">Object obj = new Object(); // 声明强引用SoftReference&lt;Object&gt; sf = new SoftReference&lt;&gt;(obj);obj = null; //销毁强引用</code></pre><h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><h3 id="弱引用（Weak-Reference）——发现即回收"><a href="#弱引用（Weak-Reference）——发现即回收" class="headerlink" title="弱引用（Weak Reference）——发现即回收"></a>弱引用（Weak Reference）——发现即回收</h3><p>弱引用也是用来描述那些非必需对象，<mark>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</mark>。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<mark>弱引用对象可以存在较长的时间</mark>。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p><mark>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</mark>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><p>在 JDK1.2 版之后提供了 WeakReference 类来实现弱引用</p><pre><code class="line-numbers language-java">Object obj = new Object(); // 声明强引用WeakReference&lt;Object&gt; sf = new WeakReference&lt;&gt;(obj);obj = null; //销毁强引用</code></pre><p><mark>弱引用对象与软引用对象的最大不同</mark>就在于，当 GC 在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC 总是进行回收。<mark>弱引用对象更容易、更快被 GC 回收</mark>。</p><p><strong>面试题：你开发中使用过 WeakHashMap 吗？</strong></p><p>WeakHashMap 用来存储图片信息，可以在内存不足的时候，及时回收，避免了 OOM</p><h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><h3 id="虚引用（Phantom-Reference）——对象回收跟踪"><a href="#虚引用（Phantom-Reference）——对象回收跟踪" class="headerlink" title="虚引用（Phantom Reference）——对象回收跟踪"></a>虚引用（Phantom Reference）——对象回收跟踪</h3><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get()方法取得对象时，总是 null</p><p><mark>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</mark></p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p><mark>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</mark></p><p>在 JDK1.2 版之后提供了 PhantomReference 类来实现虚引用。</p><pre><code class="line-numbers language-java">Object obj = new Object(); // 声明强引用ReferenceQueue phantomQueue = new ReferenceQueue();PhantomReference&lt;Object&gt; sf = new PhantomReference&lt;&gt;(obj, phantomQueue);obj = null;</code></pre><h2 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h2><p>它用于实现对象的 finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p><p>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象调用它的 finalize()方法，第二次 GC 时才回收被引用的对象</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 垃圾回收概述及算法</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-la-ji-shou-ji/java-jvm-la-ji-hui-shou-gai-shu-ji-suan-fa/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-la-ji-shou-ji/java-jvm-la-ji-hui-shou-gai-shu-ji-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-垃圾回收概述及算法"><a href="#【Java-JVM】-垃圾回收概述及算法" class="headerlink" title="【Java JVM】 垃圾回收概述及算法"></a>【Java JVM】 垃圾回收概述及算法</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 垃圾回收概述及算法date: 2023-06-29 11:15tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 垃圾回收概述及算法</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/1897e07ed60519836df9be6a83591095.png"></p><p><mark>Java 堆是垃圾收集器的工作重点</mark></p><p>从次数上讲：</p><ul><li><mark>频繁收集 Young 区</mark></li><li><mark>较少收集 Old 区</mark></li><li><mark>基本不收集 Perm 区（元空间）</mark></li></ul><p><strong>垃圾回收相关算法</strong></p><p>引用计数算法<br>可达性分析算法</p><p><strong>在 Java 语言中，GC Roots 包括以下几类元素：</strong></p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象</li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用。<ul><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li>反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><p><strong>定义虚拟机中的对象可能的三种状态</strong></p><ul><li><mark>可触及的</mark>：从根节点开始，可以到达这个对象。</li><li><mark>可复活的</mark>：对象的所有引用都被释放，但是对象有可能在 finalize()中复活。</li><li><mark>不可触及的</mark>：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<mark>finalize()只会被调用一次</mark>。</li></ul><p><strong>标记-清除算法</strong></p><p><img src="/attachment/9c66f66a1597af353ca2f4216372db31.png"></p><p><strong>标记-复制算法</strong></p><p><img src="/attachment/2ecba1e7edc81e0ecbbd160d756a3134.png"></p><p><strong>标记-压缩（整理）算法</strong></p><p><img src="/attachment/6d2cce503c46869e14fc415ce9d0c210.png"></p><table><thead><tr><th align="left"></th><th align="left">Mark-Sweep</th><th align="left">Mark-Compact</th><th align="left">Copying</th></tr></thead><tbody><tr><td align="left"><strong>速率</strong></td><td align="left">中等</td><td align="left">最慢</td><td align="left">最快</td></tr><tr><td align="left"><strong>空间开销</strong></td><td align="left">少（但会堆积碎片）</td><td align="left">少（不堆积碎片）</td><td align="left">通常需要活对象的 2 倍空间（不堆积碎片）</td></tr><tr><td align="left"><strong>移动对象</strong></td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr></tbody></table><p><strong>分区算法</strong></p><p><img src="/attachment/6f988c2524fca2f8f977ce858646318b.png"></p><h2 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h2><h3 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p><img src="/attachment/56b24bceb0ef0a6e014044ecb7829639.png"></p><p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p><p>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>垃圾收集机制是 Java 的招牌能力，<mark>极大地提高了开发效率</mark>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><p><strong>大厂面试题</strong></p><blockquote><p><mark>蚂蚁金服</mark></p><ul><li><p>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms 和 G1？</p></li><li><p>JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法？</p></li><li><p>G1 回收器讲下回收过程 GC 是什么？为什么要有 GC？</p></li><li><p>GC 的两种判定方法？CMS 收集器与 G1 收集器的特点</p></li></ul><p><mark>百度</mark></p><ul><li><p>说一下 GC 算法，分代回收说下</p></li><li><p>垃圾收集策略和算法</p></li></ul><p><mark>天猫</mark></p><ul><li><p>JVM GC 原理，JVM 怎么回收内存</p></li><li><p>CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</p></li></ul><p><mark>滴滴</mark></p><ul><li>Java 的垃圾回收器都有哪些，说下 g1 的应用场景，平时你是如何搭配使用垃圾回收器的</li></ul><p><mark>京东</mark></p><ul><li><p>你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，</p></li><li><p>包括原理，流程，优缺点。垃圾回收算法的实现原理</p></li></ul><p><mark>阿里</mark></p><ul><li><p>讲一讲垃圾回收算法。</p></li><li><p>什么情况下触发垃圾回收？</p></li><li><p>如何选择合适的垃圾收集算法？</p></li><li><p>JVM 有哪三种垃圾回收器？</p></li></ul><p><mark>字节跳动</mark></p><ul><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>System.gc（）和 Runtime.gc（）会做什么事情？</li><li>Java GC 机制？GC Roots 有哪些？</li><li>Java 对象的回收方式，回收算法。</li><li>CMS 和 G1 了解么，CMS 解决什么问题，说一下回收的过程。</li><li>CMS 回收停顿了几次，为什么要停顿两次?</li></ul></blockquote><h4 id="什么是垃圾？-1"><a href="#什么是垃圾？-1" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h4><blockquote><p>An object is considered garbage when it can no longer be reached from any pointer in the running program</p></blockquote><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p><p><strong>磁盘碎片整理的日子</strong></p><p>机械硬盘需要进行磁盘整理，同时还有坏道</p><p><img src="/attachment/07648e46d44a82d819525cc995077f17.png"></p><h2 id="为什么需要-GC"><a href="#为什么需要-GC" class="headerlink" title="为什么需要 GC"></a>为什么需要 GC</h2><p><strong>想要学习 GC，首先需要理解为什么需要 GC？</strong></p><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<mark>内存迟早都会被消耗完</mark>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<mark>JVM 将整理出的内存分配给新的对象</mark>。</p><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<mark>没有 GC 就不能保证应用程序的正常进行</mark>。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>在早期的 C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码：</p><pre><code class="line-numbers language-c++">MibBridge *pBridge= new cmBaseGroupBridge();//如果注册失败，使用Delete释放该对象所占内存区域if (pBridge-&gt;Register(kDestroy) != NO ERROR）    delete pBridge;</code></pre><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<mark>频繁申请和释放内存的管理负担</mark>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<mark>内存泄漏</mark>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<mark>应用程序崩溃</mark>。</p><p>在有了垃圾回收机制后，上述代码极有可能变成这样</p><pre><code class="line-numbers language-c++">MibBridge *pBridge = new cmBaseGroupBridge();pBridge-&gt;Register(kDestroy);</code></pre><p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p><h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<mark>降低内存泄漏和内存溢出的风险</mark></p><ul><li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地<mark>专注于业务开发</mark></p><p>oracle 官网关于垃圾回收的介绍 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p><h4 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h4><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<mark>弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力</mark>。</p><p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 outofMemoryError 时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<mark>实施必要的监控和调节</mark>。</p><h4 id="GC-主要关注的区域"><a href="#GC-主要关注的区域" class="headerlink" title="GC 主要关注的区域"></a>GC 主要关注的区域</h4><p>GC 主要关注于 方法区 和堆中的垃圾收集</p><p><img src="/attachment/1897e07ed60519836df9be6a83591095.png"></p><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。其中，<mark>Java 堆是垃圾收集器的工作重点</mark></p><p>从次数上讲：</p><ul><li><mark>频繁收集 Young 区</mark></li><li><mark>较少收集 Old 区</mark></li><li><mark>基本不收集 Perm 区（元空间）</mark></li></ul><h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><p><strong>对象存活判断</strong></p><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<mark>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</mark>。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<mark>垃圾标记阶段</mark>。</p><p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<mark>引用计数算法</mark>和<mark>可达性分析算法</mark>。</p><h3 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h3><h4 id="方式一：引用计数算法"><a href="#方式一：引用计数算法" class="headerlink" title="方式一：引用计数算法"></a>方式一：引用计数算法</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<mark>引用计数器属性。用于记录对象被引用的情况。</mark></p><p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</p><p>优点：<mark>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</mark></p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<mark>存储空间的开销</mark>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<mark>时间开销</mark>。</li><li>引用计数器有一个严重的问题，即<mark>无法处理循环引用</mark>的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li></ul><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>当 p 的指针断开的时候，内部的引用形成一个循环，这就是循环引用</p><p><img src="/attachment/c8746e307a8431a009bb260f0947d668.png"></p><p><strong>举例</strong></p><p>测试 Java 中是否采用的是引用计数算法</p><pre><code class="line-numbers language-java">public class RefCountGC {    // 这个成员属性的唯一作用就是占用一点内存    private byte[] bigSize = new byte[5*1024*1024];    // 引用    Object reference = null;    public static void main(String[] args) {        RefCountGC obj1 = new RefCountGC();        RefCountGC obj2 = new RefCountGC();        obj1.reference = obj2;        obj2.reference = obj1;        obj1 = null;        obj2 = null;        // 显示的执行垃圾收集行为        // 这里发生GC，obj1和obj2是否被回收？        System.gc();    }}// 运行结果PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</code></pre><p>上述进行了 GC 收集的行为，所以可以证明 JVM 中采用的不是引用计数器的算法</p><p><img src="/attachment/df753aa61d8f85f7e6b78268300071b7.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p><p>Python 如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li></ul><h3 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h3><h4 id="可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>可达性分析算法（根搜索算法、追踪性垃圾收集）</h4><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<mark>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</mark>。</p><p>相较于引用计数算法，这里的可达性分析就是 Java、C#选择的。这种类型的垃圾收集通常也叫作<mark>追踪性垃圾收集（Tracing Garbage Collection）</mark></p><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<mark>搜索被根对象集合所连接的目标对象是否可达</mark>。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<mark>引用链（Reference Chain）</mark></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><img src="/attachment/2cd5c01dddcffe565640a089aa988e0e.png"></p><p><strong>在 Java 语言中，GC Roots 包括以下几类元素：</strong></p><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java 类的引用类型静态变量</li><li>方法区中常量引用的对象- 比如：字符串常量池（String Table）里的引用</li></ul></li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用。<ul><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li>反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><p><img src="/attachment/f02089c0ea5475396815ae9bec593b1a.png"></p><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（PartialGC）。</p><p>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GCRoots 集合中去考虑，才能保证可达性分析的准确性。</p><p>小技巧：由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p><p><strong>注意</strong></p><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致 GC 进行时必须“stop The World”的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。</li></ul><h3 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h3><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供<mark>对象被销毁之前的自定义处理逻辑</mark>。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize()方法。</p><p>finalize() 方法允许在子类中被重写，<mark>用于在对象被回收时进行资源释放</mark>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><p>永远不要主动调用某个对象的 finalize()方法 I 应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在 finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize()方法将没有执行机会。</li><li>一个糟糕的 finalize()会严重影响 Gc 的性能。</li></ul><p>从功能上来说，finalize()方法与 C++中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize()方法在本质上不同于 C++中的析构函数。</p><p>由于 finalize()方法的存在，<mark>虚拟机中的对象一般处于三种可能的状态</mark>。</p><h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<mark>一个无法触及的对象有可能在某一个条件下“复活”自己</mark>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li><mark>可触及的</mark>：从根节点开始，可以到达这个对象。</li><li><mark>可复活的</mark>：对象的所有引用都被释放，但是对象有可能在 finalize()中复活。</li><li><mark>不可触及的</mark>：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<mark>finalize()只会被调用一次</mark>。</li></ul><p>以上 3 种状态中，是由于 inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p><ol><li>如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行 finalize()方法</li><li>如果对象 objA 没有重写 finalize()方法，或者 finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li><li>如果对象 objA 重写了 finalize()方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize()方法执行。</li><li><mark>finalize()方法是对象逃脱死亡的最后机会</mark>，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize 方法只会被调用一次。</li></ol><p><strong>举例</strong></p><pre><code class="line-numbers language-java">public class CanReliveObj {    // 类变量，属于GC Roots的一部分    public static CanReliveObj canReliveObj;    @Override    protected void finalize() throws Throwable {        super.finalize();        System.out.println("调用当前类重写的finalize()方法");        canReliveObj = this;    }    public static void main(String[] args) throws InterruptedException {        canReliveObj = new CanReliveObj();        canReliveObj = null;        System.gc();        System.out.println("-----------------第一次gc操作------------");        // 因为Finalizer线程的优先级比较低，暂停2秒，以等待它        Thread.sleep(2000);        if (canReliveObj == null) {            System.out.println("obj is dead");        } else {            System.out.println("obj is still alive");        }        System.out.println("-----------------第二次gc操作------------");        canReliveObj = null;        System.gc();        // 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了        Thread.sleep(2000);        if (canReliveObj == null) {            System.out.println("obj is dead");        } else {            System.out.println("obj is still alive");        }    }}</code></pre><p>运行结果</p><pre><code>-----------------第一次gc操作------------调用当前类重写的finalize()方法obj is still alive-----------------第二次gc操作------------obj is dead</code></pre><p>在第一次 GC 时，执行了 finalize 方法，但 finalize()方法只会被调用一次，所以第二次该对象被 GC 标记并清除了。</p><h3 id="MAT-与-JProfiler-的-GC-Roots-溯源"><a href="#MAT-与-JProfiler-的-GC-Roots-溯源" class="headerlink" title="MAT 与 JProfiler 的 GC Roots 溯源"></a>MAT 与 JProfiler 的 GC Roots 溯源</h3><h4 id="MAT-是什么？"><a href="#MAT-是什么？" class="headerlink" title="MAT 是什么？"></a>MAT 是什么？</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p><p>大家可以在 <a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a> 下载并使用 MAT</p><h4 id="获取-dump-文件"><a href="#获取-dump-文件" class="headerlink" title="获取 dump 文件"></a>获取 dump 文件</h4><h5 id="方式一：命令行使用-jmap"><a href="#方式一：命令行使用-jmap" class="headerlink" title="方式一：命令行使用 jmap"></a>方式一：命令行使用 jmap</h5><p><img src="/attachment/6aa2469b622e7dec30dc087ed6bb63a9.png"></p><h5 id="方式二：使用-JVisualVM-导出"><a href="#方式二：使用-JVisualVM-导出" class="headerlink" title="方式二：使用 JVisualVM 导出"></a>方式二：使用 JVisualVM 导出</h5><p>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</p><p>可通过以下方法捕获 heap dump：</p><ul><li><p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump（堆 Dump）。</p></li><li><p>在 Monitor（监视）子标签页中点击 Heap Dump（堆 Dump）按钮。</p></li></ul><p>本地应用程序的 Heap dumps 作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。</p><p>右击这个节点选择 save as（另存为）即可将 heap dump 保存到本地。</p><h5 id="方式三：使用-MAT-打开-Dump-文件"><a href="#方式三：使用-MAT-打开-Dump-文件" class="headerlink" title="方式三：使用 MAT 打开 Dump 文件"></a>方式三：使用 MAT 打开 Dump 文件</h5><p><img src="/attachment/cd064eb1a78d30aa94590155ce8eff7f.png"></p><h4 id="JProfiler-的-GC-Roots-溯源"><a href="#JProfiler-的-GC-Roots-溯源" class="headerlink" title="JProfiler 的 GC Roots 溯源"></a>JProfiler 的 GC Roots 溯源</h4><p>我们在实际的开发中，一般不会查找全部的 GC Roots，可能只是查找某个对象的整个链路，或者称为 GC Roots 溯源，这个时候，我们就可以使用 JProfiler</p><p><img src="/attachment/c2135568d2ba0032595e5b236841a1ce.png"></p><h3 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在 JVM 中比较常见的三种垃圾收集算法是<mark>标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</mark></p><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并并应用于 Lisp 语言。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><mark>标记</mark>：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象。</li><li><mark>清除</mark>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</li></ul><p><img src="/attachment/9c66f66a1597af353ca2f4216372db31.png"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>标记清除算法的效率不算高</li><li>在进行 GC 的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h4 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><h3 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h3><h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于 1963 年发表了著名的论文，“使用双存储区的 Lisp 语言垃圾收集器 CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="/attachment/2ecba1e7edc81e0ecbbd160d756a3134.png"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h4 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h4><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在新生代，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src="/attachment/b4f52ca663928026801ffe352d8ce4c3.png"></p><h3 id="清除阶段：标记-压缩（整理）算法"><a href="#清除阶段：标记-压缩（整理）算法" class="headerlink" title="清除阶段：标记-压缩（整理）算法"></a>清除阶段：标记-压缩（整理）算法</h3><h4 id="标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="标记-压缩（或标记-整理、Mark-Compact）算法"></a>标记-压缩（或标记-整理、Mark-Compact）算法</h4><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><p>1970 年前后，G.L.Steele、C.J.Chene 和 D.s.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><ol><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li><li>之后，清理边界外所有的空间。</li></ol><p><img src="/attachment/6d2cce503c46869e14fc415ce9d0c210.png"></p><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<mark>标记-清除-压缩（Mark-Sweep-Compact）算法</mark>。</p><p>二者的本质差异在于标记-清除算法是一种<mark>非移动式的回收算法</mark>，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h4 id="指针碰撞（Bump-the-Pointer）"><a href="#指针碰撞（Bump-the-Pointer）" class="headerlink" title="指针碰撞（Bump the Pointer）"></a>指针碰撞（Bump the Pointer）</h4><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th align="left"></th><th align="left">Mark-Sweep</th><th align="left">Mark-Compact</th><th align="left">Copying</th></tr></thead><tbody><tr><td align="left"><strong>速率</strong></td><td align="left">中等</td><td align="left">最慢</td><td align="left">最快</td></tr><tr><td align="left"><strong>空间开销</strong></td><td align="left">少（但会堆积碎片）</td><td align="left">少（不堆积碎片）</td><td align="left">通常需要活对象的 2 倍空间（不堆积碎片）</td></tr><tr><td align="left"><strong>移动对象</strong></td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr></tbody></table><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p><p>难道就没有一种最优算法吗？</p><p>回答：无，没有最好的算法，只有最合适的算法</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<mark>不同生命周期的对象可以采取不同的收集方式</mark>，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<mark>Http 请求中的 Session 对象、线程、Socket 连接</mark>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<mark>String 对象</mark>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p><mark>目前几乎所有的 GC 都采用分代手机算法执行垃圾回收的。</mark></p><p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><h4 id="年轻代（Young-Gen）"><a href="#年轻代（Young-Gen）" class="headerlink" title="年轻代（Young Gen）"></a>年轻代（Young Gen）</h4><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解。</p><h4 id="老年代（Tenured-Gen）"><a href="#老年代（Tenured-Gen）" class="headerlink" title="老年代（Tenured Gen）"></a>老年代（Tenured Gen）</h4><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark 阶段的开销与存活对象的数量成正比。</li><li>Sweep 阶段的开销与所管理区域的大小成正相关。</li><li>Compact 阶段的开销与存活对象的数据成正比。</li></ul><p>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h3 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h3><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将<mark>严重影响用户体验或者系统的稳定性</mark>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<mark>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</mark>。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<mark>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</mark></p><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<mark>造成系统吞吐量的下降</mark>。</p><h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="/attachment/6f988c2524fca2f8f977ce858646318b.png"></p><h4 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h4><p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 StringTable</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-stringtable/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-stringtable/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-StringTable"><a href="#【Java-JVM】-StringTable" class="headerlink" title="【Java JVM】 StringTable"></a>【Java JVM】 StringTable</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 StringTabledate: 2023-06-28 20:57tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 StringTable</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>String 再也不用 char[] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间</p><p><strong>String 的基本特性</strong></p><ul><li>不可变性</li></ul><p><strong>字符串拼接操作</strong></p><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是 StringBuilder</li><li>如果拼接的结果调用 intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><p><strong>intern()</strong></p><p>intern 是一个 native 方法，调用的是底层 C 的方法</p><p>JDK1.6 中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<mark>对象复制一份</mark>，放入串池，并返回串池中的对象地址</li></ul><p>JDK1.7 起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<mark>对象的引用地址</mark>复制一份，放入串池，并返回串池中的引用地址</li></ul><h2 id="String-的基本特性"><a href="#String-的基本特性" class="headerlink" title="String 的基本特性"></a>String 的基本特性</h2><ul><li>String：字符串，使用一对””引起来表示</li><li>String 声明为 final 的，不可被继承</li><li>String 实现了 Serializable 接口：表示字符串是支持序列化的。</li><li>String 实现了 Comparable 接口：表示 string 可以比较大小</li><li>String 在 jdk8 及以前内部定义了 final char[] value 用于存储字符串数据。JDK9 时改为 byte[]</li></ul><h3 id="String-在-jdk9-中存储结构变更"><a href="#String-在-jdk9-中存储结构变更" class="headerlink" title="String 在 jdk9 中存储结构变更"></a>String 在 jdk9 中存储结构变更</h3><p>官网地址：<a href="http://openjdk.java.net/jeps/254">JEP 254: Compact Strings (java.net)</a></p><blockquote><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>The current implementation of the <code>String</code> class stores characters in a <code>char</code> array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most <code>String</code> objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal <code>char</code> arrays of such <code>String</code> objects is going unused.</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>We propose to change the internal representation of the <code>String</code> class from a UTF-16 <code>char</code> array to a <code>byte</code> array plus an encoding-flag field. The new <code>String</code> class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p><p>String-related classes such as <code>AbstractStringBuilder</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p><p>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.</p><p>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.</p></blockquote><p><strong>动机</strong></p><p>目前 String 类的实现将字符存储在一个 char 数组中，每个字符使用两个字节（16 位）。从许多不同的应用中收集到的数据表明，字符串是堆使用的主要组成部分，此外，大多数字符串对象只包含 Latin-1 字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部字符数组中有一半的空间没有被使用。</p><p><strong>说明</strong></p><p>我们建议将 String 类的内部表示方法从 UTF-16 字符数组改为字节数组加编码标志域。新的 String 类将根据字符串的内容，以 ISO-8859-1/Latin-1（每个字符一个字节）或 UTF-16（每个字符两个字节）的方式存储字符编码。编码标志将表明使用的是哪种编码。</p><hr><p>与字符串相关的类，如<mark>AbstractStringBuilder、StringBuilder 和 StringBuffer 将被更新以使用相同的表示方法，HotSpot VM 的内在字符串操作也是如此</mark>。</p><p>这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共 API 或其他接口。</p><p>迄今为止所做的原型设计工作证实了内存占用的预期减少，GC 活动的大幅减少，以及在某些角落情况下的轻微性能倒退。</p><p>结论：String 再也不用 char[] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间</p><pre><code class="line-numbers language-Java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    @Stable    private final byte[] value;}</code></pre><h3 id="String-的基本特性-1"><a href="#String-的基本特性-1" class="headerlink" title="String 的基本特性"></a>String 的基本特性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p><ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li><li>当调用 string 的 replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li></ul><p>通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p><p><mark>字符串常量池是不会存储相同内容的字符串的</mark></p><p>String 的 String Pool 是一个固定大小的 Hashtable，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 String.intern 时性能会大幅下降。</p><p>使用<code>-XX:StringTablesize</code>可设置 StringTable 的长度</p><ul><li>在 jdk6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求</li><li>在 jdk7 中，StringTable 的长度默认值是 60013，StringTablesize 设置没有要求</li><li>在 JDK8 中，设置 StringTable 长度的话，1009 是可以设置的最小值</li></ul><h2 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h2><p>在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p><p>常量池就类似一个 Java 系统级别提供的缓存。8 种基本数据类型的常量池都是系统协调的，<mark>String 类型的常量池比较特殊。它的主要使用方法有两种。</mark></p><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern()方法。这个后面重点谈</li></ul><p>Java 6 及以前，字符串常量池存放在永久代</p><p>Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即将<mark>字符串常量池的位置调整到 Java 堆内</mark></p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用<code>String.intern()</code>。</li></ul><p>Java8 元空间，字符串常量在堆</p><p><img src="/attachment/3f6d679d119affe193f8149f1c430db1.png"></p><p><img src="/attachment/2a24a0b2817601cef003816faf1ee253.png"></p><p><strong>StringTable 为什么要调整？</strong></p><p>官网地址：[Java SE 7 Features and Enhancements (oracle.com)](</p><pre><code class="line-numbers language-java">**Synopsis:** In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the `String.intern()` method will see more significant differences.</code></pre><p>简介：在 JDK 7 中，内部字符串不再分配在 Java 堆的永久代中，而是分配在 Java 堆的主要部分（称为年轻代和老年代），与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主 Java 堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但<mark>加载许多类或大量使用 String.intern()方法的大型应用程序将看到更明显的差异</mark>。</p><h2 id="String-的基本操作"><a href="#String-的基本操作" class="headerlink" title="String 的基本操作"></a>String 的基本操作</h2><pre><code class="line-numbers language-java">@Testpublic void test1() {    System.out.print1n("1"); //2321    System.out.println("2");    System.out.println("3");    System.out.println("4");    System.out.println("5");    System.out.println("6");    System.out.println("7");    System.out.println("8");    System.out.println("9");    System.out.println("10"); //2330    System.out.println("1"); //2321    System.out.println("2"); //2322    System.out.println("3");    System.out.println("4");    System.out.println("5");    System.out.print1n("6");    System.out.print1n("7");    System.out.println("8");    System.out.println("9");    System.out.println("10");//2330}</code></pre><p>Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列（包含同一份码点序列的常量），并且必须是指向同一个 String 类实例。</p><pre><code class="line-numbers language-java">class Memory {    public static void main(String[] args) {//line 1        int i= 1;//line 2        Object obj = new Object();//line 3        Memory mem = new Memory();//Line 4        mem.foo(obj);//Line 5    }//Line 9    private void foo(Object param) {//line 6        String str = param.toString();//line 7        System.out.println(str);    }//Line 8}</code></pre><p><img src="/attachment/73c902a26c2b5b2d5d8e13339acb0e50.png"></p><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是 StringBuilder</li><li>如果拼接的结果调用 intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><p><strong>举例 1</strong></p><pre><code class="line-numbers language-java">  public static void test1() {      // 都是常量，前端编译期会进行代码优化      // 通过idea直接看对应的反编译的class文件，会显示 String s1 = "abc"; 说明做了代码优化      String s1 = "a" + "b" + "c";      String s2 = "abc";      // true，有上述可知，s1和s2实际上指向字符串常量池中的同一个值      System.out.println(s1 == s2);  }</code></pre><p><strong>举例 2</strong></p><pre><code class="line-numbers language-java">public static void test5() {    String s1 = "javaEE";    String s2 = "hadoop";    String s3 = "javaEEhadoop";    String s4 = "javaEE" + "hadoop";    String s5 = s1 + "hadoop";    String s6 = "javaEE" + s2;    String s7 = s1 + s2;    System.out.println(s3 == s4); // true 编译期优化    System.out.println(s3 == s5); // false s1是变量，不能编译期优化    System.out.println(s3 == s6); // false s2是变量，不能编译期优化    System.out.println(s3 == s7); // false s1、s2都是变量    System.out.println(s5 == s6); // false s5、s6 不同的对象实例    System.out.println(s5 == s7); // false s5、s7 不同的对象实例    System.out.println(s6 == s7); // false s6、s7 不同的对象实例    String s8 = s6.intern();    System.out.println(s3 == s8); // true intern之后，s8和s3一样，指向字符串常量池中的"javaEEhadoop"}</code></pre><p><strong>举例 3</strong></p><pre><code class="line-numbers language-java">public void test6(){    String s0 = "beijing";    String s1 = "bei";    String s2 = "jing";    String s3 = s1 + s2;    System.out.println(s0 == s3); // false s3指向对象实例，s0指向字符串常量池中的"beijing"    String s7 = "shanxi";    final String s4 = "shan";    final String s5 = "xi";    String s6 = s4 + s5;    System.out.println(s6 == s7); // true s4和s5是final修饰的，编译期就能确定s6的值了}</code></pre><ul><li>不使用 final 修饰，即为变量。如 s3 行的 s1 和 s2，会通过 new StringBuilder 进行拼接</li><li>使用 final 修饰，即为常量。会在编译器进行代码优化。<mark>在实际开发中，能够使用 final 的，尽量使用</mark></li></ul><p><strong>举例 4</strong></p><pre><code class="line-numbers language-java">public void test3(){    String s1 = "a";    String s2 = "b";    String s3 = "ab";    String s4 = s1 + s2;    System.out.println(s3==s4);}</code></pre><p><strong>字节码</strong></p><p>我们拿例 4 的字节码进行查看，可以发现<code>s1 + s2</code>实际上是 new 了一个 StringBuilder 对象，并使用了 append 方法将 s1 和 s2 添加进来，最后调用了 toString 方法赋给 s4</p><pre><code class="line-numbers language-java"> 0 ldc #2 &lt;a&gt; 2 astore_1 3 ldc #3 &lt;b&gt; 5 astore_2 6 ldc #4 &lt;ab&gt; 8 astore_3 9 new #5 &lt;java/lang/StringBuilder&gt;12 dup13 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;16 aload_117 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;20 aload_221 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;24 invokevirtual #8 &lt;java/lang/StringBuilder.toString&gt;27 astore 429 getstatic #9 &lt;java/lang/System.out&gt;32 aload_333 aload 435 if_acmpne 42 (+7)38 iconst_139 goto 43 (+4)42 iconst_043 invokevirtual #10 &lt;java/io/PrintStream.println&gt;46 return</code></pre><pre><code class="line-numbers language-java">public class Test{    public static void main(String[] args) {                int times = 50000;        // String                long start = System.currentTimeMillis();                testString(times);                long end = System.currentTimeMillis();                System.out.println("String: " + (end-start) + "ms");        // StringBuilder                start = System.currentTimeMillis();                testStringBuilder(times);                end = System.currentTimeMillis();                System.out.println("StringBuilder: " + (end-start) + "ms");        // StringBuffer                start = System.currentTimeMillis();                testStringBuffer(times);                end = System.currentTimeMillis();                System.out.println("StringBuffer: " + (end-start) + "ms");        }    public static void testString(int times) {                String str = "";                for (int i = 0; i &lt; times; i++) {                        str += "test";                }        }                public static void testStringBuilder(int times) {                StringBuilder sb = new StringBuilder();                for (int i = 0; i &lt; times; i++) {                        sb.append("test");                }        }            public static void testStringBuffer(int times) {                StringBuffer sb = new StringBuffer();                for (int i = 0; i &lt; times; i++) {                        sb.append("test");                }        }}// 结果String: 7963msStringBuilder: 1msStringBuffer: 4ms</code></pre><p>本实验进行 5 万次循环，String 拼接方式的时间是 StringBuilder.append 方式的约 8000 倍，StringBuffer.append()方式的时间是 StringBuilder.append()方式的约 4 倍</p><p>可以看到，通过 StringBuilder 的 append 方式的速度，要比直接对 String 使用“+”拼接的方式<mark>快的不是一点半点</mark></p><p>那么，在实际开发中，对于需要<mark>多次或大量拼接</mark>的操作，在不考虑线程安全问题时，我们就应该尽可能<mark>使用 StringBuilder 进行 append 操作</mark></p><p>除此之外，还有那些操作能够帮助我们提高字符串方面的运行效率呢？</p><p>StringBuilder 空参构造器的初始化大小为 16。那么，如果提前知道需要拼接 String 的个数，就应该直接使用<mark>带参构造器</mark>指定 capacity，以减少扩容的次数（扩容的逻辑可以自行查看源代码）</p><pre><code class="line-numbers language-java">/**  * Constructs a string builder with no characters in it and an  * initial capacity of 16 characters.  */public StringBuilder() {        super(16);}/** * Constructs a string builder with no characters in it and an  * initial capacity specified by the {@code capacity} argument.  *  * @param      capacity  the initial capacity.  * @throws     NegativeArraySizeException  if the {@code capacity}  * argument is less than {@code 0}.  */public StringBuilder(int capacity) {     super(capacity);}</code></pre><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h2><p>官方 API 文档中的解释</p><blockquote><p>public String intern()</p><p>Returns a canonical representation for the string object.</p><p>A pool of strings, initially empty, is maintained privately by the class <code>String</code>.</p><p>When the intern method is invoked, if the pool already contains a string equal to this <code>String</code> object as determined by the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-"><code>equals(Object)</code></a> method, then the string from the pool is returned. Otherwise, this <code>String</code> object is added to the pool and a reference to this <code>String</code> object is returned.</p><p>It follows that for any two strings <code>s</code> and <code>t</code>, <code>s.intern() == t.intern()</code> is <code>true</code> if and only if <code>s.equals(t)</code> is <code>true</code>.</p><p>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.</p><ul><li><p><strong>Returns:</strong></p><p>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.</p></li></ul></blockquote><p>当调用 intern 方法时，如果池子里已经包含了一个与这个 String 对象相等的字符串，正如 equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个 String 对象被添加到池中，并返回这个 String 对象的引用。</p><p>由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t)为真时，s.intern() == t.intern()为真。</p><p>所有字面字符串和以字符串为值的常量表达式都是 interned。</p><p>返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池。</p><hr><p>intern 是一个 native 方法，调用的是底层 C 的方法</p><pre><code class="line-numbers language-java">public native String intern();</code></pre><p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，它会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><pre><code class="line-numbers language-java">String myInfo = new string("I love atguigu").intern();</code></pre><p>也就是说，如果在任意字符串上调用 String.intern 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 true</p><pre><code class="line-numbers language-java">("a"+"b"+"c").intern() == "abc"</code></pre><p>通俗点讲，Interned string 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p><p><img src="/attachment/bc908346a704ffbcf4fc8575dcccd315.png"></p><h3 id="intern-的使用：JDK6-vs-JDK7-x2F-8"><a href="#intern-的使用：JDK6-vs-JDK7-x2F-8" class="headerlink" title="intern 的使用：JDK6 vs JDK7/8"></a>intern 的使用：JDK6 vs JDK7/8</h3><pre><code class="line-numbers language-Java">/**  * ① String s = new String("1")  * 创建了两个对象  * 堆空间中一个new对象  * 字符串常量池中一个字符串常量"1"（注意：此时字符串常量池中已有"1"）  * ② s.intern()由于字符串常量池中已存在"1"  *   * s  指向的是堆空间中的对象地址  * s2 指向的是堆空间中常量池中"1"的地址  * 所以不相等  */ String s = new String("1"); s.intern(); String s2 = "1"; System.out.println(s==s2);// jdk1.6 false jdk7/8 false /**  * ① String s3 = new String("1") + new String("1")   * 等价于new String（"11"），但是，常量池中并不生成字符串"11"；   *   * ② s3.intern()   * 由于此时常量池中并无"11"，所以把s3中记录的对象的地址存入常量池   * 所以s3 和 s4 指向的都是一个地址  */  String s3 = new String("1") + new String("1");  s3.intern();  String s4 = "11";  System.out.println(s3==s4); //jdk1.6 false jdk7/8 true</code></pre><p><img src="/attachment/fcf7d7267f447a1782ae5ac0ba92bee2.png"></p><p><img src="/attachment/3a3233e6e4b441573c392676bd347c94.png"></p><p>总结 String 的 intern()的使用：</p><p>JDK1.6 中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<mark>对象复制一份</mark>，放入串池，并返回串池中的对象地址</li></ul><p>JDK1.7 起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<mark>对象的引用地址</mark>复制一份，放入串池，并返回串池中的引用地址</li></ul><p><strong>练习 1</strong></p><p><img src="/attachment/f1578e784dad1aae5449aca0d0052990.png"></p><p><img src="/attachment/63fdc1eb9474be7d0354a07e2034025f.png"></p><p><strong>练习 2</strong></p><p><img src="/attachment/a11485ee9129bf9e5808e96d14f7561b.png"></p><h3 id="intern-的效率测试：空间角度"><a href="#intern-的效率测试：空间角度" class="headerlink" title="intern 的效率测试：空间角度"></a>intern 的效率测试：空间角度</h3><p>我们通过测试一下，使用了 intern 和不使用的时候，其实相差还挺多的</p><pre><code class="line-numbers language-java">public class StringIntern2 {    static final int MAX_COUNT = 1000 * 10000;        static final String[] arr = new String[MAX_COUNT];            public static void main(String[] args) {                Integer [] data = new Integer[]{1,2,3,4,5,6,7,8,9,10};                long start = System.currentTimeMillis();                for (int i = 0; i &lt; MAX_COUNT; i++) {                    // arr[i] = new String(String.valueOf(data[i%data.length]));                    arr[i] = new String(String.valueOf(data[i%data.length])).intern();                }                long end = System.currentTimeMillis();                System.out.println("花费的时间为：" + (end - start));                try {                        Thread.sleep(1000000);                } catch (Exception e) {                        e.getStackTrace();                }        }}// 运行结果不使用intern：7256ms使用intern：1395ms</code></pre><p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用 intern()方法能够节省内存空间。</p><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern()方法，就会很明显降低内存的大小。</p><h2 id="StringTable-的垃圾回收"><a href="#StringTable-的垃圾回收" class="headerlink" title="StringTable 的垃圾回收"></a>StringTable 的垃圾回收</h2><pre><code class="line-numbers language-java">public class StringGCTest {    /**      * -Xms15m -Xmx15m -XX:+PrintGCDetails      */        public static void main(String[] args) {                        for (int i = 0; i &lt; 100000; i++) {                    String.valueOf(i).intern();                }        }}</code></pre><p>运行结果</p><pre><code class="line-numbers language-java">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;504K(4608K)] 4096K-&gt;1689K(15872K), 0.0581583 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] [GC (Allocation Failure) [PSYoungGen: 4600K-&gt;504K(4608K)] 5785K-&gt;2310K(15872K), 0.0015621 secs][Times: user=0.00 sys=0.00, real=0.00 secs][GC (Allocation Failure) [PSYoungGen: 4600K-&gt;504K(4608K)] 6406K-&gt;2350K(15872K), 0.0034849 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 4608K, used 1919K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)  eden space 4096K, 34% used [0x00000000ffb00000,0x00000000ffc61d30,0x00000000fff00000)  from space 512K, 98% used [0x00000000fff00000,0x00000000fff7e010,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 11264K, used 1846K [0x00000000ff000000, 0x00000000ffb00000, 0x00000000ffb00000)  object space 11264K, 16% used [0x00000000ff000000,0x00000000ff1cd9b0,0x00000000ffb00000)                                Metaspace      used 3378K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 361K, capacity 388K, committed 512K, reserved 1048576K</code></pre><h2 id="G1-中的-String-去重操作"><a href="#G1-中的-String-去重操作" class="headerlink" title="G1 中的 String 去重操作"></a>G1 中的 String 去重操作</h2><p>官网地址：<a href="http://openjdk.java.net/jeps/192">JEP 192: String Deduplication in G1 (java.net)</a></p><blockquote><h2 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h2><p>Many large-scale Java applications are currently bottlenecked on memory. Measurements have shown that roughly 25% of the Java heap live data set in these types of applications is consumed by <code>String</code> objects. Further, roughly half of those <code>String</code> objects are duplicates, where duplicates means <code>string1.equals(string2)</code> is true. Having duplicate <code>String</code> objects on the heap is, essentially, just a waste of memory. This project will implement automatic and continuous <code>String</code> deduplication in the G1 garbage collector to avoid wasting memory and reduce the memory footprint.</p></blockquote><p>目前，许多大规模的 Java 应用程序在内存上遇到了瓶颈。测量表明，在这些类型的应用程序中，大约 25%的 Java 堆实时数据集被<code>String'对象所消耗。此外，这些 "String "对象中大约有一半是重复的，其中重复意味着 "string1.equals(string2) "是真的。在堆上有重复的</code>String’对象，从本质上讲，只是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动和持续的`String’重复数据删除，以避免浪费内存，减少内存占用。</p><hr><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p><p>背景：对许多 Java 应用（有大的也有小的）做的测试得出以下结果：</p><ul><li>堆存活数据集合里面 string 对象占了 25%</li><li>堆存活数据集合里面重复的 string 对象有 13.5%</li><li>string 对象的平均长度是 45</li></ul><p>许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<mark>Java 堆中存活的数据集合差不多 25%是 String 对象</mark>。更进一步，这里面差不多一半 string 对象是重复的，重复的意思是说： <code>stringl.equals(string2)= true</code>。<mark>堆上存在重复的 String 对象必然是一种内存的浪费</mark>。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 string 对象进行去重，这样就能避免浪费内存。</p><p><strong>实现</strong></p><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。<mark>对每一个访问的对象都会检查是否是候选的要去重的 String 对象</mark></li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 string 对象。</li><li>使用一个 hashtable 来记录所有的被 String 对象使用的不重复的 char 数组。当去重的时候，会查这个 hashtable，来看堆上是否已经存在一个一模一样的 char 数组。</li><li>如果存在，String 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char 数组会被插入到 hashtable，这样以后的时候就可以共享这个数组了。</li></ol><p><strong>命令行选项</strong></p><pre><code class="line-numbers language-java"># 开启String去重，默认是不开启的，需要手动开启。 UseStringDeduplication(bool)  # 打印详细的去重统计信息 PrintStringDeduplicationStatistics(bool) # 达到这个年龄的String对象被认为是去重的候选对象StringpeDuplicationAgeThreshold(uintx)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 执行引擎</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-xing-yin-qing/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-xing-yin-qing/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-执行引擎"><a href="#【Java-JVM】-执行引擎" class="headerlink" title="【Java JVM】 执行引擎"></a>【Java JVM】 执行引擎</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 执行引擎date: 2023-06-28 18:48tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 执行引擎</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎属于 JVM 的下层，里面包括<mark>解释器、及时编译器、垃圾回收器</mark></p><p><strong>执行引擎的工作流程</strong></p><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。</li><li>每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><p><strong>执行引擎的工作流程</strong></p><p><img src="/attachment/ccc3c6c5c3dc387139ebdecd14d4ba53.png"></p><p><img src="/attachment/52823c05c01d2c2d9c734c45cca2f1ec.png"></p><p><strong>JIT 编译器</strong></p><p>根据热点探测功能，<mark>将有价值的字节码编译为本地机器指令</mark>，以换取更高的程序执行效率。</p><p>目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><p>执行引擎属于 JVM 的下层，里面包括<mark>解释器、及时编译器、垃圾回收器</mark></p><p><img src="/attachment/8e6c7753d7097cae253d8aeb2bc07909.png"></p><p>执行引擎是 Java 虚拟机核心的组成部分之一。</p><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<mark>虚拟机的执行引擎则是由软件自行实现的</mark>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<mark>能够执行那些不被硬件直接支持的指令集格式</mark>。</p><p>JVM 的主要任务是负责<mark>装载字节码到其内部</mark>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。</p><p><img src="/attachment/0b9faa2979bdc4c652ec2ba05265f291.png"></p><p>那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是<mark>将字节码指令解释/编译为对应平台上的本地机器指令</mark>.才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。</li><li>每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><p><img src="/attachment/fb312b0a9eb3001e1fa1d5cbdc57c5a4.png"></p><p>从外观上来看，所有的 Java 虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p><h2 id="执行引擎的工作流程-1"><a href="#执行引擎的工作流程-1" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h2><p><img src="/attachment/ccc3c6c5c3dc387139ebdecd14d4ba53.png"></p><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤<br>Java 代码编译是由 Java 源码编译器（<mark>前端编译器</mark>）来完成，流程图如下所示：</p><p><img src="/attachment/c9b2e1b6a6205b927d7d01c64e9d3a4b.png"></p><p>Java 字节码的执行是由 JVM 执行引擎（<mark>后端编译器</mark>）来完成，流程图 如下所示</p><p><img src="/attachment/23dcedb438a05d1d41939953e331b105.png"></p><h3 id="什么是解释器（Interpreter）？什么是-JIT-编译器？"><a href="#什么是解释器（Interpreter）？什么是-JIT-编译器？" class="headerlink" title="什么是解释器（Interpreter）？什么是 JIT 编译器？"></a>什么是解释器（Interpreter）？什么是 JIT 编译器？</h3><p>解释器：当 Java 虚拟机启动时会根据预定义的规范<mark>对字节码采用逐行解释的方式执行</mark>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><h3 id="为什么-Java-是半编译半解释型语言？"><a href="#为什么-Java-是半编译半解释型语言？" class="headerlink" title="为什么 Java 是半编译半解释型语言？"></a>为什么 Java 是半编译半解释型语言？</h3><p>JDK1.0 时代，将 Java 语言定位为“解释执行”还是比较准确的。再后来，Java 也发展出可以直接生成本地代码的编译器。现在 JVM 在执行 Java 代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p><strong>图示</strong></p><p><img src="/attachment/52823c05c01d2c2d9c734c45cca2f1ec.png"></p><h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令（一般为英文简写，如 mov，inc 等），可读性稍好</p><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同。</p><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p><ul><li>x86 指令集，对应的是 x86 架构的平台</li><li>ARM 指令集，对应的是 ARM 架构的平台</li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>在汇编语言中，<mark>用助记符（Mnemonics）代替机器指令的操作码，用 地址符号（Symbol）或标号（Label）代替指令或操作数的地址</mark>。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><p>由于计算机只认识指令码，所以用<mark>汇编语言编写的程序还必须翻译成机器指令码</mark>，计算机才能识别和执行。</p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<mark>更接近人的语言</mark></p><p>当计算机执行高级语言编写的程序时，<mark>仍然需要把程序解释和编译成机器的指令码</mark>。完成这个过程的程序就叫做解释程序或编译程序。</p><p><img src="/attachment/a284a35043b5483a07330826b1c4fe84.png"></p><p>高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码，如下面说的 C 和 C++</p><h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p><img src="/attachment/6266a12e6edd4e793e6dfcdfe3d70bd9.png"></p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、<mark>与硬件环境无关</mark>。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码典型的应用为：Java bytecode</p><p><img src="/attachment/b1566ad1ed55281e7d016484ee5d439a.png"></p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM 设计者们的初衷仅仅只是单纯地为了<mark>满足 Java 程序实现跨平台特性</mark>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><p><img src="/attachment/5edc939c99b89f922e8ebba10f9a115d.png"></p><p>为什么 Java 源文件不直接翻译成 JMV，而是翻译成字节码文件？可能是因为直接翻译的代价是比较大的</p><h3 id="解释器工作机制"><a href="#解释器工作机制" class="headerlink" title="解释器工作机制"></a>解释器工作机制</h3><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在 Java 的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><ul><li>字节码解释器在执行时通过<mark>纯软件代码模拟字节码</mark>的执行，效率非常低下。</li><li>而模板解释器将<mark>每一条字节码和一个模板函数相关联</mark>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul><p>在 HotSpot VM 中，解释器主要由 Interpreter 模块和 Code 模块构成。</p><ul><li>Interpreter 模块：实现了解释器的核心功能</li><li>Code 模块：用于管理 HotSpot VM 在运行时生成的本地机器指令</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，<mark>基于解释器执行已经沦落为低效的代名词</mark>，并且时常被一些 C/C++程序员所调侃。</p><p>为了解决这个问题，JVM 平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<mark>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</mark>，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h2 id="JIT-编译器"><a href="#JIT-编译器" class="headerlink" title="JIT 编译器"></a>JIT 编译器</h2><h3 id="Java-代码的执行分类"><a href="#Java-代码的执行分类" class="headerlink" title="Java 代码的执行分类"></a>Java 代码的执行分类</h3><ul><li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p></li><li><p>第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p></li></ul><p>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用<mark>解释器与即时编译器并存的架构</mark>。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++ 程序一较高下的地步。</p><p><strong>问题来了</strong></p><p>有些开发人员会感觉到诧异，<mark>既然 HotSpot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？</mark>比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以： 尽管 JRockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<mark>当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间</mark>。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="HotSpot-JVM-执行方式"><a href="#HotSpot-JVM-执行方式" class="headerlink" title="HotSpot JVM 执行方式"></a>HotSpot JVM 执行方式</h3><p>当虚拟机启动的时候，<mark>解释器可以首先发挥作用</mark>，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<mark>将有价值的字节码编译为本地机器指令</mark>，以换取更高的程序执行效率。</p><p><strong>案例来了</strong></p><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<mark>机器在热机状态可以承受的负载要大于冷机状态</mark>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的 JVM 均是解释执行，还没有进行热点代码统计和 JIT 动态编译，导致机器启动之后，当前 1/2 发布成功的服务器马上全部宕机，此故障说明了 JIT 的存在。—阿里团队</p><p><img src="/attachment/966cf12465062a6891fb47e57df7d287.png"></p><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<mark>前端编译器</mark>（其实叫“编译器的前端”更准确一些）把.java 文件转变成.class 文件的过程；</p><p>也可能是指虚拟机的<mark>后端运行期编译器</mark>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</p><p>还可能是指使用<mark>静态提前编译器</mark>（AOT 编译器，Ahead of Time Compiler）直接把.java 文件编译成本地机器代码的过程。</p><ul><li>前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。</li><li>JIT 编译器：HotSpot VM 的 C1、C2 编译器。</li><li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ul><h3 id="热点代码及探测技术"><a href="#热点代码及探测技术" class="headerlink" title="热点代码及探测技术"></a>热点代码及探测技术</h3><p>当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。</p><p><mark>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</mark>，因此都可以通过 JIT 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为<mark>OSR（On Stack Replacement）编译</mark>。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT 编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<mark>热点探测功能</mark>。</p><p><mark>目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测</mark>。</p><p>采用基于计数器的热点探测，HotSpot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为<mark>方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）</mark>。</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发 JIT 编译。</p><p>这个阀值可以通过虚拟机参数 <code>-XX:CompileThreshold</code>来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断<mark>方法调用计数器与回边计数器值之和</mark>是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p><img src="/attachment/22b25d3ae3bdcbde8eb120c13eb7cd85.png"></p><h4 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h4><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<mark>一段时间之内方法被调用的次数</mark>。当超过<mark>一定的时间限度</mark>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<mark>衰减（Counter Decay）</mark>，而这段时间就称为此方法统计的<mark>半衰周期（Counter Half Life Time）</mark></p><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个<mark>方法中循环体代码执行的次数</mark>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。</p><p><img src="/attachment/66a9528242ac3cdc0d0cd98f0b18352f.png"></p><h3 id="HotSpotVM-可以设置程序执行方法"><a href="#HotSpotVM-可以设置程序执行方法" class="headerlink" title="HotSpotVM 可以设置程序执行方法"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下 HotSpot VM 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为 Java 虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li><code>-Xint</code>：完全采用解释器模式执行程序；</li><li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><h3 id="HotSpotVM-中-JIT-分类"><a href="#HotSpotVM-中-JIT-分类" class="headerlink" title="HotSpotVM 中 JIT 分类"></a>HotSpotVM 中 JIT 分类</h3><p>JIT 的编译器还分为了两种，分别是 C1 和 C2，在 HotSpot VM 中内嵌有两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，但大多数情况下我们简称为 C1 编译器 和 C2 编译器。开发人员可以通过如下命令显式指定 Java 虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><code>-client</code>：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器；C1 编译器会对字节码<mark>进行简单和可靠的优化，耗时短</mark>，以达到更快的编译速度。</li><li><code>-server</code>：指定 Java 虚拟机运行在 server 模式下，并使用 C2 编译器。C2<mark>进行耗时较长的优化，以及激进优化</mark>，但优化的代码执行效率更高。</li></ul><p><mark>分层编译（Tiered Compilation）策略</mark>：程序解释执行（不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。</p><p>不过在 Java7 版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由 C1 编译器和 C2 编译器相互协作共同来执行编译任务。</p><h4 id="C1-和-C2-编译器不同的优化策略"><a href="#C1-和-C2-编译器不同的优化策略" class="headerlink" title="C1 和 C2 编译器不同的优化策略"></a>C1 和 C2 编译器不同的优化策略</h4><p>在不同的编译器上有不同的优化策略，C1 编译器上主要有<mark>方法内联、去虚拟化、冗余消除</mark>。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><p>C2 的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在 C2 上有如下几种优化：</p><ul><li><mark>标量替换</mark>：用标量值代替聚合对象的属性值</li><li><mark>栈上分配</mark>：对于未逃逸的对象分配对象在栈而不是堆</li><li><mark>同步消除</mark>：清除同步操作，通常指 synchronized</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般来讲，JIT 编译出来的机器码性能比解释器高。C2 编译器启动时长比 C1 慢，系统稳定执行以后，C2 编译器执行速度远快于 C1 编译器</p><h3 id="写到最后-1"><a href="#写到最后-1" class="headerlink" title="写到最后 1"></a>写到最后 1</h3><ul><li>自 JDK10 起，HotSpot 又加入了一个全新的及时编译器：Graal 编译器</li><li>编译效果短短几年时间就追评了 C2 编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code>去激活才能使用</li></ul><h3 id="写到最后-2：AOT-编译器"><a href="#写到最后-2：AOT-编译器" class="headerlink" title="写到最后 2：AOT 编译器"></a>写到最后 2：AOT 编译器</h3><p>jdk9 引入了 AOT 编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9 引入了实验性 AOT 编译工具 jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，<mark>即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码</mark>，并部署至托管环境中的过程。而<mark>AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</mark></p><p>最大的好处：Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li><mark>破坏了 java “ 一次编译，到处运行”的理念</mark>，必须为每个不同的硬件，OS 编译对应的发行包</li><li><mark>降低了 Java 链接过程的动态性</mark>，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持 Linux X64 java base</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 对象实例化</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-dui-xiang-shi-li-hua/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-dui-xiang-shi-li-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-对象实例化"><a href="#【Java-JVM】-对象实例化" class="headerlink" title="【Java JVM】 对象实例化"></a>【Java JVM】 对象实例化</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 对象实例化date: 2023-06-27 22:01tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 对象实例化</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/22035e5419c0efa849223bb5aee25bd6.png"></p><p><strong>对象内存布局</strong></p><p><img src="/attachment/c0db7552106bb333b0921da619fbe64d.png"></p><p><img src="/attachment/d624b81576677a1bf4269fb55698da2f.png"></p><p><strong>对象的访问定位</strong></p><p><img src="/attachment/1e7f2cd21587c0875acb295e6f4c82b9.png"></p><p><img src="/attachment/a0c7dfc632af0acb9776239d8f4844f0.png"></p><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><p><strong>面试题</strong></p><blockquote><p><mark>美团</mark>：</p><p>对象在 JVM 中是怎么存储的？<br>对象头信息里面有哪些东西？</p><p><mark>蚂蚁金服</mark>：</p><p>Java 对象头有什么？</p></blockquote><p><img src="/attachment/22035e5419c0efa849223bb5aee25bd6.png"></p><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ul><li>new：最常见的方式、Xxx 的静态方法，XxxBuilder/XxxFactory 的静态方法</li><li>Class 的 newInstance 方法：反射的方式，只能调用空参的构造器，权限必须是 public</li><li>Constructor 的 newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用 clone()：不调用任何的构造器，要求当前的类需要实现 Cloneable 接口，实现 clone()</li><li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li><li>第三方库 Objenesis</li></ul><h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><p>前面所述是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析：</p><p><img src="/attachment/ad0fadb693d44217a7d1f40318016996.png"></p><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1. 判断对象对应的类是否加载、链接、初始化"></a>1. 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p><p>如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 key 进行查找对应的 .class 文件；</p><ul><li>如果没有找到文件，则抛出 ClassNotFoundException 异常</li><li>如果找到，则进行类加载，并生成对应的 Class 对象</li></ul><h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a>2. 为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小</p><p><strong>如果内存规整</strong>：虚拟机将采用的是<mark>指针碰撞法（Bump The Point）</mark>来为对象分配内存。</p><ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial ，ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。</li></ul><p><strong>如果内存不规整</strong>：虚拟机需要维护一个<mark>空闲列表（Free List）</mark>来为对象分配内存。</p><ul><li>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li></ul><p>选择哪种分配方式由 Java 堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3. 处理并发问题"></a>3. 处理并发问题</h4><ul><li>采用 CAS 失败重试、区域加锁保证更新的原子性</li><li>每个线程预先分配一块 TLAB：通过设置 <code>-XX:+UseTLAB</code>参数来设定</li></ul><h4 id="4-初始化分配到的内存"><a href="#4-初始化分配到的内存" class="headerlink" title="4. 初始化分配到的内存"></a>4. 初始化分配到的内存</h4><p>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p><h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5. 设置对象的对象头"></a>5. 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。</p><h4 id="6-执行-init-方法进行初始化"><a href="#6-执行-init-方法进行初始化" class="headerlink" title="6. 执行 init 方法进行初始化"></a>6. 执行 init 方法进行初始化</h4><p>在 Java 程序的视角看来，初始化才正式开始。<mark>初始化成员变量，执行实例化代码块，调用类的构造方法</mark>，并把堆内对象的首地址赋值给引用变量。</p><p>因此一般来说（由字节码中跟随 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><p><strong>给对象属性赋值的操作</strong></p><ul><li>属性的默认初始化</li><li>显式初始化</li><li>代码块中初始化</li><li>构造器中初始化</li></ul><p><strong>对象实例化的过程</strong></p><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ol><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/attachment/c0db7552106bb333b0921da619fbe64d.png"></p><h3 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h3><p>对象头包含了两部分，分别是<mark>运行时元数据（Mark Word）</mark>和<mark>类型指针</mark>。如果是数组，还需要记录数组的长度</p><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul><li>哈希值（HashCode）</li><li>GC 分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程 ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据 InstanceKlass，确定该对象所属的类型。</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果 CompactFields 参数为 true（默认为 true）：子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><p><strong>举例</strong></p><pre><code class="line-numbers language-java">public class Customer{    int id = 1001;    String name;    Account acct;    {        name = "匿名客户";    }    public Customer() {        acct = new Account();    }}public class CustomerTest{    public static void main(string[] args){        Customer cust=new Customer();    }}</code></pre><p><strong>图示</strong></p><p><img src="/attachment/d624b81576677a1bf4269fb55698da2f.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/attachment/f9d76f30d7b8ca2967d19d869057bdfa.png"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><img src="/attachment/1e7f2cd21587c0875acb295e6f4c82b9.png"></p><p>JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="/attachment/819fc0c4a61a238852fc9ba8f81dea03.png"></p><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/attachment/2f7042acb64b87c816b54bd67cce8810.png"></p><p>reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改</p><h3 id="直接指针（HotSpot-采用）"><a href="#直接指针（HotSpot-采用）" class="headerlink" title="直接指针（HotSpot 采用）"></a>直接指针（HotSpot 采用）</h3><p><img src="/attachment/a0c7dfc632af0acb9776239d8f4844f0.png"></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 方法区</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-fang-fa-qu/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-fang-fa-qu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-方法区"><a href="#【Java-JVM】-方法区" class="headerlink" title="【Java JVM】 方法区"></a>【Java JVM】 方法区</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 方法区date: 2023-06-27 21:38tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 方法区</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/59bb4b5b89aa44b67b0fee7cf403c301.png"></p><p><img src="/attachment/9957ca7ad9cee8e8ce69426c98801ceb.png"></p><p><strong>方法区</strong></p><ul><li>各个线程共享的内存区域。</li><li>JVM 启动的时候被创建</li><li>可以选择固定大小或者可扩展</li><li>方法区的大小决定了系统可以保存多少个类</li><li>如果系统定义了太多的类，导致方法区溢出</li><li>关闭 JVM 就会释放这个区域的内存。</li></ul><p><strong>元空间与永久代最大的区别</strong></p><p>元空间不在虚拟机设置的内存中，而是使用本地内存</p><p><strong>内部结构</strong></p><ul><li>模数</li><li>版本号</li><li>运行时常量池<ul><li>编译期生成的各种字面量与符号引用</li><li>具有动态性</li></ul></li><li>类型信息<ul><li>完整有效名称</li><li>直接父类的完整有效名</li><li>访问修饰符</li><li>直接接口的一个有序列表</li></ul></li><li>域（Field）信息<ul><li>域名称、域类型、域修饰符</li></ul></li><li>方法（Method）信息<ul><li>方法名称</li><li>方法的返回类型（或 void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul></li><li>non-final 的类变量</li><li>全局常量</li><li>属性(Attribute)信息</li></ul><p><img src="/attachment/ae99a235f97699238faa0bc34df370a0.png"></p><p><strong>方法区的演进</strong></p><ul><li>JDK1.6 永久代</li><li>JDK1.7 去永久代 字符串常量池、静态变量移除，保存在堆中</li><li>JDK1.8 元空间 类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</li></ul><p><strong>方法区的垃圾回收</strong></p><ul><li>该类所有的实例都已经被回收</li><li>加载该类的类加载器已经被回收</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用</li></ul><h2 id="【Java-JVM】-方法区-1"><a href="#【Java-JVM】-方法区-1" class="headerlink" title="【Java JVM】 方法区"></a>【Java JVM】 方法区</h2><p><img src="/attachment/c9b76c4abd5ef9039af1c0bbd217a852.png"></p><p>从线程共享与否的角度来看</p><p><img src="/attachment/5d178b8d683053e6e6bfba988dde8584.png"></p><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><img src="/attachment/59bb4b5b89aa44b67b0fee7cf403c301.png"></p><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ec22e5d6086dd6219195b2d886118d65.png" alt="image-20210510195446194"></p><h3 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h3><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 HotSpotJVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，<mark>方法区看作是一块独立于 Java 堆的内存空间</mark>。</p><p><img src="/attachment/f0ae4b24c023d63d49c1f8ecc645940a.png"></p><h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><ul><li>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域。</li><li>方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMemoryError: PermGen space</code> 或者<code>java.lang.OutOfMemoryError: Metaspace</code><ul><li><mark>加载大量的第三方的 jar 包；Tomcat 部署的工程过多（30~50 个）；大量动态的生成反射类</mark></li></ul></li><li>关闭 JVM 就会释放这个区域的内存。</li></ul><h3 id="HotSpot-中方法区的演进"><a href="#HotSpot-中方法区的演进" class="headerlink" title="HotSpot 中方法区的演进"></a>HotSpot 中方法区的演进</h3><p>在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代。</p><p><img src="/attachment/483da7a8da89c592a8941c059481c81b.png"></p><p>本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。《Java 虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。</p><p>现在来看，当年使用永久代，不是好的 idea。导致 Java 程序更容易 OOM（超过<code>-XX:MaxPermsize</code>上限）</p><p>本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。《Java 虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。</p><p>现在来看，当年使用永久代，不是好的 idea。导致 Java 程序更容易 OOM（超过<code>-XX:MaxPermsize</code>上限）</p><p><img src="/attachment/5e6a7171094285966c2bc887302b22b6.png"></p><p>而到了 JDK8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Metaspace）来代替</p><p><img src="/attachment/d6cbaba72c91d6e44cc16731113ce82c.png"></p><p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：<mark>元空间不在虚拟机设置的内存中，而是使用本地内存</mark></p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常</p><h2 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h2><h3 id="设置方法区内存的大小"><a href="#设置方法区内存的大小" class="headerlink" title="设置方法区内存的大小"></a>设置方法区内存的大小</h3><p>方法区的大小不必是固定的，JVM 可以根据应用的需要动态调整。</p><p><strong>jdk7 及以前</strong></p><ul><li><mark>通过<code>-XX:Permsize</code>来设置永久代初始分配空间。默认值是 20.75M</mark></li><li><mark>通过<code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器模式是 82M</mark></li><li>当 JVM 加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code>。</li></ul><p><img src="/attachment/06c458374ee1504b27422bf510f6601e.png"></p><p><strong>JDK8 以后</strong></p><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</li><li>默认值依赖于平台。windows 下，<code>-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制</code>。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的<code>-XX:MetaspaceSize</code>值为 21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li></ul><p><strong>举例 1：《深入理解 Java 虚拟机》的例子</strong></p><p><img src="/attachment/6467374ce758d46e32216db2aa383b4b.png"></p><pre><code class="line-numbers language-java">/** * jdk8中： * -XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=10m * jdk6中： * -XX:PermSize=10m-XX:MaxPermSize=10m */public class OOMTest extends ClassLoader{    public static void main(String[] args){        int j = 0;        try{            OOMTest test = new OOMTest();            for (int i=0;i&lt;10000;i++){                //创建Classwriter对象，用于生成类的二进制字节码                ClassWriter classWriter = new ClassWriter(0);                //指明版本号，public，类名，包名，父类，接口                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, "Class" + i, nu1l, "java/lang/Object", null);                //返回byte[]                byte[] code = classWriter.toByteArray();                //类的加载                test.defineClass("Class" + i, code, 0, code.length); //CLass对象                j++;            }        } finally{            System.out.println(j);        }    }}</code></pre><h3 id="如何解决这些-OOM"><a href="#如何解决这些-OOM" class="headerlink" title="如何解决这些 OOM"></a>如何解决这些 OOM</h3><ol><li>要解决 OOM 异常或 heap space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GCRoots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GCRoots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（<code>-Xmx</code>与<code>-Xms</code>），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p><img src="/attachment/3a1be6724e8bacdfc29320ce5e72440c.png"></p><h3 id="方法区（Method-Area）存储什么？"><a href="#方法区（Method-Area）存储什么？" class="headerlink" title="方法区（Method Area）存储什么？"></a>方法区（Method Area）存储什么？</h3><p>《深入理解 Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：</p><blockquote><p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p></blockquote><p><img src="/attachment/9adfe27cfc53d473026f7dc917020b81.png"></p><h3 id="方法区的内部结构-1"><a href="#方法区的内部结构-1" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient 的某个子集）</p><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（或 void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ol><h4 id="non-final-的类变量"><a href="#non-final-的类变量" class="headerlink" title="non-final 的类变量"></a>non-final 的类变量</h4><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li></ul><pre><code class="line-numbers language-java">public class MethodAreaTest {    public static void main(String[] args) {        Order order = new Order();        order.hello();        System.out.println(order.count);    }}class Order {    public static int count = 1;    public static void hello() {        System.out.println("hello!");    }}</code></pre><h4 id="补充说明：全局常量（static-final）"><a href="#补充说明：全局常量（static-final）" class="headerlink" title="补充说明：全局常量（static final）"></a>补充说明：全局常量（static final）</h4><p>被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><p><img src="/attachment/ade6b28e2aab25aabf0841ae68d8dc5c.png"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚 ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。</li></ul><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p><img src="/attachment/7c9c305ae5f1da388f4d3fd70682acf1.png"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><h4 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h4><p>一个 java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p><p>比如：如下的代码：</p><pre><code class="line-numbers language-java">public class SimpleClass {    public void sayHello() {        System.out.println("hello");    }}</code></pre><p>虽然只有 194 字节，但是里面却使用了 String、System、PrintStream 及 Object 等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><p><img src="/attachment/268f5b17a7e86f22123b35e4f510550f.png"></p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么?"></a>常量池中有什么?</h4><p>击中常量池内存储的数据类型包括：</p><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码：</p><pre><code class="line-numbers language-java">public class MethodAreaTest2 {    public static void main(String args[]) {        Object obj = new Object();    }}</code></pre><p><code>Object obj = new Object();</code>将会被翻译成如下字节码：</p><pre><code class="line-numbers language-java">0: new #2  // Class java/lang/Object1: dup2: invokespecial // Method java/lang/Object "&lt;init&gt;"() V</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li><mark>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</mark></li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过<mark>索引访问</mark>的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<mark>真实地址</mark>。</li><li>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备<mark>动态性</mark>。</li><li>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li></ul><h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><pre><code class="line-numbers language-java">public class MethodAreaDemo {    public static void main(String args[]) {        int x = 500;        int y = 100;        int a = x / y;        int b = 50;        System.out.println(a+b);    }}</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">图示</p><p>collapse: closed</p><p><img src="/attachment/a0cbae16994f267abe7469e7c90c5c64.png" alt></p><p><img src="/attachment/08de10e5a3cea7d1e03bbf7247a8c197.png" alt></p><p><img src="/attachment/371f9178b2e0e72e91498dd53ca7c2cd.png" alt></p><p><img src="/attachment/6f0329b172b363c0c0569a298c2f4a8a.png" alt></p><p><img src="/attachment/54f8e88a4abf386f690b00a634eef544.png" alt></p><p><img src="/attachment/8a37efa2b6d1dadb25195ffb942d8cf8.png" alt></p><p><img src="/attachment/434386a161926b62dd266dc99a745e2f.png" alt></p><p><img src="/attachment/c3cb4f8dae146ce212b3daddd02f2f2c.png" alt></p><p><img src="/attachment/8068de277d82f56799e574d32bb02a72.png" alt></p><p><img src="/attachment/fd5de0bb552d58443d1b0a2c61b161b9.png" alt></p><p><img src="/attachment/0c3e93a35ceae3906fb9a48fff64f503.png" alt></p><p><img src="/attachment/ca14a26ed49d0c8dfd7220054fbf17c7.png" alt></p><p><img src="/attachment/b017ac4c80bd46c5a20fa05f24486df6.png" alt></p><p><img src="/attachment/40bb954f71a88942c65355a8bda2a870.png" alt></p><p><img src="/attachment/03b4a06d751e0c29afa8a4b94c4d9407.png" alt></p><p><img src="/attachment/0449a069f07a07621612fa1a7e3ae498.png" alt></p></div><h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><ol><li>首先明确：只有 Hotspot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java 虚拟机规范》管束，并不要求统一</li><li>Hotspot 中方法区的变化：</li></ol><table><thead><tr><th align="left">JDK1.6 及之前</th><th align="left">有永久代（permanet），静态变量存储在永久代上</th></tr></thead><tbody><tr><td align="left"><strong>JDK1.7</strong></td><td align="left"><strong>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td align="left"><strong>JDK1.8</strong></td><td align="left"><strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</strong></td></tr></tbody></table><p><img src="/attachment/61e3a169451be91df83a3b30133cc781.png"></p><p><img src="/attachment/d5620302918b786b48da661e2bb30778.png"></p><p><img src="/attachment/204b9a748ac6895316c6ef38add16858.png"></p><h3 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h3><p>官网地址：<a href="http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation (java.net)</a></p><p><img src="/attachment/fe8133a594e2af4b095c5546a3931390.png"></p><p>JRockit 是和 HotSpot 融合后的结果，因为 JRockit 没有永久代，所以他们不需要配置永久代</p><p>随着 Java8 的到来，HotSpot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个<mark>与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）</mark>。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p><p>这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生 Perm 区的 oom。比如某个实际 Web 工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</li></ul><pre><code class="line-numbers language-java">"Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space"</code></pre><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。</li></ul><p>有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p><h3 id="StringTable-为什么要调整位置？"><a href="#StringTable-为什么要调整位置？" class="headerlink" title="StringTable 为什么要调整位置？"></a>StringTable 为什么要调整位置？</h3><p>jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><pre><code class="line-numbers language-java">/** * 静态引用对应的对象实体始终都存在堆空间 * jdk7: * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails * jdk8: * -Xms200m -Xmx200m-XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails */public class StaticFieldTest {    private static byte[] arr = new byte[1024 * 1024 * 100];    public static void main(String[] args) {        System.out.println(StaticFieldTest.arr);        try {            Thread.sleep(1000000);        } catch (InterruptedException e){            e.printStackTrace();        }    }}</code></pre><pre><code class="line-numbers language-java">/** * staticobj、instanceobj、Localobj存放在哪里？ */public class StaticobjTest {    static class Test {        static ObjectHolder staticobj = new ObjectHolder();        ObjectHolder instanceobj = new ObjectHolder();        void foo() {            ObjectHolder localobj = new ObjectHolder();            System.out.println("done");        }    }    private static class ObjectHolder {        public static void main(String[] args) {            Test test = new StaticobjTest.Test();            test.foo();        }    }}</code></pre><p>使用 JHSDB 工具进行分析，这里细节略掉</p><p><img src="/attachment/39c462e94e423a87a1d0b57682eeff48.png"></p><p>staticobj 随着 Test 的类型信息存放在方法区，instanceobj 随着 Test 的对象实例存放在 Java 堆，localobject 则是存放在 foo()方法栈帧的局部变量表中。</p><p><img src="/attachment/24be39b00b869cd685514171e5b30d43.png"></p><p>测试发现：三个对象的数据在内存中的地址都落在 Eden 区范围内，所以结论：只要是对象实例必然会在 Java 堆中分配。</p><p>接着，找到了一个引用该 staticobj 对象的地方，是在一个 java.lang.Class 的实例里，并且给出了这个实例的地址，通过 Inspector 查看该对象实例，可以清楚看到这确实是一个 java.lang.Class 类型的对象实例，里面有一个名为 staticobj 的实例字段：</p><p>从《Java 虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 class 对象存放在一起，存储于 Java 堆之中，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 zGC 收集器就不支持类卸载）。</p><p>一般来说<mark>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</mark>。但是这部分区域的回收<mark>有时又确实是必要的</mark>。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p><p><mark>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</mark></p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，<mark>只要常量池中的常量没有被任何地方引用，就可以被回收</mark>。</p><p>回收废弃常量与回收 Java 堆中的对象非常类似。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><mark>该类所有的实例都已经被回收</mark>，也就是 Java 堆中不存在该类及其任何派生子类的实例。</li><li><mark>加载该类的类加载器已经被回收</mark>，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</li><li><mark>该类对应的 java.lang.Class 对象没有在任何地方被引用</mark>，无法在任何地方通过反射访问该类的方法。</li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，<u>通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</u>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/attachment/9957ca7ad9cee8e8ce69426c98801ceb.png"></p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p><mark>百度</mark>：</p><p>说一下 JVM 内存模型吧，有哪些区？分别干什么的？</p><p><mark>蚂蚁金服</mark>：</p><p>Java8 的内存分代改进 JVM 内存分哪几个区，每个区的作用是什么？<br>一面：JVM 内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个 survivor 区？<br>二面：Eden 和 survior 的比例分配</p><p><mark>小米</mark>：</p><p>jvm 内存分区，为什么要有新生代和老年代</p><p><mark>字节跳动</mark>：</p><p>二面：Java 的内存分区<br>二面：讲讲 vm 运行时数据库区 什么时候对象会进入老年代？</p><p><mark>京东</mark>：</p><p>JVM 的内存结构，Eden 和 Survivor 比例。<br>JVM 内存为什么要分成新生代，老年代，持久代。<br>新生代中为什么要分为 Eden 和 survivor。</p><p><mark>天猫</mark>：</p><p>一面：Jvm 内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM 的内存模型，Java8 做了什么改</p><p><mark>拼多多</mark>：</p><p>JVM 内存分哪几个区，每个区的作用是什么？</p><p><mark>美团</mark>：</p><p>java 内存分配 jvm 的永久代中会发生垃圾回收吗？<br>一面：jvm 内存分区，为什么要有新生代和老年代？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 堆</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-dui/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-dui/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-堆"><a href="#【Java-JVM】-堆" class="headerlink" title="【Java JVM】 堆"></a>【Java JVM】 堆</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 堆date: 2023-06-27 08:47tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 堆</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>堆的特性</strong></p><ul><li>堆针对一个 JVM 进程来说是唯一的， 所有的线程共享 Java 堆</li><li>堆内存的大小是可以调节的。</li><li>物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>所有的对象实例以及数组都应当在运行时分配在堆上。</li><li>是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li></ul><p><img src="/attachment/1434661924f4062a9b65dc180e0f15e2.png"></p><p><strong>堆内存细分</strong></p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><p><img src="/attachment/9dd7d25d52002c58513e2214c35050dd.png"></p><p><strong>对象分配过程</strong></p><ol><li>new 的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</li><li>啥时候能去养老区呢？可以设置次数。默认是 15 次。<ul><li><mark>可以设置参数：<code>-Xx:MaxTenuringThreshold= N</code>进行设置</mark></li></ul></li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。</li></ol><p><img src="/attachment/8e785d6c1a2318cb2e5dfaf3139505ee.png"></p><ul><li><mark>针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是 to</mark></li><li><mark>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</mark></li></ul><p><strong>分代GC</strong></p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC / Old GC）：只是老年代的圾收集。<ul><li>目前，只有 CMSGC 会有单独收集老年代的行为。</li><li><mark>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</li></ul><p><strong>堆空间分代思想</strong></p><ul><li>新生代：有 Eden、两块大小相同的 survivor（又称为 from/to，s0/s1）构成，to 总为空。</li><li>老年代：存放新生代中经历多次 GC 仍然存活的对象。</li></ul><p><strong>内存分配策略</strong></p><ul><li>优先分配到 Eden</li><li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断：如果 survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保： <code>-XX:HandlePromotionFailure</code></li></ul><p><strong>为对象分配内存：TLAB</strong></p><p>对 Eden 区域继续进行划分，JVM 为<mark>每个线程分配了一个私有缓存区域</mark>，它包含在 Eden 空间内。<br>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量, 将这种内存分配方式称之为<mark>快速分配策略</mark>。</p><p><strong>逃逸分析</strong></p><p>对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<mark>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</mark>.。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><p><strong>逃逸分析：代码优化</strong></p><ul><li>栈上分配</li><li>同步省略</li><li>分离对象或标量替换</li></ul><h2 id="堆（Heap）的核心概述"><a href="#堆（Heap）的核心概述" class="headerlink" title="堆（Heap）的核心概述"></a>堆（Heap）的核心概述</h2><p>堆针对一个 JVM 进程来说是唯一的，也就是一个进程只有一个 JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p><img src="/attachment/b51e9dffe8c3478bace823f8eb6b1cc5.png"></p><p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p><p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><p>《Java 虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（<code>The heap is the run-time data area from which memory for all class instances and arrays is allocated</code>）</p><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><p>堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p><p><img src="/attachment/1434661924f4062a9b65dc180e0f15e2.png"></p><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+<mark>永久区</mark></p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space 永久区 Perm</li></ul><p>Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+<mark>元空间</mark></p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><p>约定：新生区（代）&lt;=&gt;年轻代 、 养老区&lt;=&gt;老年区（代）、 永久区&lt;=&gt;永久代</p><h3 id="堆空间内部结构（JDK7）"><a href="#堆空间内部结构（JDK7）" class="headerlink" title="堆空间内部结构（JDK7）"></a>堆空间内部结构（JDK7）</h3><p><img src="/attachment/3779a9d93bd8c2aefb93572560bcbe1c.png"></p><h3 id="堆空间内部结构（JDK8）"><a href="#堆空间内部结构（JDK8）" class="headerlink" title="堆空间内部结构（JDK8）"></a>堆空间内部结构（JDK8）</h3><p><img src="/attachment/9dd7d25d52002c58513e2214c35050dd.png"></p><h2 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h2><h3 id="堆空间大小的设置"><a href="#堆空间大小的设置" class="headerlink" title="堆空间大小的设置"></a>堆空间大小的设置</h3><p>Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xms”用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li>“-Xmx”则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li></ul><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出 OutOfMemoryError 异常。</p><p>通常会将-Xms 和-Xmx 两个参数配置相同的值，其目的是<mark>为了能够在 ava 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</mark></p><p>默认情况下</p><ul><li>初始内存大小：物理电脑内存大小 / 64</li><li>最大内存大小：物理电脑内存大小 / 4</li></ul><h3 id="OutOfMemory-举例"><a href="#OutOfMemory-举例" class="headerlink" title="OutOfMemory 举例"></a>OutOfMemory 举例</h3><pre><code class="line-numbers language-java">public class OOMTest {    public static void main(String[]args){        ArrayList&lt;Picture&gt; list = new ArrayList&lt;&gt;();        while(true){            try {                Thread.sleep(20);            } catch (InterruptedException e){                e.printStackTrace();            }            list.add(new Picture(new Random().nextInt(1024*1024)));        }    }}</code></pre><pre><code class="line-numbers language-java">Exception in thread "main" java.lang.OutofMemoryError: Java heap space    at com.atguigu. java.Picture.&lt;init&gt;(OOMTest. java:25)    at com.atguigu.java.O0MTest.main(OOMTest.java:16)</code></pre><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在 JVM 中的 Java 对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致</li></ul><p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）</p><p>下面这参数开发中一般不会调：</p><p><img src="/attachment/bff5926f5d63d4ab9a2c3df000d1e417.png"></p><p>配置新生代与老年代在堆结构的占比。</p><ul><li>默认<code>-XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3</li><li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5</li></ul><p>在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 8：1：1</p><p>当然开发人员可以通过选项“<code>-xx:SurvivorRatio</code>”调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></p><p><mark>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。</mark>绝大部分的 Java 对象的销毁都在新生代进行了。</p><ul><li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的。</li></ul><p>可以使用选项”<code>-Xmn</code>“设置新生代最大内存大小，这个参数一般使用默认值就可以了。</p><p><img src="/attachment/2fc6b56fe45c90ced8a4761e8e666c68.png"></p><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new 的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</li><li>啥时候能去养老区呢？可以设置次数。默认是 15 次。<ul><li><mark>可以设置参数：<code>-Xx:MaxTenuringThreshold= N</code>进行设置</mark></li></ul></li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。</li></ol><pre><code class="line-numbers language-java">java.lang.OutofMemoryError: Java heap space</code></pre><p><img src="/attachment/afd07e824bee4156aa6d93fda27658ae.png"></p><p><strong>流程图</strong></p><p><img src="/attachment/8e785d6c1a2318cb2e5dfaf3139505ee.png"></p><p><strong>总结</strong></p><ul><li><mark>针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是 to</mark></li><li><mark>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</mark></li></ul><p><strong>常用调优工具（在 JVM 下篇：性能监控与调优篇会详细介绍）</strong></p><ul><li>JDK 命令行</li><li>Eclipse:Memory Analyzer Tool</li><li>Jconsole</li><li>VisualVM</li><li>Jprofiler</li><li>Java Flight Recorder</li><li>GCViewer</li><li>GC Easy</li></ul><h2 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h2><p>JVM 在进行 GC 时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 Hotspot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC / Old GC）：只是老年代的圾收集。<ul><li>目前，只有 CMSGC 会有单独收集老年代的行为。</li><li><mark>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</li></ul><h3 id="年轻代-GC（Minor-GC）触发机制"><a href="#年轻代-GC（Minor-GC）触发机制" class="headerlink" title="年轻代 GC（Minor GC）触发机制"></a>年轻代 GC（Minor GC）触发机制</h3><ul><li>当年轻代空间不足时，就会触发 MinorGC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。（每次 Minor GC 会清理年轻代的内存。）</li><li>因为<mark>Java 对象大多都具备朝生夕灭的特性</mark>.，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li><li>Minor GC 会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ul><p><img src="/attachment/e85cc346dc69b8b92c4d6a0d98d19d02.png"></p><h3 id="老年代-GC（Major-GC-x2F-Full-GC）触发机制"><a href="#老年代-GC（Major-GC-x2F-Full-GC）触发机制" class="headerlink" title="老年代 GC（Major GC / Full GC）触发机制"></a>老年代 GC（Major GC / Full GC）触发机制</h3><ul><li><p>指发生在老年代的 GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了</p></li><li><p>出现了 Major Gc，经常会伴随至少一次的 Minor GC（但非绝对的，在 Paralle1 Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发 Minor Gc。如果之后空间还不足，则触发 Major GC</li></ul></li><li><p>Major GC 的速度一般会比 Minor GC 慢 10 倍以上，STW 的时间更长</p></li><li><p>如果 Major GC 后，内存还不足，就报 OOM 了</p></li></ul><h3 id="Full-GC-触发机制（后面细讲）："><a href="#Full-GC-触发机制（后面细讲）：" class="headerlink" title="Full GC 触发机制（后面细讲）："></a>Full GC 触发机制（后面细讲）：</h3><p>触发 Full GC 执行的情况有如下五种：</p><ol><li>调用 System.gc()时，系统建议执行 Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li><li>由 Eden 区、survivor space0（From Space）区向 survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p><mark>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</mark></p><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把 Java 堆分代？不分代就不能正常工作了吗？</p><p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有 Eden、两块大小相同的 survivor（又称为 from/to，s0/s1）构成，to 总为空。</li><li>老年代：存放新生代中经历多次 GC 仍然存活的对象。</li></ul><p><img src="/attachment/b1ed1563befbf6d0921d1a256ab57ada.png"></p><p>其实不分代完全可以，分代的唯一理由就是优化 GC 性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="/attachment/a44c4e59f124d8424de5f90f1fb398b4.png"></p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 survivor 空间中，并将对象年龄设为 1。对象在 survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到 Eden</li><li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断：如果 survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保： <code>-XX:HandlePromotionFailure</code></li></ul><h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="为什么有-TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么有-TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么有 TLAB（Thread Local Allocation Buffer）？"></a>为什么有 TLAB（Thread Local Allocation Buffer）？</h3><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li></ul><h3 id="什么是-TLAB？"><a href="#什么是-TLAB？" class="headerlink" title="什么是 TLAB？"></a>什么是 TLAB？</h3><ul><li>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为<mark>每个线程分配了一个私有缓存区域</mark>，它包含在 Eden 空间内。</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<mark>快速分配策略</mark>。</li><li>据我所知所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。</li></ul><p><img src="/attachment/b514a6f31fd0de1cc9e3f729b0b7ca1f.png"></p><h3 id="TLAB-的再说明"><a href="#TLAB-的再说明" class="headerlink" title="TLAB 的再说明"></a>TLAB 的再说明</h3><ul><li>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但<mark>JVM 确实是将 TLAB 作为内存分配的首选</mark>。</li><li>在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启 TLAB 空间。</li><li>默认情况下，TLAB 空间的内存非常小，<mark>仅占有整个 Eden 空间的 1%</mark>，当然我们可以通过选项 “<code>-XX:TLABWasteTargetPercent</code>” 设置 TLAB 空间所占用 Eden 空间的百分比大小。</li><li>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</li></ul><p><img src="/attachment/8f8efd7b2a02c0b4e7a8c03fd1b83366.png"></p><h2 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p><pre><code class="line-numbers language-java">// 详细的参数内容会在JVM下篇：性能监控与调优篇中进行详细介绍，这里先熟悉下-XX:+PrintFlagsInitial  //查看所有的参数的默认初始值-XX:+PrintFlagsFinal  //查看所有的参数的最终值（可能会存在修改，不再是初始值）-Xms  //初始堆空间内存（默认为物理内存的1/64）-Xmx  //最大堆空间内存（默认为物理内存的1/4）-Xmn  //设置新生代的大小。（初始值及最大值）-XX:NewRatio  //配置新生代与老年代在堆结构的占比-XX:SurvivorRatio  //设置新生代中Eden和S0/S1空间的比例-XX:MaxTenuringThreshold  //设置新生代垃圾的最大年龄-XX:+PrintGCDetails //输出详细的GC处理日志//打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc-XX:HandlePromotionFalilure：//是否设置空间分配担保</code></pre><p>在发生 Minor GC 之前，虚拟机会<mark>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</mark>。</p><ul><li>如果大于，则此次 Minor GC 是安全的</li><li>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允担保失败。<ul><li>如果<code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul><li>如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的；</li><li>如果小于，则改为进行一次 Full GC。</li></ul></li><li>如果<code>HandlePromotionFailure=false</code>，则改为进行一次 Full Gc。</li></ul></li></ul><p>在 JDK6 Update24 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 openJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK6 Update 24 之后的规则变为<mark>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC</mark>，否则将进行 FullGC。</p><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><p>在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述：</p><blockquote><p>随着 JIT 编译期的发展与<mark>逃逸分析技术</mark>逐渐成熟，<mark>栈上分配</mark>、<mark>标量替换优化技术</mark>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></blockquote><p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<mark>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</mark>.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p><h3 id="6-X-1-逃逸分析概述"><a href="#6-X-1-逃逸分析概述" class="headerlink" title="6.X.1. 逃逸分析概述"></a>6.X.1. 逃逸分析概述</h3><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p><p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><p><strong>举例 1</strong></p><pre><code class="line-numbers language-java">public void my_method() {    V v = new V();    // use v    // ....    v = null;}</code></pre><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧</p><pre><code class="line-numbers language-java">public static StringBuffer createStringBuffer(String s1, String s2) {    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb;}</code></pre><p>上述方法如果想要<code>StringBuffer sb</code>不发生逃逸，可以这样写</p><pre><code class="line-numbers language-java">public static String createStringBuffer(String s1, String s2) {    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb.toString();}</code></pre><p><strong>举例 2</strong></p><pre><code class="line-numbers language-java">public class EscapeAnalysis {    public EscapeAnalysis obj;    /**     * 方法返回EscapeAnalysis对象，发生逃逸     * @return     */    public EscapeAnalysis getInstance() {        return obj == null ? new EscapeAnalysis() : obj;    }    /**     * 为成员属性赋值，发生逃逸     */    public void setObj() {        this.obj = new EscapeAnalysis();    }    /**     * 对象的作用于仅在当前方法中有效，没有发生逃逸     */    public void useEscapeAnalysis() {        EscapeAnalysis e = new EscapeAnalysis();    }    /**     * 引用成员变量的值，发生逃逸     */    public void useEscapeAnalysis2() {        EscapeAnalysis e = getInstance();    }}</code></pre><p><strong>参数设置</strong></p><p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析</li><li>通过选项“<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果</li></ul><p><strong>结论</strong>：<mark>开发中能使用局部变量的，就不要使用在方法外定义。</mark></p><h3 id="逃逸分析：代码优化"><a href="#逃逸分析：代码优化" class="headerlink" title="逃逸分析：代码优化"></a>逃逸分析：代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、<mark>栈上分配</mark>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p><p>二、<mark>同步省略</mark>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>三、<mark>分离对象或标量替换</mark>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。</p><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p><strong>常见的栈上分配的场景</strong></p><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p><h4 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h4><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT 编译器可以<mark>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</mark>。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<mark>锁消除</mark>。</p><p><strong>举例</strong></p><pre><code class="line-numbers language-java">public void f() {    Object hellis = new Object();    synchronized(hellis) {        System.out.println(hellis);    }}</code></pre><p>代码中对 hellis 这个对象加锁，但是 hellis 对象的生命周期只在 f()方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉，优化成：</p><pre><code class="line-numbers language-java">public void f() {    Object hellis = new Object();    System.out.println(hellis);}</code></pre><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p><mark>标量（scalar）</mark>是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做<mark>聚合量（Aggregate）</mark>，Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><p><strong>举例</strong></p><pre><code class="line-numbers language-java">public static void main(String args[]) {    alloc();}private static void alloc() {    Point point = new Point(1,2);    System.out.println("point.x" + point.x + ";point.y" + point.y);}class Point {    private int x;    private int y;}</code></pre><p>以上代码，经过标量替换后，就会变成</p><pre><code class="line-numbers language-java">private static void alloc() {    int x = 1;    int y = 2;    System.out.println("point.x = " + x + "; point.y=" + y);}</code></pre><p>可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。</p><p><strong>标量替换参数设置</strong></p><p>参数<code>-XX:EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配到栈上。</p><p>上述代码在主函数中进行了 1 亿次 alloc。调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码：</p><pre><code class="line-numbers language-shell">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></pre><p>这里设置参数如下：</p><ul><li>参数<code>-server</code>：启动 Server 模式，因为在 server 模式下，才可以启用逃逸分析。</li><li>参数<code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</li><li>参数<code>-Xmx10m</code>：指定了堆空间最大为 10MB</li><li>参数<code>-XX:+PrintGC</code>：将打印 Gc 日志</li><li>参数<code>-XX:+EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="逃逸分析小结：逃逸分析并不成熟"><a href="#逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="逃逸分析小结：逃逸分析并不成熟"></a>逃逸分析小结：逃逸分析并不成熟</h3><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是<mark>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </mark></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也<mark>是即时编译器优化技术中一个十分重要的手段</mark>。</p><p>注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确<mark>所有的对象实例都是创建在堆上</mark>。</p><p>目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从 survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 MinorGc。</p><p>当 GC 发生在老年代时则被称为 MajorGc 或者 FullGC。一般的，MinorGc 的发生频率要比 MajorGC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 本地方法接口和本地方法栈</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-ben-di-fang-fa-jie-kou-he-ben-di-fang-fa-zhan/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-ben-di-fang-fa-jie-kou-he-ben-di-fang-fa-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-本地方法接口和本地方法栈"><a href="#【Java-JVM】-本地方法接口和本地方法栈" class="headerlink" title="【Java JVM】 本地方法接口和本地方法栈"></a>【Java JVM】 本地方法接口和本地方法栈</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 本地方法接口和本地方法栈date: 2023-06-27 08:41tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 本地方法接口和本地方法栈</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>本地方法</strong></p><p>一个 Native Method 是一个 Java 调用非 Java 代码的接囗</p><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。</p><ul><li>与 Java 环境的交互</li><li>与操作系统的交互</li><li>Sun’s Java</li></ul><p><strong>本地方法栈</strong></p><p>Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</p><ul><li>线程私有的</li><li>允许被实现成固定或者是可动态扩展的内存大小。</li><li>本地方法是使用 C 语言实现的。</li></ul><h2 id="什么是本地方法？"><a href="#什么是本地方法？" class="headerlink" title="什么是本地方法？"></a>什么是本地方法？</h2><p>简单地讲，<mark>一个 Native Method 是一个 Java 调用非 Java 代码的接囗</mark>。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++中，你可以用 extern “c” 告知 c++编译器去调用一个 c 的函数。</p><blockquote><p>A native method is a Java method whose implementation is provided by non-java code.</p></blockquote><p>在定义一个 native method 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 java 语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。</p><p><img src="/attachment/5ca7a7cb376d56c2e03359300c0206c4.png"></p><p>举例</p><pre><code class="line-numbers language-java">public class IHaveNatives{    public native void methodNative1(int x);    public native static long methodNative2();    private native synchronized float methodNative3(Object o);    native void methodNative4(int[] ary) throws Exception;}</code></pre><p>标识符 native 可以与其它 java 标识符连用，但是 abstract 除外</p><h2 id="为什么使用-Native-Method？"><a href="#为什么使用-Native-Method？" class="headerlink" title="为什么使用 Native Method？"></a>为什么使用 Native Method？</h2><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><p><strong>与 Java 环境的交互</strong></p><p><mark>有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。</mark>你可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</p><p><strong>与操作系统的交互</strong></p><p>JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。<mark>通过使用本地方法，我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 c 写的。</mark>还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><p><strong>Sun’s Java</strong></p><p><mark>Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。</mark>jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority()方法是用 Java 实现的，但是它实现调用的是该类里的本地方法 setPriority()。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 Windows 95 的平台上，这个本地方法最终将调用 Win32 setPriority() ApI。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVw 调用。</p><p><strong>现状</strong></p><p><mark>目前该方法使用的越来越少了，除非是与硬件有关的应用</mark>，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><mark>Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</mark></p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><p>本地方法是使用 C 语言实现的。</p><p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p><p><img src="/attachment/77d70a4e20bd0b9d633f23e7a887df65.png"></p><p><mark>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</mark></p><ul><li>本地方法可以通过本地方法接口来<mark>访问虚拟机内部的运行时数据区</mark>。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p><mark>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</mark>如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 虚拟机栈</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-xu-ni-ji-zhan/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-xu-ni-ji-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-虚拟机栈"><a href="#【Java-JVM】-虚拟机栈" class="headerlink" title="【Java JVM】 虚拟机栈"></a>【Java JVM】 虚拟机栈</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 虚拟机栈date: 2023-06-26 20:10tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 虚拟机栈</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>内存中的栈与堆</strong></p><p><mark>栈是运行时的单位，而堆是存储的单位</mark></p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><strong>栈帧</strong></p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><ul><li><mark>局部变量表（Local Variables）</mark><ul><li>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类<strong>基本数据类型</strong>、<strong>对象引用（reference）</strong>，以及 <strong>returnAddress 类型</strong>。</li><li>线程的私有数据，不存在数据安全问题</li><li>局部变量表所需的容量大小是在编译期确定下来的</li><li>方法嵌套调用的次数由栈的大小决定</li><li>局部变量表中的变量只在当前方法调用中有效</li></ul></li><li><mark>操作数栈（operand Stack）（或表达式栈）</mark><ul><li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</li><li>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</li></ul></li><li><mark>动态链接（DynamicLinking）</mark>（或指向运行时常量池的方法引用）<ul><li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。</li><li>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li></ul></li><li><mark>方法返回地址（Return Address）</mark>（或方法正常退出或者异常退出的定义）<ul><li>调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</li></ul></li><li><mark>一些附加信息</mark></li></ul><p><strong>方法的调用：解析与分配</strong></p><ul><li><p>静态链接</p><ul><li>如果被调用的<mark>目标方法在编译期可知，且运行期保持不变时</mark>，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li></ul></li><li><p>动态链接</p><ul><li>如果<mark>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用</mark>，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</li></ul></li><li><p>早期绑定</p><ul><li>指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定</li></ul></li><li><p>晚期绑定</p><ul><li>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</li></ul></li></ul><p><strong>方法重写的本质</strong></p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li><li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodsrror 异常。</li></ol><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><h3 id="虚拟机栈出现的背景"><a href="#虚拟机栈出现的背景" class="headerlink" title="虚拟机栈出现的背景"></a>虚拟机栈出现的背景</h3><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p><p><mark>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</mark>。</p><h3 id="初步印象"><a href="#初步印象" class="headerlink" title="初步印象"></a>初步印象</h3><p>有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p><h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h3><p><mark>栈是运行时的单位，而堆是存储的单位</mark></p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="/attachment/65679828a0aa144040eec979b770b1ba.png"></p><h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h3><h4 id="Java-虚拟机栈是什么？"><a href="#Java-虚拟机栈是什么？" class="headerlink" title="Java 虚拟机栈是什么？"></a>Java 虚拟机栈是什么？</h4><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用，是线程私有的。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>生命周期和线程一致</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><h4 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h4><p>栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。</p><p>JVM 直接对 Java 栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="/attachment/020448e4897168f9db30c8aaa0951c02.png"></p><h4 id="面试题：开发中遇到哪些异常？"><a href="#面试题：开发中遇到哪些异常？" class="headerlink" title="面试题：开发中遇到哪些异常？"></a>面试题：开发中遇到哪些异常？</h4><p><strong>栈中可能出现的异常</strong></p><p>Java 虚拟机规范允许<mark>Java 栈的大小是动态的或者是固定不变的</mark>。</p><ul><li>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个<mark>StackOverflowError </mark>异常。</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<mark> OutOfMemoryError </mark>异常。</li></ul><pre><code class="line-numbers language-java">public static void main(String[] args) {    test();}public static void test() {    test();}//抛出异常：Exception in thread"main"java.lang.StackoverflowError//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</code></pre><p><strong>设置栈内存大小</strong></p><p>我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><pre><code class="line-numbers language-java">public class StackDeepTest{    private static int count=0;    public static void recursion(){        count++;        recursion();    }    public static void main(String args[]){        try{            recursion();        } catch (Throwable e){            System.out.println("deep of calling="+count);            e.printstackTrace();        }    }}</code></pre><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以<mark>栈帧（Stack Frame）的格式存在</mark>。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>JVM 直接对 Java 栈的操作只有两个，就是对<mark>栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则</mark>。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<mark>当前栈帧（Current Frame）</mark>，与当前栈帧相对应的方法就是<mark>当前方法（Current Method）</mark>，定义这个方法的类就是<mark>当前类（Current Class）</mark>。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="/attachment/2a6d668718c304aba6313ef388239a8d.png"></p><p>不同线程中所包含的栈帧是<strong>不允许</strong>存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java 方法有两种返回函数的方式，<mark>一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</mark>。</p><pre><code class="line-numbers language-java">public class CurrentFrameTest{    public void methodA(){        system.out.println（"当前栈帧对应的方法-&gt;methodA");        methodB();        system.out.println（"当前栈帧对应的方法-&gt;methodA");    }    public void methodB(){        System.out.println（"当前栈帧对应的方法-&gt;methodB");    }</code></pre><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><mark>局部变量表（Local Variables）</mark></li><li><mark>操作数栈（operand Stack）（或表达式栈）</mark></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="/attachment/3fe56e305a573fe9277ccbbfb97c591f.png"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="/attachment/579ce824212ae244c82d6fc0402b71e9.png"></p><h2 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h2><p>局部变量表也被称之为局部变量数组或本地变量表</p><ul><li><mark>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</mark>，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<mark>不存在数据安全问题</mark></li><li><mark>局部变量表所需的容量大小是在编译期确定下来的</mark>，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li><mark>方法嵌套调用的次数由栈的大小决定</mark>。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><mark>局部变量表中的变量只在当前方法调用中有效</mark>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul><h3 id="关于-Slot-的理解"><a href="#关于-Slot-的理解" class="headerlink" title="关于 Slot 的理解"></a>关于 Slot 的理解</h3><ul><li>局部变量表，最基本的存储单元是 Slot（变量槽）</li><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束。</li><li>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference），returnAddress 类型的变量。</li><li>在局部变量表里，32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 slot。</li><li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。</li><li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<mark>按照顺序被复制</mark>到局部变量表中的每一个 slot 上</li><li><mark>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</mark>。（比如：访问 long 或 doub1e 类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<mark>该对象引用 this 将会存放在 index 为 0 的 slot 处</mark>，其余的参数按照参数表顺序继续排列。</li></ul><p><img src="/attachment/92133e7cc7ccf4d20c715af4423eb839.png"></p><h3 id="Slot-的重复利用"><a href="#Slot-的重复利用" class="headerlink" title="Slot 的重复利用"></a>Slot 的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><pre><code class="line-numbers language-java">public class SlotTest {    public void localVarl() {        int a = 0;        System.out.println(a);        int b = 0;    }    public void localVar2() {        {            int a = 0;            System.out.println(a);        }        //此时的就会复用a的槽位        int b = 0;    }}</code></pre><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。<br>我们知道类变量表有两次初始化的机会，第一次是在“<mark>准备阶段</mark>”，执行系统初始化，对类变量设置零值，另一次则是在“<mark>初始化</mark>”阶段，赋予程序员在代码中定义的初始值。<br>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><pre><code class="line-numbers language-java">public void test(){    int i;    System.out.println(i);}</code></pre><p>这样的代码是<strong>错误</strong>的，没有赋值不能够使用。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p><mark>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</mark>。</p><h2 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h2><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 <mark>操作数栈</mark>，也可以称之为<mark>表达式栈（Expression Stack）</mark></p><p><mark>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</mark></p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="/attachment/12ace445a989be337e5f2662ebfb3af6.png"></p><p>代码举例</p><pre><code class="line-numbers language-java">public void testAddOperation(){    byte i = 15;    int j = 8;    int k = i + j;}</code></pre><p>字节码指令信息</p><pre><code class="line-numbers language-java">public void testAddOperation();    Code:    0: bipush 15    2: istore_1    3: bipush 8    5: istore_2    6:iload_1    7:iload_2    8:iadd    9:istore_3    10:return</code></pre><p>操作数栈，<mark>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</mark>。</p><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<mark>这个方法的操作数栈是空的</mark>。</p><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性中，为 max_stack 的值。</p><p>栈中的任何一个元素都是可以任意的 Java 数据类型</p><ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul><p>操作数栈<mark>并非采用访问索引的方式来进行数据访问</mark>的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p><mark>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</mark>，并更新 PC 寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p><p>另外，我们说 Java 虚拟机的<mark>解释引擎是基于栈的执行引擎</mark>，其中的栈指的就是操作数栈。</p><h2 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h2><pre><code class="line-numbers language-java">public void testAddOperation() {    byte i = 15;    int j = 8;    int k = i + j;}</code></pre><p>使用 javap 命令反编译 class 文件：<code> javap -v 类名.class</code></p><pre><code class="line-numbers language-java">public void testAddoperation(); Code:0: bipush 15 2: istore_1 3: bipush 85: istore_26: iload_17: iload_28: iadd9: istore_3    10: return</code></pre><pre><code class="line-numbers language-ad-tip">title: 图示collapse: closed![](attachment/ad89529ba7178a5ebacc8a78a081ded2.png)![](attachment/2dadc03355600dd390b398bfc5676dbf.png)![](attachment/75451e7d0a015ce182714e467fc954a9.png)![](attachment/e08ebc2a6d61b807cfdb0db3affb6e0a.png)![](attachment/959bdd3af6f843ed0f5579ead533a764.png)![](attachment/c2a1e4c3bb9c573fe87ebf0e0830b855.png)![](attachment/7c524b0634343f8635e9e415efebb3e2.png)![](attachment/87decfa0c98b8efbdc2e42aeafc7c580.png)</code></pre><h2 id="栈顶缓存技术（Top-Of-Stack-Cashing）技术"><a href="#栈顶缓存技术（Top-Of-Stack-Cashing）技术" class="headerlink" title="栈顶缓存技术（Top Of Stack Cashing）技术"></a>栈顶缓存技术（Top Of Stack Cashing）技术</h2><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<mark>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</mark>。</p><h2 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h2><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p><p>每一个栈帧内部都包含一个指向<mark>运行时常量池中该栈帧所属方法的引用</mark>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<mark>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</mark>。</p><p><img src="/attachment/20620d1c366828c0879829e44b875f9a.png"></p><p>为什么需要运行时常量池呢？</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p><h2 id="方法的调用：解析与分配"><a href="#方法的调用：解析与分配" class="headerlink" title="方法的调用：解析与分配"></a>方法的调用：解析与分配</h2><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的<mark>目标方法在编译期可知，且运行期保持不变时</mark>，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>如果<mark>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用</mark>，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><p><mark>静态链接和动态链接不是名词，而是动词，这是理解的关键。</mark></p><hr><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<mark>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</mark></p><h3 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h3><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h3 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h3><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><hr><p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<mark>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</mark></p><p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++语言中的虚函数（C++中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p><hr><h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><p>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。</p><p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例：</p><pre><code class="line-numbers language-java">xxxxxxxxxx&nbsp; class Father {&nbsp;&nbsp;    public static void print(String str) {&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println("father " + str);&nbsp;&nbsp;    }&nbsp;&nbsp;    private void show(String str) {&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println("father" + str);&nbsp;    }}class Son extends Father {&nbsp;&nbsp;    public class VirtualMethodTest {&nbsp;&nbsp;&nbsp;&nbsp;        public static void main(String[] args) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            Son.print("coder");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             // Father fa=new Father(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;              // fa.show("atguigu.com"); &nbsp; &nbsp; &nbsp;          } &nbsp;      }}</code></pre><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul><li><mark>invokestatic：调用静态方法，解析阶段确定唯一方法版本</mark></li><li><mark>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</mark></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。<mark>其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。</mark></p><p><strong>关于 invokednamic 指令</strong></p><ul><li><p>JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是<mark>Java 为了实现「动态类型语言」支持而做的一种改进。</mark></p></li><li><p>但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。<mark>直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</mark></p></li><li><p>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</p></li></ul><h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，<mark>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</mark>，这是动态语言的一个重要特征。</p><h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><p><strong>Java 语言中方法重写的本质：</strong></p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li><li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodsrror 异常。</li></ol><p><strong>IllegalAccessError 介绍</strong></p><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。<mark>因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</mark></p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><p><img src="/attachment/17f5dbe93d4620016c169fe6d51ee85d.png"></p><p>举例 2：</p><pre><code class="line-numbers language-java">interface Friendly {    void sayHello();    void sayGoodbye();}class Dog {    public void sayHello() {}    public String tostring() {        return "Dog";    }}class Cat implements Friendly {    public void eat() {}    public void sayHello() {}    public void sayGoodbye() {}    protected void finalize() {}}class CockerSpaniel extends Dog implements Friendly {    public void sayHello() {        super.sayHello();    }    public void sayGoodbye() {}}</code></pre><p><img src="/attachment/1c49d88c264acaba1b6f07dac48ef671.png"></p><h2 id="方法返回地址（return-address）"><a href="#方法返回地址（return-address）" class="headerlink" title="方法返回地址（return address）"></a>方法返回地址（return address）</h2><p>存放调用该方法的 pc 寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<mark>调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</mark>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<mark>正常完成出口</mark>；<ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long 类型），freturn（Float 类型），dreturn（Double 类型），areturn。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul></li><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<mark>异常完成出口</mark>。</li></ol><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><pre><code class="line-numbers language-shell">Exception table:from to target type4 16  19   any19 21  19   any</code></pre><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p><mark>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</mark></p><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过 -Xss 设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul></li></ul><table><thead><tr><th align="left">运行时数据区</th><th align="left">是否存在 Error</th><th align="left">是否存在 GC</th></tr></thead><tbody><tr><td align="left">程序计数器</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">虚拟机栈</td><td align="left">是（SOE）</td><td align="left">否</td></tr><tr><td align="left">本地方法栈</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">方法区</td><td align="left">是（OOM）</td><td align="left">是</td></tr><tr><td align="left">堆</td><td align="left">是</td><td align="left">是</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 程序计数器</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-cheng-xu-ji-shu-qi/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-cheng-xu-ji-shu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-程序计数器"><a href="#【Java-JVM】-程序计数器" class="headerlink" title="【Java JVM】 程序计数器"></a>【Java JVM】 程序计数器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 程序计数器date: 2023-06-26 20:04tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 程序计数器</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><ul><li>运行速度最快的存储区域</li><li>线程私有的</li></ul><p><img src="/attachment/0b930d65761c294a90cb2883ca4400a1.png"></p><h2 id="【Java-JVM】-程序计数器-1"><a href="#【Java-JVM】-程序计数器-1" class="headerlink" title="【Java JVM】 程序计数器"></a>【Java JVM】 程序计数器</h2><p>JVM 中的程序计数寄存器（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<mark>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</mark>。</p><p><img src="/attachment/12f0376bde5f9843ae31c8821ecd6a47.png"></p><p><strong>作用</strong></p><p>PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="/attachment/0b930d65761c294a90cb2883ca4400a1.png"></p><p>它是一块很小的内存空间，几乎可以忽略不记。也是<mark>运行速度最快的存储区域</mark>。</p><p>在 JVM 规范中，<mark>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</mark>。</p><p><mark>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法</mark>。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（undefined）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在 Java 虚拟机规范中没有规定任何 OutofMemoryError 情况的区域。</p><p><strong>使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？</strong></p><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="/attachment/0b52d6e810a0b5f42a1e34671ee71af8.png"></p><p><strong>PC 寄存器为什么被设定为私有的？</strong></p><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<mark>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器</mark>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><strong>CPU 时间片</strong></p><p>CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="/attachment/3e19fc4b7d6fac33082106c26ba77996.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 运行时数据区</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-yun-xing-shi-shu-ju-qu/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-yun-xing-shi-shu-ju-qu/java-jvm-yun-xing-shi-shu-ju-qu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-运行时数据区"><a href="#【Java-JVM】-运行时数据区" class="headerlink" title="【Java JVM】 运行时数据区"></a>【Java JVM】 运行时数据区</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 运行时数据区date: 2023-06-26 19:52tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 运行时数据区</code></pre><h2 id="【Java-JVM】-运行时数据区-1"><a href="#【Java-JVM】-运行时数据区-1" class="headerlink" title="【Java JVM】 运行时数据区"></a>【Java JVM】 运行时数据区</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="/attachment/619b7180ea59327ec4453a5ff954d58a.png"></p><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。</p><p><img src="/attachment/f2616a329b559a3ce239cde3c919a6d8.png"></p><p>我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说内存充当了 CPU 和磁盘之间的桥梁</p><p><img src="/attachment/bf912d10ad6cbecef8b8124fec1ea4a6.png"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="/attachment/36080f91a8d593ebf36bd299b731a927.png"></p><p>每个 JVM 只有一个 Runtime 实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><p><img src="/attachment/603d671a47a208c2f3f6f0624fcd999b.png"></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射。</p><p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。</p><p>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run()方法。</p><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><p>如果你使用 console 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[] args)</code>的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：</p><ul><li><mark>虚拟机线程</mark>：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li><mark>周期任务线程</mark>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li><mark>GC 线程</mark>：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li><li><mark>编译线程</mark>：这种线程在运行时会将字节码编译成到本地代码。</li><li><mark>信号调度线程</mark>：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。</li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>undefined</p><p>undefined</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-本地方法接口和本地方法栈"><a href="#【Java-JVM】-本地方法接口和本地方法栈" class="headerlink" title="【Java JVM】 本地方法接口和本地方法栈"></a>【Java JVM】 本地方法接口和本地方法栈</h2><p>undefined</p><h2 id="【Java-JVM】-堆"><a href="#【Java-JVM】-堆" class="headerlink" title="【Java JVM】 堆"></a>【Java JVM】 堆</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-方法区"><a href="#【Java-JVM】-方法区" class="headerlink" title="【Java JVM】 方法区"></a>【Java JVM】 方法区</h2><p>undefined</p><p>undefined</p><h2 id="【Java-JVM】-本地方法接口和本地方法栈-1"><a href="#【Java-JVM】-本地方法接口和本地方法栈-1" class="headerlink" title="【Java JVM】 本地方法接口和本地方法栈"></a>【Java JVM】 本地方法接口和本地方法栈</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 类加载子系统</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-lei-jia-zai-zi-xi-tong/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-lei-jia-zai-zi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-类加载子系统"><a href="#【Java-JVM】-类加载子系统" class="headerlink" title="【Java JVM】 类加载子系统"></a>【Java JVM】 类加载子系统</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 类加载子系统date: 2023-06-26 14:31tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 【Java JVM】 类加载子系统</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/4c1bee83d303cc5bf62846b606d20797.png"></p><p><strong>加载阶段</strong></p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li></ol><p><strong>链接阶段</strong></p><ul><li>验证（Verify）  保证被加载类的正确性</li><li>准备（Prepare） 为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li>解析（Resolve）将常量池内的符号引用转换为直接引用的过程。</li></ul><p><strong>初始化阶段</strong><br>执行类构造器方法<code>&lt;clinit()&gt;</code>的过程</p><p><strong>类加载器</strong></p><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）<br>扩展类加载器（Extension ClassLoader）<br>应用程序类加载器（系统类加载器，AppClassLoader）<br>用户自定义类加载器</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p><strong>双亲委派机制</strong></p><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ol><p><img src="/attachment/6be2c9763db7f5d50140d631cef1551e.png"></p><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><ul><li>Class 文件</li><li><mark>类加载子系统</mark></li><li>运行时数据区<ul><li>方法区</li><li>堆</li><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li>执行引擎</li><li>本地方法接口</li><li>本地方法库</li></ul><p><img src="/attachment/d71b64f84eee3c3a41c8ddbb7e6595a1.png"></p><p><img src="/attachment/2a0c5f9bbe34fae811e8a9b62fc96fd6.png"></p><h2 id="类加载器与类的加载过程"><a href="#类加载器与类的加载过程" class="headerlink" title="类加载器与类的加载过程"></a>类加载器与类的加载过程</h2><p><strong>类加载器子系统作用</strong></p><p><img src="/attachment/4c1bee83d303cc5bf62846b606d20797.png"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。</li><li>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li></ul><p><strong>类加载器 ClasLoader 角色</strong></p><p><img src="/attachment/0020dbaba999e3925f0a5ed292d0cfc1.png"></p><ul><li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。</li><li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区。</li><li>在.class 文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li></ul><p>流程图表示:</p><p><img src="/attachment/c18cad79a7d1bddd4bcb4467f459a88f.png"></p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><img src="/attachment/d1c50ba5d1ffe0b51296d87d334d06ba.png"></p><ul><li><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li></ol></li><li><ol start="2"><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li></ol></li><li><ol start="3"><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li></ol></li></ul><p><strong>补充：加载 class 文件的方式</strong></p><ul><li>从<mark>本地系统</mark>中直接加载</li><li>通过<mark>网络</mark>获取，典型场景：Web Applet</li><li>从 zip<mark>压缩包</mark>中读取，成为日后 jar、war 格式的基础</li><li>运行时计算生成，使用最多的是：<mark>动态代理技术</mark></li><li>由其他文件生成，典型场景：<mark>JSP 应用</mark></li><li>从专有<mark>数据库</mark>中提取.class 文件，比较少见</li><li>从<mark>加密文件</mark>中获取，典型的防 Class 文件被反编译的保护措施</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul><li><strong>验证（Verify）</strong>：<ul><li>目的在子确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，<mark>文件格式验证，元数据验证，字节码验证，符号引用验证。</mark></li></ul></li><li><strong>准备（Prepare）</strong>：<ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li><mark>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</mark></li><li><mark>这里不会为实例变量分配初始化</mark>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li></ul></li><li><strong>解析（Resolve）</strong>：<ul><li>将常量池内的<mark>符号引用转换为直接引用</mark>的过程。</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li></ul></li></ul><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li><mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark></li><li>此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li><mark>&lt;clinit&gt;()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li><li>若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>JVM 支持两种类型的类加载器 。分别为<mark>引导类加载器（Bootstrap ClassLoader）</mark>和<mark>自定义类加载器（User-Defined ClassLoader）</mark>。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将<mark>所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</mark>。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：</p><p><img src="/attachment/131d0a1cd4c6140529134d880f81b150.png"></p><p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载使用 C/C++语言实现的，嵌套在 JVM 内部。</li><li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 java.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li></ul><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li><li>派生于 ClassLoader 类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/1ib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li><li><mark>该类加载是程序中默认的类加载器</mark>，一般来说，Java 应用的类都是由它来完成加载</li><li>通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ol><li>开发人员可以通过继承抽象类 ava.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 findClass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h3 id="ClassLoader-的使用说明"><a href="#ClassLoader-的使用说明" class="headerlink" title="ClassLoader 的使用说明"></a>ClassLoader 的使用说明</h3><p>ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p><p><img src="/attachment/3e69cfdd82aff1392792cc6bec4f0126.png"></p><p>sun.misc.Launcher 它是一个 java 虚拟机的入口应用</p><p><img src="/attachment/51a9855273a25202fcb3ab00ab99dde2.png"></p><p><strong>获取 ClassLoader 的途径</strong></p><ul><li><p>方式一：获取当前 ClassLoader</p><pre><code class="line-numbers language-java">clazz.getClassLoader()</code></pre></li><li><p>方式二：获取当前线程上下文的 ClassLoader</p><pre><code class="line-numbers language-java">Thread.currentThread().getContextClassLoader()</code></pre></li><li><p>方式三：获取系统的 ClassLoader</p><pre><code class="line-numbers language-java">ClassLoader.getSystemClassLoader()</code></pre></li><li><p>方式四：获取调用者的 ClassLoader</p><pre><code class="line-numbers language-java">DriverManager.getCallerClassLoader()</code></pre></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p><p><strong>工作原理</strong></p><ul><li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="/attachment/6be2c9763db7f5d50140d631cef1551e.png"></p><p><strong>举例</strong></p><p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p><p><img src="/attachment/f03ae091611a3057c41919a2e191c48c.png"></p><p><strong>优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li></ul></li></ul><p><strong>沙箱安全机制</strong></p><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>如何判断两个 class 对象是否相同</strong></p><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。</li></ul><p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p><p><strong>对类加载器的引用</strong></p><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会<mark>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</mark>。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p><p><strong>类的主动使用和被动使用</strong></p><p>Java 程序对类的使用方式分为：主动使用和被动使用。</p><p>主动使用，又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>初始化一个类的子类</li><li>Java 虚拟机启动时被标明为启动类的类</li><li>JDK 7 开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle 实例的解析结果<br>REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用 Java 类的方式都被看作是对<mark>类的被动使用</mark>，都<mark>不会导致类的初始化</mark>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 JVM与Java体系结构</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-jvm-yu-java-ti-xi-jie-gou/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-jvm-yu-java-ti-xi-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-JVM与Java体系结构"><a href="#【Java-JVM】-JVM与Java体系结构" class="headerlink" title="【Java JVM】 JVM与Java体系结构"></a>【Java JVM】 JVM与Java体系结构</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 JVM与Java体系结构date: 2023-06-26 14:21tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java JVM】 JVM与Java体系结构</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>JVM 的整体结构</strong></p><p><img src="/attachment/a9ccb623753dce919afda664344209f6.png"></p><p><strong>Java 代码执行流程</strong></p><p><img src="/attachment/3aac9ca7b7118b1d09ef502e5e72aa56.png"></p><p><strong>JVM 的架构模型</strong></p><p>基于栈式架构</p><h2 id="【Java-JVM】-JVM与Java体系结构-1"><a href="#【Java-JVM】-JVM与Java体系结构-1" class="headerlink" title="【Java JVM】 JVM与Java体系结构"></a>【Java JVM】 JVM与Java体系结构</h2><p><strong>JVM：跨语言的平台</strong></p><p>Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大 Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ul><li>作为一个平台，Java 虚拟机扮演着举足轻重的作用<ul><li>Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分</li></ul></li><li>作为灯种文化，Java 几乎成为了“开源”的代名词。<ul><li>第三方开源软件和框架。如 Tomcat、Struts，MyBatis，Spring 等。</li><li>就连 JDK 和 JVM 自身也有不少开源的实现，如 openJDK、Harmony。</li></ul></li><li>作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li></ul><p><strong>字节码</strong></p><ul><li>我们平时说的 java 字节码，指的是用 java 语言编译成的字节码。准确的说任何能在 jvm 平台上执行的字节码格式都是一样的。所以应该统称为：<mark>jvm 字节码</mark>。</li><li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</li><li>Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式—Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</li></ul><p><strong>多语言混合编程</strong></p><ul><li><mark>Java 平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</mark></li><li>试想一下，在一个项目之中，并行处理用 Clojure 语言编写，展示层使用 JRuby/Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<mark>各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为它们最终都运行在一个虚拟机之上。</mark></li><li>对这些运行于 Java 虚拟机之上、Java 之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如 Da Vinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），<mark>推动 Java 虚拟机从“Java 语言的虚拟机”向 “多语言虚拟机”的方向发展。</mark></li></ul><p><img src="/attachment/1035091e21fda5293e5dadeea0a612f6.png"></p><h2 id="Java-发展的重大事件"><a href="#Java-发展的重大事件" class="headerlink" title="## Java 发展的重大事件"></a>## Java 发展的重大事件</h2><ul><li>1990 年，在 Sun 计算机公司中，由 Patrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 oak，后期命名为 Java</li><li>1995 年，Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。</li><li>1996 年 1 月 23 日，Sun Microsystems 发布了 JDK 1.0。</li><li>1998 年，JDK1.2 版本发布。同时，sun 发布了 JSP/Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用 3 大领域挺进。</li><li>2000 年，JDK1.3 发布，<mark>Java HotSpot Virtual Machine 正式发布，成为 Java 的默认虚拟机。</mark></li><li>2002 年，JDK1.4 发布，古老的 Classic 虚拟机退出历史舞台。</li><li>2003 年年底，<mark>Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营。</mark></li><li>2004 年，JDK1.5 发布。同时 JDK1.5 改名为 JavaSE5.0。</li><li>2006 年，JDK6 发布。同年，<mark>Java 开源并建立了 OpenJDK</mark>。顺理成章，<mark>Hotspot 虚拟机也成为了 openJDK 中的默认虚拟机。</mark></li><li>2007 年，<mark>Java 平台迎来了新伙伴 Clojure。</mark></li><li>2008 年，Oracle 收购了 BEA，<mark>得到了 JRockit 虚拟机。</mark></li><li>2009 年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 Scala，这是 Java 平台的又一次大规模应用。</li><li>2010 年，Oracle 收购了 Sun，<mark>获得 Java 商标和最真价值的 HotSpot 虚拟机</mark>。此时，Oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合：HotRockit</li><li>2011 年，JDK7 发布。在 JDK1.7u4 中，<mark>正式启用了新的垃圾回收器 G1。</mark></li><li>2017 年，JDK9 发布。<mark>将 G1 设置为默认 Gc，替代 CMS</mark></li><li>同年，<mark>IBM 的 J9 开源</mark>，形成了现在的 Open J9 社区</li><li>2018 年，Android 的 Java 侵权案判决，Google 赔偿 Oracle 计 88 亿美元</li><li>同年，Oracle 宣告 JavaEE 成为历史名词 JDBC、JMS、Servlet 赠予 Eclipse 基金会</li><li>同年，JDK11 发布，LTS 版本的 JDK，<mark>发布革命性的 ZGC，调整 JDK 授权许可</mark></li><li>2019 年，JDK12 发布，加入 RedHat 领导开发的<mark>shenandoah GC</mark></li></ul><h2 id="JVM-的整体结构"><a href="#JVM-的整体结构" class="headerlink" title="JVM 的整体结构"></a>JVM 的整体结构</h2><p><img src="/attachment/a9ccb623753dce919afda664344209f6.png"></p><h2 id="Java-代码执行流程"><a href="#Java-代码执行流程" class="headerlink" title="Java 代码执行流程"></a>Java 代码执行流程</h2><p><img src="/attachment/3aac9ca7b7118b1d09ef502e5e72aa56.png"></p><h2 id="JVM-的架构模型"><a href="#JVM-的架构模型" class="headerlink" title="JVM 的架构模型"></a>JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种基于<mark>栈的指令集架构</mark>，另外一种指令集架构则是基于<mark>寄存器的指令集架构</mark>。</p><p>具体来说：这两种架构之间的区别：</p><p><strong>基于栈式架构的特点</strong></p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><p><strong>基于寄存器架构的特点</strong></p><ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ul><h2 id="JVM-的生命周期"><a href="#JVM-的生命周期" class="headerlink" title="JVM 的生命周期"></a>JVM 的生命周期</h2><p><strong>虚拟机的启动</strong></p><p>Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p><strong>虚拟机的执行</strong></p><ul><li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li><mark>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</mark></li></ul><p><strong>虚拟机的退出</strong></p><p>有如下的几种情况：</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致 Java 虚拟机进程终止</li><li>某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。</li></ul><h2 id="JVM-的发展历程"><a href="#JVM-的发展历程" class="headerlink" title="JVM 的发展历程"></a>JVM 的发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在 1996 年 Java1.0 版本的时候，Sun 公司发布了一款名为 sun classic VM 的 Java 虚拟机，它同时也是<mark>世界上第一款商用 Java 虚拟机</mark>，JDK1.4 时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li><li>如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在 hotspot 内置了此虚拟机。</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul><li>为了解决上一个虚拟机问题，jdk1.2 时，Sun 提供了此虚拟机。</li><li>Exact Memory Management：准确式内存管理<ul><li>也可以叫 Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li></ul></li><li>具备现代高性能虚拟机的维形<ul><li>热点探测</li><li>编译器与解释器混合工作模式</li></ul></li><li>只在 solaris 平台短暂使用，其他平台上还是 classic vm<ul><li>英雄气短，终被 Hotspot 虚拟机替换</li></ul></li></ul><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><ul><li>HotSpot 历史<ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。</li><li>JDK1.3 时，HotSpot VM 成为默认虚拟机</li></ul></li><li><mark>目前 Hotspot 占有绝对的市场地位，称霸武林。</mark><ul><li>不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot</li><li>Sun / Oracle JDK 和 OpenJDK 的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）</li></ul></li><li>从服务器、桌面到移动端、嵌入式都有应用。</li><li>名称中的 HotSpot 指的就是它的热点代码探测技术。<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><ul><li><p><mark>专注于服务器端应用</mark></p><ul><li>它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li></ul></li><li><p>大量的行业基准测试显示，<mark>JRockit JVM 是世界上最快的 JVM。</mark></p><ul><li>使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。</li></ul></li><li><p>优势：全面的 Java 运行时解决方案组合</p><ul><li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要</li><li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li><p>2008 年，JRockit 被 oracle 收购。</p></li><li><p>Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。</p></li><li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p></li></ul><h3 id="IBM-的-J9"><a href="#IBM-的-J9" class="headerlink" title="IBM 的 J9"></a>IBM 的 J9</h3><ul><li><p>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9</p></li><li><p>市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM</p></li><li><p>广泛用于 IBM 的各种 Java 产品。</p></li><li><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机。</p></li><li><p>2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9</p></li></ul><h3 id="KVM-和-CDC-x2F-CLDC-Hotspot"><a href="#KVM-和-CDC-x2F-CLDC-Hotspot" class="headerlink" title="KVM 和 CDC / CLDC Hotspot"></a>KVM 和 CDC / CLDC Hotspot</h3><ul><li><p>Oracle 在 Java ME 产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM</p></li><li><p>KVM（Kilobyte）是 CLDC-HI 早期产品</p></li><li><p>目前移动领域地位尴尬，智能机被 Android 和 iOS 二分天下。</p></li><li><p>KVM 简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul></li><li><p>所有的虚拟机的原则：一次编译，到处运行。</p></li></ul><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ul><li><p>前面三大“高性能 Java 虚拟机”使用在通用硬件平台上这里 Azul VW 和 BEA Liquid VM 是<mark>与特定硬件平台绑定、软硬件配合的专有虚拟机</mark></p><ul><li>高性能 Java 虚拟机中的战斗机。</li></ul></li><li><p>Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机。</p></li><li><p><mark>每个 Azul VM 实例都可以管理至少数十个 CPU 和数百 GB 内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</mark></p></li><li><p>2010 年，AzulSystems 公司开始从硬件转向软件，发布了自己的 Zing JVM，可以在通用 x86 平台上提供接近于 Vega 系统的特性。</p></li></ul><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ul><li><p>高性能 Java 虚拟机中的战斗机。</p></li><li><p>BEA 公司开发的，直接运行在自家 Hypervisor 系统上</p></li><li><p>Liquid VM 即是现在的 JRockit VE（Virtual Edition），<mark>Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</mark></p></li><li><p>随着 JRockit 虚拟机终止开发，Liquid vM 项目也停止了。</p></li></ul><h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><ul><li><p>Apache 也曾经推出过与 JDK1.5 和 JDK1.6 兼容的 Java 运行平台 Apache Harmony。</p></li><li><p>它是 IBM 和 Intel 联合开发的开源 JVM，受到同样开源的 OpenJDK 的压制，Sun 坚决不让 Harmony 获得 JCP 认证，最终于 2011 年退役，IBM 转而参与 OpenJDK</p></li><li><p>虽然目前并没有 Apache Harmony 被大规模商用的案例，但是它的 Java 类库代码吸纳进了 Android SDK。</p></li></ul><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><ul><li><p>微软为了在 IE3 浏览器中支持 Java Applets，开发了 Microsoft JVM。</p></li><li><p>只能在 Windows 平台下运行。但确是当时 Windows 下性能最好的 Java VM。</p></li><li><p>1997 年，Sun 以侵犯商标、不正当竞争罪名指控微软成功，赔了 Sun 很多钱。微软 WindowsXP SP3 中抹掉了其 VM。现在 Windows 上安装的 jdk 都是 HotSpot。</p></li></ul><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><ul><li><p>由 AliJVM 团队发布。阿里，国内使用 Java 最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p><mark>基于 OpenJDK 开发了自己的定制版本 AlibabaJDK</mark>，简称 AJDK。是整个阿里 Java 体系的基石。</p></li><li><p>基于 OpenJDK Hotspot VM 发布的国内第一个优化、<mark>深度定制且开源的高性能服务器版 Java 虚拟机</mark>。</p><ul><li>创新的 GCIH（GC invisible heap）技术实现了 off-heap，<mark>即将生命周期较长的 Java 对象从 heap 中移到 heap 之外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</mark></li><li>GCIH 中的<mark>对象还能够在多个 Java 虚拟机进程中实现共享</mark></li><li>使用 crc32 指令实现 JVM intrinsic 降低 JNI 的调用开销</li><li>PMU hardware 的 Java profiling tool 和诊断协助功能</li><li>针对大数据场景的 ZenGc</li></ul></li><li><p>taobao vm 应用在阿里产品上性能高，硬件严重依赖 intel 的 cpu，损失了兼容性，但提高了性能</p><ul><li>目前已经在淘宝、天猫上线，把 oracle 官方 JvM 版本全部替换了。</li></ul></li></ul><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ul><li><p>谷歌开发的，应用于 Android 系统，并在 Android2.2 中提供了 JIT，发展迅猛。</p></li><li><p>Dalvik VM 只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循 Java 虚拟机规范，不能直接执行 Java 的 Class 文件</p></li><li><p>基于寄存器架构，不是 jvm 的栈架构。</p></li><li><p>执行的是编译以后的 dex（Dalvik Executable）文件。执行效率比较高。</p><ul><li>它执行的 dex（Dalvik Executable）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。</li></ul></li><li><p>Android 5.0 使用支持提前编译（Ahead of Time Compilation，AoT）的 ART VM 替换 Dalvik VM。</p></li></ul><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><ul><li><p>2018 年 4 月，oracle Labs 公开了 Graal VM，号称 “Run Programs Faster Anywhere”，野心勃勃。与 1995 年 java 的”write once，run anywhere”遥相呼应。</p></li><li><p>Graal VM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R 等</p></li><li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p></li><li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。Graal VM 提供 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p></li><li><p>如果说 HotSpot 有一天真的被取代，Graal VM 希望最大。但是 Java 的软件生态没有丝毫变化。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。</p><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p><img src="/attachment/67533b374f7f87d72e12fd1124acd359.png"></p><p><img src="/attachment/4f8de9f88f1480adfdb444eaa3ff062c.png"></p><p><img src="/attachment/aaef307175d242b5dd524fd424cc58a7.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 锁</title>
      <link href="/database/mysql/mysql-suo/"/>
      <url>/database/mysql/mysql-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-锁"><a href="#【MySQL】-锁" class="headerlink" title="【MySQL】 锁"></a>【MySQL】 锁</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 锁date: 2023-06-25 22:16tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 锁</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>并发事务的情况</strong></p><ul><li>写-写情况：即并发事务相继对相同的记录做出改动。 – 脏写</li><li>读-写或写-读情况：即一个事务进行读取操作，另一个进行改动操作。  – 脏读、不可重复读、幻读</li></ul><p><strong>锁结构</strong></p><ul><li>trx信息：代表这个锁结构是哪个事务生成的。</li><li>is_waiting ：代表当前事务是否在等待。</li></ul><p><img src="/attachment/161ec1961aef73abc354f82b621b4f7c.png"></p><p><strong>解决并发事务带来问题的两种基本方式</strong></p><ul><li>读操作利用多版本并发控制（ MVCC ），写操作进行加锁。</li><li>读、写操作都采用加锁的方式。</li></ul><p><strong>读操作</strong></p><ul><li>一致性读（Consistent Reads） 事务利用MVCC 进行的读取操作</li><li>锁定读（Locking Reads）  共享锁和独占锁</li></ul><p><strong>写操作</strong></p><ul><li>DELETE <ol><li>先在B+ 树中定位到这条记录的位置，</li><li>然后获取一下这条记录的X锁，</li><li>然后再执行delete mark 操作。</li></ol></li><li>UPDATE<ul><li>未修改键值且未改变存储空间：<ol><li>在B+树中定位到待修改记录的位置。</li><li>获取记录的X锁（锁定读）。</li><li>在原记录位置进行修改操作。</li></ol></li><li>未修改键值但改变了存储空间：<ol><li>在B+树中定位到待修改记录的位置。</li><li>获取记录的X锁（锁定读）。</li><li>彻底删除该记录（移入垃圾链表）。</li><li>插入一条新记录。</li><li>新插入的记录由INSERT操作提供的隐式锁进行保护。</li></ol></li><li>修改了键值：<ol><li>相当于先执行DELETE操作再执行INSERT操作。</li><li>加锁操作遵循DELETE和INSERT的规则。</li></ol></li></ul></li><li>INSERT<ul><li>隐式锁 保护</li></ul></li></ul><p><strong>多粒度锁</strong></p><ul><li><p>共享锁，英文名： Shared Locks，简称S锁。 在事务要读取一条记录时，需要先获取该记录的S锁。</p></li><li><p>独占锁，也常称排他锁，英文名： Exclusive Locks ，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。</p></li><li><p>行锁  DML 语句 DQL 语句</p><ul><li>行S锁</li><li>行X锁</li></ul></li><li><p>表锁  DDL 语句</p><ul><li>表S锁</li><li>表X锁</li></ul></li><li><p>意向锁 为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁</p><ul><li>意向共享锁，英文名： Intention Shared Lock ，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。</li><li>意向独占锁，英文名： Intention Exclusive Lock ，简称IX锁。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。</li></ul></li></ul><p><img src="/attachment/2ed86ba8130e63a3194c27bd2ec8052f.png"></p><p><strong>InnoDB 存储引擎相关锁</strong></p><p>表级锁</p><ul><li>AUTO-INC锁<ul><li>id 字段声明了AUTO_INCREMENT </li><li>轻量级的锁</li></ul></li></ul><p>行级锁</p><ul><li>Record Locks 记录锁<ul><li>仅仅把一条记录锁上</li><li>分 X锁 S锁</li><li><img src="/attachment/ece8f03d4b6e3eb6703eba7f14860179.png"></li></ul></li><li>Gap Locks 间隔锁<ul><li>记录前边的间隙插入新记录</li><li>解决幻读</li><li><img src="/attachment/9b396b346bb2541cfc2bf9cf71aafade.png"></li></ul></li><li>Next-Key Locks 邻键锁<ul><li>既锁住某条记录，又阻止其他事务在该记录前边的间隙插入新记录</li><li><img src="/attachment/e90eee308ee767cf1b2394ad7bb494d8.png"></li></ul></li><li>Insert Intention Locks 插入意向锁<ul><li>有事务想在某个间隙中插入新记录，但是现在在等待。</li><li><img src="/attachment/38332344b5963095d1b246349b494971.png"></li></ul></li><li>隐式锁<ul><li>一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id 的存在，相当于加了一个隐式锁。</li></ul></li></ul><p><strong>InnoDB锁的内存结构</strong></p><p><img src="/attachment/85002faeead4df3acc3ca0fe807dab1d.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="并发事务的情况"><a href="#并发事务的情况" class="headerlink" title="并发事务的情况"></a>并发事务的情况</h3><ul><li>读-读情况：即并发事务相继读取相同的记录。<br>读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。</li><li>写-写情况：即并发事务相继对相同的记录做出改动。<br>在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。<br>读-写或写-读情况：也就是一个事务进行读取操作，另一个进行改动操作。<br>这种情况下可能发生脏读、不可重复读、幻读的问题。</li></ul><p>在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。</p><h3 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h3><p>这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的</p><p><img src="/attachment/830e40aa7b2a310a14441c6c27df6a3c.png"></p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。</p><p>比方说事务T1 要对这条记录做改动，就需要生成一个锁结构与之关联：</p><p><img src="/attachment/fb84dcdd9da6e3b4ab6d8228e2994005.png"></p><p>其实在锁结构里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：</p><ul><li>trx信息：代表这个锁结构是哪个事务生成的。</li><li>is_waiting ：代表当前事务是否在等待。</li></ul><p>如图所示，当事务T1 改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting 属性就是false ，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。</p><p>在事务T1 提交之前，另一个事务T2 也想对该记录做改动，那么先去看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting 属性值为true ，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁，画个图表示就是这样：</p><p><img src="/attachment/161ec1961aef73abc354f82b621b4f7c.png"></p><p>在事务T1 提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2 还在等待获取锁，所以把事务T2 对应的锁结构的is_waiting 属性设置为false ，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2 就算获取到锁了。效果图就是这样：</p><p><img src="/attachment/cc45bd5f6c7036e7b59d01065b627937.png"></p><p>我们总结一下后续内容中可能用到的几种说法，以免大家混淆：</p><ul><li>不加锁<br>意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。</li><li>获取锁成功，或者加锁成功<br>意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting 属性为false ，也就是事务可以继续执行操作。</li><li>获取锁失败，或者加锁失败，或者没有获取到锁<br>意思就是在内存中生成了对应的锁结构，不过锁结构的is_waiting 属性为true ，也就是事务需要等待，不可以继续执行操作。</li></ul><h2 id="解决并发事务带来问题的两种基本方式"><a href="#解决并发事务带来问题的两种基本方式" class="headerlink" title="解决并发事务带来问题的两种基本方式"></a>解决并发事务带来问题的两种基本方式</h2><h3 id="方案一：读操作利用多版本并发控制（-MVCC-），写操作进行加锁。"><a href="#方案一：读操作利用多版本并发控制（-MVCC-），写操作进行加锁。" class="headerlink" title="方案一：读操作利用多版本并发控制（ MVCC ），写操作进行加锁。"></a>方案一：读操作利用多版本并发控制（ MVCC ），写操作进行加锁。</h3><p>读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC 时， 读-写操作并不冲突。</p><h3 id="方案二：读、写操作都采用加锁的方式。"><a href="#方案二：读、写操作都采用加锁的方式。" class="headerlink" title="方案二：读、写操作都采用加锁的方式。"></a>方案二：读、写操作都采用加锁的方式。</h3><p>这样在读取记录的时候也就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><h3 id="一致性读（Consistent-Reads）"><a href="#一致性读（Consistent-Reads）" class="headerlink" title="一致性读（Consistent Reads）"></a>一致性读（Consistent Reads）</h3><p>事务利用MVCC 进行的读取操作称之为<strong>一致性读</strong>，或者<strong>一致性无锁读</strong>，有的地方也称之为<strong>快照读</strong></p><h3 id="锁定读（Locking-Reads）"><a href="#锁定读（Locking-Reads）" class="headerlink" title="锁定读（Locking Reads）"></a>锁定读（Locking Reads）</h3><h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以设计MySQL 的大叔给锁分了个类：</p><ul><li>共享锁，英文名： Shared Locks ，简称S锁。在事务要读取一条记录时，需要先获取该记录的S锁。</li><li>独占锁，也常称排他锁，英文名： Exclusive Locks ，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。</li></ul><p><img src="/attachment/374c86eaca4bde2a35b9123cb75cfa2c.png"></p><h4 id="锁定读的语句"><a href="#锁定读的语句" class="headerlink" title="锁定读的语句"></a>锁定读的语句</h4><p>对读取的记录加S锁：</p><pre><code class="line-numbers language-sql">SELECT ... LOCK IN SHARE MODE;</code></pre><p>对读取的记录加X锁：</p><pre><code class="line-numbers language-sql">SELECT ... FOR UPDATE;</code></pre><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>写操作无非是DELETE 、UPDATE 、INSERT 这三种</p><ul><li>DELETE ：</li></ul><p>对一条记录做DELETE 操作的过程其实是</p><ol><li>先在B+ 树中定位到这条记录的位置，</li><li>然后获取一下这条记录的X锁，</li><li>然后再执行delete mark 操作。</li></ol><p>我们也可以把这个<strong>定位待删除记录在B+ 树中位置</strong>的过程看成是一个获取X锁的锁定读。</p><ul><li>UPDATE ：</li></ul><ol><li>如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在B+ 树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。其实我们也可以把这个<strong>定位待修改记录在B+ 树中位置</strong>的过程看成是一个获取X锁的锁定读。</li><li>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+ 树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个<strong>定位待修改记录在B+ 树中位置</strong>的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT 操作提供的隐式锁进行保护。</li><li>如果修改了该记录的键值，则相当于在原记录上做DELETE 操作之后再来一次INSERT 操作，加锁操作就需要按照DELETE 和INSERT 的规则进行了。</li></ol><ul><li>INSERT ：</li></ul><p>新插入一条记录的操作并不加锁，设计InnoDB 的大叔通过一种称之为<strong>隐式锁</strong>的东东来保护这条新插入的记录在本事务提交前不被别的事务访问</p><h2 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h2><p>之前提到的锁都是针对记录的，也可以被称之为<strong>行级锁</strong>或者<strong>行锁</strong>，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细</p><p>其实一个事务也可以在表级别进行加锁，自然就被称之为<strong>表级锁</strong>或者<strong>表锁</strong>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。</p><p>给表加的锁也可以分为共享锁（ S锁）和独占锁（ X锁）：</p><h3 id="给表加S锁："><a href="#给表加S锁：" class="headerlink" title="给表加S锁："></a>给表加S锁：</h3><p>如果一个事务给表加了S锁，那么：</p><ul><li>别的事务可以继续获得该表的S锁</li><li>别的事务可以继续获得该表中的某些记录的S锁</li><li>别的事务不可以继续获得该表的X锁</li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul><h3 id="给表加X锁："><a href="#给表加X锁：" class="headerlink" title="给表加X锁："></a>给表加X锁：</h3><p>如果一个事务给表加了X锁（意味着该事务要独占这个表），那么：</p><ul><li>别的事务不可以继续获得该表的S锁</li><li>别的事务不可以继续获得该表中的某些记录的S锁</li><li>别的事务不可以继续获得该表的X锁</li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>我们在对教学楼整体上锁（ 表锁）时，怎么知道教学楼中有没有教室已经被上锁（ 行锁）了呢？</p><p><strong>总结</strong></p><p>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。</p><p><img src="/attachment/2ed86ba8130e63a3194c27bd2ec8052f.png"></p><h2 id="MySQL中的行锁和表锁"><a href="#MySQL中的行锁和表锁" class="headerlink" title="MySQL中的行锁和表锁"></a>MySQL中的行锁和表锁</h2><p>InnoDB 存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。下边我们详细看一下。</p><h3 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h3><h4 id="表级别的S锁、X锁"><a href="#表级别的S锁、X锁" class="headerlink" title="表级别的S锁、X锁"></a>表级别的S锁、X锁</h4><p>在对某个表执行SELECT 、INSERT 、DELETE 、UPDATE 语句时， InnoDB 存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p><p>在对某个表执行一些诸如ALTER TABLE 、DROP TABLE 这类的DDL 语句时，其他事务对这个表并发执行诸如SELECT 、INSERT 、DELETE 、UPDATE 的语句会发生阻塞，同理，某个事务中对某个表执行SELECT 、INSERT 、DELETE 、UPDATE 语句时，在其他会话中对这个表执行DDL 语句也会发生阻塞</p><p>这个过程其实是通过在<strong>server层</strong>使用一种称之为<strong>元数据锁</strong>（英文名： Metadata Locks ，简称MDL ）东东来实现的，一般情况下也不会使用InnoDB 存储引擎自己提供的表级别的S锁和X锁。</p><p>其实这个InnoDB 存储引擎提供的表级S锁或者X锁是相当鸡肋，只会在一些特殊情况下，比方说<strong>崩溃恢复</strong>过程中用到。</p><p>不过我们还是可以手动获取一下的，比方说在系统变量autocommit=0，innodb_table_locks =1 时，手动获取InnoDB 存储引擎提供的表t 的S锁或者X锁可以这么写：</p><ul><li>LOCK TABLES t READ ： InnoDB 存储引擎会对表t 加表级别的S锁。</li><li>LOCK TABLES t WRITE ： InnoDB 存储引擎会对表t 加表级别的X锁。</li></ul><h4 id="表级别的IS锁、IX锁"><a href="#表级别的IS锁、IX锁" class="headerlink" title="表级别的IS锁、IX锁"></a>表级别的IS锁、IX锁</h4><p>当我们在对使用InnoDB 存储引擎的表的某些记录加S锁之前，那就需要先在表级别加一个IS锁，当我们在对使用InnoDB 存储引擎的表的某些记录加X锁之前，那就需要先在表级别加一个IX锁。</p><p>S锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。</p><h4 id="表级别的AUTO-INC锁"><a href="#表级别的AUTO-INC锁" class="headerlink" title="表级别的AUTO-INC锁"></a>表级别的AUTO-INC锁</h4><p>在使用MySQL 过程中，我们可以为表的某个列添加AUTO_INCREMENT 属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值</p><p>比方说我们有一个表：</p><pre><code class="line-numbers language-sql">CREATE TABLE t (id INT NOT NULL AUTO_INCREMENT,c VARCHAR(100),PRIMARY KEY (id)) Engine=InnoDB CHARSET=utf8;</code></pre><p>由于这个表的id 字段声明了AUTO_INCREMENT ，也就意味着在书写插入语句时不需要为其赋值.</p><p>系统实现这种自动给AUTO_INCREMENT 修饰的列递增赋值的原理主要是两个：</p><ul><li>采用AUTO-INC 锁，也就是在执行插入语句时就在表级别加一个AUTO-INC 锁，然后为每条待插入记录的<strong>AUTO_INCREMENT</strong> 修饰的列分配<strong>递增</strong>的值，在该语句执行结束后，再把AUTO-INC 锁释放掉。这样一个事务在持有AUTO-INC 锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</li><li>采用一个轻量级的锁，在为插入语句生成AUTO_INCREMENT 修饰的列的值时获取一下这个<strong>轻量级锁</strong>，然后生成本次插入语句需要用到的AUTO_INCREMENT 列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。</li></ul><h3 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h3><p>行锁，也称为记录锁，顾名思义就是在记录上加的锁。</p><p>使对同一条记录加行锁，如果类型不同，起到的功效也是不同的。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="line-numbers language-sql">CREATE TABLE hero (number INT,name VARCHAR(100),country varchar(100),PRIMARY KEY (number),KEY idx_name (name)) Engine=InnoDB CHARSET=utf8;</code></pre><p>我们主要是想用这个表存储三国时的英雄，然后向这个表里插入几条记录：</p><pre><code class="line-numbers language-sql">INSERT INTO hero VALUES(1, 'l刘备', '蜀'),(3, 'z诸葛亮', '蜀'),(8, 'c曹操', '魏'),(15, 'x荀彧', '魏'),(20, 's孙权', '吴');</code></pre><p>现在表里的数据就是这样的：</p><p><img src="/attachment/d2449908ad089564eaa35f943a597b26.png"></p><pre><code class="line-numbers language-ad-tip">采用utf8字符集，该字符集并没有对应的按照汉语拼音进行排序的比较规则</code></pre><p>我们把hero 表中的聚簇索引的示意图画一下：</p><p><img src="/attachment/26e8bb3d7af0b8def3361644af2eef81.png"></p><h4 id="常用的行锁类型"><a href="#常用的行锁类型" class="headerlink" title="常用的行锁类型"></a>常用的行锁类型</h4><h5 id="Record-Locks-："><a href="#Record-Locks-：" class="headerlink" title="Record Locks ："></a>Record Locks ：</h5><p>LOCK_REC_NOT_GAP (正经记录锁) 仅仅把一条记录锁上</p><p>比方说我们把number 值为8 的那条记录加一个正经记录锁的示意图如下：</p><p><img src="/attachment/ece8f03d4b6e3eb6703eba7f14860179.png"></p><p>正经记录锁是有S锁和X锁之分的，让我们分别称之为S型正经记录锁和X型正经记录锁吧</p><h5 id="Gap-Locks-："><a href="#Gap-Locks-：" class="headerlink" title="Gap Locks ："></a>Gap Locks ：</h5><p>使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上正经记录锁。</p><p>提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP 简称为gap锁。</p><p><img src="/attachment/9b396b346bb2541cfc2bf9cf71aafade.png"></p><p>不允许别的事务在number 值为8 的记录前边的间隙插入新记录</p><p>这个gap锁的提出仅仅是为了防止插入幻影记录而提出的</p><p>给哪条记录加gap锁才能阻止其他事务插入number 值在(20, +∞) 这个区间的新记录呢?</p><p>参考数据页时介绍的两条伪记录了：</p><ul><li>Infimum 记录，表示该页面中最小的记录。</li><li>Supremum 记录，表示该页面中最大的记录。</li></ul><p>为了实现阻止其他事务插入number 值在(20, +∞) 这个区间的新记录，我们可以给索引中的最后一条记录，也就是number 值为20 的那条记录所在页面的Supremum 记录加上一个gap锁</p><p><img src="/attachment/8e2b8dfb65a52fb31b0429976d42e168.png"></p><p>这样就可以阻止其他事务插入number 值在(20, +∞) 这个区间的新记录。为了大家理解方便，之后的索引示意图中都会把这个Supremum 记录画出来。</p><h5 id="Next-Key-Locks-："><a href="#Next-Key-Locks-：" class="headerlink" title="Next-Key Locks ："></a>Next-Key Locks ：</h5><p>既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录</p><p>Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY 简称为next-key锁。</p><p><img src="/attachment/e90eee308ee767cf1b2394ad7bb494d8.png"></p><p>next-key锁的本质就是一个正经记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p><h5 id="Insert-Intention-Locks-："><a href="#Insert-Intention-Locks-：" class="headerlink" title="Insert Intention Locks ："></a>Insert Intention Locks ：</h5><p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁<br>如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。<br>设计InnoDB 的大叔规定事务在等待的时候也需要在内存中生成一个锁结构, 表明有事务想在某个间隙中插入新记录，但是现在在等待。</p><p>把这种类型的锁命名为Insert Intention Locks ，官方的类型名称为： LOCK_INSERT_INTENTION ，我们也可以称为插入意向锁。</p><p><img src="/attachment/38332344b5963095d1b246349b494971.png"></p><p>比方说现在T1 为number 值为8 的记录加了一个gap锁，然后T2 和T3 分别想向hero 表中插入number 值分别为4 、5 的两条记录，所以现在为number 值为8 的记录加的锁的示意图就如下所示：</p><p><img src="/attachment/4d049c35d004eaa8be62091cfc3c75e3.png"></p><p>从图中可以看到，由于T1 持有gap锁，所以T2 和T3 需要生成一个插入意向锁的锁结构并且处于等待状态。当T1 提交后会把它获取到的锁都释放掉，这样T2 和T3 就能获取到对应的插入意向锁了（本质上就是把插入意向锁对应锁结构的is_waiting 属性改为false ）， T2 和T3 之间也并不会相互阻塞，它们可以同时获取到number 值为8的插入意向锁，然后执行插入操作。</p><h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>一个事务在执行INSERT 操作时，如果即将插入的间隙已经被其他事务加了gap锁，那么本次INSERT 操作会阻塞，并且当前事务会在该间隙上加一个插入意向锁，否则一般情况下INSERT 操作是不加锁的。</p><p>那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），没提交，然后另一个事务：</p><ul><li>立即使用SELECT … LOCK IN SHARE MODE 语句读取这条事务，也就是在要获取这条记录的S锁，或者使用SELECT … FOR UPDATE 语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的X锁<br>如果允许这种情况的发生，那么可能产生脏读问题。</li><li>立即修改这条记录，也就是要获取这条记录的X锁，该咋办？<br>如果允许这种情况的发生，那么可能产生脏写问题。</li></ul><p><strong>我们把聚簇索引和二级索引中的记录分开看一下：</strong></p><ul><li>情景一：</li></ul><p>对于聚簇索引记录来说，有一个trx_id 隐藏列，该隐藏列记录着最后改动该记录的事务id 。<br>那么如果在当前事务中新插入一条聚簇索引记录后，该记录的trx_id 隐藏列代表的就是当前事务的事务id ，<br>如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id 隐藏列代表的事务是否是当前的活跃事务，<br>如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构， is_waiting 属性是false ），<br>然后自己进入等待状态（也就是为自己也创建一个锁结构， is_waiting 属性是true ）。</p><ul><li>情景二：</li></ul><p>对于二级索引记录来说，本身并没有trx_id 隐藏列，但是在二级索引页面的Page Header 部分有一个PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的事务id ，<br>如果PAGE_MAX_TRX_ID 属性值小于当前最小的活跃事务id ，那么说明对该页面做修改的事务都已经提交了，<br>否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。</p><p>一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id 这个牛逼的东东的存在，相当于加了一个隐式锁。</p><h2 id="InnoDB锁的内存结构"><a href="#InnoDB锁的内存结构" class="headerlink" title="InnoDB锁的内存结构"></a>InnoDB锁的内存结构</h2><p>决定在对不同记录加锁时，如果符合下边这些条件：</p><p>如果符合下边这些条件：</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的<br>那么这些记录的锁就可以被放到一个锁结构中</li></ul><p>InnoDB 存储引擎中的锁结构：</p><p><img src="/attachment/85002faeead4df3acc3ca0fe807dab1d.png"></p><h3 id="锁所在的事务信息："><a href="#锁所在的事务信息：" class="headerlink" title="锁所在的事务信息："></a>锁所在的事务信息：</h3><p>不论是表锁还是行锁，都是在事务执行过程中生成的，<strong>哪个事务生成了这个锁结构</strong>，这里就记载着这个事务的信息。</p><h3 id="索引信息："><a href="#索引信息：" class="headerlink" title="索引信息："></a>索引信息：</h3><p>对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。</p><h3 id="表锁／行锁信息："><a href="#表锁／行锁信息：" class="headerlink" title="表锁／行锁信息："></a>表锁／行锁信息：</h3><p>表锁结构和行锁结构在这个位置的内容是不同的：</p><ul><li>表锁：<ul><li>记载着这是对哪个表加的锁，还有其他的一些信息。</li></ul></li><li>行锁：<ul><li>记载了三个重要的信息：<ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，<strong>一条记录就对应着一个比特位</strong>，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li></ul></li></ul></li></ul><h3 id="type-mode-："><a href="#type-mode-：" class="headerlink" title="type_mode ："></a>type_mode ：</h3><p>这是一个32位的数，被分成了lock_mode 、lock_type 和rec_lock_type 三个部分，如图所示：</p><p><img src="/attachment/78c76fd0161343d3226a2ec4a9dce15f.png"></p><ul><li><p>锁的模式（ lock_mode ），占用低4位，可选的值如下：</p><ul><li>LOCK_IS （十进制的0 ）：表示共享意向锁，也就是IS锁。</li><li>LOCK_IX （十进制的1 ）：表示独占意向锁，也就是IX锁。</li><li>LOCK_S （十进制的2 ）：表示共享锁，也就是S锁。</li><li>LOCK_X （十进制的3 ）：表示独占锁，也就是X锁。</li><li>LOCK_AUTO_INC （十进制的4 ）：表示AUTO-INC锁。</li></ul></li><li><p>锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p><ul><li>LOCK_TABLE （十进制的16 ），也就是当第5个比特位置为1时，表示表级锁。</li><li>LOCK_REC （十进制的32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li><p>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在lock_type 的值为LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</p><ul><li>LOCK_ORDINARY （十进制的0 ）：表示next-key锁。</li><li>LOCK_GAP （十进制的512 ）：也就是当第10个比特位置为1时，表示gap锁。</li><li>LOCK_REC_NOT_GAP （十进制的1024 ）：也就是当第11个比特位置为1时，表示正经记录锁。</li><li>LOCK_INSERT_INTENTION （十进制的2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。<br><strong>is_waiting 属性也放到了type_mode 这个32位的数字中</strong></li><li>LOCK_WAIT （十进制的256 ） ：也就是当第9个比特位置为1 时，表示is_waiting 为true ，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为0 时，表示is_waiting 为false ，也就是当前事务获取锁成功。</li></ul></li></ul><h4 id="一堆比特位"><a href="#一堆比特位" class="headerlink" title="一堆比特位"></a>一堆比特位</h4><p>对应着一个页面中的记录，一个比特位映射一个heap_no</p><p><img src="/attachment/dbd7d8cbbc1f954c4d21c18f051888cb.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 事务的隔离级别与 MVCC</title>
      <link href="/database/mysql/mysql-shi-wu-de-ge-chi-ji-bie-yu-mvcc/"/>
      <url>/database/mysql/mysql-shi-wu-de-ge-chi-ji-bie-yu-mvcc/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-事务的隔离级别与-MVCC"><a href="#【MySQL】-事务的隔离级别与-MVCC" class="headerlink" title="【MySQL】 事务的隔离级别与 MVCC"></a>【MySQL】 事务的隔离级别与 MVCC</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 事务的隔离级别与 MVCCdate: 2023-06-25 21:00tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 事务的隔离级别与 MVCC</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>并发事务问题</strong></p><ul><li>脏写（ Dirty Write ） 如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写</li><li>脏读（ Dirty Read ）一个事务读到了另一个未提交事务修改过的数据</li><li>不可重复读（Non-Repeatable Read） 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</li><li>幻读（Phantom）一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</li></ul><p><strong>事务隔离级别</strong></p><ul><li>READ UNCOMMITTED ：未提交读。</li><li>READ COMMITTED ：已提交读。</li><li>REPEATABLE READ ：可重复读。</li><li>SERIALIZABLE ：可串行化。</li></ul><p><strong>MVCC</strong></p><p>MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD 、REPEATABLE READ 这两种隔离级别的事务在执行普通的SEELCT 操作时访问记录的版本链的过程</p><p>版本链</p><ul><li>trx_id ：事务的事务id</li><li>roll_pointer 通过它来找到该记录修改前的信息</li></ul><p><img src="/attachment/36756f24ac5454d6bdf4625a79b63021.png"></p><p><strong>ReadView</strong></p><ul><li>m_ids ：表示在生成ReadView 时当前系统中活跃的读写事务的事务id 列表。</li><li>min_trx_id ：表示在生成ReadView 时当前系统中活跃的读写事务中最小的事务id ，也就是m_ids 中的最小值。</li><li>max_trx_id ：表示生成ReadView 时系统中应该分配给下一个事务的id 值。</li><li>creator_trx_id ：表示生成该ReadView 的事务的事务id 。</li></ul><p>READ COMMITTED —— 每次读取数据前都生成一个ReadView<br>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</p><h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><pre><code class="line-numbers language-sql">CREATE TABLE hero (number INT,name VARCHAR(100),country varchar(100),PRIMARY KEY (number)) Engine=InnoDB CHARSET=utf8;</code></pre><p>然后向这个表里插入一条数据：</p><pre><code class="line-numbers language-sql">INSERT INTO hero VALUES(1, '刘备', '蜀');</code></pre><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySQL 是一个客户端／服务器架构的软件</p><p>对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（ Session ）</p><h3 id="事务并发执行遇到的问题"><a href="#事务并发执行遇到的问题" class="headerlink" title="事务并发执行遇到的问题"></a>事务并发执行遇到的问题</h3><h4 id="脏写（-Dirty-Write-）"><a href="#脏写（-Dirty-Write-）" class="headerlink" title="脏写（ Dirty Write ）"></a>脏写（ Dirty Write ）</h4><p>如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写</p><p><img src="/attachment/33d4b1e593f31ee6473d80a30557b4c7.png"></p><h4 id="脏读（-Dirty-Read-）"><a href="#脏读（-Dirty-Read-）" class="headerlink" title="脏读（ Dirty Read ）"></a>脏读（ Dirty Read ）</h4><p>一个事务读到了另一个未提交事务修改过的数据</p><p><img src="/attachment/5466605563e108d2623de1678bbedd39.png"></p><h4 id="不可重复读（Non-Repeatable-Read）"><a href="#不可重复读（Non-Repeatable-Read）" class="headerlink" title="不可重复读（Non-Repeatable Read）"></a>不可重复读（Non-Repeatable Read）</h4><p>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</p><p><img src="/attachment/da2541ea1621f71c378e7fa04afdb962.png"></p><h4 id="幻读（Phantom）"><a href="#幻读（Phantom）" class="headerlink" title="幻读（Phantom）"></a>幻读（Phantom）</h4><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</p><p><img src="/attachment/31a5f163a9ce74f0ceeaa76fa75924a2.png"></p><h3 id="SQL标准中的四种隔离级别"><a href="#SQL标准中的四种隔离级别" class="headerlink" title="SQL标准中的四种隔离级别"></a>SQL标准中的四种隔离级别</h3><p>给这些问题按照严重性来排一下序：</p><p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p><p>设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生</p><p>制定了一个所谓的SQL标准，在标准中设立了4个隔离级别：</p><ul><li>READ UNCOMMITTED ：未提交读。</li><li>READ COMMITTED ：已提交读。</li><li>REPEATABLE READ ：可重复读。</li><li>SERIALIZABLE ：可串行化。</li></ul><p><img src="/attachment/bf6978fc8a103b03d278aed2748f433e.png"></p><p><strong>脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</strong></p><h3 id="MySQL中支持的四种隔离级别"><a href="#MySQL中支持的四种隔离级别" class="headerlink" title="MySQL中支持的四种隔离级别"></a>MySQL中支持的四种隔离级别</h3><p>与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</p><h4 id="如何设置事务的隔离级别"><a href="#如何设置事务的隔离级别" class="headerlink" title="如何设置事务的隔离级别"></a>如何设置事务的隔离级别</h4><pre><code class="line-numbers language-sql">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</code></pre><p>其中的level 可选值有4个:</p><pre><code>level: {REPEATABLE READ| READ COMMITTED| READ UNCOMMITTED| SERIALIZABLE}</code></pre><p>设置事务的隔离级别的语句中，在SET 关键字后可以放置GLOBAL 关键字、SESSION 关键字或者什么都不放，这样会对不同范围的事务产生不同的影响，具体如下：</p><ul><li>使用GLOBAL 关键字（在全局范围影响）：<ul><li>只对执行完该语句之后产生的会话起作用。</li><li>当前已经存在的会话无效。</li></ul></li><li>使用SESSION 关键字（在会话范围影响）：<ul><li>对当前会话的所有后续的事务有效</li><li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。</li><li>如果在事务之间执行，则对后续的事务有效。</li></ul></li><li>上述两个关键字都不用（只对执行语句后的下一个事务产生影响）：<ul><li>只对当前会话中下一个即将开启的事务有效。</li><li>下一个事务执行完后，后续事务将恢复到之前的隔离级别。</li><li>该语句不能在已经开启的事务中间执行，会报错的。</li></ul></li></ul><h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>聚簇索引记录中都包含两个必要的隐藏列</p><ul><li>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id 赋值给trx_id 隐藏列。</li><li>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表</p><p><img src="/attachment/36756f24ac5454d6bdf4625a79b63021.png"></p><p>所有的版本都会被roll_pointer 属性连接成一个链表，我们把这个链表称之为版本链</p><p>每个版本中还包含生成该版本时对应的事务id</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了</p><p>对于使用SERIALIZABLE 隔离级别的事务来说，设计InnoDB 的大叔规定使用加锁的方式来访问记录（加锁是啥我们后续文章中说哈）</p><p>对于使用READ COMMITTED 和REPEATABLE READ 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的</p><p><strong>核心问题</strong></p><p>需要判断一下版本链中的哪个版本是当前事务可见的</p><p>提出了一个<strong>ReadView</strong> 的概念，这个ReadView 中主要包含4个比较重要的内容：</p><ul><li>m_ids ：表示在生成ReadView 时当前系统中活跃的读写事务的事务id 列表。</li><li>min_trx_id ：表示在生成ReadView 时当前系统中活跃的读写事务中最小的事务id ，也就是m_ids 中的最小值。</li><li>max_trx_id ：表示生成ReadView 时系统中应该分配给下一个事务的id 值。</li><li>creator_trx_id ：表示生成该ReadView 的事务的事务id 。</li></ul><p>有了这个ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的trx_id 属性值<strong>等于</strong>ReadView 中的creator_trx_id 值，意味着当前事务在访问它自己修改过的记录，所以该版本可以被<strong>当前事务访问</strong>。</li><li>如果被访问版本的trx_id 属性值<strong>小于</strong>ReadView 中的min_trx_id 值，表明生成该版本的事务在当前事务生成ReadView 前<strong>已经提交</strong>，所以该版本<strong>可以</strong>被当前事务访问。</li><li>如果被访问版本的trx_id 属性值<strong>大于</strong>ReadView 中的max_trx_id 值，表明生成该版本的事务在当前事务生成ReadView 后才开启，所以该版本<strong>不可以</strong>被当前事务访问。</li><li>如果被访问版本的trx_id 属性值<strong>介于</strong>ReadView 的min_trx_id 和max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在m_ids 列表中，如果在，说明创建ReadView 时生成该版本的事务还是活跃的，该版本<strong>不可以</strong>被访问；如果不在，说明创建ReadView 时生成该版本的事务已经被提交，该版本<strong>可以</strong>被访问。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="/attachment/637fb8acc43e6383704d22877b86d666.png"></p><p>接下来看一下READ COMMITTED 和REPEATABLE READ 所谓的生成ReadView的时机不同到底不同在哪里。</p><h5 id="READ-COMMITTED-——-每次读取数据前都生成一个ReadView"><a href="#READ-COMMITTED-——-每次读取数据前都生成一个ReadView" class="headerlink" title="READ COMMITTED —— 每次读取数据前都生成一个ReadView"></a>READ COMMITTED —— 每次读取数据前都生成一个ReadView</h5><pre><code class="line-numbers language-sql"># Transaction 100BEGIN;UPDATE hero SET name = '关羽' WHERE number = 1;UPDATE hero SET name = '张飞' WHERE number = 1;# Transaction 200BEGIN;# 更新了一些别的表的记录...</code></pre><p><img src="/attachment/2171c85e333c55b04530231cd7d53a4e.png"></p><p>假设现在有一个使用READ COMMITTED 隔离级别的事务开始执行：</p><pre><code class="line-numbers language-sql"># 使用READ COMMITTED隔离级别的事务BEGIN;# SELECT1：Transaction 100、200未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'</code></pre><p>这个SELECT1 的执行过程如下：</p><ul><li>在执行 SELECT 语句时会先生成一个<strong>ReadView</strong> ， ReadView 的m_ids 列表的内容就是[100, 200] ，min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’张飞’ ，该版本的trx_id 值为100 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li><li>下一个版本的列name 的内容是’关羽’ ，该版本的trx_id 值也为100 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’刘备’ ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为’刘备’ 的记录。</li></ul><p>之后，我们把事务id 为100 的事务提交一下，就像这样：</p><pre><code class="line-numbers language-sql"># Transaction 100BEGIN;UPDATE hero SET name = '关羽' WHERE number = 1;UPDATE hero SET name = '张飞' WHERE number = 1;COMMIT;</code></pre><p>然后再到事务id 为200 的事务中更新一下表hero 中number 为1 的记录：</p><pre><code class="line-numbers language-sql"># Transaction 200BEGIN;# 更新了一些别的表的记录...UPDATE hero SET name = '赵云' WHERE number = 1;UPDATE hero SET name = '诸葛亮' WHERE number = 1;</code></pre><p>此刻，表hero 中number 为1 的记录的版本链就长这样：</p><p><img src="/attachment/ec61e30d9e71825c622557bc39c68924.png"></p><p>然后再到刚才使用READ COMMITTED 隔离级别的事务中继续查找这个number 为1 的记录，如下：</p><pre><code class="line-numbers language-sql"># 使用READ COMMITTED隔离级别的事务BEGIN;# SELECT1：Transaction 100、200均未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'# SELECT2：Transaction 100提交，Transaction 200未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'张飞'</code></pre><p>这个SELECT2 的执行过程如下：</p><ul><li>在执行SELECT 语句时会又会单独生成一个ReadView ，该ReadView 的m_ids 列表的内容就是[200] （ 事务id 为100 的那个事务已经提交了，所以再次生成快照时就没有它了）， min_trx_id 为200 ，max_trx_id 为201 ， creator_trx_id 为0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’诸葛亮’ ，该版本的trx_id 值为200 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li><li>下一个版本的列name 的内容是’赵云’ ，该版本的trx_id 值为200 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’张飞’ ，该版本的trx_id 值为100 ，小于ReadView 中的min_trx_id 值200 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为’张飞’ 的记录。</li></ul><p><strong>总结</strong></p><p>使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h5 id="REPEATABLE-READ-——-在第一次读取数据时生成一个ReadView"><a href="#REPEATABLE-READ-——-在第一次读取数据时生成一个ReadView" class="headerlink" title="REPEATABLE READ —— 在第一次读取数据时生成一个ReadView"></a>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</h5><p>只会在第一次执行查询语句时生成一个ReadView ，之后的查询就不会重复生成了。</p><p>比方说现在系统里有两个事务id 分别为100 、200 的事务在执行：</p><pre><code class="line-numbers language-sql"># Transaction 100BEGIN;UPDATE hero SET name = '关羽' WHERE number = 1;UPDATE hero SET name = '张飞' WHERE number = 1;# Transaction 200BEGIN;# 更新了一些别的表的记录...</code></pre><p>此刻，表hero 中number 为1 的记录得到的版本链表如下所示：</p><p><img src="/attachment/231a456a5254a23ea1f26f00a85667dd.png"></p><p>假设现在有一个使用REPEATABLE READ 隔离级别的事务开始执行：</p><pre><code class="line-numbers language-sql"># 使用REPEATABLE READ隔离级别的事务BEGIN;# SELECT1：Transaction 100、200未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'</code></pre><p>这个SELECT1 的执行过程如下：</p><ul><li>在执行SELECT 语句时会先生成一个ReadView ， ReadView 的m_ids 列表的内容就是[100, 200] ，min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’张飞’ ，该版本的trx_id 值为100 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li><li>下一个版本的列name 的内容是’关羽’ ，该版本的trx_id 值也为100 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’刘备’ ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为’刘备’ 的记录。</li></ul><p>之后，我们把事务id 为100 的事务提交一下，就像这样：</p><pre><code class="line-numbers language-sql"># Transaction 100BEGIN;UPDATE hero SET name = '关羽' WHERE number = 1;UPDATE hero SET name = '张飞' WHERE number = 1;COMMIT;</code></pre><p>然后再到事务id 为200 的事务中更新一下表hero 中number 为1 的记录：</p><pre><code class="line-numbers language-sql"># Transaction 200BEGIN;# 更新了一些别的表的记录...UPDATE hero SET name = '赵云' WHERE number = 1;UPDATE hero SET name = '诸葛亮' WHERE number = 1;</code></pre><p>此刻，表hero 中number 为1 的记录的版本链就长这样：</p><p><img src="/attachment/cee859da72faeb6e3b31c814e8f10bdc.png"></p><p>然后再到刚才使用REPEATABLE READ 隔离级别的事务中继续查找这个number 为1 的记录，如下：</p><pre><code class="line-numbers language-sql"># 使用REPEATABLE READ隔离级别的事务BEGIN;# SELECT1：Transaction 100、200均未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'# SELECT2：Transaction 100提交，Transaction 200未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值仍为'刘备'</code></pre><p>这个SELECT2 的执行过程如下：</p><ul><li>因为当前事务的隔离级别为REPEATABLE READ ，而之前在执行SELECT1 时已经生成过ReadView 了，所以此时直接复用之前的ReadView ，之前的ReadView 的m_ids 列表的内容就是[100, 200] ， min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’诸葛亮’ ，该版本的trx_id 值为200 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li><li>下一个版本的列name 的内容是’赵云’ ，该版本的trx_id 值为200 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’张飞’ ，该版本的trx_id 值为100 ，而m_ids 列表中是包含值为100 的事务id 的，所以该版本也不符合要求，同理下一个列name 的内容是’关羽’ 的版本也不符合要求。继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’刘备’ ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值 100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c 为’刘备’ 的记录。</li></ul><p>也就是说两次SELECT 查询得到的结果是重复的，记录的列c 值都是’刘备’ ，这就是可重复读的含义。如果我们之后再把事务id 为200 的记录提交了，然后再到刚才使用REPEATABLE READ 隔离级别的事务中继续查找这个number 为1 的记录，得到的结果还是’刘备’ ，具体执行过程大家可以自己分析一下。</p><h3 id="MVCC小结"><a href="#MVCC小结" class="headerlink" title="MVCC小结"></a>MVCC小结</h3><p>所谓的MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD 、REPEATABLE READ 这两种隔离级别的事务在执行普通的SEELCT 操作时访问记录的版本链的过程</p><p>这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同就是：</p><p><strong>生成ReadView的时机不同</strong>，</p><ul><li>READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，</li><li>而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul><h3 id="关于purge"><a href="#关于purge" class="headerlink" title="关于purge"></a>关于purge</h3><p>我们说insert undo 在事务提交之后就可以被释放掉了，而update undo 由于还需要支持MVCC ，不能立即删除掉。<br>为了支持MVCC ，对于delete mark 操作来说，仅仅是在记录上打一个删除标记，并没有真正将它删除掉。</p><p>随着系统的运行，在确定系统中包含最早产生的那个ReadView 的事务不会再访问某些update undo日志以及被打了删除标记的记录后，有一个后台运行的<strong>purge线程</strong>会把它们真正的删除掉。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 日志 - undo</title>
      <link href="/database/mysql/mysql-ri-zhi-undo/"/>
      <url>/database/mysql/mysql-ri-zhi-undo/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-日志-undo"><a href="#【MySQL】-日志-undo" class="headerlink" title="【MySQL】 日志 - undo"></a>【MySQL】 日志 - undo</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 日志 - undodate: 2023-06-25 16:14tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 日志 - undo</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>回滚</strong>是指将已经提交的事务撤销，恢复到事务开始之前的状态。保证数据的一致性和完整性。<br><strong>把回滚时所需的东西都给记下来</strong><br>把这些为了回滚而记录的这些东东称之为撤销日志，英文名为undo log</p><p><strong>事务id</strong><br>如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB 存储引擎就会给它分配一个独一无二的事务id<br>在内存中维护一个全局变量，每当需要为某个事务分配一个事务id 时，就会把该变量的值当作事务id 分配给该事务，并且把该变量自增1。<br><strong>trx_id隐藏列</strong></p><p><strong>roll pointer隐藏列的含义</strong></p><p>本质上就是一个指向记录对应的undo日志的一个指针。</p><p><img src="/attachment/dca520e076cde66ce47fe2ae73824f33.png"></p><p><strong>undo日志的格式</strong></p><ul><li>INSERT操作对应的undo日志<ul><li>写对应的undo 日志时，主要是把这条记录的主键信息记上。<br><img src="/attachment/1ada3449637039388de5c57e0fa1644b.png"></li></ul></li><li>DELETE操作对应的undo日志<ul><li>被删除的记录其实也会根据记录头信息中的next_record 属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为垃圾链表。<br><img src="/attachment/06169958235dfb6a4b4ac6c00cbc8507.png"></li></ul></li><li>UPDATE操作对应的undo日志<ul><li>不更新主键的情况   — 更新后的列和更新前的列占用的存储空间<ul><li>就地更新（in-place update）</li><li>先删除掉旧记录，再插入新记录</li></ul></li><li>更新主键的情况<ul><li>将旧记录进行delete mark 操作</li><li>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。</li></ul></li></ul></li></ul><p><strong>FIL_PAGE_UNDO_LOG页面</strong></p><p><img src="/attachment/dbddb08e41e8e92e4a7f98f1bb2f3a8f.png"></p><p><strong>Undo页面链表</strong></p><p><img src="/attachment/4e06859c7c633b8ed617fd3e56517015.png"></p><p><strong>undo日志具体写入过程</strong></p><p>每一个Undo页面链表都对应着一个段，称之为Undo Log Segment 。<br><img src="/attachment/fc15ca718a01e53181cd23b1cdcd6c6f.png"></p><p><strong>为事务分配Undo页面链表详细过程</strong></p><ol><li>回滚段分配：</li></ol><ul><li>在事务对普通表的记录进行改动之前，会先从系统表空间的第5号页面中分配一个回滚段。</li><li>一旦某个回滚段被分配给了事务，后续对普通表的记录改动不会重复分配。</li></ul><ol start="2"><li>回滚段分配方式：</li></ol><ul><li>使用循环方式（round-robin）分配回滚段，依次分配给不同的事务。</li></ul><ol start="3"><li>缓存的undo slot：</li></ol><ul><li>分配到回滚段后，会检查回滚段的缓存链表中是否有已经缓存的undo slot。</li><li>根据操作类型（如INSERT或DELETE）选择相应的缓存链表进行查找。</li><li>如果存在缓存的undo slot，则将其分配给当前事务。</li><li>如果没有可用的缓存undo slot，则在Rollback Segment Header页面中查找可用的undo slot。</li></ul><ol start="4"><li>分配可用的undo slot：</li></ol><ul><li>从Rollback Segment Header页面中开始查找可用的undo slot。</li><li>从第0个undo slot开始，如果其值为FIL_NULL，则表示该undo slot为空闲，将其分配给当前事务。</li><li>如果第0个undo slot不满足条件，则继续查找下一个undo slot，直到找到可用的undo slot。</li><li>如果所有的1024个undo slot都不为空闲，则报错。</li></ul><ol start="5"><li>Undo Log Segment和Undo页面链表：</li></ol><ul><li>如果分配到的undo slot是从缓存链表中获取的，那么对应的Undo Log Segment已经分配。</li><li>否则，需要重新分配一个Undo Log Segment，并从该Undo Log Segment中申请一个页面作为Undo页面链表的第一个页面。</li></ul><ol start="6"><li>写入Undo日志：</li></ol><ul><li>事务可以将undo日志写入先前申请的Undo页面链表中。</li></ul><h2 id="事务回滚的需求"><a href="#事务回滚的需求" class="headerlink" title="事务回滚的需求"></a>事务回滚的需求</h2><p>出现问题</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入ROLLBACK 语句结束当前的事务的执行。</li></ul><p><strong>回滚</strong>是指将已经提交的事务撤销，恢复到事务开始之前的状态。保证数据的一致性和完整性。</p><p><strong>把回滚时所需的东西都给记下来</strong></p><p>把这些为了回滚而记录的这些东东称之为撤销日志，英文名为undo log</p><p>由于查询操作（ SELECT ）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</p><h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><h3 id="给事务分配id的时机"><a href="#给事务分配id的时机" class="headerlink" title="给事务分配id的时机"></a>给事务分配id的时机</h3><p>如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB 存储引擎就会给它分配一个独一无二的事务id</p><p>分配方式如下</p><ul><li>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id ，否则的话是不分配事务id 的。</li><li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id ，否则的话也是不分配事务id 的。</li></ul><h3 id="事务id是怎么生成的"><a href="#事务id是怎么生成的" class="headerlink" title="事务id是怎么生成的"></a>事务id是怎么生成的</h3><p>这个事务id 本质上就是一个数字，它的分配策略和我们前边提到的对隐藏列row_id （当用户没有为表创建主键 和UNIQUE 键时InnoDB 自动创建的列）的分配策略大抵相同，具体策略如下：</p><ul><li>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务id 时，就会把该变量的值当作事务id 分配给该事务，并且把该变量自增1。</li><li>每当这个变量的值为256 的倍数时，就会将该变量的值刷新到系统表空间的页号为5 的页面中一个称之为Max Trx ID 的属性处，这个属性占用8 个字节的存储空间。</li><li>当系统下一次重新启动时，会将上边提到的Max Trx ID 属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于Max Trx ID 属性值）。</li></ul><p>这样就可以保证整个系统中分配的事务id 值是一个递增的数字。先被分配id 的事务得到的是较小的事务id ，后被分配id 的事务得到的是较大的事务id 。</p><h3 id="trx-id隐藏列"><a href="#trx-id隐藏列" class="headerlink" title="trx_id隐藏列"></a>trx_id隐藏列</h3><p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列。</p><p><img src="/attachment/30cfac561c89751ffeed249c4ac4bad3.png"></p><h2 id="undo日志的格式"><a href="#undo日志的格式" class="headerlink" title="undo日志的格式"></a>undo日志的格式</h2><p>为了实现事务的原子性，<br>InnoDB 存储引擎在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。<br>一般每对一条记录做一次改动，就对应着一条undo日志，但在某些更新记录的操作中，也可能会对应着2 条undo日志</p><h3 id="INSERT操作对应的undo日志"><a href="#INSERT操作对应的undo日志" class="headerlink" title="INSERT操作对应的undo日志"></a>INSERT操作对应的undo日志</h3><p>插入的结果就是这条记录被放到了一个数据页中。<br>如果希望回滚这个插入操作，那么把这条记录删除就好了，也就是说在写对应的undo 日志时，主要是把这条记录的主键信息记上。</p><p>设计了一个类型为 TRX_UNDO_INSERT_REC 的undo日志</p><p><img src="/attachment/1ada3449637039388de5c57e0fa1644b.png"></p><ul><li>undo no 在一个事务中是从0 开始递增的，也就是说只要事务没提交，每生成一条undo日志，那么该条日志的undo no 就增1。</li><li>如果记录中的主键只包含一个列，那么在类型为TRX_UNDO_INSERT_REC 的undo日志中只需要把该列占用的存储空间大小和真实值记录下来，如果记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的len 就代表列占用的存储空间大小， value 就代表列的真实值）。</li></ul><pre><code class="line-numbers language-ad-tip">当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。不过记录undo日志时，我们只需要考虑向**聚簇索引**插入记录时的情况就好了，因为其实聚簇索引记录和二级索引记录是一一对应的，我们在回滚插入操作时，只需要知道这条记录的主键信息，然后**根据主键信息做对应的删除操作**，做删除操作时就会顺带着把所有二级索引中相应的记录也删除掉。后边说到的DELETE操作和UPDATE操作对应的undo日志也都是针对聚簇索引记录而言的，我们之后就不强调了。</code></pre><pre><code class="line-numbers language-ad-tip">为了最大限度的节省undo日志占用的存储空间，和我们前边说过的redo日志类似，设计InnoDB的大叔会给undo日志中的某些属性进行压缩处理，具体的压缩细节我们就不唠叨了。</code></pre><pre><code class="line-numbers language-ad-example">title: 示例```sql# 插入两条记录INSERT INTO undo_demo(id, key1, col)VALUES (1, 'AWM', '狙击枪'), (2, 'M416', '步枪');```第一条undo日志的undo no 为0 ，记录主键占用的存储空间长度为4 ，真实值为1 。画一个示意图就是这样：![](attachment/4474a5bc4274ae85d9515a24d16f5ee3.png)第二条undo日志的undo no 为1 ，记录主键占用的存储空间长度为4 ，真实值为2 。画一个示意图就是这样（与第一条undo日志对比， undo no 和主键各列信息有不同）：![](attachment/7d2d541d16f1ebdfd7310249c8d70fa7.png)</code></pre><h4 id="roll-pointer隐藏列的含义"><a href="#roll-pointer隐藏列的含义" class="headerlink" title="roll pointer隐藏列的含义"></a>roll pointer隐藏列的含义</h4><p>本质上就是一个指向记录对应的undo日志的一个指针。</p><p><img src="/attachment/dca520e076cde66ce47fe2ae73824f33.png"></p><p>roll_pointer 本质就是一个指针，指向记录对应的undo日志。</p><h3 id="DELETE操作对应的undo日志"><a href="#DELETE操作对应的undo日志" class="headerlink" title="DELETE操作对应的undo日志"></a>DELETE操作对应的undo日志</h3><p>插入到页面中的记录会根据记录头信息中的next_record 属性组成一个单向链表，我们把这个链表称之为正常记录链表</p><p>被删除的记录其实也会根据记录头信息中的next_record 属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为垃圾链表。</p><p><strong>假设此刻某个页面中的记录分布情况是这样的</strong></p><p><img src="/attachment/8447c9f1e11276338034c8f58b777e16.png"></p><p>页面的Page Header 部分的PAGE_FREE 属性的值代表指向垃圾链表头节点的指针。</p><p>假设现在我们准备使用DELETE 语句把正常记录链表中的最后一条记录给删除掉，其实这个删除的过程需要经历两个阶段：</p><p>阶段一：仅仅将记录的delete_mask 标识位设置为1 ，其他的不做修改（其实会修改记录的trx_id 、roll_pointer 这些隐藏列的值）。设计InnoDB 的大叔把这个阶段称之为delete mark 。</p><p><img src="/attachment/1482eea1a3c45b7dc02bffc72502aab3.png"></p><p>正常记录链表中的最后一条记录的delete_mask值被设置为1，但是并没有被加入到垃圾链表。也就是此时记录处于一个中间状态</p><p>阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。</p><p>所谓真正的删除就是<strong>把该记录从正常记录链表中移除，并且加入到垃圾链表中，然后还要调整一些页面的其他信息</strong>，比如页面中的用户记录数量PAGE_N_RECS 、上次插入记录的位置PAGE_LAST_INSERT 、垃圾链表头节点的指针PAGE_FREE 、页面中可重用的字节数量PAGE_GARBAGE 、还有页目录的一些信息等等。设计InnoDB 的大叔把这个阶段称之为<strong>purge</strong> 。</p><p><img src="/attachment/72485d4f6abd41a83f5a19aa460e454d.png"></p><p><img src="/attachment/06169958235dfb6a4b4ac6c00cbc8507.png"></p><p>在删除语句所在的事务提交之前，只会经历阶段一，也就是delete mark 阶段（提交之后我们就不用回滚了，所以只需考虑对删除操作的阶段一做的影响进行回滚）。</p><p>注意一下这几点：</p><ul><li>在对一条记录进行delete mark 操作前，需要把该记录的旧的trx_id 和roll_pointer 隐藏列的值都给记到对应的undo日志中来，就是我们图中显示的old trx_id 和old roll_pointer 属性。<br>这样有一个好处，那就是可以通过undo日志的old roll_pointer 找到记录在修改之前对应的undo 日志。比方说在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作，这个过程的示意图就是这样：</li></ul><p><img src="/attachment/75cb3575b78b1274b8f7588af08d3c61.png"></p><p>undo 日志串成了一个链表。这个链表就称之为<strong>版本链</strong></p><ul><li>与类型为TRX_UNDO_INSERT_REC 的undo日志不同，类型为TRX_UNDO_DEL_MARK_REC 的undo 日志还多了一个索引列各列信息的内容<br>如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到这个索引列各列信息部分<br>所谓的相关信息包括该列在记录中的位置（用pos 表示），该列占用的存储空间大小（用len 表示），该列实际值（用value 表示）。</li></ul><pre><code class="line-numbers language-ad-example">title: 示例```sqlBEGIN; # 显式开启一个事务，假设该事务的id为100# 插入两条记录INSERT INTO undo_demo(id, key1, col)VALUES (1, 'AWM', '狙击枪'), (2, 'M416', '步枪');# 删除一条记录DELETE FROM undo_demo WHERE id = 1;```![](attachment/6a23f0b932bd9d7a43cc8261dae304f3.png)</code></pre><h3 id="UPDATE操作对应的undo日志"><a href="#UPDATE操作对应的undo日志" class="headerlink" title="UPDATE操作对应的undo日志"></a>UPDATE操作对应的undo日志</h3><p>在执行UPDATE 语句时， InnoDB 对更新主键和不更新主键这两种情况有截然不同的处理方案。</p><h4 id="不更新主键的情况"><a href="#不更新主键的情况" class="headerlink" title="不更新主键的情况"></a>不更新主键的情况</h4><ul><li>就地更新（in-place update）</li></ul><p>更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行就地更新： 直接在原记录的基础上修改对应列的值</p><ul><li>先删除掉旧记录，再插入新记录</li></ul><p>如果有<strong>任何</strong>一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。</p><p>删除并不是delete mark 操作，而是<strong>真正</strong>的删除掉，也就是把这条记录从正常记录链表中移除并加入到垃圾链表中，并且修改页面中相应的统计信息（比如PAGE_FREE 、PAGE_GARBAGE 等这些信息）</p><p>设计了一种类型为TRX_UNDO_UPD_EXIST_REC 的undo日志</p><p>它的完整结构如下：</p><p><img src="/attachment/697ff0ee0dc43b8dc4102d3066b362e1.png"></p><p>注意这么几点：</p><ul><li>n_updated 属性表示本条UPDATE 语句执行后将有几个列被更新，后边跟着的&lt;pos, old_len, old_value&gt; 分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。</li><li>如果在UPDATE 语句中更新的列包含索引列，那么也会添加索引列各列信息这个部分，否则的话是不会添加这个部分的。</li></ul><pre><code class="line-numbers language-ad-example">title: 示例```sqlBEGIN; # 显式开启一个事务，假设该事务的id为100# 插入两条记录INSERT INTO undo_demo(id, key1, col)VALUES (1, 'AWM', '狙击枪'), (2, 'M416', '步枪');# 删除一条记录DELETE FROM undo_demo WHERE id = 1;# 更新一条记录UPDATE undo_demoSET key1 = 'M249', col = '机枪'WHERE id = 2;```![](attachment/a8c6721ce95c69c055ec30a6ff22878d.png)</code></pre><h4 id="更新主键的情况"><a href="#更新主键的情况" class="headerlink" title="更新主键的情况"></a>更新主键的情况</h4><ul><li>将旧记录进行delete mark 操作</li></ul><p>在UPDATE 语句所在的事务提交前，对旧记录只做一个delete mark 操作<br>在事务提交后才由专门的线程做purge操作，把它加入到垃圾链表中。</p><ul><li>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。<br>由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。</li></ul><h2 id="通用链表结构"><a href="#通用链表结构" class="headerlink" title="通用链表结构"></a>通用链表结构</h2><p>在写入undo日志的过程中会使用到多个链表，很多链表都有同样的节点结构<br><img src="/attachment/1d51ddc012e93d621b948614da9e0e84.png"></p><ul><li>Pre Node Page Number 和Pre Node Offset 的组合就是指向前一个节点的指针</li><li>Next Node Page Number 和Next Node Offset 的组合就是指向后一个节点的指针。</li></ul><p>整个List Node 占用12 个字节的存储空间。</p><p>为了更好的管理链表，设计InnoDB 的大叔还提出了一个<strong>基节点</strong>的结构，里边存储了这个链表的头节点、尾节点以及链表长度信息，基节点的结构示意图如下：</p><p><img src="/attachment/bd6c7c3185930138b1a278c90e1b4623.png"></p><p>其中：</p><ul><li>List Length 表明该链表一共有多少节点。</li><li>First Node Page Number 和First Node Offset 的组合就是指向链表头节点的指针。</li><li>Last Node Page Number 和Last Node Offset 的组合就是指向链表尾节点的指针。</li></ul><p>整个List Base Node 占用16 个字节的存储空间。</p><p>undefined</p><h2 id="FIL-PAGE-UNDO-LOG页面"><a href="#FIL-PAGE-UNDO-LOG页面" class="headerlink" title="FIL_PAGE_UNDO_LOG页面"></a>FIL_PAGE_UNDO_LOG页面</h2><p>表空间其实是由许许多多的页面构成的. 专门用来存储undo日志的, 称之为FIL_PAGE_UNDO_LOG 类型的</p><p><img src="/attachment/dbddb08e41e8e92e4a7f98f1bb2f3a8f.png"></p><p>Undo Page Header 是Undo页面所特有的</p><p><img src="/attachment/a1b1085573cca29947e1caab8380b967.png"></p><ul><li>TRX_UNDO_PAGE_TYPE ：本页面准备存储什么种类的undo日志。<ul><li>TRX_UNDO_INSERT （使用十进制1 表示）：类型为TRX_UNDO_INSERT_REC 的undo日志属于此大类，一般由INSERT 语句产生，或者在UPDATE 语句中有更新主键的情况也会产生此类型的undo日志。</li><li>TRX_UNDO_UPDATE （使用十进制2 表示）：除了类型为TRX_UNDO_INSERT_REC 的undo日志，其他类型的undo日志都属于这个大类，比如我们前边说的TRX_UNDO_DEL_MARK_REC 、TRX_UNDO_UPD_EXIST_REC 啥的，一般由DELETE 、UPDATE 语句产生的undo日志属于这个大类。</li></ul></li><li>TRX_UNDO_PAGE_START ：表示在当前页面中是从什么位置开始存储undo日志的，或者说表示第一条undo日志在本页面中的起始偏移量。</li><li>TRX_UNDO_PAGE_FREE ：与上边的TRX_UNDO_PAGE_START 对应，表示当前页面中存储的最后一条undo 日志结束时的偏移量，或者说从这个位置开始，可以继续写入新的undo日志。</li><li>TRX_UNDO_PAGE_NODE： 代表一个List Node 结构</li></ul><h2 id="Undo页面链表"><a href="#Undo页面链表" class="headerlink" title="Undo页面链表"></a>Undo页面链表</h2><h3 id="单个事务中的Undo页面链表"><a href="#单个事务中的Undo页面链表" class="headerlink" title="单个事务中的Undo页面链表"></a>单个事务中的Undo页面链表</h3><p>每条记录进行改动前，都需要记录1条或2条的undo日志，所以在一个事务执行过程中可能产生很多undo日志，这些日志可能一个页面放不下，需要放到多个页面中，这些页面就通过我们上边介绍的TRX_UNDO_PAGE_NODE 属性连成了链表：</p><p><img src="/attachment/7d2fffea050cebeec50bb194f5224f74.png"></p><p>大家往上再瞅一瞅上边的图，我们特意把链表中的第一个Undo页面给标了出来，称它为first undo page ，其余的Undo页面称之为normal undo page ，这是因为在first undo page 中除了记录Undo Page Header 之外，还会记录其他的一些管理信息，这个我们稍后再说哈。</p><p>在一个事务执行过程中，可能混着执行INSERT 、DELETE 、UPDATE 语句，也就意味着会产生不同类型的undo日志。<br>同一个Undo页面要么只存储TRX_UNDO_INSERT 大类的undo日志，要么只存储 TRX_UNDO_UPDATE 大类的undo日志<br>在一个事务执行过程中就可能需要2个Undo页面的链表，一个称之为insert undo链表，另一个称之为update undo链表，</p><p><img src="/attachment/a6ba0236eed051a8a857f1455daaa207.png"></p><p>另外，设计InnoDB 的大叔规定对普通表和临时表的记录改动时产生的undo日志要分别记录，所以在一个事务中最多有4个以Undo页面为节点组成的链表：</p><p><img src="/attachment/4e06859c7c633b8ed617fd3e56517015.png"></p><p>并不是在事务一开始就会为这个事务分配这4个链表，具体分配策略如下：</p><ul><li>刚刚开启事务时，一个Undo页面链表也不分配。</li><li>当事务执行过程中向普通表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个普通表的insert undo链表。</li><li>当事务执行过程中删除或者更新了普通表中的记录之后，就会为其分配一个普通表的update undo链表。</li><li>当事务执行过程中向临时表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个临时表的insert undo链表。</li><li>当事务执行过程中删除或者更新了临时表中的记录之后，就会为其分配一个临时表的update undo链表。</li></ul><p>总结: <strong>按需分配，啥时候需要啥时候再分配，不需要就不分配。</strong></p><h3 id="多个事务中的Undo页面链表"><a href="#多个事务中的Undo页面链表" class="headerlink" title="多个事务中的Undo页面链表"></a>多个事务中的Undo页面链表</h3><p>不同事务执行过程中产生的undo日志需要被写入到不同的Undo页面链表中</p><h2 id="undo日志具体写入过程"><a href="#undo日志具体写入过程" class="headerlink" title="undo日志具体写入过程"></a>undo日志具体写入过程</h2><h3 id="段（Segment）的概念"><a href="#段（Segment）的概念" class="headerlink" title="段（Segment）的概念"></a>段（Segment）的概念</h3><p><img src="/attachment/9b951adb2a230815bbb6335b622dbf36.png"></p><p>整个Segment Header 占用10个字节大小，各个属性的意思如下：</p><ul><li>Space ID of the INODE Entry ： INODE Entry 结构所在的表空间ID。</li><li>Page Number of the INODE Entry ： INODE Entry 结构所在的页面页号。</li><li>Byte Offset of the INODE Ent ： INODE Entry 结构在该页面中的偏移量</li></ul><h3 id="Undo-Log-Segment-Header"><a href="#Undo-Log-Segment-Header" class="headerlink" title="Undo Log Segment Header"></a>Undo Log Segment Header</h3><p>每一个Undo页面链表都对应着一个段，称之为Undo Log Segment 。</p><p><img src="/attachment/50f58981009c4f5d0f1c5e115800e148.png"></p><p>可以看到这个Undo 链表的第一个页面比普通页面多了个Undo Log Segment Header</p><p><img src="/attachment/0f60c1bad451360ffc1d5c08857a0109.png"></p><ul><li>TRX_UNDO_STATE ：本Undo页面链表处在什么状态。<ul><li>一个Undo Log Segment 可能处在的状态包括：</li><li>TRX_UNDO_ACTIVE ：活跃状态，也就是一个活跃的事务正在往这个段里边写入undo日志。</li><li>TRX_UNDO_CACHED ：被缓存的状态。处在该状态的Undo页面链表等待着之后被其他事务重用。</li><li>TRX_UNDO_TO_FREE ：对于insert undo 链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li><li>TRX_UNDO_TO_PURGE ：对于update undo 链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li><li>TRX_UNDO_PREPARED ：包含处于PREPARE 阶段的事务产生的undo日志。</li></ul></li><li>TRX_UNDO_LAST_LOG ：本Undo页面链表中最后一个Undo Log Header 的位置。</li><li>TRX_UNDO_FSEG_HEADER ：本Undo页面链表对应的段的Segment Header 信息（就是我们上一节介绍的那个10字节结构，通过这个信息可以找到该段对应的INODE Entry ）。</li><li>TRX_UNDO_PAGE_LIST ： Undo页面链表的基节点。</li></ul><h3 id="Undo-Log-Header"><a href="#Undo-Log-Header" class="headerlink" title="Undo Log Header"></a>Undo Log Header</h3><p>同一个事务向一个Undo页面链表中写入的undo日志算是一个组</p><p>设计InnoDB 的大叔把存储这些属性的地方称之为Undo Log Header</p><p>所以Undo页面链表的第一个页面在真正写入undo日志前，其实都会被填充Undo Page Header 、Undo Log Segment Header 、Undo Log Header 这3个部分</p><p><img src="/attachment/78ae7b294f300af8914dfd9612bd9793.png"></p><p>Undo Log Header 具体的结构如下：</p><p><img src="/attachment/548a5d90c71252a091facf45c0f764e0.png"></p><ul><li>TRX_UNDO_TRX_ID ：生成本组undo日志的事务id 。</li><li>TRX_UNDO_TRX_NO ：事务提交后生成的一个需要序号，使用此序号来标记事务的提交顺序（先提交的此序号小，后提交的此序号大）。</li><li>TRX_UNDO_DEL_MARKS ：标记本组undo 日志中是否包含由于Delete mark 操作产生的undo日志。</li><li>TRX_UNDO_LOG_START ：表示本组undo 日志中第一条undo日志的在页面中的偏移量。</li><li>TRX_UNDO_XID_EXISTS ：本组undo日志是否包含XID信息。</li><li>TRX_UNDO_DICT_TRANS ：标记本组undo日志是不是由DDL语句产生的。</li><li>TRX_UNDO_TABLE_ID ：如果TRX_UNDO_DICT_TRANS 为真，那么本属性表示DDL语句操作的表的table id 。</li><li>TRX_UNDO_NEXT_LOG ：下一组的undo日志在页面中开始的偏移量。</li><li>TRX_UNDO_PREV_LOG ：上一组的undo日志在页面中开始的偏移量。</li><li>TRX_UNDO_HISTORY_NODE ：一个12字节的List Node 结构，代表一个称之为History 链表的节点。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对于没有被重用的Undo页面链表来说，链表的第一个页面，也就是first undo page 在真正写入undo日志前，会填充Undo Page Header 、Undo Log Segment Header 、Undo Log Header 这3个部分，之后才开始正式写入undo日志。</p><p>normal undo page 在真正写入undo日志前，只会填充Undo Page Header 。</p><p>链表的List Base Node 存放到first undo page 的Undo Log Segment Header 部分， List Node 信息存放到每一个Undo页面的undo Page Header 部分</p><p><img src="/attachment/fc15ca718a01e53181cd23b1cdcd6c6f.png"></p><h2 id="重用Undo页面"><a href="#重用Undo页面" class="headerlink" title="重用Undo页面"></a>重用Undo页面</h2><p>为每个事务单独分配相应的Undo页面链表（最多可能单独分配4个链表）</p><p>在事务提交后在某些情况下重用该事务的Undo页面链表。一个Undo页面链表是否可以被重用的条件很简单：</p><ul><li>该链表中只包含一个Undo页面。</li></ul><p>只有在Undo页面链表中只包含一个Undo 页面时，该链表才可以被下一个事务所重用。</p><ul><li>该Undo页面已经使用的空间小于整个页面空间的3/4。</li></ul><h2 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h2><h3 id="回滚段的概念"><a href="#回滚段的概念" class="headerlink" title="回滚段的概念"></a>回滚段的概念</h3><p>在这个页面中存放了各个Undo页面链表的frist undo page 的页号，他们把这些页号称之为undo slot 。</p><pre><code class="line-numbers language-ad-tip">title: 理解每个Undo页面链表都相当于是一个班，这个链表的first undo page 就相当于这个班的班长，找到了这个班的班长，就可以找到班里的其他同学（其他同学相当于normal undo page ）。有时候学校需要向这些班级传达一下精神，就需要把班长都召集在会议室，这个Rollback Segment Header 就相当于是一个会议室。</code></pre><p><img src="/attachment/a6a8df0602a2be0d8f1f149bd715ca13.png"></p><p>每一个Rollback Segment Header 页面都对应着一个段，这个段就称为Rollback Segment ，翻译过来就是回滚段。</p><p>Rollback Segment Header 的页面的各个部分的含义都是啥意思：</p><ul><li>TRX_RSEG_MAX_SIZE ：本Rollback Segment 中管理的所有Undo页面链表中的Undo页面数量之和的最大值。</li><li>TRX_RSEG_HISTORY_SIZE ： History 链表占用的页面数量。</li><li>TRX_RSEG_HISTORY ： History 链表的基节点。</li><li>TRX_RSEG_FSEG_HEADER ：本Rollback Segment 对应的10字节大小的Segment Header 结构，通过它可以找到本段对应的INODE Entry 。</li><li>TRX_RSEG_UNDO_SLOTS ：各个Undo页面链表的first undo page 的页号集合，也就是undo slot 集合。</li></ul><h3 id="从回滚段中申请Undo页面链表"><a href="#从回滚段中申请Undo页面链表" class="headerlink" title="从回滚段中申请Undo页面链表"></a>从回滚段中申请Undo页面链表</h3><h3 id="多个回滚段"><a href="#多个回滚段" class="headerlink" title="多个回滚段"></a>多个回滚段</h3><p>不同的回滚段可能分布在不同的表空间中</p><p><img src="/attachment/510d1aa73ece25d1f2766fa5a840bf0c.png"></p><h3 id="回滚段的分类"><a href="#回滚段的分类" class="headerlink" title="回滚段的分类"></a>回滚段的分类</h3><p>针对普通表和临时表划分不同种类的回滚段的原因：在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。</p><h3 id="为事务分配Undo页面链表详细过程"><a href="#为事务分配Undo页面链表详细过程" class="headerlink" title="为事务分配Undo页面链表详细过程"></a>为事务分配Undo页面链表详细过程</h3><ul><li>事务在执行过程中对普通表的记录首次做改动之前，首先会到系统表空间的第5 号页面中<strong>分配一个回滚段</strong>（其实就是获取一个Rollback Segment Header 页面的地址）。一旦<strong>某个回滚段被分配给了这个事务</strong>，那么之后该事务中再对普通表的记录做改动时，就<strong>不会重复分配</strong>了。</li><li>使用传说中的<strong>round-robin （循环使用）方式来分配回滚段</strong>。比如当前事务分配了第0 号回滚段，那么下一个事务就要分配第33 号回滚段，下下个事务就要分配第34 号回滚段，简单一点的说就是<strong>这些回滚段被轮着分配给不同的事务</strong>（就是这么简单粗暴，没啥好说的）。</li><li>在分配到回滚段后，首先看一下这个回滚段的两个cached链表<strong>有没有已经缓存了的undo slot</strong> ，比如如果事务做的是INSERT 操作，就去回滚段对应的insert undo cached链表中看看有没有缓存的undo slot ；如果事务做的是DELETE 操作，就去回滚段对应的update undo cached链表中看看有没有缓存的undo slot 。如果<strong>有缓存</strong>的undo slot ，那么就把<strong>这个缓存的undo slot 分配给该事务</strong>。如果<strong>没有缓存</strong>的undo slot 可供分配，那么就要到<strong>Rollback Segment Header</strong> 页面中<strong>找一个可用的undo slot 分配给当前事务</strong>。<ul><li>从Rollback Segment Header 页面中分配可用的undo slot 的方式我们上边也说过了，就是从第0 个undoslot 开始，如果该undo slot 的值为FIL_NULL ，意味着这个undo slot 是空闲的，就把这个undo slot分配给当前事务，否则查看第1 个undo slot 是否满足条件，依次类推，直到最后一个undo slot 。如果这1024 个undo slot 都没有值为FIL_NULL 的情况，就直接报错喽（一般不会出现这种情况）～</li></ul></li><li>找到可用的undo slot 后，如果该undo slot 是<strong>从cached链表中获取</strong>的，那么它对应的Undo LogSegment 已经分配了，否则的话需要重新分配一个<strong>Undo Log Segment</strong> ，然后从该Undo Log Segment 中<strong>申请一个页面</strong>作为Undo页面链表的<strong>first undo page</strong> 。</li><li>然后事务就可以把undo日志写入到上边申请的Undo页面链表了！</li></ul><p>对临时表的记录做改动的步骤和上述的一样，就不赘述了。</p><p>不错需要再次强调一次，如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配<strong>2个回滚段</strong>。并发执行的不同事务其实也可以被分配相同的回滚段，只要<strong>分配不同的undoslot</strong>就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 日志 - redo</title>
      <link href="/database/mysql/mysql-ri-zhi-redo/"/>
      <url>/database/mysql/mysql-ri-zhi-redo/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-日志-redo"><a href="#【MySQL】-日志-redo" class="headerlink" title="【MySQL】 日志 - redo"></a>【MySQL】 日志 - redo</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 日志 - redodate: 2023-06-25 10:13tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。</li><li>redo日志的主要功能是<strong>保证数据库的持久性和恢复能力</strong>。</li><li>redo 日志本质上只是记录了一下<strong>事务对数据库做了哪些修改</strong>, 在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。<ul><li>type ：该条redo 日志的类型。</li><li>space ID ：表空间ID。</li><li>page number ：页号。</li><li>data ：该条redo 日志的具体内容。</li></ul></li></ul><p><img src="/attachment/95d39a797c7e8abe375c63e8bf4c9052.png"></p><ul><li>Mini-Transaction<ul><li>对底层页面中的一次原子访问的过程称之为一个Mini-Transaction ，简称mtr。</li><li>以组的形式写入redo日志 —  <strong>原子</strong></li><li>修改一次Max Row ID 的值算是一个Mini-Transaction</li><li>向某个索引对应的B+ 树中插入一条记录的过程也算是一个Mini-Transaction</li></ul></li></ul><p><img src="/attachment/9dc564aab6d3f1055f5b09bf9a4eebac.png"></p><ul><li><p>redo日志的写入过程</p><ul><li>redo log block<br>  <img src="/attachment/1d05f86aacee59136739ffecdf347977.png"></li><li>redo日志缓冲区<ul><li>redo日志写入log buffer<ul><li><strong>buf_free</strong> 的全局变量，该变量指明后续写入的redo 日志应该写入到log buffer 中的哪个位置</li></ul></li></ul></li></ul></li><li><p>redo日志文件</p><ul><li>redo日志刷盘时机<ul><li>log buffer 空间不足时</li><li>事务提交时</li><li>后台线程不停的刷刷刷<ul><li>后台有一个线程，大约每秒都会刷新一次log buffer 中的redo 日志到磁盘。</li></ul></li><li>正常关闭服务器时</li><li>做所谓的checkpoint 时（我们现在没介绍过checkpoint 的概念，稍后会仔细唠叨，稍安勿躁）</li><li>其他的一些情况…</li></ul></li><li>redo日志文件格式<br>  <img src="/attachment/8e93c10b72701ec5752a42211bd479d4.png"></li></ul></li><li><p>Log Sequeue Number</p><ul><li>为记录已经写入的redo 日志量，设计了一个称之为Log Sequeue Number 的全局变量，日志序列号, 简称LSN</li><li>buf_next_to_write 标记当前log buffer 中已经有哪些日志被刷新到磁盘中了</li><li>flushed_to_disk_lsn   刷新到磁盘中的redo 日志量的全局变量</li><li>flush链表按照oldest_modification代表的LSN值进行排序</li><li>flush链表中的LSN<br>  <img src="/attachment/57704071c7325804ba415757ddcb41f6.png"></li></ul></li><li><p>checkpoint</p><ul><li><strong>判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。</strong></li><li>做一次checkpoint其实可以分为两个步骤：<ul><li>步骤一：计算一下当前系统中可以被覆盖的redo 日志对应的lsn 值最大是多少。<ul><li>凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的</li><li>把该脏页的oldest_modification 赋值给checkpoint_lsn 。</li></ul></li><li>步骤二：将checkpoint_lsn 和对应的redo 日志文件组偏移量以及此次checkpint 的编号写到日志文件的管理信息（就是checkpoint1 或者checkpoint2 ）中。</li></ul></li></ul></li><li><p>崩溃恢复</p><ul><li>确定恢复的起点</li><li>确定恢复的终点</li></ul></li></ul><h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。</p><p>redo日志的主要功能是<strong>保证数据库的持久性和恢复能力</strong>。当事务进行修改数据库的操作时，redo日志会记录这些操作的详细信息，包括修改的数据、修改前后的值等。通过redo日志，可以将事务的操作重新应用到数据库中，以实现事务的持久性。</p><h3 id="redo日志的特点如下："><a href="#redo日志的特点如下：" class="headerlink" title="redo日志的特点如下："></a>redo日志的特点如下：</h3><ul><li><strong>占用空间小</strong>: 存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间</li><li><strong>顺序记录</strong>：redo日志以顺序的方式记录事务的操作，而不是随机记录。这样可以提高日志的写入效率。</li><li><strong>非持久性</strong>：redo日志不需要永久保存在磁盘上，只需要在事务执行过程中保持在内存中和写入磁盘的缓冲区中。只有当事务提交后，才会将redo日志写入磁盘进行持久化保存。</li><li><strong>循环利用</strong>：当redo日志写满时，可以将最旧的日志覆盖掉，从而实现循环利用。这样可以节省存储空间，并保证日志文件的大小不会无限增长。</li></ul><h2 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h2><p>redo 日志本质上只是记录了一下<strong>事务对数据库做了哪些修改</strong></p><p><img src="/attachment/95d39a797c7e8abe375c63e8bf4c9052.png"></p><p>各个部分的详细释义如下：</p><ul><li>type ：该条redo 日志的类型。</li><li>space ID ：表空间ID。</li><li>page number ：页号。</li><li>data ：该条redo 日志的具体内容。</li></ul><h3 id="简单的redo日志类型"><a href="#简单的redo日志类型" class="headerlink" title="简单的redo日志类型"></a>简单的redo日志类型</h3><p>对页面的修改是极其简单的， redo 日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了，设计InnoDB 的大叔把这种极其简单的redo 日志称之为<strong>物理日志</strong></p><p>根据在页面中写入数据的多少划分了几种不同的redo 日志类型：</p><ul><li>MLOG_1BYTE （ type 字段对应的十进制数字为1 ）：表示在页面的某个偏移量处写入1个字节的redo 日志类型。</li><li>MLOG_2BYTE （ type 字段对应的十进制数字为2 ）：表示在页面的某个偏移量处写入2个字节的redo 日志类型。</li><li>MLOG_4BYTE （ type 字段对应的十进制数字为4 ）：表示在页面的某个偏移量处写入4个字节的redo 日志类型。</li><li>MLOG_8BYTE （ type 字段对应的十进制数字为8 ）：表示在页面的某个偏移量处写入8个字节的redo 日志类型。</li><li>MLOG_WRITE_STRING （ type 字段对应的十进制数字为30 ）：表示在页面的某个偏移量处写入一串数据。</li></ul><p><img src="/attachment/69cf44d08da23ebe909980205fd09e2e.png"></p><p>MLOG_WRITE_STRING 类型的redo 日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个len 字段：</p><p><img src="/attachment/8fe8edd4fa5ed6340e0cdc70f8e87812.png"></p><h3 id="复杂一些的redo日志类型"><a href="#复杂一些的redo日志类型" class="headerlink" title="复杂一些的redo日志类型"></a>复杂一些的redo日志类型</h3><p>语句对B+ 树所做更新：</p><ul><li><p>表中包含多少个索引，一条INSERT 语句就可能更新多少棵B+ 树。</p></li><li><p>针对某一棵B+ 树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在内节点页面中添加目录项记录）。</p></li><li><p>可能更新Page Directory 中的槽信息。</p></li><li><p>Page Header 中的各种页面统计信息，比如PAGE_N_DIR_SLOTS 表示的槽数量可能会更改， PAGE_HEAP_TOP代表的还未使用的空间最小地址可能会更改， PAGE_N_HEAP 代表的本页面中的记录数量可能会更改，吧啦吧啦，各种信息都可能会被修改。</p></li><li><p>我们知道在数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的next_record 属性来维护这个单向链表。</p></li><li><p>还有别的吧啦吧啦的更新的地方，就不一一唠叨了…</p></li></ul><p><img src="/attachment/353da489b21aa85f4bc415e560dba28c.png"></p><p>新的redo 日志类型:</p><ul><li>MLOG_REC_INSERT （对应的十进制数字为9 ）：表示插入一条使用非紧凑行格式的记录时的redo 日志类型。</li><li>MLOG_COMP_REC_INSERT （对应的十进制数字为38 ）：表示插入一条使用紧凑行格式的记录时的redo 日志类型。</li><li>MLOG_COMP_PAGE_CREATE （ type 字段对应的十进制数字为58 ）：表示创建一个存储紧凑行格式记录的页面的redo 日志类型。</li><li>MLOG_COMP_REC_DELETE （ type 字段对应的十进制数字为42 ）：表示删除一条使用紧凑行格式记录的redo 日志类型。</li><li>MLOG_COMP_LIST_START_DELETE （ type 字段对应的十进制数字为44 ）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的redo 日志类型。</li><li>MLOG_COMP_LIST_END_DELETE （ type 字段对应的十进制数字为43 ）：与MLOG_COMP_LIST_START_DELETE类型的redo 日志呼应，表示删除一系列记录直到MLOG_COMP_LIST_END_DELETE 类型的redo 日志对应的记录为止。</li></ul><pre><code class="line-numbers language-ad-tip">Redundant是一种比较原始的行格式，它就是非紧凑的。而Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。</code></pre><p>这些类型的redo 日志既包含物理层面的意思，也包含逻辑层面的意思，具体指：</p><p>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。<br>逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。</p><p><img src="/attachment/3f5b621b58bec69fe578eb9bc1fbeb5b.png"></p><p>这个类型为MLOG_COMP_REC_INSERT 的redo 日志结构有几个地方需要大家注意：</p><ul><li>field1_len ~ fieldn_len 代表着该记录若干个字段占用存储空间的大小</li><li>offset 代表的是该记录的前一条记录在页面中的地址。</li><li>通过end_seg_len 的值可以间接的计算出一条记录占用存储空间的总大小</li><li>mismatch_index 的值也是为了节省redo 日志的大小而设立的，大家可以忽略。</li></ul><h3 id="redo日志格式小结"><a href="#redo日志格式小结" class="headerlink" title="redo日志格式小结"></a>redo日志格式小结</h3><p>redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。</p><h2 id="Mini-Transaction"><a href="#Mini-Transaction" class="headerlink" title="Mini-Transaction"></a>Mini-Transaction</h2><h3 id="以组的形式写入redo日志"><a href="#以组的形式写入redo日志" class="headerlink" title="以组的形式写入redo日志"></a>以组的形式写入redo日志</h3><p>在执行语句的过程中产生的redo 日志被设计InnoDB 的大叔人为的划分成了若干个不可分割的组，比如：</p><ul><li>更新Max Row ID 属性时产生的redo 日志是不可分割的。</li><li>向聚簇索引对应B+ 树的页面中插入一条记录时产生的redo 日志是不可分割的。</li><li>向某个二级索引对应B+ 树的页面中插入一条记录时产生的redo 日志是不可分割的。</li><li>还有其他的一些对页面的访问操作时产生的redo 日志是不可分割的。。。</li></ul><p><strong>不可分割的含义</strong></p><ul><li><p>我们以向某个索引对应的B+ 树插入一条记录为例，在向B+ 树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p></li><li><p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为MLOG_COMP_REC_INSERT 的redo 日志就好了，我们把这种情况称之为乐观插入。</p></li><li><p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的页分裂操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条目录项记录指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条redo 日志，我们把这种情况称之为悲观插入。</p></li></ul><p><img src="/attachment/71287f939b738feec0b12a85ffd153dc.png"></p><p>向某个索引对应的B+ 树中插入一条记录的这个过程必须是<strong>原子</strong>的</p><p>规定在执行这些需要保证原子性的操作时必须以组的形式来记录的redo 日志，在进行系统奔溃重启恢复时，针对某个组中的redo 日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？</p><ul><li>有的需要保证原子性的操作会生成多条redo 日志，比如向某个索引对应的B+ 树中进行一次悲观插入就需要生成许多条redo 日志。</li></ul><p>该组中的最后一条redo 日志后边加上一条特殊类型的redo 日志，该类型名称为MLOG_MULTI_REC_END ， type 字段对应的十进制数字为31 ，该类型的redo 日志结构很简单，只有一个type 字段：</p><p><img src="/attachment/3855e8a74e6878458e3752e1c9087c43.png"></p><p>所以某个需要保证原子性的操作产生的一系列redo 日志必须要以一个类型为MLOG_MULTI_REC_END 结尾，就像这样：<br><img src="/attachment/d61609ebe74a8f9dbb9f8934e231bbdf.png"></p><p>这样在系统奔溃重启进行恢复时，只有当解析到类型为MLOG_MULTI_REC_END 的redo 日志，才认为解析到了一组完整的redo 日志，才会进行恢复。否则的话直接放弃前边解析到的redo 日志。</p><ul><li>有的需要保证原子性的操作只生成一条redo 日志，比如更新Max Row ID 属性的操作就只会生成一条redo日志。</li></ul><p>用7个比特位就足以包括所有的redo 日志类型，而type 字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条redo 日志，<br><img src="/attachment/9734a9b9fbeff14ce4e3e19643c39999.png"></p><p>如果type 字段的第一个比特位为1 ，代表该需要保证原子性的操作只产生了单一的一条redo 日志，否则表示该需要保证原子性的操作产生了一系列的redo 日志。</p><h3 id="Mini-Transaction的概念"><a href="#Mini-Transaction的概念" class="headerlink" title="Mini-Transaction的概念"></a>Mini-Transaction的概念</h3><p>对底层页面中的一次原子访问的过程称之为一个Mini-Transaction ，简称mtr。</p><ul><li>修改一次Max Row ID 的值算是一个Mini-Transaction</li><li>向某个索引对应的B+ 树中插入一条记录的过程也算是一个Mini-Transaction</li></ul><p>一个所谓的mtr 可以包含一组redo 日志，在进行奔溃恢复时这一组redo 日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr 组成，每一个mtr 又可以包含若干条redo 日志，画个图表示它们的关系就是这样：</p><p><img src="/attachment/9dc564aab6d3f1055f5b09bf9a4eebac.png"></p><h2 id="redo日志的写入过程"><a href="#redo日志的写入过程" class="headerlink" title="redo日志的写入过程"></a>redo日志的写入过程</h2><h3 id="redo-log-block"><a href="#redo-log-block" class="headerlink" title="redo log block"></a>redo log block</h3><p>为了更好的进行系统奔溃恢复，他们把通过mtr 生成的redo 日志都放在了大小为512字节的页中。</p><p>log buffer 本质上是一片连续的内存空间，被划分成了若干个512 字节大小的block 。</p><p>用来存储redo 日志的页称为block</p><p><strong>redo log block 的示意图如下：</strong></p><p><img src="/attachment/1d05f86aacee59136739ffecdf347977.png"></p><p>真正的redo 日志都是存储到占用496 字节大小的log block body 中，图中的log block header 和log block trailer 存储的是一些管理信息。</p><p><strong>管理信息示意图:</strong></p><p><img src="/attachment/f8cb74a8b560c202a167d8ef4b88bbc7.png"></p><p>其中log block header 的几个属性的意思分别如下：</p><ul><li>LOG_BLOCK_HDR_NO ：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li><li>LOG_BLOCK_HDR_DATA_LEN ：表示block中已经使用了多少字节，初始值为12 （因为log block body 从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果log block body已经被全部写满，那么本属性的值被设置为512 。</li><li>LOG_BLOCK_FIRST_REC_GROUP ：一条redo 日志也可以称之为一条redo 日志记录（ redo log record ），</li><li>一个mtr 会生产多条redo 日志记录，这些redo 日志记录被称之为一个redo 日志记录组（ redo logrecord group ）。LOG_BLOCK_FIRST_REC_GROUP 就代表该block中第一个mtr 生成的redo 日志记录组的偏移量（其实也就是这个block里第一个mtr 生成的第一条redo 日志的偏移量）。</li><li>LOG_BLOCK_CHECKPOINT_NO ：表示所谓的checkpoint 的序号， checkpoint 是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</li></ul><p>log block trailer 中属性的意思如下：</p><ul><li>LOG_BLOCK_CHECKSUM ：表示block的校验值，用于正确性校验，我们暂时不关心它。</li></ul><h3 id="redo日志缓冲区"><a href="#redo日志缓冲区" class="headerlink" title="redo日志缓冲区"></a>redo日志缓冲区</h3><p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer 的连续内存空间，翻译成中文就是redo日志缓冲区，我们也可以简称为log buffer 。</p><p>这片内存空间被划分成若干个连续的redo log block</p><p><img src="/attachment/8d197b0dcbbb096473c844ae946009d9.png"></p><p>默认值为16MB</p><h4 id="redo日志写入log-buffer"><a href="#redo日志写入log-buffer" class="headerlink" title="redo日志写入log buffer"></a>redo日志写入log buffer</h4><p>向log buffer 中写入redo 日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写</p><p>当我们想往log buffer 中写入redo 日志时，第一个遇到的问题就是应该写在哪个 block 的哪个偏移量处，所以设计InnoDB 的大叔特意提供了一个称之为<strong>buf_free</strong> 的全局变量，该变量指明后续写入的redo 日志应该写入到log buffer 中的哪个位置</p><p><img src="/attachment/7b62e9267e29b45a0d2259da7c5d96dc.png"></p><p>mtr 执行过程中可能产生若干条redo 日志，这些redo 日志是一个不可分割的组，<br>所以其实并不是每生成一条redo 日志，就将其插入到log buffer 中，<br>而是每个mtr 运行过程中产生的日志先暂时存到一个地方，<br>当该mtr 结束的时候，将过程中产生的一组redo 日志再全部复制到log buffer 中</p><p>假设<br>有两个名为T1 、T2 的事务，每个事务都包含2个mtr ，我们给这几个mtr 命名一下：</p><ul><li>事务T1 的两个mtr 分别称为mtr_T1_1 和mtr_T1_2 。</li><li>事务T2 的两个mtr 分别称为mtr_T2_1 和mtr_T2_2 。</li></ul><p>用示意图来描述一下这些mtr 产生的日志情况：</p><p><img src="/attachment/86ea507cc9ab069492f0ecea0409e987.png"></p><p>不同的事务可能是并发执行的，所以T1 、T2 之间的mtr 可能是交替执行的。</p><p>每当一个mtr 执行完成时，伴随该mtr 生成的一组redo 日志就需要被复制到log buffer 中，也就是说不同事务的mtr 可能是交替写入log buffer 的</p><p><img src="/attachment/3936f656aa6e353e47a4f05234d68999.png"></p><h2 id="redo日志文件"><a href="#redo日志文件" class="headerlink" title="redo日志文件"></a>redo日志文件</h2><h3 id="redo日志刷盘时机"><a href="#redo日志刷盘时机" class="headerlink" title="redo日志刷盘时机"></a>redo日志刷盘时机</h3><p>在一些情况下它们会被刷新到磁盘里</p><ul><li>log buffer 空间不足时</li><li>事务提交时</li><li>后台线程不停的刷刷刷<ul><li>后台有一个线程，大约每秒都会刷新一次log buffer 中的redo 日志到磁盘。</li></ul></li><li>正常关闭服务器时</li><li>做所谓的checkpoint 时（我们现在没介绍过checkpoint 的概念，稍后会仔细唠叨，稍安勿躁）</li><li>其他的一些情况…</li></ul><h3 id="redo日志文件组"><a href="#redo日志文件组" class="headerlink" title="redo日志文件组"></a>redo日志文件组</h3><p>MySQL 的数据目录（使用SHOW VARIABLES LIKE ‘datadir’ 查看）下默认有两个名为<code>ib_logfile0</code> 和<code>ib_logfile1</code> 的文件， log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中。</p><p>磁盘上的redo 日志文件是以一个日志文件组的形式出现的。</p><p>这些文件以ib_logfile[数字] （ 数字可以是0 、1 、2 …）的形式进行命名。</p><p><img src="/attachment/841ce5d38af1aa4690e5a8b8fb7cf4bf.png"></p><p>总共的redo 日志文件大小其实就是：<br>innodb_log_file_size × innodb_log_files_in_group 。</p><h3 id="redo日志文件格式"><a href="#redo日志文件格式" class="headerlink" title="redo日志文件格式"></a>redo日志文件格式</h3><p>将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中</p><p>redo 日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储log buffer 中的block镜像的。</li></ul><p><img src="/attachment/8e93c10b72701ec5752a42211bd479d4.png"></p><p><strong>介绍一下每个redo 日志文件前2048个字节，也就是前4个特殊block的格式</strong></p><p><img src="/attachment/d7615b3b42ba54071280404008bb7f6b.png"></p><p>这4个block分别是：</p><ul><li>log file header ：描述该redo 日志文件的一些整体属性，看一下它的结构：<br><img src="/attachment/d3d42b092271e9fafc2b2525865d7a34.png"></li></ul><table><thead><tr><th align="center">属性名</th><th align="center">长度（单位：字节）</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">LOG_HEADER_FORMAT</td><td align="center">4</td><td align="left">redo 日志的版本，在MySQL5.7.21 中该值永远为1</td></tr><tr><td align="center">LOG_HEADER_PAD1</td><td align="center">4</td><td align="left">做字节填充用的，没什么实际意义，忽略～</td></tr><tr><td align="center">LOG_HEADER_START_LSN</td><td align="center">8</td><td align="left">标记本redo 日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值（关于什么是LSN我们稍后再看哈，看不懂的先忽略）。</td></tr><tr><td align="center">LOG_HEADER_CREATOR</td><td align="center">32</td><td align="left">一个字符串，标记本redo 日志文件的创建者是谁。正常运行时该值为MySQL 的版本号，比如： “MySQL 5.7.21” ，使用mysqlbackup 命令创建的redo 日志文件的该值为”ibbackup” 和创建时间。</td></tr><tr><td align="center">LOG_BLOCK_CHECKSUM</td><td align="center">4</td><td align="left">本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><ul><li>checkpoint1 ：记录关于checkpoint 的一些属性，看一下它的结构：<br><img src="/attachment/bb48c1b7b81b2c67d98200f113755e4b.png"></li></ul><table><thead><tr><th align="center">属性名</th><th align="center">长度（单位：字节）</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">LOG_CHECKPOINT_NO</td><td align="center">8</td><td align="left">服务器做checkpoint 的编号，每做一次checkpoint ，该值就加1。</td></tr><tr><td align="center">LOG_CHECKPOINT_LSN</td><td align="center">8</td><td align="left">服务器做checkpoint 结束时对应的LSN 值，系统奔溃恢复时将从该值开始。</td></tr><tr><td align="center">LOG_CHECKPOINT_OFFSET</td><td align="center">8</td><td align="left">上个属性中的LSN 值在redo 日志文件组中的偏移量</td></tr><tr><td align="center">LOG_CHECKPOINT_LOG_BUF_SIZE</td><td align="center">8</td><td align="left">服务器在做checkpoint 操作时对应的log buffer 的大小</td></tr><tr><td align="center">LOG_BLOCK_CHECKSUM</td><td align="center">4</td><td align="left">本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><ul><li>第三个block未使用，忽略～</li><li>checkpoint2 ：结构和checkpoint1 一样。</li></ul><h2 id="Log-Sequeue-Number"><a href="#Log-Sequeue-Number" class="headerlink" title="Log Sequeue Number"></a>Log Sequeue Number</h2><p>为记录已经写入的redo 日志量，设计了一个称之为Log Sequeue Number 的全局变量，日志序列号，简称LSN</p><p>规定初始的lsn 值为8704</p><p>在统计lsn 的增长量时，是按照实际写入的日志量加上占用的log block header 和log block trailer 来计算的</p><p>每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p><h3 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h3><p>redo 日志是首先写到log buffer 中，之后才会被刷新到磁盘上的redo 日志文件。所以设计InnoDB 的大叔提出了一个称之为 buf_next_to_write 的全局变量，标记当前log buffer 中已经有哪些日志被刷新到磁盘中了。</p><p><img src="/attachment/3b8a42e699920fe0a42680ac68939a94.png"></p><p>刷新到磁盘中的redo 日志量的全局变量，称之为 flushed_to_disk_lsn 。</p><p>系统第一次启动时，该变量的值和初始的lsn 值是相同的，都是8704</p><p>如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p><h3 id="lsn值和redo日志文件偏移量的对应关系"><a href="#lsn值和redo日志文件偏移量的对应关系" class="headerlink" title="lsn值和redo日志文件偏移量的对应关系"></a>lsn值和redo日志文件偏移量的对应关系</h3><p>lsn 的值是代表系统写入的redo 日志量的一个总和，一个mtr 中产生多少日志， lsn 的值就增加多少（当然有时候要加上log block header 和log block trailer 的大小），这样mtr 产生的日志写到磁盘中时，很容易计算某一个lsn 值在redo 日志文件组中的偏移量</p><h3 id="flush链表中的LSN"><a href="#flush链表中的LSN" class="headerlink" title="flush链表中的LSN"></a>flush链表中的LSN</h3><p>在mtr 结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表。</p><p><img src="/attachment/59448f56db4c485c66d2a1cdb0c8a789.png"></p><p>说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的</p><p>在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p><ul><li>oldest_modification ：如果某个页面被加载到Buffer Pool 后进行第一次修改，那么就将修改该页面的 mtr 开始时对应的lsn 值写入这个属性。</li><li>newest_modification ：每修改一次页面，都会将修改该页面的mtr 结束时对应的lsn 值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统lsn 值。</li></ul><p><strong>举例</strong></p><ul><li>假设mtr_1 执行过程中修改了页a ，那么在mtr_1 执行结束时，就会将页a 对应的控制块加入到flush链表的头部。并且将mtr_1 开始时对应的lsn ，也就是8716 写入页a 对应的控制块的oldest_modification 属性中，把mtr_1 结束时对应的lsn ，也就是8916写入页a 对应的控制块的newest_modification 属性中。画个图表示一下（为了让图片美观一些，我们把oldest_modification 缩写成了o_m ，把newest_modification 缩写成了n_m ）：</li></ul><p><img src="/attachment/67c7c0593ef4be8ecd71c88590fe4ad9.png"></p><ul><li>接着假设mtr_2 执行过程中又修改了页b 和页c 两个页面，那么在mtr_2 执行结束时，就会将页b 和页c对应的控制块都加入到flush链表的头部。并且将mtr_2 开始时对应的lsn ，也就是8916写入页b 和页c对应的控制块的oldest_modification 属性中，把mtr_2 结束时对应的lsn ，也就是9948写入页b 和页c对应的控制块的newest_modification 属性中。画个图表示一下：</li></ul><p><img src="/attachment/f94d1f76d0363cd140144eb40c3218e3.png"></p><p>每次新插入到flush链表中的节点都是被放在了头部，也就是说<strong>flush链表中前边的脏页修改的时间比较晚，后边的脏页修改时间比较早</strong>。</p><ul><li>接着假设mtr_3 执行过程中修改了页b 和页d ，不过页b 之前已经被修改过了，所以它对应的控制块已经被插入到了flush 链表，所以在mtr_3 执行结束时，只需要将页d 对应的控制块都加入到flush链表的头部即可。</li></ul><p><img src="/attachment/57704071c7325804ba415757ddcb41f6.png"></p><p>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</p><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>redo日志只是为了系统奔溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统奔溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。</p><p><strong>判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。</strong></p><p><img src="/attachment/0da7360001348c19f9108658047c0fd1.png"></p><p>如果页a被刷新到了磁盘，那么它对应的控制块就会从flush链表中移除</p><p><img src="/attachment/e6e162cae4b971e6a2627708e262ea22.png"></p><p>这样mtr_1 生成的redo 日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。</p><p>提出了一个全局变量 <strong>checkpoint_lsn</strong> 来代表当前系统中可以被覆盖的redo 日志总量是多少，这个变量初始值也是8704 。</p><p>比方说现在页a被刷新到了磁盘，mtr_1生成的redo日志就可以被覆盖了，所以我们可以进行一个增加checkpoint_lsn的操作，我们把这个过程称之为做一次checkpoint。</p><p>做一次checkpoint其实可以分为两个步骤：</p><p>步骤一：计算一下当前系统中可以被覆盖的redo 日志对应的lsn 值最大是多少。</p><ul><li>凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的</li><li>把该脏页的oldest_modification 赋值给checkpoint_lsn 。</li></ul><p>步骤二：将checkpoint_lsn 和对应的redo 日志文件组偏移量以及此次checkpint 的编号写到日志文件的管理信息（就是checkpoint1 或者checkpoint2 ）中。</p><p>维护了一个目前系统做了多少次checkpoint 的变量checkpoint_no ，每做一次checkpoint ，该变量的值就加1。<br>上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。</p><p>undefined</p><h3 id="批量从flush链表中刷出脏页"><a href="#批量从flush链表中刷出脏页" class="headerlink" title="批量从flush链表中刷出脏页"></a>批量从flush链表中刷出脏页</h3><p>如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做checkpoint ，可能就需要用户线程同步的从flush链表中把那些最早修改的脏页（ oldest_modification 最小的脏页）刷新到磁盘，这样这些脏页对应的redo 日志就没用了，然后就可以去做checkpoint 了。</p><h3 id="查看系统中的各种LSN值"><a href="#查看系统中的各种LSN值" class="headerlink" title="查看系统中的各种LSN值"></a>查看系统中的各种LSN值</h3><pre><code class="line-numbers language-sql">SHOW ENGINE INNODB STATUS</code></pre><ul><li>Log sequence number ：代表系统中的lsn 值，也就是当前系统已经写入的redo 日志量，包括写入logbuffer 中的日志。</li><li>Log flushed up to ：代表flushed_to_disk_lsn 的值，也就是当前系统已经写入磁盘的redo 日志量。</li><li>Pages flushed up to ：代表flush链表中被最早修改的那个页面对应的oldest_modification 属性值。</li><li>Last checkpoint at ：当前系统的checkpoint_lsn 值。</li></ul><h3 id="innodb-flush-log-at-trx-commit的用法"><a href="#innodb-flush-log-at-trx-commit的用法" class="headerlink" title="innodb_flush_log_at_trx_commit的用法"></a>innodb_flush_log_at_trx_commit的用法</h3><p>为了保证事务的持久性，用户线程在事务提交时需要将该事务执行过程中产生的所有redo 日志都刷新到磁盘上。</p><p><strong>innodb_flush_log_at_trx_commit</strong> 的系统变量</p><ul><li>0 ：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步redo 日志，这个任务是交给后台线程做的。这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将redo 日志刷新到磁盘，那么该事务对页面的修改会丢失。</li><li>1 ：当该系统变量值为1时，表示在事务提交时需要将redo 日志同步到磁盘，可以保证事务的持久性。1也是innodb_flush_log_at_trx_commit 的默认值。</li><li>2 ：当该系统变量值为2时，表示在事务提交时需要将redo 日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是操作系统也挂了的话，那就不能保证持久性了。</li></ul><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><h3 id="确定恢复的起点"><a href="#确定恢复的起点" class="headerlink" title="确定恢复的起点"></a>确定恢复的起点</h3><p>redo 日志文件组的第一个文件的管理信息中有两个block都存储了checkpoint_lsn 的信息，我们当然是要选取最近发生的那次checkpoint的信息。</p><h3 id="确定恢复的终点"><a href="#确定恢复的终点" class="headerlink" title="确定恢复的终点"></a>确定恢复的终点</h3><p><img src="/attachment/cd81fa87dd718fed10415acc55ac175e.png"></p><p>普通block的log block header 部分有一个称之为LOG_BLOCK_HDR_DATA_LEN 的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为512 。如果该属性的值不为512 ，那么就是它了，它就是此次奔溃恢复中需要扫描的最后一个block。</p><h3 id="怎么恢复"><a href="#怎么恢复" class="headerlink" title="怎么恢复"></a>怎么恢复</h3><p>确定了需要扫描哪些redo 日志进行奔溃恢复之后，接下来就是怎么进行恢复了。</p><p>假设现在的redo 日志文件中有5条redo 日志，如图：</p><p><img src="/attachment/99f809bbdc1359a32f7be7d187f5efa3.png"></p><p>由于redo 0 在checkpoint_lsn 后边，恢复时可以不管它。我们现在可以按照redo 日志的顺序依次扫描checkpoint_lsn 之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。</p><ul><li>使用哈希表</li></ul><p>根据redo 日志的space ID 和page number 属性计算出散列值，把space ID 和page number 相同的redo日志放到哈希表的同一个槽里，如果有多个space ID 和page number 都相同的redo 日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，</p><p><img src="/attachment/37f0ae78d9f018981aa767d5c3700f6d.png"></p><ul><li>跳过已经刷新到磁盘的页面</li></ul><h2 id="LOG-BLOCK-HDR-NO是如何计算的"><a href="#LOG-BLOCK-HDR-NO是如何计算的" class="headerlink" title="LOG_BLOCK_HDR_NO是如何计算的"></a>LOG_BLOCK_HDR_NO是如何计算的</h2><p>对于实际存储redo 日志的普通的log block 来说，在log block header 处有一个称之为 LOG_BLOCK_HDR_NO 的属性</p><p>使用下边的公式计算该block的LOG_BLOCK_HDR_NO 值：</p><pre><code class="line-numbers language-sql">((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</code></pre><p><img src="/attachment/df91a46b5d15f3eec07ea9d95c5b1df2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 事务</title>
      <link href="/database/mysql/mysql-shi-wu/"/>
      <url>/database/mysql/mysql-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-事务"><a href="#【MySQL】-事务" class="headerlink" title="【MySQL】 事务"></a>【MySQL】 事务</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 事务date: 2023-06-25 09:25tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 事务</code></pre><h2 id="事务的起源"><a href="#事务的起源" class="headerlink" title="事务的起源"></a>事务的起源</h2><p><strong>举例</strong></p><p>银行为了存储人们的账户信息会建立一个account 表：</p><pre><code class="line-numbers language-sql">CREATE TABLE account (id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',name VARCHAR(100) COMMENT '客户名称',balance INT COMMENT '余额',PRIMARY KEY (id)) Engine=InnoDB CHARSET=utf8;</code></pre><p>每一个操作都相当于现实世界中账户的一次状态转换</p><pre><code class="line-numbers language-sql">UPDATE account SET balance = balance - 10 WHERE id = 1;UPDATE account SET balance = balance + 10 WHERE id = 2;</code></pre><p>让某些数据库操作符合现实世界中状态转换的规则</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>事务是一个不可分割的操作单元，要么全部执行成功，要么全部失败回滚。如果事务中的任何一步操作失败，则整个事务都会被回滚到最初的状态，保证数据的一致性。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>多个事务并发执行时，每个事务的操作应该与其他事务的操作相互隔离，互不干扰。每个事务在执行期间所做的修改对其他事务是不可见的，直到事务提交。</p><p><strong>示例</strong></p><p>步骤一：读取狗哥账户的余额到变量A中，这一步骤简写为read(A) 。<br>步骤二：将狗哥账户的余额减去转账金额，这一步骤简写为A = A - 5 。<br>步骤三：将狗哥账户修改过的余额写到磁盘里，这一步骤简写为write(A) 。<br>步骤四：读取猫爷账户的余额到变量B，这一步骤简写为read(B) 。<br>步骤五：将猫爷账户的余额加上转账金额，这一步骤简写为B = B + 5 。<br>步骤六：将猫爷账户修改过的余额写到磁盘里，这一步骤简写为write(B) 。</p><p><img src="/attachment/b5f78daf4692c06f126ef8133bc049e2.png"></p><p><strong>实际</strong></p><p><img src="/attachment/d84bf87925b105c7ace16d15d8e6a101.png"></p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>事务执行前后，数据库的完整性约束必须保持一致。</p><p>每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。</p><p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>一旦事务提交，其所做的修改将永久保存在数据库中，即使系统发生故障也不会丢失。系统保证已提交的事务对数据库的修改是永久性的。</p><h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><p>把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称之为一个事务（英文名是： transaction ）</p><p>叔根据这些操作所执行的不同阶段把事务大致上划分成了这么几个状态：</p><ul><li>活动的（active）</li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。</p><ul><li>部分提交的（partially committed）</li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p><ul><li>失败的（failed）</li></ul><p>当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p><ul><li>中止的（aborted）</li></ul><p>。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p><ul><li>提交的（committed）</li></ul><p>当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。</p><p><img src="/attachment/bf07be398a246489bbc88fe730befae7.png"></p><p>只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。</p><h2 id="MySQL中事务的语法"><a href="#MySQL中事务的语法" class="headerlink" title="MySQL中事务的语法"></a>MySQL中事务的语法</h2><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><h4 id="BEGIN-WORK"><a href="#BEGIN-WORK" class="headerlink" title="BEGIN [WORK];"></a>BEGIN [WORK];</h4><p>BEGIN 语句代表开启一个事务，后边的单词WORK 可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。</p><h4 id="START-TRANSACTION"><a href="#START-TRANSACTION" class="headerlink" title="START TRANSACTION;"></a>START TRANSACTION;</h4><p>START TRANSACTION 语句和BEGIN 语句有着相同的功效，都标志着开启一个事务</p><p>可以在START TRANSACTION 语句后边跟随几个修饰符</p><ul><li><p>READ ONLY<br>标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p></li><li><p>READ WRITE<br>标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p></li><li><p>WITH CONSISTENT SNAPSHOT<br>启动一致性读</p></li></ul><h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p>COMMIT [WORK]</p><h3 id="手动中止事务"><a href="#手动中止事务" class="headerlink" title="手动中止事务"></a>手动中止事务</h3><p>ROLLBACK [WORK]</p><h3 id="支持事务的存储引擎"><a href="#支持事务的存储引擎" class="headerlink" title="支持事务的存储引擎"></a>支持事务的存储引擎</h3><p>目前只有InnoDB 和NDB 存储引擎支持</p><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>MySQL 中有一个系统变量autocommit</p><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><p>导致事务隐式提交的语句包括：</p><ul><li>定义或修改数据库对象的数据定义语言（Data definition language，缩写为： DDL ）。</li><li>隐式使用或修改mysql 数据库中的表</li><li>事务控制或关于锁定的语句</li><li>加载数据的语句</li><li>关于MySQL 复制的一些语句</li><li>其它的一些语句</li></ul><h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>保存点（英文： savepoint ）的概念</p><p>在事务对应的数据库语句中打几个点，我们在调用ROLLBACK 语句时可以指定会滚到哪个点，而不是回到最初的原点</p><p>定义保存点的语法如下：</p><pre><code class="line-numbers language-sql">SAVEPOINT 保存点名称;</code></pre><p>当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词WORK 和SAVEPOINT 是可有可无的）：</p><pre><code class="line-numbers language-sql">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</code></pre><p>如果我们想删除某个保存点，可以使用这个语句：</p><pre><code class="line-numbers language-sql">RELEASE SAVEPOINT 保存点名称;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB的Buffer Pool</title>
      <link href="/database/mysql/mysql-innodb-de-buffer-pool/"/>
      <url>/database/mysql/mysql-innodb-de-buffer-pool/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-InnoDB的Buffer-Pool"><a href="#【MySQL】-InnoDB的Buffer-Pool" class="headerlink" title="【MySQL】 InnoDB的Buffer Pool"></a>【MySQL】 InnoDB的Buffer Pool</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 InnoDB的Buffer Pooldate: 2023-06-24 14:49tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 InnoDB的Buffer Pool</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>磁盘太慢，用内存作为缓存很有必要。</li><li>Buffer Pool 本质上是InnoDB 向操作系统申请的一段<strong>连续的内存空间</strong>，可以通过 innodb_buffer_pool_size 来调整它的大小。</li><li>Buffer Pool 向操作系统申请的连续内存由<strong>控制块</strong>和<strong>缓存页</strong>组成，每个控制块和缓存页都是一一对应的，在填充足够多的控制块和缓存页的组合后， Buffer Pool 剩余的空间可能产生不够填充一组控制块和缓存页，这部分空间不能被使用，也被称为碎片。</li><li>InnoDB 使用了许多<strong>链表</strong>来管理Buffer Pool 。</li><li>free链表中每一个<strong>节点</strong>都代表一个<strong>空闲的缓存页</strong>，在将磁盘中的页加载到Buffer Pool 时，会从free链表中寻找空闲的缓存页。</li><li>为了快速定位某个页是否被加载到Buffer Pool ，使用<strong>表空间号 + 页号</strong>作为key ，<strong>缓存页</strong>作为value ，建立<strong>哈希表</strong>。</li><li>在Buffer Pool 中<strong>被修改的页</strong>称为<strong>脏页</strong>，脏页并不是立即刷新，而是被加入到<strong>flush链表</strong>中，待之后的某个时刻同步到磁盘上。</li><li>LRU链表分为<strong>young</strong> 和<strong>old</strong> 两个区域，可以通过innodb_old_blocks_pct 来调节old 区域所占的比例。首次从磁盘上加载到Buffer Pool 的页会被放到old 区域的头部，在innodb_old_blocks_time 间隔时间内访问该页不会把它移动到young 区域头部。在Buffer Pool 没有可用的空闲缓存页时，会首先<strong>淘汰掉</strong>old 区域的一些页。</li><li>我们可以通过指定innodb_buffer_pool_instances 来控制Buffer Pool 实例的个数，每个Buffer Pool 实例中都有各自独立的链表，互不干扰。</li><li>自MySQL 5.7.5 版本之后，可以在服务器运行过程中调整Buffer Pool 大小。每个Buffer Pool 实例由若干个chunk 组成，每个chunk 的大小可以在服务器启动时通过启动参数调整。</li></ol><p><img src="/attachment/29ea829b7b4ac4c2406b67567c247b48.png"></p><p><img src="/attachment/67abbef1a879e0fa04c8fb83cd658680.png"></p><p><img src="/attachment/de8451072ba42c2df458bd4fe2425abc.png"></p><h2 id="缓存的重要性"><a href="#缓存的重要性" class="headerlink" title="缓存的重要性"></a>缓存的重要性</h2><p>即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。</p><p>将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO 的开销了。</p><h2 id="InnoDB的Buffer-Pool"><a href="#InnoDB的Buffer-Pool" class="headerlink" title="InnoDB的Buffer Pool"></a>InnoDB的Buffer Pool</h2><h3 id="什么个Buffer-Pool"><a href="#什么个Buffer-Pool" class="headerlink" title="什么个Buffer Pool"></a>什么个Buffer Pool</h3><p>为了缓存磁盘中的页，在MySQL 服务器启动的时候就向操作系统申请了一片连续的内存，他们给这片内存起了个名，叫做Buffer Pool （中文名是缓冲池）</p><p>默认情况下Buffer Pool 只有128M 大小</p><h3 id="Buffer-Pool内部组成"><a href="#Buffer-Pool内部组成" class="headerlink" title="Buffer Pool内部组成"></a>Buffer Pool内部组成</h3><p>控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边</p><p><img src="/attachment/29ea829b7b4ac4c2406b67567c247b48.png"></p><h3 id="free链表的管理"><a href="#free链表的管理" class="headerlink" title="free链表的管理"></a>free链表的管理</h3><p>最好在某个地方记录一下Buffer Pool中哪些缓存页是可用的</p><p>把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中</p><h3 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h3><p><strong>创建一个哈希表</strong></p><ul><li>用表空间号 + 页号作为key</li><li>缓存页作为value</li></ul><p>先从哈希表中根据表空间号 + 页号看看有没有对应的缓存页，如果有，直接使用该缓存页就好，<br>如果没有，那就从free链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</p><h3 id="flush链表的管理"><a href="#flush链表的管理" class="headerlink" title="flush链表的管理"></a>flush链表的管理</h3><p>如果我们修改了Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为<strong>脏页</strong>（英文名： dirty page ）</p><p>最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能</p><p>凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫<strong>flush链表</strong></p><p><img src="/attachment/67abbef1a879e0fa04c8fb83cd658680.png"></p><h3 id="LRU链表的管理"><a href="#LRU链表的管理" class="headerlink" title="LRU链表的管理"></a>LRU链表的管理</h3><h4 id="缓存不够的窘境"><a href="#缓存不够的窘境" class="headerlink" title="缓存不够的窘境"></a>缓存不够的窘境</h4><p>如果需要缓存的页占用的内存大小超过了Buffer Pool 大小</p><p>假设我们一共访问了n 次页，那么被访问的页已经在缓存中的次数除以n 就是所谓的缓存命中率，我们的期望就是让缓存命中率越高越好</p><h4 id="简单的LRU链表"><a href="#简单的LRU链表" class="headerlink" title="简单的LRU链表"></a>简单的LRU链表</h4><p>我们可以再创建一个链表，由于这个链表是为了按照最近最少使用的原则去淘汰缓存页的，所以这个链表可以被称为LRU链表（LRU的英文全称：Least Recently Used）</p><h4 id="划分区域的LRU链表"><a href="#划分区域的LRU链表" class="headerlink" title="划分区域的LRU链表"></a>划分区域的LRU链表</h4><p><strong>两种比较尴尬的情况</strong></p><ul><li>情况一: InnoDB 提供了一个看起来比较贴心的服务—— 预读（英文名： read ahead ）<ul><li>InnoDB 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到Buffer Pool 中。</li><li>预读又可以细分为下边两种<ul><li>线性预读<ul><li>提供了一个系统变量innodb_read_ahead_threshold</li><li>如果顺序访问了某个区（ extent ）的页面超过这个系统变量的值，就会触发一次异步读取下一个区中全部的页面到BufferPool 的请求</li></ul></li><li>随机预读<ul><li>如果Buffer Pool 中已经缓存了某个区的13个连续的页面，不论这些页面是不是顺序读取的，都会触发一次异步读取本区中所有其的页面到Buffer Pool 的请求。</li></ul></li></ul></li></ul></li></ul><p>如果此时Buffer Pool 的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在LRU链表尾部的一些缓存页会很快的被淘汰掉，会大大降低缓存命中率。</p><ul><li>情况二: 可能会写一些需要扫描全表的查询语句</li><li>当需要访问这些页时，会把它们统统都加载到Buffer Pool 中，Buffer Pool 中的所有页都被换了一次血，其他查询语句在执行时又得执行一次从磁盘加载到Buffer Pool的操作。</li><li>而这种全表扫描的语句执行的频率也不高，每次执行都要把Buffer Pool 中的缓存页换一次血，这严重的影响到其他查询对 Buffer Pool 的使用，从而大大降低了缓存命中率。</li></ul><p><strong>总结</strong>一下上边说的可能降低Buffer Pool 的两种情况：</p><ul><li>加载到Buffer Pool 中的页不一定被用到。</li><li>如果非常多的使用频率偏低的页被同时加载到Buffer Pool 时，可能会把那些使用频率非常高的页从Buffer Pool 中淘汰掉。</li></ul><p>因为有这两种情况的存在，所以设计InnoDB 的大叔把这个LRU链表按照一定比例分成两截，分别是：</p><ul><li>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做热数据，或者称young区域。</li><li>另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做冷数据，或者称old区域。</li></ul><p><img src="/attachment/de8451072ba42c2df458bd4fe2425abc.png"></p><p>我们是按照<strong>某个比例</strong>将LRU链表分成两半的，不是某些节点固定是young区域的，某些节点固定是old区域的，随着程序的运行，某个节点所属的区域也可能发生变化。</p><p>有了这个被划分成young 和old 区域的LRU 链表之后，设计InnoDB 的大叔就可以针对我们上边提到的两种可能降低缓存命中率的情况进行优化了：</p><ul><li><p>针对预读的页面可能不进行后续访情况的优化<br>当磁盘上的某个页面在<strong>初次加载</strong>到Buffer Pool中的某个缓存页时，该缓存页对应的控制块会被放到old区域的头部。<br>这样针对预读到Buffer Pool 却不进行后续访问的页面就会被逐渐从old 区域逐出，而不会影响young 区域中被使用比较频繁的缓存页。</p></li><li><p>针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化</p><ul><li>首次被加载到Buffer Pool 的页被放到了old 区域的头部，但是后续会被马上访问到，每次进行访问的时候又会把该页放到young 区域的头部，这样仍然会把那些使用频率比较高的页面给顶下去</li><li>规定：<ul><li>在对某个处在old 区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部</li></ul></li></ul></li></ul><h4 id="更进一步优化LRU链表"><a href="#更进一步优化LRU链表" class="headerlink" title="更进一步优化LRU链表"></a>更进一步优化LRU链表</h4><p>只有被访问的缓存页位于young 区域的1/4 的后边，才会被移动到LRU链表头部，这样就可以降低调整LRU链表的频率，从而提升性能（也就是说如果某个缓存页对应的节点在young 区域的1/4 中，再次访问该缓存页时也不会将其移动到LRU 链表头部）。</p><p>尽量高效的提高 Buffer Pool 的缓存命中率</p><h3 id="其他的一些链表"><a href="#其他的一些链表" class="headerlink" title="其他的一些链表"></a>其他的一些链表</h3><ul><li>unzip LRU链表用于管理解压页</li><li>zip clean链表用于管理没有被解压的压缩页</li><li>zip free数组中每一个元素都代表一个链表</li><li>它们组成所谓的伙伴系统来为压缩页提供内存空间等等</li></ul><h3 id="刷新脏页到磁盘"><a href="#刷新脏页到磁盘" class="headerlink" title="刷新脏页到磁盘"></a>刷新脏页到磁盘</h3><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。<br>主要有两种刷新路径：</p><ul><li><p>从LRU链表的冷数据中刷新一部分页面到磁盘。<br>后台线程会定时从LRU链表尾部开始扫描一些页面，扫描的页面数量可以通过系统变量innodb_lru_scan_depth 来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为 <strong>BUF_FLUSH_LRU</strong> 。</p></li><li><p>从flush链表中刷新一部分页面到磁盘。<br>后台线程也会定时从flush链表中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为<strong>BUF_FLUSH_LIST</strong> 。</p></li></ul><p>有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到Buffer Pool 时没有可用的缓存页，这时就会尝试看看<strong>LRU链表尾部有没有可以直接释放掉的未修改页面</strong>，<br><strong>如果没有的话会不得不将LRU链表尾部的一个脏页同步刷新到磁盘</strong>（和磁盘交互是很慢的，这会降低处理用户请求的速度）。这种刷新单个页面到磁盘中的刷新方式被称之为<strong>BUF_FLUSH_SINGLE_PAGE</strong> 。</p><h3 id="多个Buffer-Pool实例"><a href="#多个Buffer-Pool实例" class="headerlink" title="多个Buffer Pool实例"></a>多个Buffer Pool实例</h3><p>当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances 的值修改为1。</p><h3 id="innodb-buffer-pool-chunk-size"><a href="#innodb-buffer-pool-chunk-size" class="headerlink" title="innodb_buffer_pool_chunk_size"></a>innodb_buffer_pool_chunk_size</h3><p>Pool 的大小通过配置innodb_buffer_pool_size 启动参数来调整大小</p><p>innodb_buffer_pool_chunk_size的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的。</p><h3 id="配置Buffer-Pool时的注意事项"><a href="#配置Buffer-Pool时的注意事项" class="headerlink" title="配置Buffer Pool时的注意事项"></a>配置Buffer Pool时的注意事项</h3><ul><li>innodb_buffer_pool_size 必须是innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances 的倍数</li><li>如果在服务器启动时， innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances 的值已经大于innodb_buffer_pool_size 的值，那么innodb_buffer_pool_chunk_size 的值会被服务器自动设置为innodb_buffer_pool_size/innodb_buffer_pool_instances 的值。</li></ul><h3 id="Buffer-Pool中存储的其它信息"><a href="#Buffer-Pool中存储的其它信息" class="headerlink" title="Buffer Pool中存储的其它信息"></a>Buffer Pool中存储的其它信息</h3><p>存储锁信息、自适应哈希索引等信息</p><h3 id="查看Buffer-Pool的状态信息"><a href="#查看Buffer-Pool的状态信息" class="headerlink" title="查看Buffer Pool的状态信息"></a>查看Buffer Pool的状态信息</h3><pre><code class="line-numbers language-sql">SHOW ENGINE INNODB STATUS\G</code></pre><ul><li>Total memory allocated ：代表Buffer Pool 向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。</li><li>Dictionary memory allocated ：为数据字典信息分配的内存空间大小，注意这个内存空间和Buffer Pool没啥关系，不包括在Total memory allocated 中。</li><li>Buffer pool size ：代表该Buffer Pool 可以容纳多少缓存页，注意，单位是页！</li><li>Free buffers ：代表当前Buffer Pool 还有多少空闲缓存页，也就是free链表中还有多少个节点。</li><li>Database pages ：代表LRU 链表中的页的数量，包含young 和old 两个区域的节点数量。</li><li>Old database pages ：代表LRU 链表old 区域的节点数量。</li><li>Modified db pages ：代表脏页数量，也就是flush链表中节点的数量。</li><li>Pending reads ：正在等待从磁盘上加载到Buffer Pool 中的页面数量。</li><li>Pending writes LRU ：即将从LRU 链表中刷新到磁盘中的页面数量。</li><li>Pending writes flush list ：即将从flush 链表中刷新到磁盘中的页面数量。</li><li>Pending writes single page ：即将以单个页面的形式刷新到磁盘中的页面数量。</li><li>Pages made young ：代表LRU 链表中曾经从old 区域移动到young 区域头部的节点数量。</li><li>Page made not young ：在将innodb_old_blocks_time 设置的值大于0时，首次访问或者后续访问某个处在old 区域的节点时由于不符合时间间隔的限制而不能将其移动到young 区域头部时， Page made not young 的值会加1。</li><li>youngs/s ：代表每秒从old 区域被移动到young 区域头部的节点数量。</li><li>non-youngs/s ：代表每秒由于不满足时间限制而不能从old 区域移动到young 区域头部的节点数量。</li><li>Pages read 、created 、written ：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速率。</li><li>Buffer pool hit rate ：表示在过去某段时间，平均访问1000次页面，有多少次该页面已经被缓存到Buffer Pool 了。</li><li>young-making rate ：表示在过去某段时间，平均访问1000次页面，有多少次访问使页面移动到young 区域的头部了。</li><li>not (young-making rate) ：表示在过去某段时间，平均访问1000次页面，有多少次访问没有使页面移动到young 区域的头部。</li><li>LRU len ：代表LRU链表中节点的数量。</li><li>unzip_LRU ：代表unzip_LRU链表中节点的数量（由于我们没有具体唠叨过这个链表，现在可以忽略它的值）。</li><li>I/O sum ：最近50s读取磁盘页的总数。</li><li>I/O cur ：现在正在读取的磁盘页数量。</li><li>I/O unzip sum ：最近50s解压的页面数量。</li><li>I/O unzip cur ：正在解压的页面数量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 optimizer trace表</title>
      <link href="/database/mysql/mysql-optimizer-trace-biao/"/>
      <url>/database/mysql/mysql-optimizer-trace-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-optimizer-trace表"><a href="#【MySQL】-optimizer-trace表" class="headerlink" title="【MySQL】 optimizer trace表"></a>【MySQL】 optimizer trace表</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 optimizer trace表date: 2023-06-24 14:40tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 optimizer trace表</code></pre><h2 id="【MySQL】-optimizer-trace表-1"><a href="#【MySQL】-optimizer-trace表-1" class="headerlink" title="【MySQL】 optimizer trace表"></a>【MySQL】 optimizer trace表</h2><p>查看优化器生成执行计划的整个过程</p><p>这个OPTIMIZER_TRACE 表有4个列，分别是：</p><ul><li>QUERY ：表示我们的查询语句。</li><li>TRACE ：表示优化过程的JSON格式文本。</li><li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE ：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li><li>INSUFFICIENT_PRIVILEGES ：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是1 ，我们暂时不关心这个字段的值。</li></ul><p>优化过程大致分为了三个阶段：</p><ul><li>prepare 阶段</li><li>optimize 阶段</li><li>execute 阶段</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 Explain详解</title>
      <link href="/database/mysql/mysql-explain-xiang-jie/"/>
      <url>/database/mysql/mysql-explain-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-Explain详解"><a href="#【MySQL】-Explain详解" class="headerlink" title="【MySQL】 Explain详解"></a>【MySQL】 Explain详解</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 Explain详解date: 2023-06-24 12:50tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 Explain详解</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>EXPLAIN 语句帮助理解 MySQL 如何执行 SQL 查询。每个输出列都有特定的含义。<br><strong>主要列：</strong></p><ul><li>table: 显示访问的表名。</li><li>id: 对于每个 SELECT 关键字，都会分配一个唯一的 id 值。</li><li>select_type: 描述了查询中各部分的类型（例如，SIMPLE, PRIMARY, UNION等）。</li><li>partitions: 显示涉及到的分区信息。</li><li>type：显示了 MySQL 使用哪种内部机制来查找行。可能是全索引扫描、范围扫描、全表扫描等方式之一。</li><li>possible_keys 和 key：显示 MySQL 可能和实际使用什么索引进行查询优化。</li><li>key_len：显示所选择的键长度，在某些条件下可能不使用全部长度来获取数据结果集</li><li>ref：表示参考什么信息寻找索引值 (如果可能) 在给定表上匹配一个行操作，这可以是常量或者函数等值对比结果</li><li>rows: 预计需要读取多少行以获得最终结果集.</li><li>filtered : 表示返回结果集百分比(通过where过滤后), 是估算值.</li><li>Extra: 提供MySQL如何处理查询以及检索表中行额外信息.<br><strong>Json格式：</strong><br>Json 格式提供了更详细且直观地查看执行计划花费成本与评价性能。</li><li>read_cost: IO 成本 + 检测 rows × (1 - filter) 条记录 CPU 成本</li><li>eval_cost: 检测 rows × filter 条记录成本</li><li>prefix_cost: 单独查询 s1 表成本 = read_cost + eval_cost</li><li>data_read_per_join :在此次查询中需要读取数据量</li></ul><p>总体而言，使用 EXPLAIN 可以帮助开发人员诊断低效率或潜在问题的 SQL 查询，并为优化提供依据。</p><h2 id="【MySQL】-Explain详解-1"><a href="#【MySQL】-Explain详解-1" class="headerlink" title="【MySQL】 Explain详解"></a>【MySQL】 Explain详解</h2><h3 id="EXPLAIN-语句输出的各个列的作用"><a href="#EXPLAIN-语句输出的各个列的作用" class="headerlink" title="EXPLAIN 语句输出的各个列的作用:"></a>EXPLAIN 语句输出的各个列的作用:</h3><pre><code class="line-numbers language-sql">EXPLAIN SELECT 1;</code></pre><p><img src="/attachment/3b588558bc6309016c37debba719dde2.png"></p><h2 id="执行计划输出中各列详解"><a href="#执行计划输出中各列详解" class="headerlink" title="执行计划输出中各列详解"></a>执行计划输出中各列详解</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p><strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名</strong></p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>每出现一个SELECT 关键字，会为它分配一个唯一的id 值。</p><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表。</p><p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>为每一个SELECT 关键字代表的小查询都定义了一个称之为select_type 的属性，意思是我们只要知道了某个小查询的select_type 属性，就知道了这个小查询在整个大查询中扮演了一个什么角色</p><p><strong>select_type 取值</strong></p><p><img src="/attachment/1b63c5033aeef5ddc5e715da92f0d3e0.png"></p><ul><li>SIMPLE<br>查询语句中不包含UNION 或者子查询的查询都算作是SIMPLE 类型</li><li>PRIMARY<br>对于包含UNION 、UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type 值就是PRIMARY</li><li>UNION<br>对于包含UNION 或者UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type 值就是UNION</li><li>UNION RESULT<br>MySQL 选择使用临时表来完成UNION 查询的去重工作，针对该临时表的查询的select_type 就是UNIONRESULT</li><li>SUBQUERY<br>如果包含子查询的查询语句不能够转为对应的semi-join 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个SELECT 关键字代表的那个查询的select_type 就是SUBQUERY<br><strong>由于select_type为SUBQUERY的子查询由于会被物化，所以只需要执行一遍</strong></li><li>DEPENDENT SUBQUERY<br>如果包含子查询的查询语句不能够转为对应的semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个SELECT 关键字代表的那个查询的select_type 就是DEPENDENT SUBQUERY<br><strong>select_type为DEPENDENT SUBQUERY的查询可能会被执行多次</strong></li><li>DEPENDENT UNION<br>在包含UNION 或者UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的select_type 的值就是DEPENDENT UNION 。</li><li>DERIVED<br>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的select_type 就是DERIVED ，比方说下边这个查询</li><li>MATERIALIZED<br>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的select_type 属性就是MATERIALIZED</li><li>UNCACHEABLE SUBQUERY</li><li>UNCACHEABLE UNION</li></ul><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>MySQL 对某个表的执行查询时的访问方法</p><p>其中的type 列就表明了这个访问方法是个啥</p><p>完整的访问方法如下： system ， const ，eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ，range ， index ， ALL 。</p><ul><li><p>system<br>该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system 。</p></li><li><p>const</p></li></ul><p>根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</p><ul><li>eq_ref</li></ul><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref</p><ul><li>ref</li></ul><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表</p><ul><li>fulltext</li></ul><p>全文索引</p><ul><li>ref_or_null</li></ul><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL 值时，那么对该表的访问方法就可能是ref_or_null</p><ul><li>index_merge</li></ul><p>一般情况下对于某个表的查询只能使用到一个索引，但我们唠叨单表访问方法时特意强调了在某些场景下可以使用Intersection 、Union 、Sort-Union 这三种索引合并的方式来执行查询</p><ul><li>unique_subquery</li></ul><p>类似于两表连接中被驱动表的eq_ref 访问方法， unique_subquery 是针对在一些包含IN 子查询的查询语句中，如果查询优化器决定将IN 子查询转换为EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的type 列的值就是unique_subquery</p><ul><li>index_subquery</li></ul><p>index_subquery 与unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引</p><ul><li>range</li></ul><p>如果使用索引获取某些范围区间的记录，那么就可能使用到range 访问方法</p><ul><li>index</li></ul><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index</p><ul><li>ALL</li></ul><p>全表扫描</p><h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p>possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些， key 列表示实际用到的索引有哪些</p><p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>key_len 列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度, 由这三个部分构成的</p><ul><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100) ，使用的字符集是utf8 ，那么该列实际占用的最大存储空间就是100 × 3 = 300 个字节。</li><li>如果该索引列可以存储NULL 值，则key_len 比不可以存储NULL 值时多1个字节。</li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ul><p>由于id 列的类型是INT ，并且不可以存储NULL 值，所以在使用该列的索引时key_len 大小就是4 。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>在访问方法是const 、eq_ref 、ref 、ref_or_null 、unique_subquery 、index_subquery 其中之一时， ref 列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows 列就代表预计扫描的索引记录行数。</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>condition filtering 的概念, MySQL 在计算驱动表扇出时采用的一个策略</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>Extra 列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL 到底将如何执行给定的查询语句。</p><ul><li>No tables used</li></ul><p>当查询语句的没有FROM 子句时将会提示该额外信息</p><ul><li>Impossible WHERE</li></ul><p>查询语句的WHERE 子句永远为FALSE 时将会提示该额外信息</p><ul><li>No matching min/max row</li></ul><p>当查询列表处有MIN 或者MAX 聚集函数，但是并没有符合WHERE 子句中的搜索条件的记录时，将会提示该额外信息</p><ul><li>Using index</li></ul><p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra 列将会提示该额外信息</p><ul><li>Using index condition</li></ul><p>有些搜索条件中虽然出现了索引列，但却不能使用到索引</p><ul><li>Using where</li></ul><p>当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE 子句中有针对该表的搜索条件时，在 Extra 列中会提示上述额外信息。</p><ul><li>Using join buffer (Block Nested Loop)</li></ul><p>当被驱动表不能有效的利用索引加快访问速度， MySQL 一般会为其分配一块名叫join buffer 的内存块来加快查询速度，也就是我们所讲的基于块的嵌套循环算法</p><ul><li>Not exists</li></ul><p>当我们使用左（外）连接时，如果WHERE 子句中包含要求被驱动表的某个列等于NULL 值的搜索条件，而且那个列又是不允许存储NULL 值的，那么在该表的执行计划的Extra 列就会提示Not exists 额外信息</p><p><strong>没有必要到被驱动表中找到全部符合ON子句条件的记录</strong></p><ul><li>Using intersect(…) 、Using union(…) 和Using sort_union(…)</li></ul><p>如果执行计划的Extra 列出现了Using intersect(…) 提示，说明准备使用Intersect 索引合并的方式执行查询，括号中的… 表示需要进行索引合并的索引名称；如果出现了Using union(…) 提示，说明准备使用Union 索引合并的方式执行查询；出现了Using sort_union(…) 提示，说明准备使用Sort-Union 索引合并的方式执行查询。</p><ul><li>Zero limit</li></ul><p>当我们的LIMIT 子句的参数为0 时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息</p><ul><li>Using filesort</li></ul><p>很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序</p><p>把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：filesort ）。</p><ul><li>Using temporary</li></ul><p>如果查询中使用到了内部的临时表，在执行计划的Extra 列将会显示Using temporary 提示</p><ul><li>Start temporary, End temporary</li></ul><p>查询优化器会优先尝试将IN 子查询转换成semi-join ，而semi-join 又有好多种执行策略</p><p>当执行策略为DuplicateWeedout 时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，<br>驱动表查询执行计划的Extra 列将显示Start temporary 提示<br>被驱动表查询执行计划的 Extra 列将显示End temporary 提示</p><ul><li>LooseScan</li></ul><p>在将In 子查询转为semi-join 时，如果采用的是LooseScan 执行策略，则在驱动表执行计划的Extra 列就是显示LooseScan 提示</p><ul><li>FirstMatch(tbl_name)</li></ul><p>在将In 子查询转为semi-join 时，如果采用的是FirstMatch 执行策略，则在被驱动表执行计划的Extra列就是显示FirstMatch(tbl_name)</p><h2 id="Json格式的执行计划"><a href="#Json格式的执行计划" class="headerlink" title="Json格式的执行计划"></a>Json格式的执行计划</h2><p>提供了一种查看某个执行计划花费的成本的方式</p><ul><li>read_cost 是由下边这两部分组成的<ul><li>IO 成本</li><li>检测rows × (1 - filter) 条记录的CPU 成本</li></ul></li><li>eval_cost 是这样计算的：<ul><li>检测 rows × filter 条记录的成本。</li></ul></li><li>prefix_cost 就是单独查询s1 表的成本<ul><li>read_cost + eval_cost</li></ul></li><li>data_read_per_join 表示在此次查询中需要读取的数据量</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 MySQL基于规则的优化</title>
      <link href="/database/mysql/mysql-mysql-ji-yu-gui-ze-de-you-hua/"/>
      <url>/database/mysql/mysql-mysql-ji-yu-gui-ze-de-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-MySQL基于规则的优化"><a href="#【MySQL】-MySQL基于规则的优化" class="headerlink" title="【MySQL】 MySQL基于规则的优化"></a>【MySQL】 MySQL基于规则的优化</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 MySQL基于规则的优化date: 2023-06-23 16:19tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 MySQL基于规则的优化</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<strong>查询重写</strong></p><ul><li>条件化简<ul><li>移除不必要的括号</li><li>常量传递（constant_propagation）</li><li>等值传递（equality_propagation）</li><li>移除没用的条件（trivial_condition_removal）</li><li>表达式计算</li><li>HAVING子句和WHERE子句的合并</li><li>常量表检测</li></ul></li><li>外连接消除<ul><li>在外连接查询中，指定的WHERE 子句中包含被驱动表中的列不为NULL 值的条件称之为空值拒绝</li><li>符合空值拒绝的条件后，外连接和内连接可以相互转换。</li><li>选出成本最低的那种连接顺序来执行查询</li></ul></li><li>子查询优化<ul><li>按返回的结果集区分子查询<ul><li>标量子查询</li><li>行子查询</li><li>列子查询</li><li>表子查询</li></ul></li><li>按与外层查询关系来区分子查询<ul><li>不相关子查询</li><li>相关子查询</li></ul></li><li>标量子查询、行子查询的执行方式<ul><li>包含不相关的标量子查询或者行子查询的查询语句<ul><li>分别独立的执行外层查询和子查询</li></ul></li><li>相关的标量子查询或者行子查询<ul><li>先从外层查询中获取一条记录，本例中也就是先从s1 表中获取一条记录。</li><li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从s1 表中获取的那条记录中找出s1.key3 列的值，然后执行子查询。</li><li>最后根据子查询的查询结果来检测外层查询WHERE 子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li><li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li></ul></li></ul></li><li>IN子查询优化<ul><li>物化表的提出<ul><li>将子查询结果集中的记录保存到临时表</li></ul></li><li>物化表转连接</li><li>将子查询转换为semi-join<ul><li>只关心在s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配</li><li>如果IN 子查询符合转换为semi-join 的条件，查询优化器会优先把该子查询为semi-join ，然后再考虑下边5种执行半连接的策略中哪个成本最低：</li><li>Table pullout （子查询中的表上拉）<ul><li>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表上拉到外层查询的FROM 子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中</li></ul></li><li>DuplicateWeedout execution strategy （重复值消除）<ul><li>可以建立一个临时表</li></ul></li><li>LooseScan execution strategy （松散索引扫描）<ul><li>只取值相同的记录的第一条去做匹配操作的方式</li></ul></li><li>FirstMatch execution strategy （首次匹配）<ul><li>先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录</li></ul></li><li>semi-join的适用条件<ul><li>该子查询必须是和IN 语句组成的布尔表达式，并且在外层查询的WHERE 或者ON 子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和IN 子查询的搜索条件必须使用AND 连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由UNION 连接起来的形式。</li><li>该子查询不能包含GROUP BY 或者HAVING 语句或者聚集函数。</li><li>… 还有一些条件比较少见，就不唠叨啦～</li></ul></li><li>不符合转换为semi-join 的条件<ul><li>先将子查询物化之后再执行查询</li><li>执行IN to EXISTS 转换。</li></ul></li></ul></li></ul></li></ul></li><li>ANY/ALL子查询优化<br>  <img src="/attachment/3b96bdbc57b41498b8685f778d9785a7.png"></li><li>[NOT] EXISTS子查询的执行<ul><li>可以先执行子查询，得出该[NOT] EXISTS 子查询的结果是TRUE 还是FALSE ，并重写原先的查询语句</li></ul></li><li>对于派生表的优化<ul><li>对于含有派生表的查询， MySQL 提供了两种执行策略：<ul><li>最容易想到的就是把派生表物化。</li><li>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</li></ul></li></ul></li><li>当派生表中有这些语句就不可以和外层查询合并：<ul><li>聚集函数，比如MAX()、MIN()、SUM()啥的</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>LIMIT</li><li>UNION 或者 UNION ALL</li><li>派生表对应的子查询的SELECT 子句中含有另一个子查询</li><li>… 还有些不常用的情况就不多说了哈～</li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计MySQL 的大叔还是依据一些规则,竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<strong>查询重写</strong></p><h2 id="条件化简"><a href="#条件化简" class="headerlink" title="条件化简"></a>条件化简</h2><h3 id="移除不必要的括号"><a href="#移除不必要的括号" class="headerlink" title="移除不必要的括号"></a>移除不必要的括号</h3><p>优化器会把那些用不到的括号给干掉</p><pre><code class="line-numbers language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;((a = 5 AND b = c) OR ((a &amp;gt; c) AND (c &amp;lt; 5)))&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;(a = 5 and b = c) OR (a &amp;gt; c AND c &amp;lt; 5)&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="常量传递（constant-propagation）"><a href="#常量传递（constant-propagation）" class="headerlink" title="常量传递（constant_propagation）"></a>常量传递（constant_propagation）</h3><p>有时候某个表达式是某个列和某个常量做等值匹配. 当这个表达式和其他涉及列a 的表达式使用AND 连接起来时，可以将其他表达式中的a 的值替换为5</p><pre><code class="line-numbers language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;a = 5 AND b &amp;gt; a&lt;/p&gt;&lt;/div&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;a = 5 AND b &amp;gt; 5&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="等值传递（equality-propagation）"><a href="#等值传递（equality-propagation）" class="headerlink" title="等值传递（equality_propagation）"></a>等值传递（equality_propagation）</h3><pre><code class="line-numbers language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;a = b and b = c and c = 5&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;a = 5 and b = 5 and c = 5&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="移除没用的条件（trivial-condition-removal）"><a href="#移除没用的条件（trivial-condition-removal）" class="headerlink" title="移除没用的条件（trivial_condition_removal）"></a>移除没用的条件（trivial_condition_removal）</h3><p>对于一些明显永远为TRUE 或者FALSE 的表达式，优化器会移除掉它们</p><pre><code class="line-numbers language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;(a &amp;lt; 1 and b = b) OR (a = 6 OR 5 != 5)&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;a &amp;lt; 1 OR a = 6&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="表达式计算"><a href="#表达式计算" class="headerlink" title="表达式计算"></a>表达式计算</h3><pre><code class="line-numbers language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;a = 5 + 1&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;a = 6&lt;/p&gt;&lt;/div&gt;</code></pre><p><strong>最好让索引列以单独的形式出现在表达式中</strong></p><h3 id="HAVING子句和WHERE子句的合并"><a href="#HAVING子句和WHERE子句的合并" class="headerlink" title="HAVING子句和WHERE子句的合并"></a>HAVING子句和WHERE子句的合并</h3><p>如果查询语句中没有出现诸如SUM 、MAX 等等的聚集函数以及GROUP BY 子句，优化器就把HAVING 子句和WHERE 子句合并起来。</p><h3 id="常量表检测"><a href="#常量表检测" class="headerlink" title="常量表检测"></a>常量表检测</h3><p>设计MySQL 的大叔觉得下边这两种查询运行的特别快：</p><ul><li>查询的表中一条记录没有，或者只有一条记录。</li><li>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</li></ul><p>把通过主键等值匹配或者唯一二级索引列等值匹配这两种方式查询的表称之为常量表（英文名： constant tables ）</p><p>优化器在分析一个查询语句时，</p><ul><li>先首先执行常量表查询</li><li>然后把查询中涉及到该表的条件全部替换成常数</li><li>最后再分析其余表的查询成本</li></ul><pre><code class="line-numbers language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;SELECT * FROM table1 INNER JOIN table2ON table1.column1 = table2.column2WHERE table1.primary_key = 1;&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2ON table1表column1列的常量值 = table2.column2;&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="外连接消除"><a href="#外连接消除" class="headerlink" title="外连接消除"></a>外连接消除</h2><p>外连接和内连接的本质区别就是：<br>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃</p><p>凡是不符合WHERE子句中条件的记录都不会参与连接<br>只要我们在搜索条件中指定关于被驱动表相关列的值不为NULL ，那么外连接中在被驱动表中找不到符合ON 子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了！</p><p>我们把这种在外连接查询中，指定的WHERE 子句中包含被驱动表中的列不为NULL 值的条件称之为空值拒绝（英文名： reject-NULL ）。</p><p>在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。</p><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><h3 id="按返回的结果集区分子查询"><a href="#按返回的结果集区分子查询" class="headerlink" title="按返回的结果集区分子查询"></a>按返回的结果集区分子查询</h3><p>因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型</p><ul><li><p>标量子查询<br><strong>只返回一个单一值的子查询</strong>称之为标量子查询</p></li><li><p>行子查询<br>返回一条记录的子查询，不过这条记录需要包含多个列</p></li><li><p>列子查询<br>列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录</p></li><li><p>表子查询<br>子查询的结果既包含很多条记录，又包含很多个列</p></li></ul><h3 id="按与外层查询关系来区分子查询"><a href="#按与外层查询关系来区分子查询" class="headerlink" title="按与外层查询关系来区分子查询"></a>按与外层查询关系来区分子查询</h3><ul><li><p>不相关子查询<br>如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为不相关子查询</p></li><li><p>相关子查询<br>如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为相关子查询</p></li></ul><h3 id="子查询在布尔表达式中的使用"><a href="#子查询在布尔表达式中的使用" class="headerlink" title="子查询在布尔表达式中的使用"></a>子查询在布尔表达式中的使用</h3><ul><li><p>使用= 、&gt; 、&lt; 、&gt;= 、&lt;= 、&lt;&gt; 、!= 、&lt;=&gt; 作为布尔表达式的操作符<br>这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录</p></li><li><p>[NOT] IN/ANY/SOME/ALL子查询</p><ul><li>IN 或者NOT IN<ul><li>操作数 [NOT] IN (子查询)</li><li>判断某个操作数在不在由子查询结果集组成的集合中</li></ul></li><li>ANY/SOME （ ANY 和SOME 是同义词）<ul><li>操作数 comparison_operator ANY/SOME(子查询)</li><li>ANY相当于判断子查询结果集中是否存在某个值和给定的操作数相等，它的含义和IN是相同的。</li></ul></li><li>ALL<ul><li>操作数 comparison_operator ALL(子查询)</li></ul></li></ul></li><li><p>EXISTS子查询</p><ul><li>仅仅需要判断子查询的结果集中是否有记录</li><li>[NOT] EXISTS (子查询)</li></ul></li></ul><h3 id="子查询语法注意事项"><a href="#子查询语法注意事项" class="headerlink" title="子查询语法注意事项"></a>子查询语法注意事项</h3><ul><li>子查询必须用小括号扩起来。不扩起来的子查询是非法的</li><li>在SELECT 子句中的子查询必须是标量子查询。</li><li>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用LIMIT 1 语句来限制记录数量。</li><li>对于[NOT] IN/ANY/SOME/ALL 子查询来说，子查询中不允许有LIMIT 语句。</li><li>ORDER BY 子句 子查询的结果其实就相当于一个集合，集合里的值排不排序一点儿都不重要</li><li>DISTINCT 语句 集合里的值去不去重也没啥意义</li><li>没有聚集函数以及HAVING 子句的GROUP BY 子句。</li><li>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</li></ul><h3 id="子查询在MySQL中是怎么执行的"><a href="#子查询在MySQL中是怎么执行的" class="headerlink" title="子查询在MySQL中是怎么执行的"></a>子查询在MySQL中是怎么执行的</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><pre><code class="line-numbers language-sql">CREATE TABLE single_table (id INT NOT NULL AUTO_INCREMENT,key1 VARCHAR(100),key2 INT,key3 VARCHAR(100),key_part1 VARCHAR(100),key_part2 VARCHAR(100),key_part3 VARCHAR(100),common_field VARCHAR(100),PRIMARY KEY (id),KEY idx_key1 (key1),UNIQUE KEY idx_key2 (key2),KEY idx_key3 (key3),KEY idx_key_part(key_part1, key_part2, key_part3)) Engine=InnoDB CHARSET=utf8;</code></pre><h4 id="标量子查询、行子查询的执行方式"><a href="#标量子查询、行子查询的执行方式" class="headerlink" title="标量子查询、行子查询的执行方式"></a>标量子查询、行子查询的执行方式</h4><p>对于<strong>包含不相关的标量子查询或者行子查询的查询语句</strong>来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。</p><p>对于相关的标量子查询或者行子查询来说</p><ul><li>先从外层查询中获取一条记录，本例中也就是先从s1 表中获取一条记录。</li><li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从s1 表中获取的那条记录中找出s1.key3 列的值，然后执行子查询。</li><li>最后根据子查询的查询结果来检测外层查询WHERE 子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li><li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li></ul><h3 id="IN子查询优化"><a href="#IN子查询优化" class="headerlink" title="IN子查询优化"></a>IN子查询优化</h3><h4 id="物化表的提出"><a href="#物化表的提出" class="headerlink" title="物化表的提出"></a>物化表的提出</h4><p>为了优化IN 子查询倾注了太多心血</p><p>不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里</p><p><strong>写入临时表的过程</strong></p><ul><li>该临时表的列就是子查询结果集中的列。</li><li>写入临时表的记录会被去重。</li><li>一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用Memory 存储引擎的临时表，而且会为该表建立哈希索引。</li></ul><p>把这个将子查询结果集中的记录保存到临时表的过程称之为物化（英文名：Materialize ）</p><h4 id="物化表转连接"><a href="#物化表转连接" class="headerlink" title="物化表转连接"></a>物化表转连接</h4><pre><code class="line-numbers language-sql">SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');</code></pre><p>当我们把子查询进行物化之后，假设子查询物化表的名称为materialized_table ，该物化表存储的子查询结果集的列为m_val ，那么这个查询其实可以从下边两种角度来看待</p><ul><li><p>从表s1 的角度来看待，整个查询的意思其实是：对于s1 表中的每条记录来说，如果该记录的key1 列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：<br><img src="/attachment/a373317ab7e8083dfda2ee519833cf69.png"></p></li><li><p>从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在s1 表中找到对应的key1 列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：</p></li></ul><p><img src="/attachment/1fd4cf961ac0155cdf6a4591fc0f8066.png"></p><p>也就是说其实上边的查询就相当于表s1 和子查询物化表materialized_table 进行内连接</p><p>分析一下上述查询中使用外层查询的表s1 和物化表materialized_table 进行内连接的成本都是由哪几部分组成的：</p><ul><li>如果使用s1 表作为驱动表的话，总查询成本由下边几个部分组成：<ul><li>物化子查询时需要的成本</li><li>扫描s1 表时的成本</li><li>s1表中的记录数量 × 通过m_val = xxx 对materialized_table 表进行单表访问的成本（我们前边说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。</li></ul></li><li>如果使用materialized_table 表作为驱动表的话，总查询成本由下边几个部分组成：<ul><li>物化子查询时需要的成本</li><li>扫描物化表时的成本</li><li>物化表中的记录数量 × 通过key1 = xxx 对s1 表进行单表访问的成本（非常庆幸key1 列上建立了索引，所以这个步骤是非常快的）。</li></ul></li></ul><h3 id="将子查询转换为semi-join"><a href="#将子查询转换为semi-join" class="headerlink" title="将子查询转换为semi-join"></a>将子查询转换为semi-join</h3><p>虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用</p><p>能不能不进行物化操作直接把子查询转换为连接呢？</p><p>我们可以分三种情况讨论：</p><ul><li>情况一：对于s1 表的某条记录来说， s2 表中没有任何记录满足s1.key1 = s2.common_field 这个条件，那么该记录自然也不会加入到最后的结果集。</li><li>情况二：对于s1 表的某条记录来说， s2 表中有且只有记录满足s1.key1 = s2.common_field 这个条件，那么该记录会被加入最终的结果集。</li><li>情况三：对于s1 表的某条记录来说， s2 表中至少有2条记录满足s1.key1 = s2.common_field 这个条件，那么该记录会被多次加入最终的结果集。</li></ul><p>由于我们只关心s2 表中是否存在记录满足s1.key1 = s2.common_field 这个条件，而不关心具体有多少条记录与之匹配，又因为有情况三的存在，我们上边所说的IN 子查询和两表连接之间并不完全等价。</p><p>提出了一个新概念 — 半连接（英文名： semi-join ）。将s1 表和s2 表进行半连接的意思就是</p><p>对于s1 表的某条记录来说，我们只关心在s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留s1 表的记录。</p><h4 id="怎么实现这种所谓的半连接呢？"><a href="#怎么实现这种所谓的半连接呢？" class="headerlink" title="怎么实现这种所谓的半连接呢？"></a>怎么实现这种所谓的半连接呢？</h4><p><strong>Table pullout （子查询中的表上拉）</strong></p><p>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表上拉到外层查询的FROM 子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中</p><pre><code class="line-numbers language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;SELECT * FROM s1WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = 'a');&lt;/p&gt;&lt;/div&gt;由于key2 列是s2 表的唯一二级索引列，所以我们可以直接把s2 表上拉到外层查询的FROM 子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，上拉之后的查询就是这样的：&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;SELECT s1.* FROM s1 INNER JOIN s2ON s1.key2 = s2.key2WHERE s2.key3 = 'a';&lt;/p&gt;&lt;/div&gt;</code></pre><p><strong>主键或者唯一索引列中的数据本身就是不重复</strong></p><p><strong>DuplicateWeedout execution strategy （重复值消除）</strong></p><p>s1 表中的某条记录可能在s2 表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表</p><p><strong>LooseScan execution strategy （松散索引扫描）</strong></p><p>在子查询中，对于s2 表的访问可以使用到key1 列的索引，而恰好子查询的查询列表处就是key1 列，这样在将该查询转换为半连接查询后，如果将s2 作为驱动表执行查询的话，那么执行过程就是这样</p><p><img src="/attachment/1dce000b49353f37f1c133ac69533d4e.png"></p><p>虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为<strong>松散索引扫描</strong>。</p><p><strong>Semi-join Materialization execution strategy</strong></p><p>先把外层查询的IN 子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种semi-join ，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。</p><p><strong>FirstMatch execution strategy （首次匹配）</strong></p><p>先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。</p><h4 id="semi-join的适用条件"><a href="#semi-join的适用条件" class="headerlink" title="semi-join的适用条件"></a>semi-join的适用条件</h4><p>只有形如这样的查询才可以被转换为semi-join ：</p><pre><code class="line-numbers language-sql">SELECT ... FROM outer_tablesWHERE expr IN (SELECT ... FROM inner_tables ...) AND ...</code></pre><p>或者这样的形式也可以：</p><pre><code class="line-numbers language-sql">SELECT ... FROM outer_tablesWHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...</code></pre><p>用文字总结一下，只有符合下边这些条件的子查询才可以被转换为semi-join ：</p><ul><li>该子查询必须是和IN 语句组成的布尔表达式，并且在外层查询的WHERE 或者ON 子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和IN 子查询的搜索条件必须使用AND 连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由UNION 连接起来的形式。</li><li>该子查询不能包含GROUP BY 或者HAVING 语句或者聚集函数。</li><li>… 还有一些条件比较少见，就不唠叨啦～</li></ul><h4 id="不适用于semi-join的情况"><a href="#不适用于semi-join的情况" class="headerlink" title="不适用于semi-join的情况"></a>不适用于semi-join的情况</h4><ul><li>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用OR 连接起来</li></ul><pre><code class="line-numbers language-ad-example">```sqlSELECT * FROM s1WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a')OR key2 &gt; 100;```</code></pre><ul><li>使用NOT IN 而不是IN 的情况</li></ul><pre><code class="line-numbers language-ad-example">```sqlSELECT * FROM s1WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = 'a')```</code></pre><ul><li>在SELECT 子句中的IN子查询的情况</li></ul><pre><code class="line-numbers language-ad-example">```sqlSELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a') FROM s1 ;```</code></pre><ul><li>子查询中包含GROUP BY 、HAVING 或者聚集函数的情况</li></ul><pre><code class="line-numbers language-ad-example">```sqlSELECT * FROM s1WHERE key2 IN (SELECT COUNT(*) FROM s2 GROUP BY key1);```</code></pre><ul><li>子查询中包含UNION 的情况</li></ul><pre><code class="line-numbers language-ad-example">```sqlSELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a'UNIONSELECT common_field FROM s2 WHERE key3 = 'b');```</code></pre><h4 id="MySQL-仍然留了两手绝活来优化不能转为semi-join-查询的子查询"><a href="#MySQL-仍然留了两手绝活来优化不能转为semi-join-查询的子查询" class="headerlink" title="MySQL 仍然留了两手绝活来优化不能转为semi-join 查询的子查询"></a>MySQL 仍然留了两手绝活来优化不能转为semi-join 查询的子查询</h4><ul><li><p>对于不相关子查询来说，可以尝试把它们物化之后再参与查询</p></li><li><p>不管子查询是相关的还是不相关的，都可以把IN 子查询尝试转为EXISTS 子查询</p></li></ul><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>如果IN 子查询符合转换为semi-join 的条件，查询优化器会优先把该子查询为semi-join ，然后再考虑下边5种执行半连接的策略中哪个成本最低：</p><ul><li>Table pullout</li><li>DuplicateWeedout</li><li>LooseScan</li><li>Materialization</li><li>FirstMatch<br>选择成本最低的那种执行策略来执行子查询。</li></ul><p>如果IN 子查询不符合转换为semi-join 的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：</p><ul><li>先将子查询物化之后再执行查询</li><li>执行IN to EXISTS 转换。</li></ul><h3 id="ANY-x2F-ALL子查询优化"><a href="#ANY-x2F-ALL子查询优化" class="headerlink" title="ANY/ALL子查询优化"></a>ANY/ALL子查询优化</h3><p><img src="/attachment/3b96bdbc57b41498b8685f778d9785a7.png"></p><h3 id="NOT-EXISTS子查询的执行"><a href="#NOT-EXISTS子查询的执行" class="headerlink" title="[NOT] EXISTS子查询的执行"></a>[NOT] EXISTS子查询的执行</h3><p>如果[NOT] EXISTS 子查询是不相关子查询，可以先执行子查询，得出该[NOT] EXISTS 子查询的结果是TRUE 还是FALSE ，并重写原先的查询语句</p><h3 id="对于派生表的优化"><a href="#对于派生表的优化" class="headerlink" title="对于派生表的优化"></a>对于派生表的优化</h3><p>我们前边说过把子查询放在外层查询的FROM 子句后，那么这个子查询的结果相当于一个派生表</p><p>对于含有派生表的查询， MySQL 提供了两种执行策略：</p><ul><li>最容易想到的就是把派生表物化。</li><li>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</li></ul><p>当派生表中有这些语句就不可以和外层查询合并：</p><ul><li>聚集函数，比如MAX()、MIN()、SUM()啥的</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>LIMIT</li><li>UNION 或者 UNION ALL</li><li>派生表对应的子查询的SELECT 子句中含有另一个子查询</li><li>… 还有些不常用的情况就不多说了哈～</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB 的统计数据收集</title>
      <link href="/database/mysql/mysql-innodb-de-tong-ji-shu-ju-shou-ji/"/>
      <url>/database/mysql/mysql-innodb-de-tong-ji-shu-ju-shou-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-InnoDB-的统计数据收集"><a href="#【MySQL】-InnoDB-的统计数据收集" class="headerlink" title="【MySQL】 InnoDB 的统计数据收集"></a>【MySQL】 InnoDB 的统计数据收集</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 InnoDB 的统计数据收集date: 2023-06-23 15:44tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 InnoDB 的统计数据收集</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>InnoDB 以<strong>表</strong>为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</li><li><strong>innodb_stats_persistent</strong> 控制着<strong>是否使用永久性统计数据</strong>；</li><li><strong>innodb_stats_persistent_sample_pages</strong> 控制着<strong>永久性统计数据</strong>的<strong>采样页面数量</strong>；</li><li><strong>innodb_stats_transient_sample_pages</strong> 控制着<strong>非永久性统计数据</strong>的<strong>采样页面数量</strong>；</li><li><strong>innodb_stats_auto_recalc</strong> 控制着<strong>是否自动重新计算统计数据</strong>。</li><li>我们可以针对某个具体的表，在创建和修改表时通过指定STATS_PERSISTENT 、STATS_AUTO_RECALC 、STATS_SAMPLE_PAGES 的值来控制相关统计数据属性。</li><li><strong>innodb_stats_method</strong> 决定着在<strong>统计某个索引列不重复值的数量时如何对待NULL 值</strong>。</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过SHOW TABLE STATUS 可以看到关于表的统计数据<br>通过SHOW INDEX 可以看到关于索引的统计数据</p><h2 id="两种不同的统计数据存储方式"><a href="#两种不同的统计数据存储方式" class="headerlink" title="两种不同的统计数据存储方式"></a>两种不同的统计数据存储方式</h2><ul><li><p>永久性的统计数据<br>这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</p></li><li><p>非永久性的统计数据<br>这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了</p></li></ul><p>提供了系统变量innodb_stats_persistent 来控制到底采用哪种方式去存储统计数据</p><p><strong>InnoDB 默认是以表为单位来收集和存储统计数据的</strong></p><p>也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。</p><p>在创建和修改表的时候通过指定STATS_PERSISTENT 属性来指明该表的统计数据存储方式</p><pre><code class="line-numbers language-sql">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);</code></pre><h2 id="基于磁盘的永久性统计数据"><a href="#基于磁盘的永久性统计数据" class="headerlink" title="基于磁盘的永久性统计数据"></a>基于磁盘的永久性统计数据</h2><p>当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里</p><p><img src="/attachment/0ca6e36a8dad1f0eae419e6308dcca56.png"></p><p>这两个表都位于mysql 系统数据库下边</p><ul><li>innodb_table_stats 存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li>innodb_index_stats 存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><h3 id="innodb-table-stats"><a href="#innodb-table-stats" class="headerlink" title="innodb_table_stats"></a>innodb_table_stats</h3><p><img src="/attachment/4502734aa98c041b96d32642ce726350.png"><br>注意这个表的主键是(database_name,table_name)</p><p><strong>innodb_table_stats表的每条记录代表着一个表的统计信息</strong></p><p>几个重要统计信息项的值如下：</p><ul><li>n_rows 的值是9693 ，表明single_table 表中大约有9693 条记录，注意这个数据是估计值。</li><li>clustered_index_size 的值是97 ，表明single_table 表的聚簇索引占用97个页面，这个值是也是一个估计值。</li><li>sum_of_other_index_sizes 的值是175 ，表明single_table 表的其他索引一共占用175个页面，这个值是也是一个估计值。</li></ul><h4 id="n-rows统计项的收集"><a href="#n-rows统计项的收集" class="headerlink" title="n_rows统计项的收集"></a>n_rows统计项的收集</h4><p>n_rows 这个统计项的值是估计值</p><p>InnoDB 统计一个表中有多少行记录的套路:</p><ul><li>按照一定算法（并不是纯粹随机的）选取几个叶子节点页面</li><li>计算每个页面中主键值记录数量</li><li>然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的n_rows 值。</li></ul><p>n_rows 值精确与否取决于统计时采样的页面数量</p><p>准备了一个名为innodb_stats_persistent_sample_pages 的系统变量来<strong>控制使用永久性的统计数据时，计算统计数据时采样的页面数量</strong>。<br>该系统变量的默认值是20</p><h4 id="clustered-index-size和sum-of-other-index-sizes统计项的收集"><a href="#clustered-index-size和sum-of-other-index-sizes统计项的收集" class="headerlink" title="clustered_index_size和sum_of_other_index_sizes统计项的收集"></a>clustered_index_size和sum_of_other_index_sizes统计项的收集</h4><p>这两个统计项的收集过程如下：</p><ul><li>从数据字典里找到表的各个索引对应的根页面位置。<br>系统表SYS_INDEXES 里存储了各个索引对应的根页面信息。</li><li>从根页面的Page Header 里找到叶子节点段和非叶子节点段对应的Segment Header 。<br>  在每个索引的根页面的Page Header 部分都有两个字段：<ul><li>PAGE_BTR_SEG_LEAF ：表示B+树叶子段的Segment Header 信息。</li><li>PAGE_BTR_SEG_TOP ：表示B+树非叶子段的Segment Header 信息。</li></ul></li><li>从叶子节点段和非叶子节点段的Segment Header 中找到这两个段对应的INODE Entry 结构。</li><li>从对应的INODE Entry 结构中可以找到该段对应所有零散的页面地址以及FREE 、NOT_FULL 、FULL 链表的基节点。</li><li>直接统计零散的页面有多少个，然后从那三个链表的List Length 字段中读出该段占用的区的大小，每个区占用64 个页，所以就可以统计出整个段占用的页面。</li><li>分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数,<ul><li>它们的和就是clustered_index_size 的值</li><li>按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是sum_of_other_index_sizes 的值。</li></ul></li></ul><p>以<strong>区为单位申请空间中有一些页可能并没有使用</strong>，但是在统计clustered_index_size 和 sum_of_other_index_sizes 时都把它们算进去了，所以说聚簇索引和其他的索引占用的页面数可能比这两个值要小一些。</p><h3 id="innodb-index-stats"><a href="#innodb-index-stats" class="headerlink" title="innodb_index_stats"></a>innodb_index_stats</h3><p><img src="/attachment/6008aa7dab16d26450bebd56b1559528.png"></p><p>注意这个表的主键是(database_name,table_name,index_name,stat_name)</p><p>其中的stat_name 是指统计项的名称，也就是说innodb_index_stats表的每条记录代表着一个索引的一个统计项。</p><p>正确查看这个结果的方式是这样的：</p><ul><li>先查看index_name 列，这个列说明该记录是哪个索引的统计信息</li><li>针对index_name 列相同的记录， stat_name 表示针对该索引的统计项名称， stat_value 展示的是该索引在该统计项上的值， stat_description 指的是来描述该统计项的含义的。<ul><li>n_leaf_pages 该索引的叶子节点占用多少页面</li><li>size 表示该索引共占用多少页面。</li><li>n_diff_pfxNN 表示对应的索引列不重复的值有多少</li></ul></li><li>在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样， size 列就表明了采样的页面数量是多少。</li></ul><h3 id="定期更新统计数据"><a href="#定期更新统计数据" class="headerlink" title="定期更新统计数据"></a>定期更新统计数据</h3><p>提供了如下两种更新统计数据的方式：</p><ul><li>开启innodb_stats_auto_recalc 。<br>系统变量innodb_stats_auto_recalc 决定着服务器是否自动重新计算统计数据，它的默认值是ON ，也就是该功能默认是开启的。<br>过自动重新计算统计数据的过程是异步发生的</li><li>手动调用ANALYZE TABLE 语句来更新统计信息</li><li>ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的</li></ul><h3 id="手动更新innodb-table-stats-和innodb-index-stats-表"><a href="#手动更新innodb-table-stats-和innodb-index-stats-表" class="headerlink" title="手动更新innodb_table_stats 和innodb_index_stats 表"></a>手动更新innodb_table_stats 和innodb_index_stats 表</h3><p>手动更新某个表或者索引的统计数据</p><p>步骤一：更新innodb_table_stats 表。<br>步骤二：让MySQL 查询优化器重新加载我们更改过的数据。</p><h2 id="基于内存的非永久性统计数据"><a href="#基于内存的非永久性统计数据" class="headerlink" title="基于内存的非永久性统计数据"></a>基于内存的非永久性统计数据</h2><p>系统变量innodb_stats_persistent 的值设置为OFF<br>直接在创建表或修改表时设置STATS_PERSISTENT 属性的值为0</p><p>由于非永久性的统计数据经常更新，所以导致MySQL 查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会生成<strong>经常变化的执行计划</strong></p><h2 id="innodb-stats-method的使用"><a href="#innodb-stats-method的使用" class="headerlink" title="innodb_stats_method的使用"></a>innodb_stats_method的使用</h2><p>索引列不重复的值的数量这个统计数据对于MySQL 查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行</p><p>它的应用场景主要有两个</p><ul><li>单表查询中单点区间太多<br>直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量</li><li>连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用ref 访问方法来对被驱动表进行查询</li></ul><p>他们提供了一个名为innodb_stats_method 的系统变量，相当于在计算某个索引列不重复值的数量时如何对待NULL 值这个锅甩给了用户，这个系统变量有三个候选值：</p><ul><li>nulls_equal ：认为所有NULL 值都是相等的。</li><li>nulls_unequal ：认为所有NULL 值都是不相等的。</li><li>nulls_ignored ：直接把NULL 值忽略掉。</li></ul><p>最好不在索引列中存放NULL值才是正解</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 MySQL基于成本的优化</title>
      <link href="/database/mysql/mysql-mysql-ji-yu-cheng-ben-de-you-hua/"/>
      <url>/database/mysql/mysql-mysql-ji-yu-cheng-ben-de-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-MySQL基于成本的优化"><a href="#【MySQL】-MySQL基于成本的优化" class="headerlink" title="【MySQL】 MySQL基于成本的优化"></a>【MySQL】 MySQL基于成本的优化</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 MySQL基于成本的优化date: 2023-06-23 13:57tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 MySQL基于成本的优化</code></pre><h2 id="什么是成本"><a href="#什么是成本" class="headerlink" title="什么是成本"></a>什么是成本</h2><h3 id="I-x2F-O-成本"><a href="#I-x2F-O-成本" class="headerlink" title="I/O 成本"></a>I/O 成本</h3><p>从磁盘到内存这个加载的过程损耗的时间</p><h3 id="CPU-成本"><a href="#CPU-成本" class="headerlink" title="CPU 成本"></a>CPU 成本</h3><p>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间</p><p>规定读取一个页面花费的成本默认是1.0 ，读取以及检测一条记录是否符合搜索条件的成本默认是0.2 。</p><h2 id="单表查询的成本"><a href="#单表查询的成本" class="headerlink" title="单表查询的成本"></a>单表查询的成本</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code class="line-numbers language-sql">CREATE TABLE single_table (id INT NOT NULL AUTO_INCREMENT,key1 VARCHAR(100),key2 INT,key3 VARCHAR(100),key_part1 VARCHAR(100),key_part2 VARCHAR(100),key_part3 VARCHAR(100),common_field VARCHAR(100),PRIMARY KEY (id),KEY idx_key1 (key1),UNIQUE KEY idx_key2 (key2),KEY idx_key3 (key3),KEY idx_key_part(key_part1, key_part2, key_part3)) Engine=InnoDB CHARSET=utf8;</code></pre><h3 id="基于成本的优化步骤"><a href="#基于成本的优化步骤" class="headerlink" title="基于成本的优化步骤"></a>基于成本的优化步骤</h3><p>MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<strong>执行计划</strong>，之后才会调用存储引擎提供的接口真正的执行查询</p><h4 id="1-根据搜索条件，找出所有可能使用的索引"><a href="#1-根据搜索条件，找出所有可能使用的索引" class="headerlink" title="1. 根据搜索条件，找出所有可能使用的索引"></a>1. 根据搜索条件，找出所有可能使用的索引</h4><p>把一个查询中可能使用到的索引称之为possible keys</p><h4 id="2-计算全表扫描的代价"><a href="#2-计算全表扫描的代价" class="headerlink" title="2. 计算全表扫描的代价"></a>2. 计算全表扫描的代价</h4><p>全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集</p><p>由于查询成本= I/O 成本+ CPU 成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><p>提供了SHOW TABLE STATUS 语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的LIKE 语句就好</p><pre><code class="line-numbers language-sql">SHOW TABLE STATUS LIKE 'single_table'</code></pre><ul><li>Rows 本选项表示表中的记录条数。</li><li>Data_length 本选项表示表占用的存储空间字节数。<ul><li>Data_length = 聚簇索引的页面数量 x 每个页面的大小</li><li>页数 = Data_length / 页占用空间字节数</li></ul></li></ul><p>对于single_table 的全表扫描所需的总成本 = I/O 成本 + CPU 成本 = 页数 * 1.0 (加载一个页面的成本常数) + 1.1(偏移值) + ROW * 0.2 (读取一条记录的成本常数) + 1.0(微调值) </p><h4 id="3-计算使用不同索引执行查询的代价"><a href="#3-计算使用不同索引执行查询的代价" class="headerlink" title="3. 计算使用不同索引执行查询的代价"></a>3. 计算使用不同索引执行查询的代价</h4><p>下边我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p><pre><code class="line-numbers language-sql">SELECT * FROM single_table WHEREkey1 IN ('a', 'b', 'c') ANDkey2 &gt; 10 AND key2 &lt; 1000 ANDkey3 &gt; key2 ANDkey_part1 LIKE '%hello%' ANDcommon_field = '123';</code></pre><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><ul><li>使用idx_key2执行查询的成本分析</li></ul><p><img src="/attachment/6f54658c205985ac9ef486424ce0fdd9.png"></p><ul><li>范围数量<br>查询优化器粗暴的认为读取索引的一个范围区间的I/O成本和读取一个页面是相同的</li></ul><p><img src="/attachment/86e2a448589112c2f07e8f3d50b86c5f.png"></p><ul><li><p>需要回表的记录数</p></li><li><p>步骤1：访问一下idx_key2 对应的B+ 树索引</p><ul><li>区间最左记录</li><li>区间最右记录 <ul><li>每次最多跨10页</li><li>计算页b 和页c 之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录</li></ul></li><li>读取二级索引记录需要付出的CPU 成本= 需要读取的二级索引记录条数 * 0.2 (读取记录的成本)  + 0.01 (微调值)</li></ul></li><li><p>步骤2: 根据这些记录里的主键值到聚簇索引中做回表操作</p><ul><li>粗略计算： 每次回表操作都相当于访问一个页面<ul><li>需要读取的二级索引记录条数 * 1 (读取一个页面所需时间成本) + 0.1 (微调值)</li></ul></li><li>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立</li></ul></li></ul><h5 id="In"><a href="#In" class="headerlink" title="In"></a>In</h5><ul><li>使用idx_key1执行查询的成本分析</li></ul><p><img src="/attachment/7e0ed677f04e40adc1f6fcd65c8c19a9.png"></p><ul><li>范围区间数量</li></ul><p>使用idx_key1 执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I/O成本就是：<br>3 x 1.0 = 3.0</p><ul><li>需要回表的记录数</li></ul><h5 id="是否有可能使用索引合并（Index-Merge）"><a href="#是否有可能使用索引合并（Index-Merge）" class="headerlink" title="是否有可能使用索引合并（Index Merge）"></a>是否有可能使用索引合并（Index Merge）</h5><h4 id="4-对比各种执行方案的代价，找出成本最低的那一个"><a href="#4-对比各种执行方案的代价，找出成本最低的那一个" class="headerlink" title="4. 对比各种执行方案的代价，找出成本最低的那一个"></a>4. 对比各种执行方案的代价，找出成本最低的那一个</h4><p>下边把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p><ul><li>全表扫描的成本： 2037.7</li><li>使用idx_key2 的成本： 134.01</li><li>使用idx_key1 的成本： 168.21<br>很显然，使用idx_key2 的成本最低，所以当然选择idx_key2 来执行查询喽。</li></ul><h3 id="基于索引统计数据的成本计算"><a href="#基于索引统计数据的成本计算" class="headerlink" title="基于索引统计数据的成本计算"></a>基于索引统计数据的成本计算</h3><p>这种通过直接访问索引对应的B+ 树来计算某个范围区间对应的索引记录条数的方式称之为index dive 。</p><p>系统变量  eq_range_index_dive_limit</p><p>小于该值将使用index dive 的方式计算各个单点区间对应的记录条数</p><p>查看一下single_table 的各个索引的统计数据</p><pre><code class="line-numbers language-sql">SHOW INDEX FROM single_table;</code></pre><p><img src="/attachment/e1da7a29877c93da11c456c2b657a456.png"></p><h2 id="连接查询的成本"><a href="#连接查询的成本" class="headerlink" title="连接查询的成本"></a>连接查询的成本</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>连接查询至少是要有两个表的，只有一个single_table 表是不够的，所以为了故事的顺利发展，我们直接构造一个和single_table 表一模一样的single_table2 表。为了简便起见，我们把single_table 表称为s1 表，把single_table2 表称为s2 表。</p><h3 id="Condition-filtering介绍"><a href="#Condition-filtering介绍" class="headerlink" title="Condition filtering介绍"></a>Condition filtering介绍</h3><p>MySQL 中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次</p><p>所以对于两表连接查询来说，它的查询成本由下边两个部分构成</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本 (具体查询多少次取决于对驱动表查询的结果集中有多少条记录)</li></ul><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的扇出（英文名： fanout ）</p><h3 id="两表连接的成本分析"><a href="#两表连接的成本分析" class="headerlink" title="两表连接的成本分析"></a>两表连接的成本分析</h3><p>连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</p><pre><code class="line-numbers language-sql">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2ON s1.key1 = s2.common_fieldWHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 ANDs2.key2 &gt; 1000 AND s2.key2 &lt; 2000;</code></pre><p>对于内连接来说，可以选择的连接顺序有两种：</p><ul><li>s1 连接s2 ，也就是s1 作为驱动表， s2 作为被驱动表。</li><li>s2 连接s1 ，也就是s2 作为驱动表， s1 作为被驱动表。</li></ul><p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。</p><p>定性的分析一下</p><ul><li>使用single_table 作为驱动表时的总成本, 使用s1 作为驱动表的情况<ul><li>分析对于驱动表的成本最低的执行方案<ul><li>看一下涉及s1 表单表的搜索条件有哪些</li></ul></li><li>然后分析对于被驱动表的成本最低的执行方案</li><li>使用idx_key2访问s1的成本 + s1的扇出 × 使用idx_key2访问s2的成本</li></ul></li><li>使用s2 作为驱动表的情况<ul><li>分析对于驱动表的成本最低的执行方案<ul><li>看一下涉及s2 表单表的搜索条件有哪些</li></ul></li><li>然后分析对于被驱动表的成本最低的执行方案</li><li>使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本</li></ul></li><li>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。</li><li>优化重点其实是下边这两个部分<ul><li>尽量减少驱动表的扇出</li><li>对被驱动表的访问成本尽量低</li></ul></li></ul><p><strong>尽量在被驱动表的连接列上建立索引</strong></p><h2 id="多表连接的成本分析"><a href="#多表连接的成本分析" class="headerlink" title="多表连接的成本分析"></a>多表连接的成本分析</h2><p>对于n 表连接的话，则有 n × (n-1) × (n-2) × ··· × 1 种连接顺序，就是n的阶乘种连接顺序，也就是$n!$ 。</p><p>有n 个表进行连接， MySQL 查询优化器要每一种连接顺序的成本都计算一遍,  减少计算非常多种连接顺序的成本的方法</p><h3 id="提前结束某种顺序的成本评估"><a href="#提前结束某种顺序的成本评估" class="headerlink" title="提前结束某种顺序的成本评估"></a>提前结束某种顺序的成本评估</h3><p>在计算各种链接顺序的成本之前，会维护一个全局的变量, 这个变量表示当前最小的连接查询成本。</p><p>MySQL 在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。<br>如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本</p><h3 id="系统变量optimizer-search-depth"><a href="#系统变量optimizer-search-depth" class="headerlink" title="系统变量optimizer_search_depth"></a>系统变量optimizer_search_depth</h3><p>如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与 optimizer_search_depth 值相同数量的表进行穷举分析</p><h3 id="根据某些规则压根儿就不考虑某些连接顺序"><a href="#根据某些规则压根儿就不考虑某些连接顺序" class="headerlink" title="根据某些规则压根儿就不考虑某些连接顺序"></a>根据某些规则压根儿就不考虑某些连接顺序</h3><p>启发式规则  就是根据以往经验指定的一些规则</p><p>凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划</p><p>提供了一个系统变量optimizer_prune_level 来控制到底是不是用这些启发式规则。</p><h2 id="调节成本常数"><a href="#调节成本常数" class="headerlink" title="调节成本常数"></a>调节成本常数</h2><p>两个成本常数：</p><ul><li>读取一个页面花费的成本默认是1.0</li><li>检测一条记录是否符合搜索条件的成本默认是0.2</li></ul><p>其实除了这两个成本常数， MySQL 还支持好多呢，它们被存储到了mysql 数据库</p><p>一条语句的执行其实是分为两层的：</p><ul><li>server 层</li><li>存储引擎层</li></ul><p>在server 层进行连接管理、查询缓存、语法解析、查询优化等操作，<br>在存储引擎层执行具体的数据存取操作。</p><p>关于这些操作对应的成本常数就存储在了server_cost 表中<br>而依赖于存储引擎的一些操作对应的成本常数就存储在了 engine_cost 表中。</p><h3 id="mysql-server-cost表"><a href="#mysql-server-cost表" class="headerlink" title="mysql.server_cost表"></a>mysql.server_cost表</h3><p>server_cost 表中在server 层进行的一些操作对应的<strong>成本常数</strong></p><p><img src="/attachment/edd07cf61391169590ec85d5b73bcdd7.png"></p><ul><li>cost_name<br>表示成本常数的名称。</li><li>cost_value<br>表示成本常数对应的值。如果该列的值为NULL 的话，意味着对应的成本常数会采用默认值。</li><li>last_update<br>表示最后更新记录的时间。</li><li>comment<br>注释。</li></ul><p>从server_cost 中的内容可以看出来，目前在server 层的一些操作对应的成本常数有以下几种</p><p><img src="/attachment/9003480538d207d6f71c5cf562b83054.png"></p><p>MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。</p><p>在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，<br>在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。</p><p>这些成本常数在server_cost 中的初始值都是NULL ，意味着优化器会使用它们的默认值来计算某个操作的成本</p><p>如果我们想修改某个成本常数的值的话，需要做两个步骤：</p><ul><li>对我们感兴趣的成本常数做更新操作</li><li>让系统重新加载这个表的值。</li></ul><pre><code class="line-numbers language-sql">FLUSH OPTIMIZER_COSTS;</code></pre><h3 id="mysql-engine-cost表"><a href="#mysql-engine-cost表" class="headerlink" title="mysql.engine_cost表"></a>mysql.engine_cost表</h3><p>engine_cost表表中在存储引擎层进行的一些操作对应的成本常数</p><p><img src="/attachment/f33176d14ac03c55626dac3402e9008f.png"></p><p>与server_cost 相比， engine_cost 多了两个列：</p><ul><li>engine_name 列  指成本常数适用的存储引擎名称。</li><li>device_type 列  指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在MySQL 5.7.21 这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是0 。</li></ul><p>我们从engine_cost 表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p><p><img src="/attachment/03f6727e70a9aa4c47a0eb0946dc6922.png"></p><p>通过为engine_cost 表插入新记录的方式来添加只针对某种存储引擎的成本常数</p><ul><li>插入针对某个存储引擎的成本常数</li><li>让系统重新加载这个表的值。</li></ul><pre><code class="line-numbers language-sql">FLUSH OPTIMIZER_COSTS;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 连接的原理</title>
      <link href="/database/mysql/mysql-lian-jie-de-yuan-li/"/>
      <url>/database/mysql/mysql-lian-jie-de-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-连接的原理"><a href="#【MySQL】-连接的原理" class="headerlink" title="【MySQL】 连接的原理"></a>【MySQL】 连接的原理</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 连接的原理date: 2023-06-23 13:26tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 连接的原理</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="连接简介："><a href="#连接简介：" class="headerlink" title="连接简介："></a>连接简介：</h3><ul><li>连接的本质是通过<strong>笛卡尔积</strong>将两个表中的记录相互匹配组合。</li><li>连接过程涉及<strong>单表条件</strong>和<strong>涉及两表条件</strong>。</li><li>连接查询的执行过程包括<strong>确定驱动表</strong>和<strong>在驱动表和被驱动表之间查找匹配记录</strong>。</li><li>连接分为<strong>内连接</strong>和<strong>外连接</strong>，内连接<strong>只返回匹配的记录</strong>，而外连接会<strong>包括未匹配的记录</strong>。</li><li>外连接可以进一步细分为<strong>左外连接</strong>和<strong>右外连接</strong>。</li></ul><h3 id="连接的原理总结："><a href="#连接的原理总结：" class="headerlink" title="连接的原理总结："></a>连接的原理总结：</h3><ul><li><strong>嵌套循环连接</strong>是一种连接算法，驱动表<strong>只访问一次</strong>，而被驱动表可能<strong>被多次访问</strong>。</li><li>使用<strong>索引</strong>可以<strong>加快连接速度</strong>。</li><li><strong>基于块的嵌套循环连接</strong>是优化的方法，通过减少被驱动表的访问次数来提高性能。</li><li>基于块的嵌套循环连接使用<strong>join buffer来加载驱动表的记录</strong>，然后一次性和被驱动表的多条记录进行匹配，减少了磁盘访问的开销。<ul><li>执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer 中</li><li>然后开始扫描被驱动表</li><li>每一条<strong>被驱动表</strong>的记录<strong>一次性</strong>和join buffer 中的<strong>多条驱动表记录</strong>做匹配</li><li>因为匹配的过程都是在内存中完成的</li></ul></li><li>基于块的嵌套循环连接也被称为Block Nested-Loop Join算法。</li></ul><p><img src="/attachment/d93fa06115d169691620716bb78a1bfb.png"></p><p><img src="/attachment/39872bfec9f8904fd7b28497b0ae04c1.png"></p><h2 id="连接简介"><a href="#连接简介" class="headerlink" title="连接简介"></a>连接简介</h2><h3 id="连接的本质"><a href="#连接的本质" class="headerlink" title="连接的本质"></a>连接的本质</h3><p><strong>笛卡尔积</strong></p><p>连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合</p><h3 id="连接过程简介"><a href="#连接过程简介" class="headerlink" title="连接过程简介"></a>连接过程简介</h3><ul><li>涉及单表的条件</li><li>涉及两表的条件</li></ul><h4 id="这个连接查询的大致执行过程"><a href="#这个连接查询的大致执行过程" class="headerlink" title="这个连接查询的大致执行过程"></a>这个连接查询的大致执行过程</h4><ol><li>首先确定第一个需要查询的表，这个表称之为驱动表</li><li>针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到t2 表中查找匹配的记录，所谓匹配的记录，指的是符合过滤条件的记录。</li></ol><h3 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h3><ul><li>对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。</li><li>对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。<br>在MySQL 中，根据选取驱动表的不同，外连接仍然可以细分为2种：</li><li>左外连接<ul><li>选取左侧的表为驱动表。</li></ul></li><li>右外连接<ul><li>选取右侧的表为驱动表。</li></ul></li></ul><h4 id="外连接的语法"><a href="#外连接的语法" class="headerlink" title="外连接的语法"></a>外连接的语法</h4><p>对于左（外）连接和右（外）连接来说，必须使用ON 子句来指出连接条件。</p><h4 id="内连接的语法"><a href="#内连接的语法" class="headerlink" title="内连接的语法"></a>内连接的语法</h4><p><strong>内连接和外连接的根本区别</strong></p><p>内连接和外连接的根本区别就是<strong>在驱动表中的记录不符合ON 子句中的连接条件时不会把该记录加入到最后的结果集</strong></p><p>由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句</p><p>对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。</p><p>左外连接和右外连接的驱动表和被驱动表不能轻易互换</p><h2 id="连接的原理"><a href="#连接的原理" class="headerlink" title="连接的原理"></a>连接的原理</h2><h3 id="嵌套循环连接（Nested-Loop-Join）"><a href="#嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="嵌套循环连接（Nested-Loop Join）"></a>嵌套循环连接（Nested-Loop Join）</h3><p>驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数</p><p><img src="/attachment/d93fa06115d169691620716bb78a1bfb.png"></p><h3 id="使用索引加快连接速度"><a href="#使用索引加快连接速度" class="headerlink" title="使用索引加快连接速度"></a>使用索引加快连接速度</h3><h3 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="基于块的嵌套循环连接（Block Nested-Loop Join）"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h3><pre><code class="line-numbers language-ad-question">采用嵌套循环连接算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访</code></pre><p>尽量减少访问被驱动表的次数</p><p>在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了</p><h4 id="join-buffer-的概念"><a href="#join-buffer-的概念" class="headerlink" title="join buffer 的概念"></a>join buffer 的概念</h4><ul><li>执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer 中</li><li>然后开始扫描被驱动表</li><li>每一条被驱动表的记录一次性和join buffer 中的多条驱动表记录做匹配</li><li>因为匹配的过程都是在内存中完成的</li></ul><p><img src="/attachment/39872bfec9f8904fd7b28497b0ae04c1.png"></p><p>这种加入了join buffer 的嵌套循环连接算法称之为基于块的嵌套连接（Block Nested-Loop Join）算法。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 单表访问方法</title>
      <link href="/database/mysql/mysql-dan-biao-fang-wen-fang-fa/"/>
      <url>/database/mysql/mysql-dan-biao-fang-wen-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-单表访问方法"><a href="#【MySQL】-单表访问方法" class="headerlink" title="【MySQL】 单表访问方法"></a>【MySQL】 单表访问方法</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 单表访问方法date: 2023-06-22 23:07tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 单表访问方法</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>MySQL Server使用<strong>查询优化器</strong>对查询语句进行优化，生成执行计划。</li><li>单表查询的访问方法主要有两种：<strong>全表扫描</strong>和<strong>使用索引</strong>。<ul><li>全表扫描通过<strong>逐行扫描表中的记录</strong>来找到符合搜索条件的记录。</li><li>使用索引可以细分为多种类型，如针对主键或唯一二级索引的等值查询、普通二级索引的等值查询、索引列的范围查询和直接扫描整个索引等。<ul><li><strong>const</strong>访问方法是通过<strong>主键</strong>或<strong>唯一二级索引</strong>来定位一条记录，具有<strong>常数级别</strong>的访问代价。</li><li><strong>ref</strong>访问方法适用于<strong>普通二级索引</strong>，其访问代价取决于<strong>等值匹配到的二级索引记录条数</strong>。</li><li><strong>ref_or_null</strong>访问方法是针对<strong>二级索引列值为NULL的情况</strong>。</li><li><strong>range</strong>访问方法用于处理使用<strong>IN操作符</strong>或<strong>范围查询</strong>的情况。</li><li><strong>index</strong>访问方法是直接通过<strong>遍历索引</strong>的叶子节点来执行查询，适用于查询列表只涉及<strong>索引列</strong>且搜索条件<strong>只包含索引中的列</strong>的情况。</li><li><strong>all</strong>访问方法是<strong>全表扫描</strong>的方式执行查询。</li></ul></li></ul></li><li>在使用二级索引进行查询时，需要注意二级索引+回表的操作，回表操作是在找到索引记录后再根据<strong>主键</strong>获取<strong>完整的用户记录</strong>进行进一步过滤。</li><li>对于range访问方法，需要<strong>明确定义范围区间</strong>，利用索引列和常数的比较操作符来构建区间。</li><li>索引合并有<strong>Intersection合并</strong>和<strong>Union合并</strong>两种方式，Intersection合并适用于多个<strong>二级索引的等值匹配</strong>，Union合并适用于<strong>多个二级索引的并集操作</strong>，<strong>Sort-Union合并</strong>用于<strong>多个二级索引查询结果的排序和合并</strong>。</li><li><strong>联合索引</strong>可以替代<strong>Intersection索引合并</strong>的方式。</li></ul><h2 id="【MySQL】-单表访问方法-1"><a href="#【MySQL】-单表访问方法-1" class="headerlink" title="【MySQL】 单表访问方法"></a>【MySQL】 单表访问方法</h2><p>MySQL Server 有一个称为查询优化器的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的执行计划</p><h2 id="访问方法（access-method）的概念"><a href="#访问方法（access-method）的概念" class="headerlink" title="访问方法（access method）的概念"></a>访问方法（access method）的概念</h2><p>对于单个表的查询来说，设计MySQL的大叔把查询的执行方式大致分为下边两种：</p><h3 id="使用全表扫描进行查询"><a href="#使用全表扫描进行查询" class="headerlink" title="使用全表扫描进行查询"></a>使用全表扫描进行查询</h3><p>把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。</p><h3 id="使用索引进行查询"><a href="#使用索引进行查询" class="headerlink" title="使用索引进行查询"></a>使用索引进行查询</h3><p>使用索引来执行查询的方式五花八门，又可以细分为许多种类：</p><ul><li>针对主键或唯一二级索引的等值查询</li><li>针对普通二级索引的等值查询</li><li>针对索引列的范围查询</li><li>直接扫描整个索引</li></ul><p>MySQL 执行查询语句的方式称之为访问方法或者访问类型</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><pre><code class="line-numbers language-sql">SELECT * FROM single_table WHERE id = 1438;</code></pre><pre><code class="line-numbers language-sql">SELECT * FROM single_table WHERE key2 = 3841;</code></pre><pre><code class="line-numbers language-sql">SELECT * FROM single_table WHERE key2 IS NULL;</code></pre><ul><li><strong>聚簇索引</strong></li><li><strong>唯一二级索引</strong></li></ul><p><img src="/attachment/a3fefae543a2f483ea40fe628cebc6cb.png"></p><p>B+ 树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的B+ 树叶子节点中的记录就是按照id 列排序的。</p><p>把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为： const ，意思是常数级别的，代价是可以忽略不计的</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><pre><code class="line-numbers language-sql">SELECT * FROM single_table WHERE key1 = 'abc';</code></pre><p><strong>普通的二级索引</strong></p><p><img src="/attachment/effbdcf15338511e7ba11bae78d0fd45.png"></p><p>使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数</p><ul><li>二级索引列值为NULL 的情况</li></ul><p>采用key IS NULL 这种形式的搜索条件最多只能使用ref 的访问方法，而不是const 的访问方法。</p><p>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用ref的访问方法</p><h2 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h2><pre><code class="line-numbers language-sql">SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;</code></pre><p><img src="/attachment/5b912954932cdcdd69aaba1da5ef1eca.png"></p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><pre><code class="line-numbers language-sql">SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79);</code></pre><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><pre><code class="line-numbers language-sql">SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';</code></pre><p>这个查询符合下边这两个条件：</p><ul><li>它的查询列表只有3个列： key_part1 , key_part2 , key_part3 ，而索引idx_key_part 又包含这三个列。</li><li>搜索条件中只有key_part2 列。这个列也包含在索引idx_key_part 中。</li></ul><p>可以直接通过遍历idx_key_part 索引的叶子节点的记录来比较key_part2 = ‘abc’ 这个条件是否成立</p><p>把匹配成功的二级索引记录的key_part1 , key_part2 , key_part3 列的值直接加到结果集中就行了。</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>全表扫描执行查询的方式称之为： all 。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="重温-二级索引-回表"><a href="#重温-二级索引-回表" class="headerlink" title="重温 二级索引 + 回表"></a>重温 二级索引 + 回表</h3><p>因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用idx_key1 索引进行查询时只会用到与key1 列有关的搜索条件，其余条件，比如key2 &gt; 1000 这个条件在步骤1中是用不到的，只有在步骤2完成<strong>回表操作后</strong>才能继续针对完整的用户记录中继续过滤。</p><h3 id="明确range访问方法使用的范围区间"><a href="#明确range访问方法使用的范围区间" class="headerlink" title="明确range访问方法使用的范围区间"></a>明确range访问方法使用的范围区间</h3><p>其实对于B+ 树索引来说，只要索引列和常数使用= 、&lt;=&gt; 、IN 、NOT IN 、IS NULL 、IS NOT NULL 、&gt; 、&lt; 、&gt;= 、&lt;= 、BETWEEN 、!= （不等于也可以写成&lt;&gt; ）或者LIKE 操作符连接起来，就可以产生一个所谓的区间。</p><h3 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h3><h4 id="Intersection合并"><a href="#Intersection合并" class="headerlink" title="Intersection合并"></a>Intersection合并</h4><p>在二级索引列都是等值匹配的情况下才可能使用Intersection 索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。</p><p><strong>读取多个二级索引后取交集</strong></p><h4 id="Union合并"><a href="#Union合并" class="headerlink" title="Union合并"></a>Union合并</h4><p><strong>读取多个二级索引后取集</strong></p><p>采用Union 索引合并的方式把 Or 连接的两个主键集合取并集，然后进行回表操作，将结果返回给用户。</p><pre><code class="line-numbers language-sql">SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');</code></pre><ul><li>先按照搜索条件key1 = ‘a’ AND key3 = ‘b’ 从索引idx_key1 和idx_key3 中使用Intersection 索引合并的方式得到一个主键集合。</li><li>再按照搜索条件key_part1 = ‘a’ AND key_part2 = ‘b’ AND key_part3 = ‘c’ 从联合索引idx_key_part 中得到另一个主键集合。</li><li>采用Union 索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li></ul><h4 id="Sort-Union合并"><a href="#Sort-Union合并" class="headerlink" title="Sort-Union合并"></a>Sort-Union合并</h4><p><strong>读取多个二级索引后对结果按主键排序并返回合并</strong></p><pre><code class="line-numbers language-sql">SELECT * FROM single_table WHERE key1 &lt; 'a' OR key3 &gt; 'z'</code></pre><ul><li>先根据key1 &lt; ‘a’ 条件从idx_key1 二级索引总获取记录，并按照记录的主键值进行排序</li><li>再根据key3 &gt; ‘z’ 条件从idx_key3 二级索引总获取记录，并按照记录的主键值进行排序</li><li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和Union 索引合并方式就一样了。</li></ul><h4 id="联合索引替代Intersection索引合并"><a href="#联合索引替代Intersection索引合并" class="headerlink" title="联合索引替代Intersection索引合并"></a>联合索引替代Intersection索引合并</h4>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB的表空间</title>
      <link href="/database/mysql/mysql-innodb-de-biao-kong-jian/"/>
      <url>/database/mysql/mysql-innodb-de-biao-kong-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-InnoDB的表空间"><a href="#【MySQL】-InnoDB的表空间" class="headerlink" title="【MySQL】 InnoDB的表空间"></a>【MySQL】 InnoDB的表空间</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 InnoDB的表空间date: 2023-06-22 05:36tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 InnoDB的表空间</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/58b87e5bda10eaf0599a9f58b8bf8ba3.png"></p><h3 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h3><ol><li><strong>区</strong>: 连续的<strong>64</strong>个页就是一个区，也就是说一个区默认占用1MB空间大小。每<strong>256</strong>个区被划分成一组。<ul><li>第一个组最开始的3个页面的类型是固定的，也就是说extent 0 这个区最开始的3个页面的类型是固定的，分别是：<ul><li><strong>FSP_HDR</strong> 类型: 这个类型的页面是用来登记<strong>整个表空间的一些整体属性以及本组所有的区</strong>，也就是extent 0 ~ extent 255 这256个区的属性</li><li><strong>IBUF_BITMAP</strong> 类型: 这个类型的页面是存储本组所有的区的所有页面关于<strong>INSERT BUFFER 的信息</strong>。</li><li><strong>INODE</strong> 类型: 这个类型的页面存储了许多称为INODE 的数据结构</li></ul></li><li>其余各组最开始的2个页面的类型是固定的，也就是说extent 256 、extent 512 这些区最开始的2个页面的类型是固定的，分别是：<ul><li><strong>XDES 类型</strong>: 全称是extent descriptor ，用来登记<strong>本组256个区的属性</strong>，对于在extent 256区中的该类型页面存储的就是extent 256 ~ extent 511 这些区的属性</li><li><strong>IBUF_BITMAP</strong> 类型： 这个类型的页面是存储本组所有的区的所有页面关于<strong>INSERT BUFFER 的信息</strong>。</li></ul></li></ul></li><li><strong>段</strong>: 一个索引会生成<strong>2</strong>个段，一个叶子节点段，一个非叶子节点段。 定义了一个INODE Entry 结构来记录一下段中的属性<ul><li><strong>Segment ID</strong>  这个INODE Entry 结构对应的<strong>段的编号</strong>（ID）</li><li><strong>NOT_FULL_N_USED</strong> 是在<strong>NOT_FULL 链表中已经使用了多少个页面</strong>。下次从NOT_FULL 链表分配空闲页面时可以直接根据这个字段的值定位到。</li><li><strong>3个List Base Node</strong> 分别为段的<strong>FREE 链表</strong>、<strong>NOT_FULL 链表</strong>、<strong>FULL 链表定义了List Base Node</strong></li><li><strong>Magic Number</strong> 用来标记这个INODE Entry <strong>是否已经被初始化</strong>了</li><li><strong>Fragment Array Entry</strong> 每个Fragment Array Entry 结构都对应着一个零散的页面，这个结构一共4个字节，<strong>表示一个零散页面的页号</strong>。</li></ul></li><li><strong>碎片（fragment）区</strong> 有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于</li><li>区的分类<ul><li><strong>FREE</strong> <strong>空闲的区</strong></li><li><strong>FREE_FRAG</strong> **有剩余空间的碎片区</li><li><strong>FULL_FRAG</strong> <strong>没有剩余空间的碎片区</strong></li><li><strong>FSEG</strong> <strong>附属于某个段的区</strong></li></ul></li><li>XDES Entry  是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：<ul><li>Segment ID （8字节） 每一个段都有一个唯一的编号，用ID表示，此处的Segment ID 字段表示就是该区所在的段。</li><li>List Node （12字节） 这个部分可以将若干个XDES Entry 结构串联成一个链表</li><li>State （4字节）这个字段表明区的状态。</li><li>Page State Bitmap （16字节） 一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。</li></ul></li><li>链表基节点  每个链表都对应这么一个List Base Node 结构<ul><li>List Length 表明该链表一共有多少节点，</li><li>First Node Page Number 和First Node Offset 表明该链表的头节点在表空间中的位置。</li><li>Last Node Page Number 和Last Node Offset 表明该链表的尾节点在表空间中的位置。</li></ul></li></ol><h3 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h3><ol><li>系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面<ul><li>某个表属于哪个表空间，表里边有多少列</li><li>表对应的每一个列的类型是什么</li><li>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li><li>该表有哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li><li>balabala … 还有好多，不一一列举了</li></ul></li><li>SYS_TABLES表</li><li>SYS_COLUMNS表</li><li>SYS_FIELDS表</li><li>Data Dictionary Header页面<ol><li>Max Row ID: 我们生成一个名为row_id 的列作为主键，这个Max Row ID 是全局共享的</li><li>Max Table ID: InnoDB存储引擎中的所有的索引都对应一个唯一的ID</li><li>Max Space ID: InnoDB存储引擎中的所有的表空间都对应一个唯一的ID</li><li>Root of SYS_TABLES clust index ：本字段代表SYS_TABLES 表聚簇索引的根页面的页号。</li><li>Root of SYS_TABLE_IDS sec index ：本字段代表SYS_TABLES 表为ID 列建立的二级索引的根页面的页号。</li><li>Root of SYS_COLUMNS clust index ：本字段代表SYS_COLUMNS 表聚簇索引的根页面的页号。</li><li>Root of SYS_INDEXES clust index： 本字段代表SYS_INDEXES 表聚簇索引的根页面的页号。</li><li>Root of SYS_FIELDS clust index ： 本字段代表SYS_FIELDS 表聚簇索引的根页面的页号。</li></ol></li></ol><h2 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h2><h3 id="区（extent）的概念"><a href="#区（extent）的概念" class="headerlink" title="区（extent）的概念"></a>区（extent）的概念</h3><p>对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小。</p><p>每256个区被划分成一组。</p><p><img src="/attachment/7826e02e37b4826849c68183be4516f3.png"></p><p>第一个组最开始的3个页面的类型是固定的，也就是说extent 0 这个区最开始的3个页面的类型是固定的，分别是：</p><ul><li>FSP_HDR 类型: 这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区，也就是extent 0 ~ extent 255 这256个区的属性</li><li>IBUF_BITMAP 类型: 这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER 的信息。</li><li>INODE 类型: 这个类型的页面存储了许多称为INODE 的数据结构</li></ul><p>其余各组最开始的2个页面的类型是固定的，也就是说extent 256 、extent 512 这些区最开始的2个页面的类型是固定的，分别是：</p><ul><li>XDES 类型: 全称是extent descriptor ，用来登记本组256个区的属性，对于在extent 256区中的该类型页面存储的就是extent 256 ~ extent 511 这些区的属性</li><li>IBUF_BITMAP 类型： 这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER 的信息。</li></ul><h3 id="段（segment）的概念"><a href="#段（segment）的概念" class="headerlink" title="段（segment）的概念"></a>段（segment）的概念</h3><p>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。</p><p>叶子节点有自己独有的区，非叶子节点也有自己独有的区。</p><p>存放叶子节点的区的集合就算是一个段（ segment ），存放非叶子节点的区的集合也算是一个段。</p><p>说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><p>为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况</p><p>设计InnoDB 的大叔们提出了一个碎片（fragment）区的概念</p><p>在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于</p><p>碎片区直属于表空间，并不属于任何一个段。</p><p>此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。</li></ul><h3 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h3><ul><li>FREE 空闲的区: 现在还没有用到这个区中的任何页面。</li><li>FREE_FRAG 有剩余空间的碎片区: 表示碎片区中还有可用的页面。</li><li>FULL_FRAG 没有剩余空间的碎片区: 表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>FSEG 附属于某个段的区: 每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li></ul><p>这4种类型的区也可以被称为区的4种状态（ State ）</p><p>处于FREE 、FREE_FRAG 以及FULL_FRAG 这三种状态的区都是独立的，算是直属于表空间；而处于FSEG 状态的区是附属于某个段的。</p><p>为了方便管理这些区，设计InnoDB 的大叔设计了一个称为XDES Entry 的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个XDES Entry 结构</p><p><img src="/attachment/7adf50f3da76f6069a9c7045ea3d4f70.png"></p><p>XDES Entry 是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：</p><ul><li>Segment ID （8字节）<br>每一个段都有一个唯一的编号，用ID表示，此处的Segment ID 字段表示就是该区所在的段。</li><li>List Node （12字节）<br>这个部分可以将若干个XDES Entry 结构串联成一个链表</li><li>State （4字节）<br>这个字段表明区的状态。</li><li>Page State Bitmap （16字节）<br>一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。</li></ul><h4 id="XDES-Entry链表"><a href="#XDES-Entry链表" class="headerlink" title="XDES Entry链表"></a>XDES Entry链表</h4><ul><li>当段中数据较少的时候，会进行以下操作：<ul><li>首先查看表空间中是否有状态为FREE_FRAG的区；</li><li>如果找到了FREE_FRAG的区，从该区中取一些零碎的页，将数据插入其中；</li><li>如果没有找到FREE_FRAG的区，则在表空间下申请一个状态为FREE的区；</li><li>将新申请的区的状态变为FREE_FRAG，并从该区中取一些零碎的页，将数据插入其中。</li></ul></li><li>不同的段在使用零碎页的时候，都会从上述区中取；</li><li>直到该区中没有空闲空间，该区的状态变为FULL_FRAG。</li></ul><p><strong>ListNode 的作用</strong></p><ul><li>把状态为FREE的区对应的XDESEntry结构通过ListNode来连接成一个链表，这个链表我们就称之为FREE链表。</li><li>把状态为FREE_FRAG的区对应的XDESEntry结构通过ListNode来连接成一个链表，这个链表我们就称之为FREE_FRAG链表。</li><li>把状态为FULL_FRAG的区对应的XDESEntry结构通过ListNode来连接成一个链表，这个链表我们就称之为FULL_FRAG链表。</li></ul><p>为每个段中的区对应的XDES Entry 结构建立了三个链表：</p><ul><li>FREE 链表：同一个段中，所有页面都是空闲的区对应的XDES Entry 结构会被加入到这个链表。注意和直属于表空间的FREE 链表区别开了，此处的FREE 链表是附属于某个段的。</li><li>NOT_FULL 链表：同一个段中，仍有空闲空间的区对应的XDES Entry 结构会被加入到这个链表。</li><li>FULL 链表：同一个段中，已经没有空闲空间的区对应的XDES Entry 结构会被加入到这个链表。</li></ul><p><strong>每一个索引都对应两个段，每个段都会维护上述的3个链表</strong></p><p><strong>链表基节点</strong></p><p>这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息</p><p><img src="/attachment/c31d0bbe7b1eccc674b804560f2bca85.png"></p><p>每个链表都对应这么一个List Base Node 结构</p><ul><li>List Length 表明该链表一共有多少节点，</li><li>First Node Page Number 和First Node Offset 表明该链表的头节点在表空间中的位置。</li><li>Last Node Page Number 和Last Node Offset 表明该链表的尾节点在表空间中的位置。</li></ul><h3 id="段的结构"><a href="#段的结构" class="headerlink" title="段的结构"></a>段的结构</h3><p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念</p><p>定义了一个INODE Entry 结构来记录一下段中的属性</p><p><img src="/attachment/6c02f38231695f30338aa4ba235bce89.png"></p><ul><li>Segment ID<br>这个INODE Entry 结构对应的段的编号（ID）</li><li>NOT_FULL_N_USED<br>是在NOT_FULL 链表中已经使用了多少个页面。<br>下次从NOT_FULL 链表分配空闲页面时可以直接根据这个字段的值定位到。</li><li>3个List Base Node<br>分别为段的FREE 链表、NOT_FULL 链表、FULL 链表定义了List Base Node</li><li>Magic Number<br>用来标记这个INODE Entry 是否已经被初始化了</li><li>Fragment Array Entry<br>每个Fragment Array Entry 结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号。</li></ul><h3 id="各类型页面详细情况"><a href="#各类型页面详细情况" class="headerlink" title="各类型页面详细情况"></a>各类型页面详细情况</h3><h4 id="FSP-HDR-类型"><a href="#FSP-HDR-类型" class="headerlink" title="FSP_HDR 类型"></a>FSP_HDR 类型</h4><p>表空间的第一个页面，页号为0 。这个页面的类型是FSP_HDR</p><p>存储了表空间的一些整体属性以及第一个组内256个区的对应的XDES Entry 结构</p><p><img src="/attachment/ec35f4f158da1a180071733a659d37cd.png"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38 字节</td><td>页的一些通用信息</td></tr><tr><td>File Space Header</td><td>表空间头部</td><td>112字节</td><td>表空间的一些整体属性信息</td></tr><tr><td>XDES Entry</td><td>区描述信息</td><td>10240字节</td><td>存储本组256个区对应的属性信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>5986字节</td><td>“用于页结构的填充,没啥实际意义”</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><h5 id="File-Space-Header部分"><a href="#File-Space-Header部分" class="headerlink" title="File Space Header部分"></a>File Space Header部分</h5><p>用来存储表空间的一些整体属性的</p><p><img src="/attachment/88af70ee1666e4a9704abb4445e38d34.png"></p><table><thead><tr><th>占用空间大小</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Space ID</td><td>4 字节</td><td>表空间的ID</td></tr><tr><td>Not Used</td><td>4字节</td><td>“这4个字节未被使用,可以忽略”</td></tr><tr><td>Size</td><td>4字节</td><td>当前表空间占有的页面数</td></tr><tr><td>FREE Limit</td><td>4字节</td><td>“尚未被初始化的最小页号,大于或等于这个页号的区对应的XDES Entry结构都 没有被加入FREE链表”</td></tr><tr><td>Space Flags</td><td>4字节</td><td>表空间的一些占用存储空间比较小的属性</td></tr><tr><td>FRAG_N_USED</td><td>4字节</td><td>FREE_FRAG链表中已使用的页面数量</td></tr><tr><td>List Base Node for FREE List</td><td>16字节</td><td>FREE链表的基节点</td></tr><tr><td>List Base Node for FREE_FRAG List</td><td>16 字节</td><td>FREE_FREG链表的基节点</td></tr><tr><td>List Base Node for FULL_FRAG List</td><td>16 字节</td><td>FULL_FREG链表的基节点</td></tr><tr><td>Next Unused Segment ID</td><td>8字节</td><td>当前表空间中下一个未使用的 Segment ID</td></tr><tr><td>List Base Node for SEG_INODES_FULL List</td><td>16 字节</td><td>SEG_INODES_FULL链表的基节点</td></tr><tr><td>List Base Node for SEG_INODES_FREE List</td><td>16 字节</td><td>SEG_INODES_FREE链表的基节点</td></tr></tbody></table><h4 id="XDES-Entry部分"><a href="#XDES-Entry部分" class="headerlink" title="XDES Entry部分"></a>XDES Entry部分</h4><p>每一个XDES Entry 结构对应表空间的一个区</p><p>每组开头的一个页面记录着本组内所有的区对应的XDES Entry 结构。</p><p>整个表空间的第一个页面，记录本组中的所有区对应的XDES Entry 结构以外，还记录着表空间的一些整体属性，这个页面的类型就是我们刚刚说完的FSP_HDR 类型，整个表空间里只有一个这个类型的页面</p><p>除去第一个分组以外，之后的每个分组的第一个页面只需要记录本组内所有的区对应的XDES Entry 结构即可</p><p><img src="/attachment/4d0015af51df048b598e73f8a207ef35.png"></p><h4 id="IBUF-BITMAP-类型"><a href="#IBUF-BITMAP-类型" class="headerlink" title="IBUF_BITMAP 类型"></a>IBUF_BITMAP 类型</h4><p>每个分组的第二个页面的类型都是IBUF_BITMAP</p><p>这种类型的页里边记录了一些有关Change Buffer 的东东</p><h4 id="INODE-类型"><a href="#INODE-类型" class="headerlink" title="INODE 类型"></a>INODE 类型</h4><p>第一个分组的第三个页面的类型是INODE</p><p>为了方便管理，他们又为每个段设计了一个INODE Entry 结构，这个结构中记录了关于这个段的相关属性。</p><p>undefined</p><p>从图中可以看出，一个INODE 类型的页面是由这几部分构成的：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38 字节</td><td>页的一些通用信息</td></tr><tr><td>List Node for INODE Page List</td><td>通用链表节点</td><td>12字节</td><td>存储上一个INODE页面和下一个INODE页面的指针</td></tr><tr><td>INODE Entry</td><td>段描述信息</td><td>16128 字节</td><td></td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>6字节</td><td>“用于页结构的填充,没啥实际意义”</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><ul><li>SEG_INODES_FULL 链表<br>该链表中的INODE 类型的页面中已经没有空闲空间来存储额外的INODE Entry 结构了。</li><li>SEG_INODES_FREE 链表<br>该链表中的INODE 类型的页面中还有空闲空间来存储额外的INODE Entry 结构了。</li></ul><p>每当我们新创建一个段（创建索引时就会创建段）时，都会创建一个INODE Entry 结构与之对应，存储INODE Entry 的大致过程就是这样的：</p><ul><li>先看看SEG_INODES_FREE 链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的INODE 类型的页面，然后把该INODE Entry 结构防到该页面中。当该页面中无剩余空间时，就把该页放到SEG_INODES_FULL 链表中。</li><li>如果SEG_INODES_FREE 链表为空，则需要从表空间的FREE_FRAG 链表中申请一个页面，修改该页面的类型为INODE ，把该页面放到SEG_INODES_FREE 链表中，与此同时把该INODE Entry 结构放入该页面。</li></ul><h3 id="Segment-Header-结构的运用"><a href="#Segment-Header-结构的运用" class="headerlink" title="Segment Header 结构的运用"></a>Segment Header 结构的运用</h3><p><img src="/attachment/cf2886d6e955e46601662f5555432d0a.png"></p><p>其中的PAGE_BTR_SEG_LEAF 和PAGE_BTR_SEG_TOP 都占用10个字节，它们其实对应一个叫Segment Header 的结构，该结构图示如下：</p><p><img src="/attachment/cad75f83be354bc4960254cc7d86585e.png"></p><p><img src="/attachment/f0b5af1dd75ed98ca0a9dd7b267c8de5.png"></p><h2 id="系统表空间-1"><a href="#系统表空间-1" class="headerlink" title="系统表空间"></a>系统表空间</h2><h3 id="系统表空间的整体结构"><a href="#系统表空间的整体结构" class="headerlink" title="系统表空间的整体结构"></a>系统表空间的整体结构</h3><p>系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面</p><p><img src="/attachment/2306403ee0ed146539c0dbe329a92ada.png"></p><p><img src="/attachment/d175479644e7e8e81d3803c9154c1f74.png"></p><h4 id="InnoDB数据字典"><a href="#InnoDB数据字典" class="headerlink" title="InnoDB数据字典"></a>InnoDB数据字典</h4><p>MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息</p><ul><li>某个表属于哪个表空间，表里边有多少列</li><li>表对应的每一个列的类型是什么</li><li>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li><li>该表有哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li><li>balabala … 还有好多，不一一列举了</li></ul><p>为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为元数据</p><p>InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些元数据：</p><p><img src="/attachment/445f3431f591b892d0cf687c5bd94bcd.png"></p><p>这些系统表也被称为数据字典，它们都是以B+ 树的形式保存在系统表空间的某些页面</p><h5 id="SYS-TABLES表"><a href="#SYS-TABLES表" class="headerlink" title="SYS_TABLES表"></a>SYS_TABLES表</h5><p><img src="/attachment/bf7a562b1d38b08e9fbca21758846d39.png"></p><p>这个SYS_TABLES 表有两个索引</p><ul><li>以NAME 列为主键的聚簇索引</li><li>以ID 列建立的二级索引</li></ul><h5 id="SYS-COLUMNS表"><a href="#SYS-COLUMNS表" class="headerlink" title="SYS_COLUMNS表"></a>SYS_COLUMNS表</h5><p><img src="/attachment/bd4d295084678e8102e2d823577771fa.png"><br><img src="/attachment/c253da09781dc1ef2563f29cdd421265.png"></p><h5 id="SYS-FIELDS表"><a href="#SYS-FIELDS表" class="headerlink" title="SYS_FIELDS表"></a>SYS_FIELDS表</h5><p><img src="/attachment/145baea6638cb72ba441953fe55f639c.png"></p><h5 id="Data-Dictionary-Header页面"><a href="#Data-Dictionary-Header页面" class="headerlink" title="Data Dictionary Header页面"></a>Data Dictionary Header页面</h5><p><img src="/attachment/6c85e8f3959cfbf84213dfa84a6e5323.png"></p><ul><li>Max Row ID:</li></ul><p>如果我们不显式的为表定义主键，而且表中也没有UNIQUE 索引<br>InnoDB 存储引擎会默认为我们生成一个名为row_id 的列作为主键。</p><p>不论哪个拥有row_id 列的表插入一条记录时，该记录的row_id 列的值就是Max Row ID 对应的值，然后再把Max Row ID 对应的值加1，也就是说这个Max Row ID 是全局共享的。</p><ul><li>Max Table ID</li></ul><p>InnoDB存储引擎中的所有的表都对应一个唯一的ID<br>每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。</p><ul><li>Max Index ID</li></ul><p>InnoDB存储引擎中的所有的索引都对应一个唯一的ID<br>每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。</p><ul><li>Max Space ID</li></ul><p>InnoDB存储引擎中的所有的表空间都对应一个唯一的ID<br>每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。</p><ul><li>Root of SYS_TABLES clust index ：</li></ul><p>本字段代表SYS_TABLES 表聚簇索引的根页面的页号。</p><ul><li>Root of SYS_TABLE_IDS sec index ：</li></ul><p>本字段代表SYS_TABLES 表为ID 列建立的二级索引的根页面的页号。</p><ul><li>Root of SYS_COLUMNS clust index ：</li></ul><p>本字段代表SYS_COLUMNS 表聚簇索引的根页面的页号。</p><ul><li>Root of SYS_INDEXES clust index</li></ul><p>本字段代表SYS_INDEXES 表聚簇索引的根页面的页号。</p><ul><li>Root of SYS_FIELDS clust index</li></ul><p>本字段代表SYS_FIELDS 表聚簇索引的根页面的页号。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/database/db-sql/db-sql/"/>
      <url>/database/db-sql/db-sql/</url>
      
        <content type="html"><![CDATA[<h1 id="DB-SQL-Overview"><a href="#DB-SQL-Overview" class="headerlink" title="DB SQL Overview"></a>DB SQL Overview</h1><pre><code class="line-numbers language-ccard">type: folder_brief_livestyle: stripnoteOnly: true</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/database/mongodb/mongodb/"/>
      <url>/database/mongodb/mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-Overview"><a href="#MongoDB-Overview" class="headerlink" title="MongoDB Overview"></a>MongoDB Overview</h1><pre><code class="line-numbers language-ccard">type: folder_brief_livestyle: stripnoteOnly: true</code></pre><h2 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h2><p><img src="/attachment%5Ce07d7cf8dddf07f87d2c3eb506345ef8.png"></p><h2 id="MongoDB生态"><a href="#MongoDB生态" class="headerlink" title="MongoDB生态"></a>MongoDB生态</h2><p><img src="/attachment%5C0face0d5be5fc99622615abfaaa99120.png"></p><p><img src="/attachment%5Cf93af37338bd72e59606ca5b525c75c8.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数接口 Function</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-function/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-function/</url>
      
        <content type="html"><![CDATA[<h1 id="函数接口-Function"><a href="#函数接口-Function" class="headerlink" title="函数接口 Function"></a>函数接口 Function</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 函数接口 Functiondate: 2023-02-21 10:52tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: java.util.function.Function  接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</code></pre><h2 id="函数接口-Function-1"><a href="#函数接口-Function-1" class="headerlink" title="函数接口 Function"></a>函数接口 Function</h2><p><code>java.util.function.Function&lt;T,R&gt;</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p><pre><code class="line-numbers language-java">package java.util.function;import java.util.Objects;/** * Represents a function that accepts one argument and produces a result. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is {@link #apply(Object)}. * * @param &lt;T&gt; the type of the input to the function * @param &lt;R&gt; the type of the result of the function * * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; {    /**     * Applies this function to the given argument.     *     * @param t the function argument     * @return the function result     */    R apply(T t);    /**     * Returns a composed function that first applies the {@code before}     * function to its input, and then applies this function to the result.     * If evaluation of either function throws an exception, it is relayed to     * the caller of the composed function.     *     * @param &lt;V&gt; the type of input to the {@code before} function, and to the     *           composed function     * @param before the function to apply before this function is applied     * @return a composed function that first applies the {@code before}     * function and then applies this function     * @throws NullPointerException if before is null     *     * @see #andThen(Function)     */    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {        Objects.requireNonNull(before);        return (V v) -&gt; apply(before.apply(v));    }    /**     * Returns a composed function that first applies this function to     * its input, and then applies the {@code after} function to the result.     * If evaluation of either function throws an exception, it is relayed to     * the caller of the composed function.     *     * @param &lt;V&gt; the type of output of the {@code after} function, and of the     *           composed function     * @param after the function to apply after this function is applied     * @return a composed function that first applies this function and then     * applies the {@code after} function     * @throws NullPointerException if after is null     *     * @see #compose(Function)     */    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; after.apply(apply(t));    }    /**     * Returns a function that always returns its input argument.     *     * @param &lt;T&gt; the type of the input and output objects to the function     * @return a function that always returns its input argument     */    static &lt;T&gt; Function&lt;T, T&gt; identity() {        return t -&gt; t;    }}</code></pre><h3 id="抽象方法-apply"><a href="#抽象方法-apply" class="headerlink" title="抽象方法:apply"></a>抽象方法:apply</h3><p>Function 接口中最主要的抽象方法为: <code>R apply(T t) </code>，根据类型T的参数获取类型R的结果。 使用的场景例如:将 String 类型转换为 Integer 类型。</p><pre><code class="line-numbers language-java">public class Demo {    private static void method(Function&lt;String, Integer&gt; function) {        int num = function.apply("10");        System.out.println(num + 20);    }    public static void main(String[] args) {        method(s -&gt; Integer.parseInt(s));    }}</code></pre><p>当然，最好是通过方法引用的写法。</p><h3 id="默认方法-andThen"><a href="#默认方法-andThen" class="headerlink" title="默认方法:andThen"></a>默认方法:andThen</h3><p>Function 接口中有一个默认的 andThen 方法，用来进行组合操作。</p><p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多:</p><pre><code class="line-numbers language-java">public class Demo {    private static void method(Function&lt;String, Integer&gt; one,                               Function&lt;Integer, Integer&gt; two) {        int num = one.andThen(two).apply("10");        System.out.println(num + 20);    }    public static void main(String[] args) {        method(str -&gt; Integer.parseInt(str) + 10, i -&gt; i *= 10);    }}</code></pre><p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。</p><p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p><h2 id="自定义函数模型拼接"><a href="#自定义函数模型拼接" class="headerlink" title="自定义函数模型拼接"></a>自定义函数模型拼接</h2><p>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为:</p><ul><li>String str = “张二三,20”</li><li>将字符串截取数字年龄部分，得到字符串;</li><li>将上一步的字符串转换成为int类型的数字;</li><li>将上一步的int数字累加10，得到结果int数字。</li></ul><pre><code class="line-numbers language-java">public class Demo {    public static void main(String[] args) {        String str = "张二三,20";        int age = getAgeNum(str, s -&gt; s.split(",")[1],                s -&gt; Integer.parseInt(s),                n -&gt; n += 100);        System.out.println(age);    }    private static int getAgeNum(String str, Function&lt;String, String&gt; one,                                 Function&lt;String, Integer&gt; two,                                 Function&lt;Integer, Integer&gt; three) {        return one.andThen(two).andThen(three).apply(str);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数接口 Predicate</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-predicate/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-predicate/</url>
      
        <content type="html"><![CDATA[<h1 id="函数接口-Predicate"><a href="#函数接口-Predicate" class="headerlink" title="函数接口 Predicate"></a>函数接口 Predicate</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 函数接口 Predicatedate: 2023-02-21 10:47tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: 有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 java.util.function.Predicate  接口。</code></pre><h2 id="函数接口-Predicate-1"><a href="#函数接口-Predicate-1" class="headerlink" title="函数接口 Predicate"></a>函数接口 Predicate</h2><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code> 接口。接口定义如下：</p><pre><code class="line-numbers language-java">package java.util.function;import java.util.Objects;/** * Represents a predicate (boolean-valued function) of one argument. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is {@link #test(Object)}. * * @param &lt;T&gt; the type of the input to the predicate * * @since 1.8 */@FunctionalInterfacepublic interface Predicate&lt;T&gt; {    /**     * Evaluates this predicate on the given argument.     *     * @param t the input argument     * @return {@code true} if the input argument matches the predicate,     * otherwise {@code false}     */    boolean test(T t);    /**     * Returns a composed predicate that represents a short-circuiting logical     * AND of this predicate and another.  When evaluating the composed     * predicate, if this predicate is {@code false}, then the {@code other}     * predicate is not evaluated.     *     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed     * to the caller; if evaluation of this predicate throws an exception, the     * {@code other} predicate will not be evaluated.     *     * @param other a predicate that will be logically-ANDed with this     *              predicate     * @return a composed predicate that represents the short-circuiting logical     * AND of this predicate and the {@code other} predicate     * @throws NullPointerException if other is null     */    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {        Objects.requireNonNull(other);        return (t) -&gt; test(t) &amp;&amp; other.test(t);    }    /**     * Returns a predicate that represents the logical negation of this     * predicate.     *     * @return a predicate that represents the logical negation of this     * predicate     */    default Predicate&lt;T&gt; negate() {        return (t) -&gt; !test(t);    }    /**     * Returns a composed predicate that represents a short-circuiting logical     * OR of this predicate and another.  When evaluating the composed     * predicate, if this predicate is {@code true}, then the {@code other}     * predicate is not evaluated.     *     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed     * to the caller; if evaluation of this predicate throws an exception, the     * {@code other} predicate will not be evaluated.     *     * @param other a predicate that will be logically-ORed with this     *              predicate     * @return a composed predicate that represents the short-circuiting logical     * OR of this predicate and the {@code other} predicate     * @throws NullPointerException if other is null     */    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {        Objects.requireNonNull(other);        return (t) -&gt; test(t) || other.test(t);    }    /**     * Returns a predicate that tests if two arguments are equal according     * to {@link Objects#equals(Object, Object)}.     *     * @param &lt;T&gt; the type of arguments to the predicate     * @param targetRef the object reference with which to compare for equality,     *               which may be {@code null}     * @return a predicate that tests if two arguments are equal according     * to {@link Objects#equals(Object, Object)}     */    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) {        return (null == targetRef)                ? Objects::isNull                : object -&gt; targetRef.equals(object);    }}</code></pre><h3 id="抽象方法-test"><a href="#抽象方法-test" class="headerlink" title="抽象方法:test"></a>抽象方法:test</h3><p>Predicate 接口中包含一个抽象方法: boolean test(T t) 。用于条件判断的场景:</p><pre><code class="line-numbers language-java">public class Demo {    private static void method(Predicate&lt;String&gt; predicate) {        boolean veryLong = predicate.test("HelloWorld");        System.out.println("字符串很长吗:" + veryLong);    }    public static void main(String[] args) {        method(s -&gt; s.length() &gt; 5);    }}</code></pre><p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。</p><h3 id="默认方法-and"><a href="#默认方法-and" class="headerlink" title="默认方法:and"></a>默认方法:and</h3><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实 现“并且”的效果时，可以使用default方法 and 。</p><p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么:</p><pre><code class="line-numbers language-java">public class Demo {    private static void method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) {        boolean isValid = one.and(two).test("Helloworld");        System.out.println("字符串符合要求吗:" + isValid);    }    public static void main(String[] args) {        method(s -&gt; s.contains("H"), s -&gt; s.contains("W"));    }}</code></pre><h3 id="默认方法-or"><a href="#默认方法-or" class="headerlink" title="默认方法:or"></a>默认方法:or</h3><p>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。</p><p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变:</p><pre><code class="line-numbers language-java">public class Demo {    private static void method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) {        boolean isValid = one.or(two).test("Helloworld");        System.out.println("字符串符合要求吗:" + isValid);    }    public static void main(String[] args) {        method(s -&gt; s.contains("H"), s -&gt; s.contains("W"));    }}</code></pre><h3 id="默认方法-negate"><a href="#默认方法-negate" class="headerlink" title="默认方法:negate"></a>默认方法:negate</h3><p>“与”、“或”已经了解了，剩下的“非”(取反)也会简单。</p><p>从上面的实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前调用 negate 方法，正如 and 和 or 方法一样:</p><pre><code class="line-numbers language-java">public class Demo {    private static void method(Predicate&lt;String&gt; predicate) {        boolean veryLong = predicate.negate().test("HelloWorld");        System.out.println("字符串很长吗:" + veryLong);    }    public static void main(String[] args) {        method(s -&gt; s.length() &lt; 5);    }}</code></pre><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="集合信息筛选测试"><a href="#集合信息筛选测试" class="headerlink" title="集合信息筛选测试"></a>集合信息筛选测试</h3><p>数组当中有多条“姓名+性别”的信息如下，通过 Predicate 接口的拼装将符合要求的字符串筛选到集合 ArrayList 中，需要同时满足两个条件:</p><ul><li>性别必须为女</li><li>姓名为3个字</li></ul><pre><code class="line-numbers language-java">public class Demo {    public static void main(String[] args) {        String[] array = {"张三,女", "李四五,女", "李四六,男", "张二三,女"};        List&lt;String&gt; list = filter(array,                s -&gt; "女".equals(s.split(",")[1]),                s -&gt; s.split(",")[0].length() == 3);        System.out.println(list);    }    private static List&lt;String&gt; filter(String[] array, Predicate&lt;String&gt; one,                                       Predicate&lt;String&gt; two) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        for (String info : array) {            if (one.and(two).test(info)) {                list.add(info);            }        }        return list;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数接口 Consumer</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-consumer/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-consumer/</url>
      
        <content type="html"><![CDATA[<h1 id="函数接口-Consumer"><a href="#函数接口-Consumer" class="headerlink" title="函数接口 Consumer"></a>函数接口 Consumer</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 函数接口 Consumerdate: 2023-02-21 10:34tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: java.util.function.Consumer 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据， 其数据类型由泛型决定。</code></pre><h2 id="函数接口-Consumer-1"><a href="#函数接口-Consumer-1" class="headerlink" title="函数接口 Consumer"></a>函数接口 Consumer</h2><p><strong>consumer</strong><br>英 [kənˈsjuːmə(r)] 美 [kənˈsuːmər]</p><p>n. 消费者；用户，顾客</p><p><code>java.util.function.Consumer&lt;T&gt;</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据， 其数据类型由泛型决定。</p><pre><code class="line-numbers language-java">package java.util.function;import java.util.Objects;/** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, {@code Consumer} is expected * to operate via side-effects. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is {@link #accept(Object)}. * * @param &lt;T&gt; the type of the input to the operation * * @since 1.8 */@FunctionalInterfacepublic interface Consumer&lt;T&gt; {    /**     * Performs this operation on the given argument.     *     * @param t the input argument     */    void accept(T t);    /**     * Returns a composed {@code Consumer} that performs, in sequence, this     * operation followed by the {@code after} operation. If performing either     * operation throws an exception, it is relayed to the caller of the     * composed operation.  If performing this operation throws an exception,     * the {@code after} operation will not be performed.     *     * @param after the operation to perform after this operation     * @return a composed {@code Consumer} that performs in sequence this     * operation followed by the {@code after} operation     * @throws NullPointerException if {@code after} is null     */    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; { accept(t); after.accept(t); };    }}</code></pre><h3 id="抽象方法-accept"><a href="#抽象方法-accept" class="headerlink" title="抽象方法:accept"></a>抽象方法:accept</h3><p>Consumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。基本使用如下:</p><pre><code class="line-numbers language-java">public class Demo {    private static void consumeString(Consumer&lt;String&gt; function) {        function.accept("Hello");    }    public static void main(String[] args) {        consumeString(s -&gt; System.out.println(s));    }}</code></pre><p>当然，更好的写法是使用方法引用。</p><h3 id="默认方法-andThen"><a href="#默认方法-andThen" class="headerlink" title="默认方法:andThen"></a>默认方法:andThen</h3><p>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果:消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法 andThen 。下面是JDK的源代码:</p><pre><code class="line-numbers language-java"> default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; { accept(t); after.accept(t); };    }</code></pre><blockquote><p>java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p></blockquote><p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组合的情况:</p><pre><code class="line-numbers language-java">public class Demo {    private static void consumeString(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two) {        one.andThen(two).accept("Hello");    }        public static void main(String[] args) {        consumeString(                s -&gt; System.out.println(s.toUpperCase()),                s -&gt; System.out.println(s.toLowerCase()));    }}</code></pre><p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的 组合。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="格式化打印信息"><a href="#格式化打印信息" class="headerlink" title="格式化打印信息"></a>格式化打印信息</h3><p>下面的字符串数组当中存有多条信息，请按照格式“ 姓名:XX。性别:XX。 ”的格式将信息打印出来。要求将打印姓名的动作作为第一个 Consumer 接口的Lambda实例，将打印性别的动作作为第二个 Consumer 接口的Lambda实 例，将两个 Consumer 接口按照顺序“拼接”到一起。</p><pre><code class="line-numbers language-java">public class Demo {    public static void main(String[] args) {        String[] array = {"张三,女", "李四,女", "王五,男"};        printInfo(                s -&gt; System.out.print("姓名:" + s.split(",")[0]),                s -&gt; System.out.println("；性别:" + s.split(",")[1] + "。"),                array);    }    private static void printInfo(Consumer&lt;String&gt; one,                                   Consumer&lt;String&gt; two, String[] array) {        for (String info : array) {            one.andThen(two).accept(info);        }    }}// 控制台输出：姓名:张三；性别:女。姓名:李四；性别:女。姓名:王五；性别:男。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 函数式编程</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/java-han-shu-shi-bian-cheng/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/java-han-shu-shi-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-函数式编程"><a href="#Java-函数式编程" class="headerlink" title="Java 函数式编程"></a>Java 函数式编程</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java 函数式编程date: 2023-02-21 10:03tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: 函数式编程(Functional programming)是一种编程范式，它将计算视为数学函数的求值，避免使用可变数据和复杂的状态维护。函数式编程通过使用函数来将值转换成抽象单元，接着用于构建软件系统。</code></pre><h2 id="Java-函数式编程-1"><a href="#Java-函数式编程-1" class="headerlink" title="Java 函数式编程"></a>Java 函数式编程</h2><p>函数式编程(Functional programming)是一种编程范式，它将计算视为数学函数的求值，避免使用可变数据和复杂的状态维护。相比命令式编程(imperative programming)，函数式编程更强调函数的应用，而命令式编程更强调状态的变化和命令的执行顺序。</p><p>可以用下面一句话来直白地描述函数式编程：</p><p><strong>函数式编程通过使用函数来将值转换成抽象单元，接着用于构建软件系统。</strong></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在函数式编程中，有一些概念和范式不同于命令式编程(以及面向对象编程)，是特定于函数式编程的。然而编程语言通常是多种范式的混合体，所以熟悉命令式编程的程序员可能已经熟悉以下概念。</p><h2 id="Java-函数式接口基础"><a href="#Java-函数式接口基础" class="headerlink" title="Java 函数式接口基础"></a>Java 函数式接口基础</h2><p>函数式接口在Java中是指:有且仅有一个抽象方法的接口。 函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。<br>“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>只要确保接口中有且仅有一个抽象方法即可:</p><pre><code class="line-numbers language-java">修饰符 interface 接口名称 {    public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容} </code></pre><p>由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单:</p><pre><code class="line-numbers language-java">public interface MyFunctionalInterface {       void myMethod();}</code></pre><h3 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h3><p>与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解:@FunctionalInterface 。该注解可用于一个接口的定义上:</p><pre><code class="line-numbers language-java">@FunctionalInterfacepublic interface MyFunctionalInterface {       void myMethod();}</code></pre><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注 意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h3><p>对于刚刚定义好的 MyFunctionalInterface 函数式接口，典型使用场景就是作为方法的参数:</p><pre><code class="line-numbers language-java">public class Demo09FunctionalInterface {    // 使用自定义的函数式接口作为方法参数    private static void doSomething(MyFunctionalInterface inter) {        inter.myMethod(); // 调用自定义的函数式接口方法     }    public static void main(String[] args) {        // 调用使用函数式接口的方法        doSomething(() ‐&gt; System.out.println("Lambda执行啦!"));    } }</code></pre><h2 id="函数式编程基础"><a href="#函数式编程基础" class="headerlink" title="函数式编程基础"></a>函数式编程基础</h2><p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。</p><h3 id="Lambda的延迟执行"><a href="#Lambda的延迟执行" class="headerlink" title="Lambda的延迟执行"></a>Lambda的延迟执行</h3><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以 作为解决方案，提升性能。</p><p>性能浪费的日志案例<br>注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。 一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出:</p><pre><code class="line-numbers language-java">public class Demo01Logger {    private static void log(int level, String msg) {        if (level == 1) {            System.out.println(msg);        }    }    public static void main(String[] args) {        String msgA = "Hello";        String msgB = "World";        String msgC = "Java";        log(1, msgA + msgB + msgC);    }}</code></pre><p>这段代码存在问题:无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。<strong>如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费</strong>。</p><blockquote><p>备注:SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行 字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进 行字符串拼接。例如: LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位 符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置;否则不会进行字 符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p></blockquote><h4 id="Lambda的更优写法"><a href="#Lambda的更优写法" class="headerlink" title="Lambda的更优写法"></a>Lambda的更优写法</h4><p>使用Lambda必然需要一个函数式接口:</p><pre><code class="line-numbers language-java">@FunctionalInterfacepublic interface MessageBuilder {    String buildMessage();}</code></pre><p>然后对 log 方法进行改造:</p><pre><code class="line-numbers language-java"> public class Demo02LoggerLambda {    private static void log(int level, MessageBuilder builder) {        if (level == 1) {            System.out.println(builder.buildMessage());        }    }    public static void main(String[] args) {        String msgA = "Hello";        String msgB = "World";        String msgC = "Java";        log(1, () ‐&gt; msgA + msgB + msgC);    }}</code></pre><p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接;否则三个字符串将不会进行拼接。</p><p><strong>证明Lambda的延迟</strong></p><p>下面的代码可以通过结果进行验证:</p><pre><code class="line-numbers language-java">public class Demo03LoggerDelay {    private static void log(int level, MessageBuilder builder) {        if (level == 1) {            System.out.println(builder.buildMessage());        }    }    public static void main(String[] args) {        String msgA = "Hello";        String msgB = "World";        String msgC = "Java";        log(2, () ‐ &gt; {System.out.println("Lambda执行!"); return msgA + msgB + msgC;});    }}</code></pre><p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。<br>扩展:实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</p><h3 id="使用Lambda作为参数和返回值"><a href="#使用Lambda作为参数和返回值" class="headerlink" title="使用Lambda作为参数和返回值"></a>使用Lambda作为参数和返回值</h3><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数 式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。</p><p>例如 <code>java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就 可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p><pre><code class="line-numbers language-java">public class Demo04Runnable {    private static void startThread(Runnable task) {        new Thread(task).start();    }    public static void main(String[] args) {        startThread(() ‐ &gt; System.out.println("线程任务执行!"));    }}</code></pre><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一 个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。</p><pre><code class="line-numbers language-java">import java.util.Arrays;import java.util.Comparator;public class Demo06Comparator {    private static Comparator&lt;String&gt; newComparator() {        return (a,b) ‐&gt; b.length() ‐a.length();    }    public static void main(String[] args) {        String[] array = {"abc", "ab", "abcd"};        System.out.println(Arrays.toString(array));        Arrays.sort(array, newComparator());        System.out.println(Arrays.toString(array));    }}</code></pre><p>其中直接return一个Lambda表达式即可。</p><h2 id="常用函数式接口-Supplier"><a href="#常用函数式接口-Supplier" class="headerlink" title="常用函数式接口-Supplier"></a>常用函数式接口-Supplier</h2><p>undefined</p><h2 id="函数接口-Consumer"><a href="#函数接口-Consumer" class="headerlink" title="函数接口 Consumer"></a>函数接口 Consumer</h2><p>undefined</p><h2 id="函数接口-Predicate"><a href="#函数接口-Predicate" class="headerlink" title="函数接口 Predicate"></a>函数接口 Predicate</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数接口---supplier</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-supplier/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-supplier/</url>
      
        <content type="html"><![CDATA[<h1 id="函数接口—supplier"><a href="#函数接口—supplier" class="headerlink" title="函数接口—supplier"></a>函数接口—supplier</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 函数接口---supplierdate: 2023-02-21 08:42tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: Supplier 接口被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型数据。</code></pre><h2 id="函数接口—supplier-1"><a href="#函数接口—supplier-1" class="headerlink" title="函数接口—supplier"></a>函数接口—supplier</h2><p><code>java.util.function.supplier&lt;T&gt; </code></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Supplier&lt;T&gt;</code>接口被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型数据。</p><p>Supplier:包含一个无参的方法,所以是可以被<code>@FunctionalInterface</code>标识</p><ul><li><code>T get()</code>:获取结果<ul><li>该方法不需要参数,它会按照某种实现逻辑(有Lambda表达式实现)返回一个数据</li></ul></li></ul><pre><code class="line-numbers language-java">package java.util.function;/** * Represents a supplier of results. * * &lt;p&gt;There is no requirement that a new or distinct result be returned each * time the supplier is invoked. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is {@link #get()}. * * @param &lt;T&gt; the type of results supplied by this supplier * * @since 1.8 */@FunctionalInterfacepublic interface Supplier&lt;T&gt; {    /**     * Gets a result.     *     * @return a result     */    T get();}</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>supplier一般作用是用来产生一个对象（调用一次get方法，返回一次T所代表的对象）<br>supplier用来创建对象的，它和常规new对象不同:</p><p>比如我们有个Person类，如果：<br>        1、<code>Person p1 = new Person();</code>这里会马上创建一个对象<br>        2、<code>Supplier&lt;Persion&gt; s1 = Persion::new;</code>这里不会创建对象<br>            <code>Persion p1 = s1.get();</code> 这里会创建一个对象,而且会返回Persion对象<br>            <code>Persion p1 = s1.get();</code> 继续创建一个Persion对象</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="line-numbers language-java">/*   Supplier接口   Supplier&lt;T&gt;:包含一个无参的方法   T get():获取结果   该方法不需要参数,它会按照某种实现逻辑(有Lambda表达式实现)返回一个数据   Supplier&lt;T&gt;接口也称为生产型接口,如果我们指定了接口的泛型是什么类型,那么接口中的get方法就会产生什么类型数据供我们使用 */public class SupplierDemo {    public static void main(String[] args) {        /*        //匿名类写法        Supplier&lt;String&gt; s= new Supplier&lt;String&gt;() {              @Override              public String get() {                  return "iKun";              }          };        System.out.println(getString(s));         */        //Lambda表达式写法        System.out.println( getString(()-&gt;"iKun"));    }    //定义一个方法     private static String getString(Supplier&lt;String&gt; s){          return s.get();     }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web</title>
      <link href="/java/java-web/java-web/"/>
      <url>/java/java-web/java-web/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java Webdate: 2023-02-01 18:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java Web</code></pre><h2 id="【Java】-Servlet"><a href="#【Java】-Servlet" class="headerlink" title="【Java】 Servlet"></a>【Java】 Servlet</h2><p>undefined</p><h2 id="【Java】-Filter"><a href="#【Java】-Filter" class="headerlink" title="【Java】 Filter"></a>【Java】 Filter</h2><p>undefined</p><h2 id="【Java】-Listener"><a href="#【Java】-Listener" class="headerlink" title="【Java】 Listener"></a>【Java】 Listener</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web</title>
      <link href="/language/java/java-web/java-web/"/>
      <url>/language/java/java-web/java-web/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java Webdate: 2023-02-01 18:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java Web</code></pre><h2 id="【Java】-Servlet"><a href="#【Java】-Servlet" class="headerlink" title="【Java】 Servlet"></a>【Java】 Servlet</h2><p>undefined</p><h2 id="【Java】-Filter"><a href="#【Java】-Filter" class="headerlink" title="【Java】 Filter"></a>【Java】 Filter</h2><p>undefined</p><h2 id="【Java】-Listener"><a href="#【Java】-Listener" class="headerlink" title="【Java】 Listener"></a>【Java】 Listener</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Listener</title>
      <link href="/java/java-web/java-listener/"/>
      <url>/java/java-web/java-listener/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java】-Listener"><a href="#【Java】-Listener" class="headerlink" title="【Java】 Listener"></a>【Java】 Listener</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java】 Listenerdate: 2023-02-01 18:55tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Listener</code></pre><h2 id="【Java】-Listener-1"><a href="#【Java】-Listener-1" class="headerlink" title="【Java】 Listener"></a>【Java】 Listener</h2><p>web 监听器是一种 Servlet 中的特殊的类，它们能帮助开发者监听 web 中的特定事件，比如 ServletContext,HttpSession,ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p><p><img src="/attachment/950509a5c389221f66d5aa7eb3f720ca.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Listener</title>
      <link href="/language/java/java-web/java-listener/"/>
      <url>/language/java/java-web/java-listener/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java】-Listener"><a href="#【Java】-Listener" class="headerlink" title="【Java】 Listener"></a>【Java】 Listener</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java】 Listenerdate: 2023-02-01 18:55tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Listener</code></pre><h2 id="【Java】-Listener-1"><a href="#【Java】-Listener-1" class="headerlink" title="【Java】 Listener"></a>【Java】 Listener</h2><p>web 监听器是一种 Servlet 中的特殊的类，它们能帮助开发者监听 web 中的特定事件，比如 ServletContext,HttpSession,ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p><p><img src="/attachment%5C950509a5c389221f66d5aa7eb3f720ca.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Filter</title>
      <link href="/java/java-web/java-filter/"/>
      <url>/java/java-web/java-filter/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java】-Filter"><a href="#【Java】-Filter" class="headerlink" title="【Java】 Filter"></a>【Java】 Filter</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java】 Filterdate: 2023-02-01 18:51tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Filter</code></pre><h2 id="【Java】-Filter-1"><a href="#【Java】-Filter-1" class="headerlink" title="【Java】 Filter"></a>【Java】 Filter</h2><p>​ Filter（过滤器）用于拦截用户请求，在服务器作出响应前，可以在拦截后修改 request 和 response。可以实现一次编码，多处应用。Filter 不像 Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。</p><p>Web 开发人员通过 Filter 技术，对 web 服务器管理的所有 web 资源。例如实现 URL 级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。例如对 Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。</p><p>Filter 主要的作用有两个：</p><ul><li>拦截修改请求：在 HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest。根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 头和数据。</li><li>拦截修改响应：在 HttpServletResponse 到达客户端之前，拦截 HttpServletResponse。根据需要检查 HttpServletResponse, 也可以修改 HttpServletResponse 头和数据。</li></ul><p><img src="/attachment/e9d18d57caa13788555c7bab2d29b58c.png"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Filter 接口位于 javax.servlet 包下，其中提供了三个方法，完成了整个过滤器的生命周期。</p><ul><li>init() ：应用程序启动时，servlet 容器就会调用 init 方法。这个方法只调用一次，并且应该包含该过滤器的初始化代码。</li><li>doFilter：每次的访问请求如果符合拦截条件都会调用此方法，获取请求及响应对象，自定义处理逻辑。</li><li>destroy()：服务终止时，会调用 destory 方法，销毁过滤器对象。</li></ul><pre><code class="line-numbers language-java">public interface Filter {    public default void init(FilterConfig filterConfig) throws ServletException {}    public void doFilter(ServletRequest request, ServletResponse response,            FilterChain chain) throws IOException, ServletException;    public default void destroy() {}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Filter</title>
      <link href="/language/java/java-web/java-filter/"/>
      <url>/language/java/java-web/java-filter/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java】-Filter"><a href="#【Java】-Filter" class="headerlink" title="【Java】 Filter"></a>【Java】 Filter</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java】 Filterdate: 2023-02-01 18:51tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Filter</code></pre><h2 id="【Java】-Filter-1"><a href="#【Java】-Filter-1" class="headerlink" title="【Java】 Filter"></a>【Java】 Filter</h2><p>​ Filter（过滤器）用于拦截用户请求，在服务器作出响应前，可以在拦截后修改 request 和 response。可以实现一次编码，多处应用。Filter 不像 Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。</p><p>Web 开发人员通过 Filter 技术，对 web 服务器管理的所有 web 资源。例如实现 URL 级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。例如对 Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。</p><p>Filter 主要的作用有两个：</p><ul><li>拦截修改请求：在 HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest。根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 头和数据。</li><li>拦截修改响应：在 HttpServletResponse 到达客户端之前，拦截 HttpServletResponse。根据需要检查 HttpServletResponse, 也可以修改 HttpServletResponse 头和数据。</li></ul><p><img src="/attachment%5Ce9d18d57caa13788555c7bab2d29b58c.png"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Filter 接口位于 javax.servlet 包下，其中提供了三个方法，完成了整个过滤器的生命周期。</p><ul><li>init() ：应用程序启动时，servlet 容器就会调用 init 方法。这个方法只调用一次，并且应该包含该过滤器的初始化代码。</li><li>doFilter：每次的访问请求如果符合拦截条件都会调用此方法，获取请求及响应对象，自定义处理逻辑。</li><li>destroy()：服务终止时，会调用 destory 方法，销毁过滤器对象。</li></ul><pre><code class="line-numbers language-java">public interface Filter {    public default void init(FilterConfig filterConfig) throws ServletException {}    public void doFilter(ServletRequest request, ServletResponse response,            FilterChain chain) throws IOException, ServletException;    public default void destroy() {}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Servlet</title>
      <link href="/java/java-web/java-servlet/"/>
      <url>/java/java-web/java-servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java】-Servlet"><a href="#【Java】-Servlet" class="headerlink" title="【Java】 Servlet"></a>【Java】 Servlet</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java】 Servletdate: 2023-02-01 18:45tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Servlet</code></pre><h2 id="【Java】-Servlet-1"><a href="#【Java】-Servlet-1" class="headerlink" title="【Java】 Servlet"></a>【Java】 Servlet</h2><p>Servlet 是 SUN 推出的一套规范，定义了一套处理请求和发送响应的接口。一般认为 Servlet 其实就是一个遵循 Servlet 规范开发的 java 类，Serlvet 是由服务器调用的，运行在服务器端。</p><p>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器。 Tomcat 作为 Servlet 容器，负责处理客户请求, 把请求传送给 Servlet，并将 Servlet 的响应传送回给客户，而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。</p><p><img src="/attachment/4e487db9369b8b2458296d6db5eb0fea.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Servlet</title>
      <link href="/language/java/java-web/java-servlet/"/>
      <url>/language/java/java-web/java-servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java】-Servlet"><a href="#【Java】-Servlet" class="headerlink" title="【Java】 Servlet"></a>【Java】 Servlet</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java】 Servletdate: 2023-02-01 18:45tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Servlet</code></pre><h2 id="【Java】-Servlet-1"><a href="#【Java】-Servlet-1" class="headerlink" title="【Java】 Servlet"></a>【Java】 Servlet</h2><p>Servlet 是 SUN 推出的一套规范，定义了一套处理请求和发送响应的接口。一般认为 Servlet 其实就是一个遵循 Servlet 规范开发的 java 类，Serlvet 是由服务器调用的，运行在服务器端。</p><p>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器。 Tomcat 作为 Servlet 容器，负责处理客户请求, 把请求传送给 Servlet，并将 Servlet 的响应传送回给客户，而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。</p><p><img src="/attachment%5C4e487db9369b8b2458296d6db5eb0fea.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 Spring 集成</title>
      <link href="/database/mongodb/mongodb-spring-ji-cheng/"/>
      <url>/database/mongodb/mongodb-spring-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="【MongoDB】-Spring-集成"><a href="#【MongoDB】-Spring-集成" class="headerlink" title="【MongoDB】 Spring 集成"></a>【MongoDB】 Spring 集成</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MongoDB】 Spring 集成date: 2022-12-20 18:08tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 Spring 集成</code></pre><h2 id="Spring-Data-与-MongoDB"><a href="#Spring-Data-与-MongoDB" class="headerlink" title="Spring Data 与 MongoDB"></a>Spring Data 与 MongoDB</h2><h3 id="Spring-Data的层次结构"><a href="#Spring-Data的层次结构" class="headerlink" title="Spring Data的层次结构"></a>Spring Data的层次结构</h3><p><img src="/attachment%5C6293fb992b572332a190a1cecb48b691.png"></p><p>Spring Data是基于Spring runtime体系的：</p><p><img src="/attachment%5Ce395c0240f8cccfe2233f87adf9f9407.png"></p><h3 id="springboot-data-mongo层次结构"><a href="#springboot-data-mongo层次结构" class="headerlink" title="springboot-data-mongo层次结构"></a>springboot-data-mongo层次结构</h3><p><img src="/attachment%5Cb4bd6bb7ec2d65c577a433d5fee440c7.png"></p><h2 id="mongodb-Java用法"><a href="#mongodb-Java用法" class="headerlink" title="mongodb+Java用法"></a>mongodb+Java用法</h2><h3 id="使用方式及依赖包的引入"><a href="#使用方式及依赖包的引入" class="headerlink" title="使用方式及依赖包的引入"></a>使用方式及依赖包的引入</h3><ul><li>引入mongodb-driver, 使用最原生的方式通过Java调用mongodb提供的Java driver;</li><li>引入spring-data-mongo, 自行配置使用spring data 提供的对MongoDB的封装<ul><li>使用MongoTemplate 的方式</li><li>使用MongoRespository 的方式</li></ul></li><li>引入spring-data-mongo-starter, 采用spring autoconfig机制自动装配，然后再使用- MongoTemplate或者MongoRespository方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 Java API</title>
      <link href="/database/mongodb/mongodb-java-api/"/>
      <url>/database/mongodb/mongodb-java-api/</url>
      
        <content type="html"><![CDATA[<h1 id="【MongoDB】-Java-API"><a href="#【MongoDB】-Java-API" class="headerlink" title="【MongoDB】 Java API"></a>【MongoDB】 Java API</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MongoDB】 Java APIdate: 2022-12-20 18:07tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 Java API</code></pre><h2 id="MongoDB-Driver"><a href="#MongoDB-Driver" class="headerlink" title="MongoDB Driver"></a>MongoDB Driver</h2><pre><code class="line-numbers language-xml">&lt;!-- https://mvnrepository.com/artifact/org.mongodb/mongo-java-driver --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;    &lt;version&gt;3.12.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><pre><code class="line-numbers language-java">private static final String MONGO_HOST = "xxx.xxx.xxx.xxx";    private static final Integer MONGO_PORT = 27017;    private static final String MONGO_DB = "testdb";    public static void main(String args[]) {        try {            // 连接到 mongodb 服务            MongoClient mongoClient = new MongoClient(MONGO_HOST, MONGO_PORT);            // 连接到数据库            MongoDatabase mongoDatabase = mongoClient.getDatabase(MONGO_DB);            System.out.println("Connect to database successfully");            // 创建Collection            mongoDatabase.createCollection("test");            System.out.println("create collection");            // 获取collection            MongoCollection&lt;Document&gt; collection = mongoDatabase.getCollection("test");            // 插入document            Document doc = new Document("name", "MongoDB")                    .append("type", "database")                    .append("count", 1)                    .append("info", new Document("x", 203).append("y", 102));            collection.insertOne(doc);            // 统计count            System.out.println(collection.countDocuments());            // query - first            Document myDoc = collection.find().first();            System.out.println(myDoc.toJson());            // query - loop all            MongoCursor&lt;Document&gt; cursor = collection.find().iterator();            try {                while (cursor.hasNext()) {                    System.out.println(cursor.next().toJson());                }            } finally {                cursor.close();            }        } catch (Exception e) {            System.err.println(e.getClass().getName() + ": " + e.getMessage());        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 效率工具</title>
      <link href="/database/mongodb/mongodb-xiao-lu-gong-ju/"/>
      <url>/database/mongodb/mongodb-xiao-lu-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="【MongoDB】-效率工具"><a href="#【MongoDB】-效率工具" class="headerlink" title="【MongoDB】 效率工具"></a>【MongoDB】 效率工具</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MongoDB】 效率工具date: 2022-12-20 18:06tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 效率工具</code></pre><h2 id="官方MongoDB-Compass"><a href="#官方MongoDB-Compass" class="headerlink" title="官方MongoDB Compass"></a>官方MongoDB Compass</h2><blockquote><p>推荐使用</p></blockquote><p>MongoDB Compass Community由MongoDB开发人员开发，这意味着更高的可靠性和兼容性。它为MongoDB提供GUI mongodb工具，以探索数据库交互；具有完整的CRUD功能并提供可视方式。借助内置模式可视化，用户可以分析文档并显示丰富的结构。为了监控服务器的负载，它提供了数据库操作的实时统计信息。就像MongoDB一样，Compass也有两个版本，一个是Enterprise（付费），社区可以免费使用。</p><h2 id="NoSQLBooster"><a href="#NoSQLBooster" class="headerlink" title="NoSQLBooster"></a>NoSQLBooster</h2><p>NoSQLBooster是MongoDB CLI界面中非常流行的GUI工具。它正式名称为MongoBooster。NoSQLBooster是一个跨平台，它自带一些mongodb工具来管理数据库和监控服务器。这个Mongodb工具包括服务器监控工具，Visual Explain Plan，查询构建器，SQL查询，ES2017语法支持等。它有免费，个人和商业版本，当然，免费版本有一些功能限制。NoSQLBooster也可用于Windows，MacOS和Linux。支持 sql，免费版 支持 CSV、JSON 导入，但不支持 CSV、JSON 导出。集成了 mongodump/mongorestore，支持监控，和查询优化。</p><h2 id="Robot3T"><a href="#Robot3T" class="headerlink" title="Robot3T"></a>Robot3T</h2><p>Robo 3T前身是Robomongo。支持Windows，MacOS和Linux系统。Robo 3T 1.3为您提供了对MongoDB 4.0和SCRAM-SHA-256（升级的mongo shell）的支持，支持从MongoDB SRV连接字符串导入，以及许多其他修复和改进。大家也可以找到之前的Robomongo，完全免费的版本使用。</p><h2 id="Vs-Code-plugin"><a href="#Vs-Code-plugin" class="headerlink" title="Vs Code plugin"></a>Vs Code plugin</h2>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 索引</title>
      <link href="/database/mongodb/mongodb-suo-yin/"/>
      <url>/database/mongodb/mongodb-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="【MongoDB】-索引"><a href="#【MongoDB】-索引" class="headerlink" title="【MongoDB】 索引"></a>【MongoDB】 索引</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MongoDB】 索引date: 2022-12-20 18:04tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 索引</code></pre><h2 id="聚合-Aggregation-Pipline"><a href="#聚合-Aggregation-Pipline" class="headerlink" title="聚合 - Aggregation Pipline"></a>聚合 - Aggregation Pipline</h2><blockquote><p>类似于将SQL中的group by + order by + left join … 等操作管道化。</p></blockquote><h3 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h3><p><strong>图例理解</strong></p><p><img src="/attachment%5C6d3383df61d47afe1f6af5fdbf57e41c.png"></p><p><strong>准备数据</strong></p><pre><code class="line-numbers language-sh">&gt; db.orders.insertMany( [...     { _id: 1, cust_id: "abc1", ord_date: ISODate("2012-11-02T17:04:11.102Z"), status: "A", amount: 50 },...     { _id: 2, cust_id: "xyz1", ord_date: ISODate("2013-10-01T17:04:11.102Z"), status: "A", amount: 100 },...     { _id: 3, cust_id: "xyz1", ord_date: ISODate("2013-10-12T17:04:11.102Z"), status: "D", amount: 25 },...     { _id: 4, cust_id: "xyz1", ord_date: ISODate("2013-10-11T17:04:11.102Z"), status: "D", amount: 125 },...     { _id: 5, cust_id: "abc1", ord_date: ISODate("2013-11-12T17:04:11.102Z"), status: "A", amount: 25 }... ] );{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3, 4, 5 ] }&gt; db.orders.find({}){ "_id" : 1, "cust_id" : "abc1", "ord_date" : ISODate("2012-11-02T17:04:11.102Z"), "status" : "A", "amount" : 50 }{ "_id" : 2, "cust_id" : "xyz1", "ord_date" : ISODate("2013-10-01T17:04:11.102Z"), "status" : "A", "amount" : 100 }{ "_id" : 3, "cust_id" : "xyz1", "ord_date" : ISODate("2013-10-12T17:04:11.102Z"), "status" : "D", "amount" : 25 }{ "_id" : 4, "cust_id" : "xyz1", "ord_date" : ISODate("2013-10-11T17:04:11.102Z"), "status" : "D", "amount" : 125 }{ "_id" : 5, "cust_id" : "abc1", "ord_date" : ISODate("2013-11-12T17:04:11.102Z"), "status" : "A", "amount" : 25 }&gt;</code></pre><p><strong>聚合操作</strong></p><pre><code class="line-numbers language-sh">&gt; db.orders.aggregate([...                      { $match: { status: "A" } },...                      { $group: { _id: "$cust_id", total: { $sum: "$amount" } } },...                      { $sort: { total: -1 } }...                    ]){ "_id" : "xyz1", "total" : 100 }{ "_id" : "abc1", "total" : 75 }</code></pre><h3 id="Pipline操作"><a href="#Pipline操作" class="headerlink" title="Pipline操作"></a>Pipline操作</h3><p>MongoDB的聚合管道（Pipline）将MongoDB文档在一个阶段（Stage）处理完毕后将结果传递给下一个阶段（Stage）处理。<strong>阶段（Stage）操作是可以重复的。</strong></p><p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p><p>这里我们介绍一下聚合框架中常用的几个Stages：</p><ul><li><code>$project</code>：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li><code>$match</code>：用于过滤数据，只输出符合条件的文档。<code>$match</code>使用MongoDB的标准查询操作。</li><li><code>$limit</code>：用来限制MongoDB聚合管道返回的文档数。</li><li><code>$skip</code>：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li><code>$unwind</code>：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li><code>$group</code>：将集合中的文档分组，可用于统计结果。</li><li><code>$sort</code>：将输入文档排序后输出。</li><li><code>$geoNear</code>：输出接近某一地理位置的有序文档。</li><li><code>$bucket</code>: 分组（分桶）计算。</li><li><code>$facet</code>: 多次分组计算。</li><li><code>$out</code>: 将结果集输出，必须是Pipline最后一个Stage。</li></ul><p><strong>示例</strong></p><ul><li><code>$project</code></li></ul><pre><code class="line-numbers language-sh">&gt; db.orders.aggregate(...     { $project : {...         _id : 0 , // 默认不显示_id...         cust_id : 1 ,...         status : 1...     }});{ "cust_id" : "abc1", "status" : "A" }{ "cust_id" : "xyz1", "status" : "A" }{ "cust_id" : "xyz1", "status" : "D" }{ "cust_id" : "xyz1", "status" : "D" }{ "cust_id" : "abc1", "status" : "A" }</code></pre><ul><li><code>$skip</code></li></ul><pre><code class="line-numbers language-sh"> db.orders.aggregate(...     { $skip : 4 });{ "_id" : 5, "cust_id" : "abc1", "ord_date" : ISODate("2013-11-12T17:04:11.102Z"), "status" : "A", "amount" : 25 }</code></pre><ul><li><code>$unwind</code></li></ul><pre><code class="line-numbers language-sh">&gt; db.inventory2.insertOne({ "_id" : 1, "item" : "ABC1", sizes: [ "S", "M", "L"] }){ "acknowledged" : true, "insertedId" : 1 }&gt; db.inventory2.aggregate( [ { $unwind : "$sizes" } ] ){ "_id" : 1, "item" : "ABC1", "sizes" : "S" }{ "_id" : 1, "item" : "ABC1", "sizes" : "M" }{ "_id" : 1, "item" : "ABC1", "sizes" : "L" }</code></pre><ul><li><code>$bucket</code></li></ul><pre><code class="line-numbers language-sh">&gt; db.artwork.insertMany([... { "_id" : 1, "title" : "The Pillars of Society", "artist" : "Grosz", "year" : 1926,...     "price" : NumberDecimal("199.99") },... { "_id" : 2, "title" : "Melancholy III", "artist" : "Munch", "year" : 1902,...     "price" : NumberDecimal("280.00") },... { "_id" : 3, "title" : "Dancer", "artist" : "Miro", "year" : 1925,...     "price" : NumberDecimal("76.04") },... { "_id" : 4, "title" : "The Great Wave off Kanagawa", "artist" : "Hokusai",...     "price" : NumberDecimal("167.30") },... { "_id" : 5, "title" : "The Persistence of Memory", "artist" : "Dali", "year" : 1931,...     "price" : NumberDecimal("483.00") },... { "_id" : 6, "title" : "Composition VII", "artist" : "Kandinsky", "year" : 1913,...     "price" : NumberDecimal("385.00") },... { "_id" : 7, "title" : "The Scream", "artist" : "Munch", "year" : 1893 },... { "_id" : 8, "title" : "Blue Flower", "artist" : "O'Keefe", "year" : 1918,...     "price" : NumberDecimal("118.42") }... ]){        "acknowledged" : true,        "insertedIds" : [                1,                2,                3,                4,                5,                6,                7,                8        ]}&gt; db.artwork.find({}){ "_id" : 1, "title" : "The Pillars of Society", "artist" : "Grosz", "year" : 1926, "price" : NumberDecimal("199.99") }{ "_id" : 2, "title" : "Melancholy III", "artist" : "Munch", "year" : 1902, "price" : NumberDecimal("280.00") }{ "_id" : 3, "title" : "Dancer", "artist" : "Miro", "year" : 1925, "price" : NumberDecimal("76.04") }{ "_id" : 4, "title" : "The Great Wave off Kanagawa", "artist" : "Hokusai", "price" : NumberDecimal("167.30") }{ "_id" : 5, "title" : "The Persistence of Memory", "artist" : "Dali", "year" : 1931, "price" : NumberDecimal("483.00") }{ "_id" : 6, "title" : "Composition VII", "artist" : "Kandinsky", "year" : 1913, "price" : NumberDecimal("385.00") }{ "_id" : 7, "title" : "The Scream", "artist" : "Munch", "year" : 1893 } // 注意这里没有price，聚合结果中为Others{ "_id" : 8, "title" : "Blue Flower", "artist" : "O'Keefe", "year" : 1918, "price" : NumberDecimal("118.42") }&gt; db.artwork.aggregate( [...   {...     $bucket: {...       groupBy: "$price",...       boundaries: [ 0, 200, 400 ],...       default: "Other",...       output: {...         "count": { $sum: 1 },...         "titles" : { $push: "$title" }...       }...     }...   }... ] ){ "_id" : 0, "count" : 4, "titles" : [ "The Pillars of Society", "Dancer", "The Great Wave off Kanagawa", "Blue Flower" ] }{ "_id" : 200, "count" : 2, "titles" : [ "Melancholy III", "Composition VII" ] }{ "_id" : "Other", "count" : 2, "titles" : [ "The Persistence of Memory", "The Scream" ] }</code></pre><ul><li><code>$bucket + $facet</code></li></ul><blockquote><p>非常常用！</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">示例</p><p>collapse: closed</p><pre><code class="language-sh">db.artwork.aggregate( [  {    $facet: {      "price": [        {          $bucket: {              groupBy: "$price",              boundaries: [ 0, 200, 400 ],              default: "Other",              output: {                "count": { $sum: 1 },                "artwork" : { $push: { "title": "$title", "price": "$price" } }              }          }        }      ],      "year": [        {          $bucket: {            groupBy: "$year",            boundaries: [ 1890, 1910, 1920, 1940 ],            default: "Unknown",            output: {              "count": { $sum: 1 },              "artwork": { $push: { "title": "$title", "year": "$year" } }            }          }        }      ]    }  }] )<p>// 输出<br>{<br>  "year" : [<br>    {<br>      "_id" : 1890,<br>      "count" : 2,<br>      "artwork" : [<br>        {<br>          "title" : "Melancholy III",<br>          "year" : 1902<br>        },<br>        {<br>          "title" : "The Scream",<br>          "year" : 1893<br>        }<br>      ]<br>    },<br>    {<br>      "_id" : 1910,<br>      "count" : 2,<br>      "artwork" : [<br>        {<br>          "title" : "Composition VII",<br>          "year" : 1913<br>        },<br>        {<br>          "title" : "Blue Flower",<br>          "year" : 1918<br>        }<br>      ]<br>    },<br>    {<br>      "_id" : 1920,<br>      "count" : 3,<br>      "artwork" : [<br>        {<br>          "title" : "The Pillars of Society",<br>          "year" : 1926<br>        },<br>        {<br>          "title" : "Dancer",<br>          "year" : 1925<br>        },<br>        {<br>          "title" : "The Persistence of Memory",<br>          "year" : 1931<br>        }<br>      ]<br>    },<br>    {<br>      // Includes the document without a year, e.g., _id: 4<br>      "_id" : "Unknown",<br>      "count" : 1,<br>      "artwork" : [<br>        {<br>          "title" : "The Great Wave off Kanagawa"<br>        }<br>      ]<br>    }<br>  ],<br>      "price" : [<br>    {<br>      "_id" : 0,<br>      "count" : 4,<br>      "artwork" : [<br>        {<br>          "title" : "The Pillars of Society",<br>          "price" : NumberDecimal("199.99")<br>        },<br>        {<br>          "title" : "Dancer",<br>          "price" : NumberDecimal("76.04")<br>        },<br>        {<br>          "title" : "The Great Wave off Kanagawa",<br>          "price" : NumberDecimal("167.30")<br>        },<br>        {<br>          "title" : "Blue Flower",<br>          "price" : NumberDecimal("118.42")<br>        }<br>      ]<br>    },<br>    {<br>      "_id" : 200,<br>      "count" : 2,<br>      "artwork" : [<br>        {<br>          "title" : "Melancholy III",<br>          "price" : NumberDecimal("280.00")<br>        },<br>        {<br>          "title" : "Composition VII",<br>          "price" : NumberDecimal("385.00")<br>        }<br>      ]<br>    },<br>    {<br>      // Includes the document without a price, e.g., _id: 7<br>      "_id" : "Other",<br>      "count" : 2,<br>      "artwork" : [<br>        {<br>          "title" : "The Persistence of Memory",<br>          "price" : NumberDecimal("483.00")<br>        },<br>        {<br>          "title" : "The Scream"<br>        }<br>      ]<br>    }<br>  ]<br>}</p></code><p><code class="language-sh"></code></p></pre><p></p></div><blockquote><p>聚合操作使用的比较频繁</p></blockquote><h3 id="Aggregation-Options参数"><a href="#Aggregation-Options参数" class="headerlink" title="Aggregation Options参数"></a>Aggregation Options参数</h3><ul><li><code>explain</code></li></ul><pre><code class="line-numbers language-sh">&gt; db.orders.aggregate(...                      [...                        { $match: { status: "A" } },...                        { $group: { _id: "$cust_id", total: { $sum: "$amount" } } },...                        { $sort: { total: -1 } }...                      ],...                      {...                        explain: true...                      }...                    ){        "serverInfo" : {                "host" : "pdai",                "port" : 27017,                "version" : "3.6.19",                "gitVersion" : "41b289ff734a926e784d6ab42c3129f59f40d5b4"        },        "stages" : [                {                        "$cursor" : {                                "query" : {                                        "status" : "A"                                },                                "fields" : {                                        "amount" : 1,                                        "cust_id" : 1,                                        "_id" : 0                                },                                "queryPlanner" : {                                        "plannerVersion" : 1,                                        "namespace" : "testdb.orders",                                        "indexFilterSet" : false,                                        "parsedQuery" : {                                                "status" : {                                                        "$eq" : "A"                                                }                                        },                                        "winningPlan" : {                                                "stage" : "COLLSCAN",                                                "filter" : {                                                        "status" : {                                                                "$eq" : "A"                                                        }                                                },                                                "direction" : "forward"                                        },                                        "rejectedPlans" : [ ]                                }                        }                },                {                        "$group" : {                                "_id" : "$cust_id",                                "total" : {                                        "$sum" : "$amount"                                }                        }                },                {                        "$sort" : {                                "sortKey" : {                                        "total" : -1                                }                        }                }        ],        "ok" : 1}</code></pre><h2 id="聚合-Map-Reduce"><a href="#聚合-Map-Reduce" class="headerlink" title="聚合 - Map Reduce"></a>聚合 - Map Reduce</h2><p><strong>图例理解</strong></p><p><img src="/attachment%5C1ecfcd8ab17b959f91f9aebde6fdb1db.png"></p><h3 id="官网示例"><a href="#官网示例" class="headerlink" title="官网示例"></a>官网示例</h3><ul><li>准备数据</li></ul><pre><code class="line-numbers language-sh">{     _id: ObjectId("50a8240b927d5d8b5891743c"),     cust_id: "abc123",     ord_date: new Date("Oct 04, 2012"),     status: 'A',     price: 25,     items: [ { sku: "mmm", qty: 5, price: 2.5 },              { sku: "nnn", qty: 5, price: 2.5 } ]}</code></pre><ul><li>计算每个顾客总花费：</li></ul><p>map</p><pre><code class="line-numbers language-sh">var mapFunction1 = function() {                       emit(this.cust_id, this.price);                   };</code></pre><p>reduce</p><pre><code class="line-numbers language-sh">var reduceFunction1 = function(keyCustId, valuesPrices) {                          return Array.sum(valuesPrices);                      };</code></pre><p>out</p><pre><code class="line-numbers language-sh">db.orders.mapReduce(                     mapFunction1,                     reduceFunction1,                     { out: "map_reduce_example" }                   )</code></pre><ul><li>计算每个订单中Items的均价</li></ul><p>map</p><pre><code class="line-numbers language-sh">var mapFunction2 = function() {                       for (var idx = 0; idx &lt; this.items.length; idx++) {                           var key = this.items[idx].sku;                           var value = {                                         count: 1,                                         qty: this.items[idx].qty                                       };                           emit(key, value);                       }                    };</code></pre><p>reduce</p><pre><code class="line-numbers language-sh">var reduceFunction2 = function(keySKU, countObjVals) {                     reducedVal = { count: 0, qty: 0 };                     for (var idx = 0; idx &lt; countObjVals.length; idx++) {                         reducedVal.count += countObjVals[idx].count;                         reducedVal.qty += countObjVals[idx].qty;                     }                     return reducedVal;                  };</code></pre><p>finalize</p><pre><code class="line-numbers language-sh">var finalizeFunction2 = function (key, reducedVal) {                       reducedVal.avg = reducedVal.qty/reducedVal.count;                       return reducedVal;                    };</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引即为提升查询等的效率，默认是对_id进行索引的。</p><h3 id="图例理解"><a href="#图例理解" class="headerlink" title="图例理解"></a>图例理解</h3><p>以对users中score进行索引时查询的效果</p><p><img src="/attachment%5C9ae28fdca0f44545bff4406462d525d2.png"></p><h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><p>对于索引，这里简单介绍下常用的类型，其它类型和例子可以参考</p><ul><li>单一索引</li></ul><p><img src="/attachment%5Cdc6adb1eee3b62cfc710a3ac7e2dd632.png"></p><ul><li>复合索引</li></ul><p><img src="/attachment%5C16b5459df3c5a9684462f2649628f31d.png"></p><ul><li>多键索引</li></ul><p><img src="/attachment%5C70b7f16bf1139d7ea27a031492d17cc6.png"></p><h3 id="对索引的操作"><a href="#对索引的操作" class="headerlink" title="对索引的操作"></a>对索引的操作</h3><ul><li><strong>查看集合索引</strong></li></ul><pre><code class="line-numbers language-sh">db.col.getIndexes()</code></pre><ul><li><strong>查看集合索引大小</strong></li></ul><pre><code class="line-numbers language-sh">db.col.totalIndexSize()</code></pre><ul><li>删除集合所有索引</li></ul><pre><code class="line-numbers language-sh">db.col.dropIndexes()</code></pre><ul><li>删除集合指定索引</li></ul><pre><code class="line-numbers language-sh">db.col.dropIndex("索引名称")</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 CURD</title>
      <link href="/database/mongodb/mongodb-curd/"/>
      <url>/database/mongodb/mongodb-curd/</url>
      
        <content type="html"><![CDATA[<h1 id="【MongoDB】-CURD"><a href="#【MongoDB】-CURD" class="headerlink" title="【MongoDB】 CURD"></a>【MongoDB】 CURD</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MongoDB】 CURDdate: 2022-12-20 18:02tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 CURD</code></pre><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p><strong>图例</strong></p><p><img src="/attachment%5Cf4f4ba4b7189d32e69151b74e8042669.png"></p><p><strong>示例</strong></p><pre><code class="line-numbers language-sh">&gt; db.inventory.insertOne(...    { item: "canvas", qty: 100, tags: ["cotton"], size: { h: 28, w: 35.5, uom: "cm" } }... ){        "acknowledged" : true,        "insertedId" : ObjectId("5f1f8a9a099483199e74737c")}&gt; db.inventory.insertMany([...    { item: "journal", qty: 25, tags: ["blank", "red"], size: { h: 14, w: 21, uom: "cm" } },...    { item: "mat", qty: 85, tags: ["gray"], size: { h: 27.9, w: 35.5, uom: "cm" } },...    { item: "mousepad", qty: 25, tags: ["gel", "blue"], size: { h: 19, w: 22.85, uom: "cm" } }... ]){        "acknowledged" : true,        "insertedIds" : [                ObjectId("5f1f8aa8099483199e74737d"),                ObjectId("5f1f8aa8099483199e74737e"),                ObjectId("5f1f8aa8099483199e74737f")        ]}&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f8a9a099483199e74737c"), "item" : "canvas", "qty" : 100, "tags" : [ "cotton" ], "size" : { "h" : 28, "w" : 35.5, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737d"), "item" : "journal", "qty" : 25, "tags" : [ "blank", "red" ], "size" : { "h" : 14, "w" : 21, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737e"), "item" : "mat", "qty" : 85, "tags" : [ "gray" ], "size" : { "h" : 27.9, "w" : 35.5, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737f"), "item" : "mousepad", "qty" : 25, "tags" : [ "gel", "blue" ], "size" : { "h" : 19, "w" : 22.85, "uom" : "cm" } }</code></pre><h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><p><strong>图例</strong></p><p><img src="/attachment%5C537bc15edb4322549b5f265383d380bb.png"></p><p><strong>示例</strong></p><pre><code class="line-numbers language-sh">&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f8a9a099483199e74737c"), "item" : "canvas", "qty" : 100, "tags" : [ "cotton" ], "size" : { "h" : 28, "w" : 35.5, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737d"), "item" : "journal", "qty" : 25, "tags" : [ "blank", "red" ], "size" : { "h" : 14, "w" : 21, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737e"), "item" : "mat", "qty" : 85, "tags" : [ "gray" ], "size" : { "h" : 27.9, "w" : 35.5, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737f"), "item" : "mousepad", "qty" : 25, "tags" : [ "gel", "blue" ], "size" : { "h" : 19, "w" : 22.85, "uom" : "cm" } }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a79"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7a"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7b"), "item" : "planner", "qty" : 75, "size" : { "h" : 22.85, "w" : 30, "uom" : "cm" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7c"), "item" : "postcard", "qty" : 45, "size" : { "h" : 10, "w" : 15.25, "uom" : "cm" }, "status" : "A" }&gt; db.inventory.find( { status: "D" } ){ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7a"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7b"), "item" : "planner", "qty" : 75, "size" : { "h" : 22.85, "w" : 30, "uom" : "cm" }, "status" : "D" }&gt; db.inventory.find( { status: { $in: [ "A", "D" ] } } ){ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a79"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7a"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7b"), "item" : "planner", "qty" : 75, "size" : { "h" : 22.85, "w" : 30, "uom" : "cm" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7c"), "item" : "postcard", "qty" : 45, "size" : { "h" : 10, "w" : 15.25, "uom" : "cm" }, "status" : "A" }&gt; db.inventory.find( { status: "A", qty: { $lt: 30 } } ){ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }&gt; db.inventory.find( { $or: [ { status: "A" }, { qty: { $lt: 30 } } ] } ){ "_id" : ObjectId("5f1f8aa8099483199e74737d"), "item" : "journal", "qty" : 25, "tags" : [ "blank", "red" ], "size" : { "h" : 14, "w" : 21, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737f"), "item" : "mousepad", "qty" : 25, "tags" : [ "gel", "blue" ], "size" : { "h" : 19, "w" : 22.85, "uom" : "cm" } }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a79"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7c"), "item" : "postcard", "qty" : 45, "size" : { "h" : 10, "w" : 15.25, "uom" : "cm" }, "status" : "A" }&gt; db.inventory.find( {...      status: "A",...      $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]... } ){ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7c"), "item" : "postcard", "qty" : 45, "size" : { "h" : 10, "w" : 15.25, "uom" : "cm" }, "status" : "A" }</code></pre><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p><strong>图例</strong></p><p><img src="/attachment%5Cde70e3547d0ddf2f646ae7e36433ed80.png"></p><p><strong>示例</strong></p><pre><code class="line-numbers language-sh">&gt; db.inventory.insertMany( [...    { item: "mousepad", qty: 25, size: { h: 19, w: 22.85, uom: "cm" }, status: "P" },...    { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "P" },...    { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" }... ] );{        "acknowledged" : true,        "insertedIds" : [                ObjectId("5f1f96cf4326f1d6a51d3a80"),                ObjectId("5f1f96cf4326f1d6a51d3a81"),                ObjectId("5f1f96cf4326f1d6a51d3a82")        ]}&gt; db.inventory.updateOne(...    { item: "paper" },...    {...      $set: { "size.uom": "cm", status: "P" },...      $currentDate: { lastModified: true }...    }... ){ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a80"), "item" : "mousepad", "qty" : 25, "size" : { "h" : 19, "w" : 22.85, "uom" : "cm" }, "status" : "P" }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a81"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "P" }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a82"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "cm" }, "status" : "P", "lastModified" : ISODate("2020-07-28T03:09:17.014Z") }</code></pre><p>updateMany</p><pre><code class="line-numbers language-sh">&gt; db.inventory.updateMany(...    { "qty": { $lt: 50 } },...    {...      $set: { "size.uom": "in", status: "P" },...      $currentDate: { lastModified: true }...    }... ){ "acknowledged" : true, "matchedCount" : 3, "modifiedCount" : 3 }&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a80"), "item" : "mousepad", "qty" : 25, "size" : { "h" : 19, "w" : 22.85, "uom" : "in" }, "status" : "P", "lastModified" : ISODate("2020-07-28T04:33:50.391Z") }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a81"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "P" }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a82"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "cm" }, "status" : "P", "lastModified" : ISODate("2020-07-28T03:09:17.014Z") }</code></pre><p>replace one</p><pre><code class="line-numbers language-sh">&gt; db.inventory.replaceOne(...    { item: "paper" },...    { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 40 } ] }... ){ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a80"), "item" : "mousepad", "qty" : 25, "size" : { "h" : 19, "w" : 22.85, "uom" : "in" }, "status" : "P", "lastModified" : ISODate("2020-07-28T04:33:50.391Z") }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a81"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "P" }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a82"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 40 } ] }</code></pre><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p><strong>图例</strong></p><p><img src="/attachment%5C2bc5d015fbb226792deab15c04857fd0.png"></p><p><strong>示例</strong></p><pre><code class="line-numbers language-sh">&gt; db.inventory.deleteMany({ status : "P" }){ "acknowledged" : true, "deletedCount" : 2 }&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a82"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 40 } ] }</code></pre><h2 id="BulkWrite"><a href="#BulkWrite" class="headerlink" title="BulkWrite"></a>BulkWrite</h2><blockquote><p>本质是就是将上述的操作批量化。</p></blockquote><pre><code class="line-numbers language-sh">try {   db.characters.bulkWrite(      [         { insertOne :            {               "document" :               {                  "_id" : 4, "char" : "Dithras", "class" : "barbarian", "lvl" : 4               }            }         },         { insertOne :            {               "document" :               {                  "_id" : 5, "char" : "Taeln", "class" : "fighter", "lvl" : 3               }            }         },         { updateOne :            {               "filter" : { "char" : "Eldon" },               "update" : { $set : { "status" : "Critical Injury" } }            }         },         { deleteOne :            { "filter" : { "char" : "Brisbane"} }         },         { replaceOne :            {               "filter" : { "char" : "Meldane" },               "replacement" : { "char" : "Tanys", "class" : "oracle", "lvl" : 4 }            }         }      ]   );}catch (e) {   print(e);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 安装</title>
      <link href="/database/mongodb/mongodb-an-zhuang/"/>
      <url>/database/mongodb/mongodb-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="【MongoDB】-安装"><a href="#【MongoDB】-安装" class="headerlink" title="【MongoDB】 安装"></a>【MongoDB】 安装</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MongoDB】 安装date: 2022-12-20 18:00tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储description: 【MongoDB】 安装</code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><strong>官网下载</strong></li></ul><p><a href="https://www.mongodb.com/try/download/community">官网下载</a></p><ul><li><strong>官网文档</strong></li></ul><p><a href="https://docs.mongodb.com/v3.6/administration/install-community/">官网文档</a></p><ul><li><strong>菜鸟教程中安装</strong></li></ul><p><a href="https://www.runoob.com/mongodb/mongodb-window-install.html">菜鸟教程</a></p><h2 id="以Linux为例安装"><a href="#以Linux为例安装" class="headerlink" title="以Linux为例安装"></a>以Linux为例安装</h2><ul><li>yum源</li></ul><p>创建文件<code>/etc/yum.repos.d/mongodb-org-3.6.repo</code>, 加yum源：</p><pre><code class="line-numbers language-sh">[mongodb-org-3.6]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.6/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc</code></pre><ul><li>安装</li></ul><pre><code class="line-numbers language-sh">sudo yum install -y mongodb-org</code></pre><ul><li>运行</li></ul><pre><code class="line-numbers language-sh">[root@pdai yum.repos.d]# systemctl start mongod[root@pdai yum.repos.d]# sudo systemctl status mongod● mongod.service - MongoDB Database Server   Loaded: loaded (/usr/lib/systemd/system/mongod.service; enabled; vendor preset: disabled)   Active: active (running) since Tue 2020-07-28 09:59:55 CST; 26s ago     Docs: https://docs.mongodb.org/manual  Process: 8868 ExecStart=/usr/bin/mongod $OPTIONS (code=exited, status=0/SUCCESS)  Process: 8865 ExecStartPre=/usr/bin/chmod 0755 /var/run/mongodb (code=exited, status=0/SUCCESS)  Process: 8863 ExecStartPre=/usr/bin/chown mongod:mongod /var/run/mongodb (code=exited, status=0/SUCCESS)  Process: 8862 ExecStartPre=/usr/bin/mkdir -p /var/run/mongodb (code=exited, status=0/SUCCESS) Main PID: 8872 (mongod)   CGroup: /system.slice/mongod.service           └─8872 /usr/bin/mongod -f /etc/mongod.conf</code></pre><h2 id="连接和建库"><a href="#连接和建库" class="headerlink" title="连接和建库"></a>连接和建库</h2><pre><code class="line-numbers language-sh">[root@pdai yum.repos.d]# mongo --host 127.0.0.1:27017MongoDB shell version v3.6.19connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodbImplicit session: session { "id" : UUID("cb27e5a9-600f-4f57-9096-c7348a9ae5f9") }MongoDB server version: 3.6.19Welcome to the MongoDB shell.For interactive help, type "help".For more comprehensive documentation, see        http://docs.mongodb.org/Questions? Try the support group        http://groups.google.com/group/mongodb-userServer has startup warnings:2020-07-28T09:59:54.521+0800 I STORAGE  [initandlisten]2020-07-28T09:59:54.521+0800 I STORAGE  [initandlisten] ** WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine2020-07-28T09:59:54.521+0800 I STORAGE  [initandlisten] **          See http://dochub.mongodb.org/core/prodnotes-filesystem2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is 'always'.2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] **        We suggest setting it to 'never'2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is 'always'.2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] **        We suggest setting it to 'never'2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]&gt; show dbs;admin   0.000GBconfig  0.000GBlocal   0.000GB</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongDB】 整体生态</title>
      <link href="/database/mongodb/mongodb-zheng-ti-sheng-tai/"/>
      <url>/database/mongodb/mongodb-zheng-ti-sheng-tai/</url>
      
        <content type="html"><![CDATA[<h1 id="【MongDB】-整体生态"><a href="#【MongDB】-整体生态" class="headerlink" title="【MongDB】 整体生态"></a>【MongDB】 整体生态</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MongDB】 整体生态date: 2022-12-20 17:59tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongDB】 整体生态</code></pre><h2 id="整体生态"><a href="#整体生态" class="headerlink" title="整体生态"></a>整体生态</h2><p><img src="/attachment%5C48ded550d01a74c16eb9500740de971f.png"></p><h2 id="MongoDB-Server"><a href="#MongoDB-Server" class="headerlink" title="MongoDB Server"></a>MongoDB Server</h2><p><a href="https://www.mongodb.com/try/download/enterprise">Mongodb 企业版</a><br><a href="https://www.mongodb.com/try/download/community">Mongodb 社区版</a></p><h2 id="MongoDB-Cloud"><a href="#MongoDB-Cloud" class="headerlink" title="MongoDB Cloud"></a>MongoDB Cloud</h2><p><a href="https://www.mongodb.com/docs/launch-manage/">MongoDB Cloud</a></p><h2 id="MongoDB-Drivers"><a href="#MongoDB-Drivers" class="headerlink" title="MongoDB Drivers"></a>MongoDB Drivers</h2><p><a href="https://www.mongodb.com/docs/drivers/">MongoDB Drivers</a></p><h2 id="工具相关"><a href="#工具相关" class="headerlink" title="工具相关"></a>工具相关</h2><p><a href="https://docs.mongodb.com/tools/">MongoDB Tools</a></p><h3 id="MongoDB-Atlas-Open-Service-Broker"><a href="#MongoDB-Atlas-Open-Service-Broker" class="headerlink" title="MongoDB Atlas Open Service Broker"></a>MongoDB Atlas Open Service Broker</h3><p><a href="https://www.openservicebrokerapi.org/">Open Service Broker</a></p><h3 id="MongoDB-Connector-for-BI"><a href="#MongoDB-Connector-for-BI" class="headerlink" title="MongoDB Connector for BI"></a>MongoDB Connector for BI</h3><p><a href="https://docs.mongodb.com/bi-connector/current/">MongoDB Connector for BI</a></p><p>BI是指Business Intelligence，众所周知的BI工具有Tableau, MicroStrategy和Qlik等；而MongoDB BI Connector充当在mongod或mongos实例与BI工具之间转换查询和数据的层， 这样用户就可以使用SQL创建查询，可视化，图形化和报告等方式来展示MongoDB中的数据。</p><ul><li><code>MongoDB DB</code>: 数据的存储</li><li><code>BI Connector</code>: 提供一个关系模式(Schema)，以及BI工具和MongoDB之间转换SQL查询</li><li><code>ODBC data source name (DSN)</code>: 连接配置数据和认证等.</li><li><code>BI Tool</code>: 数据分析和展示工具.</li></ul><h3 id="MongoDB-Charts"><a href="#MongoDB-Charts" class="headerlink" title="MongoDB Charts"></a>MongoDB Charts</h3><p><a href="https://docs.mongodb.com/charts/saas/">MongoDB Charts</a></p><p>负责MongoDB数据可视化的一个工具。</p><h3 id="MongoDB-Database-Tools"><a href="#MongoDB-Database-Tools" class="headerlink" title="MongoDB Database Tools"></a>MongoDB Database Tools</h3><p><a href="https://docs.mongodb.com/database-tools/">MongoDB Database Tools</a></p><ul><li>二进制导入导出<ul><li>mongodump Creates a binary export of the contents of a mongod database.</li><li>mongorestore Restores data from a mongodump database dump into a mongod or mongos</li><li>bsondump Converts BSON dump files into JSON.</li></ul></li><li>数据导入导出<ul><li>mongoimport Imports content from an Extended JSON, CSV, or TSV export file.</li><li>mongoexport Produces a JSON or CSV export of data stored in a mongod instance.</li></ul></li><li>诊断工具<ul><li>mongostat Provides a quick overview of the status of a currently running mongod or mongos instance.</li><li>mongotop Provides an overview of the time a mongod instance spends reading and writing data.</li></ul></li><li>GridFS 工具<ul><li>mongofiles Supports manipulating files stored in your MongoDB instance in GridFS objects.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 基本概念</title>
      <link href="/database/mongodb/mongodb-ji-ben-gai-nian/"/>
      <url>/database/mongodb/mongodb-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="【MongoDB】-基本概念"><a href="#【MongoDB】-基本概念" class="headerlink" title="【MongoDB】 基本概念"></a>【MongoDB】 基本概念</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MongoDB】 基本概念date: 2022-12-20 17:56tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 基本概念</code></pre><h2 id="什么是NoSQL？"><a href="#什么是NoSQL？" class="headerlink" title="什么是NoSQL？"></a>什么是NoSQL？</h2><p>NoSQL是一种非关系型DMS，不需要固定的架构，可以避免joins链接，并且易于扩展。NoSQL数据库用于具有庞大数据存储需求的分布式数据存储。NoSQL用于大数据和实时Web应用程序。例如，像Twitter，Facebook，Google这样的大型公司，每天可能产生TB级的用户数据。</p><p>NoSQL数据库代表“不仅仅是SQL”或“不是SQL”。虽然NoRELNoSQL会是一个更好的名词。Carl Strozz在1998年引入了NoSQL概念。</p><p>传统的RDBMS使用SQL语法来存储和查询数据。相反，NoSQL数据库系统包含可存储结构化，半结构化，非结构化和多态数据的多种数据库技术。</p><p><img src="/attachment%5C69f491444732255e9ef2563d08f2707d.png"></p><h2 id="为什么使用NoSQL？"><a href="#为什么使用NoSQL？" class="headerlink" title="为什么使用NoSQL？"></a>为什么使用NoSQL？</h2><p>NoSQL数据库的概念在处理大量数据的互联网巨头（例如Google，Facebook，Amazon等）中变得很流行。使用RDBMS处理海量数据时，系统响应时间变慢。</p><p>为了解决此问题，当然可以通过升级现有硬件来“横向扩展”我们的系统。但这个成本很高。</p><p>这个问题的替代方案是在负载增加时将数据库负载分配到多个主机上。这种方法称为“横向扩展”。</p><p><img src="/attachment%5C7cac0f56ab2509ae914acbb84ce97e28.png"></p><p>NoSQL数据库是非关系数据库，因此在设计时考虑到Web应用程序，比关系数据库更好地扩展。</p><h3 id="NoSQL数据库的简要历史"><a href="#NoSQL数据库的简要历史" class="headerlink" title="NoSQL数据库的简要历史"></a>NoSQL数据库的简要历史</h3><ul><li>1998年-Carlo Strozzi在他的轻量级开源关系数据库中使用术语NoSQL</li><li>2000年-图形数据库Neo4j启动</li><li>2004年-推出Google BigTable</li><li>2005年-启动CouchDB</li><li>2007年-发布有关Amazon Dynamo的研究论文</li><li>2008年-Facebook开源Cassandra项目</li><li>2009年-重新引入NoSQL术语</li></ul><h3 id="NoSQL的功能"><a href="#NoSQL的功能" class="headerlink" title="NoSQL的功能"></a>NoSQL的功能</h3><ul><li>非关系<ul><li>NoSQL数据库从不遵循关系模型</li><li>切勿为tables 提供固定的固定列记录</li><li>使用自包含的聚合或BLOB</li><li>不需要对象关系映射和数据规范化</li><li>没有复杂的功能，例如查询语言，查询计划者，</li><li>参照完整性联接，ACID</li></ul></li><li>动态架构<ul><li>NoSQL数据库是无模式的或具有宽松模式的数据库</li><li>不需要对数据架构进行任何形式的定义</li><li>提供同一域中的异构数据结构</li></ul></li></ul><p><img src="/attachment%5Cb82e3f333011634a1f4b432f2f1d1532.png"></p><ul><li>简单的API<ul><li>提供易于使用的界面，用于存储和查询提供的数据</li><li>API允许进行低级数据操作和选择方法</li><li>基于文本的协议，通常与带有JSON的HTTP REST一起使用</li><li>多数不使用基于标准的查询语言</li><li>支持Web的数据库作为面向互联网的服务运行</li></ul></li><li>分布式<ul><li>可以以分布式方式执行多个NoSQL数据库</li><li>提供自动缩放和故障转移功能</li><li>通常可牺牲ACID概念来实现可伸缩性和吞吐量</li><li>分布式节点之间几乎没有同步复制，多为异步多主复制，对等，HDFS复制</li><li>仅提供最终的一致性</li><li>无共享架构。这样可以减少协调并提高分布。</li></ul></li></ul><p><img src="/attachment%5C9558c72894de678a64e4535c12813258.png"></p><h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h2><p>MongoDB是面向文档的NoSQL数据库，用于大量数据存储。MongoDB是一个在2000年代中期问世的数据库。属于NoSQL数据库的类别。</p><h3 id="MongoDB功能"><a href="#MongoDB功能" class="headerlink" title="MongoDB功能"></a>MongoDB功能</h3><p>每个数据库都包含集合，而集合又包含文档。每个文档可以具有不同数量的字段。每个文档的大小和内容可以互不相同。 文档结构更符合开发人员如何使用各自的编程语言构造其类和对象。开发人员经常会说他们的类不是行和列，而是具有键值对的清晰结构。 从NoSQL数据库的简介中可以看出，行（或在MongoDB中调用的文档）不需要预先定义架构。相反，可以动态创建字段。 MongoDB中可用的数据模型使我们可以更轻松地表示层次结构关系，存储数组和其他更复杂的结构。 可伸缩性– MongoDB环境具有很高的可伸缩性。全球各地的公司已经定义了自己的集群，其中一些集群运行着100多个节点，数据库中包含大约数百万个文档。</p><h3 id="为什么使用MongoDB"><a href="#为什么使用MongoDB" class="headerlink" title="为什么使用MongoDB"></a>为什么使用MongoDB</h3><p>以下是一些为什么应该开始使用MongoDB的原因</p><ul><li><strong>面向文档的</strong>–由于MongoDB是NoSQL类型的数据库，它不是以关系类型的格式存储数据，而是将数据存储在文档中。这使得MongoDB非常灵活，可以适应实际的业务环境和需求。</li><li><strong>临时查询</strong>-MongoDB支持按字段，范围查询和正则表达式搜索。可以查询返回文档中的特定字段。</li><li><strong>索引</strong>-可以创建索引以提高MongoDB中的搜索性能。MongoDB文档中的任何字段都可以建立索引。</li><li><strong>复制</strong>-MongoDB可以提供副本集的高可用性。副本集由两个或多个mongo数据库实例组成。每个副本集成员可以随时充当主副本或辅助副本的角色。主副本是与客户端交互并执行所有读/写操作的主服务器。辅助副本使用内置复制维护主数据的副本。当主副本发生故障时，副本集将自动切换到辅助副本，然后它将成为主服务器。</li><li><strong>负载平衡</strong>-MongoDB使用分片的概念，通过在多个MongoDB实例之间拆分数据来水平扩展。MongoDB可以在多台服务器上运行，以平衡负载或复制数据，以便在硬件出现故障时保持系统正常运行。</li></ul><h2 id="MongoDB常用术语"><a href="#MongoDB常用术语" class="headerlink" title="MongoDB常用术语"></a>MongoDB常用术语</h2><ul><li><code>_id</code> – 这是每个MongoDB文档中必填的字段。<code>_id</code>字段表示MongoDB文档中的唯一值。<code>_id</code>字段类似于文档的主键。如果创建的新文档中没有<code>_id</code>字段，MongoDB将自动创建该字段。</li><li><code>集合</code> – 这是MongoDB文档的分组。集合等效于在任何其他RDMS（例如Oracle或MS SQL）中创建的表。集合存在于单个数据库中。从介绍中可以看出，集合不强制执行任何结构。</li><li><code>游标</code> – 这是指向查询结果集的指针。客户可以遍历游标以检索结果。</li><li><code>数据库</code> – 这是像RDMS中那样的集合容器，其中是表的容器。每个数据库在文件系统上都有其自己的文件集。MongoDB服务器可以存储多个数据库。</li><li><code>文档</code> - MongoDB集合中的记录基本上称为文档。文档包含字段名称和值。</li><li><code>字段</code> - 文档中的名称/值对。一个文档具有零个或多个字段。字段类似于关系数据库中的列。</li></ul><h2 id="MongoDB与RDBMS区别"><a href="#MongoDB与RDBMS区别" class="headerlink" title="MongoDB与RDBMS区别"></a>MongoDB与RDBMS区别</h2><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td>表连接,MongoDB不支持</td><td></td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/database/redis/redis/"/>
      <url>/database/redis/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Redisdate: 2022-12-20 17:52tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</code></pre><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><blockquote><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p></blockquote><p>Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。</p><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p><h2 id="为什么要使用Redis"><a href="#为什么要使用Redis" class="headerlink" title="为什么要使用Redis"></a>为什么要使用Redis</h2><ul><li>读写性能优异<ul><li>Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。</li></ul></li><li>数据类型丰富<ul><li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li></ul></li><li>原子性<ul><li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ul></li><li>丰富的特性<ul><li>Redis支持 publish/subscribe, 通知, key 过期等特性。</li></ul></li><li>持久化<ul><li>Redis支持RDB, AOF等持久化方式</li></ul></li><li>发布订阅<ul><li>Redis支持发布/订阅模式</li></ul></li><li>分布式<ul><li>Redis Cluster</li></ul></li></ul><h2 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h2><h3 id="热点数据的缓存"><a href="#热点数据的缓存" class="headerlink" title="热点数据的缓存"></a>热点数据的缓存</h3><p>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p><p>作为缓存使用时，一般有两种方式保存数据：</p><ul><li>读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。</li><li>插入数据时，同时写入Redis。</li></ul><p>方案一：实施起来简单，但是有两个需要注意的地方：</p><ul><li>避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）</li><li>数据的实时性相对会差一点。</li></ul><p>方案二：数据实时性强，但是开发时不便于统一处理。</p><p>当然，两种方式根据实际情况来适用。如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。</p><h3 id="限时业务的运用"><a href="#限时业务的运用" class="headerlink" title="限时业务的运用"></a>限时业务的运用</h3><p>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p><h3 id="计数器相关问题"><a href="#计数器相关问题" class="headerlink" title="计数器相关问题"></a>计数器相关问题</h3><p>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p><p>在分布式锁的场景中，主要用在比如秒杀系统等。</p><h3 id="延时操作"><a href="#延时操作" class="headerlink" title="延时操作"></a>延时操作</h3><p>比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。</p><p>当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p><h3 id="排行榜相关问题"><a href="#排行榜相关问题" class="headerlink" title="排行榜相关问题"></a>排行榜相关问题</h3><p>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。</p><p>比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p><h3 id="点赞、好友等相互关系的存储"><a href="#点赞、好友等相互关系的存储" class="headerlink" title="点赞、好友等相互关系的存储"></a>点赞、好友等相互关系的存储</h3><p>Redis 利用集合的一些命令，比如求交集、并集、差集等。</p><p>在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p><h3 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h3><p>由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</p><h2 id="数据结构和对象"><a href="#数据结构和对象" class="headerlink" title="数据结构和对象"></a>数据结构和对象</h2><p>undefined</p><h2 id="单机库的实现"><a href="#单机库的实现" class="headerlink" title="单机库的实现"></a>单机库的实现</h2><p>undefined</p><h2 id="多机库实现"><a href="#多机库实现" class="headerlink" title="多机库实现"></a>多机库实现</h2><p>undefined</p><h2 id="重点功能"><a href="#重点功能" class="headerlink" title="重点功能"></a>重点功能</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/database/mysql/mysql/"/>
      <url>/database/mysql/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: MySQLdate: 2022-12-20 17:14tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: MySQL</code></pre><h2 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h2><p> MySQL是一个开源的关系型数据库管理系统（RDBMS），它是使用C和C++编写的，并以GPL（GNU通用公共许可证）发布。MySQL是最流行的开源数据库之一，广泛用于Web应用程序的开发。</p><p><img src="/attachment/a029dedcfa846b84e92c374bf30f4135.png"></p><h3 id="MySQL具有以下特点："><a href="#MySQL具有以下特点：" class="headerlink" title="MySQL具有以下特点："></a>MySQL具有以下特点：</h3><p>可靠性：MySQL具有高度的稳定性和可靠性，可以处理大量数据和高并发访问。<br>可扩展性：MySQL支持水平和垂直的扩展，可以根据需求增加服务器、集群或分区。<br>灵活性：MySQL支持多种存储引擎，如InnoDB、MyISAM等，可以根据应用程序的要求选择合适的存储引擎。<br>高性能：MySQL通过优化查询语句、索引和缓存等方式提供高性能的数据访问。<br>安全性：MySQL提供了访问控制和权限管理机制，可以保护数据的安全性。<br>跨平台性：MySQL可在各种操作系统上运行，包括Windows、Linux、Mac等。</p><h2 id="【MySQL】-数据类型"><a href="#【MySQL】-数据类型" class="headerlink" title="【MySQL】 数据类型"></a>【MySQL】 数据类型</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-数据目录"><a href="#【MySQL】-数据目录" class="headerlink" title="【MySQL】 数据目录"></a>【MySQL】 数据目录</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-字符集"><a href="#【MySQL】-字符集" class="headerlink" title="【MySQL】 字符集"></a>【MySQL】 字符集</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-索引"><a href="#【MySQL】-索引" class="headerlink" title="【MySQL】 索引"></a>【MySQL】 索引</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-存储引擎"><a href="#【MySQL】-存储引擎" class="headerlink" title="【MySQL】 存储引擎"></a>【MySQL】 存储引擎</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-InnoDB"><a href="#【MySQL】-InnoDB" class="headerlink" title="【MySQL】 InnoDB"></a>【MySQL】 InnoDB</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-B-树索引"><a href="#【MySQL】-B-树索引" class="headerlink" title="【MySQL】 B+树索引"></a>【MySQL】 B+树索引</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-InnoDB的表空间"><a href="#【MySQL】-InnoDB的表空间" class="headerlink" title="【MySQL】 InnoDB的表空间"></a>【MySQL】 InnoDB的表空间</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-单表访问方法"><a href="#【MySQL】-单表访问方法" class="headerlink" title="【MySQL】 单表访问方法"></a>【MySQL】 单表访问方法</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-连接的原理"><a href="#【MySQL】-连接的原理" class="headerlink" title="【MySQL】 连接的原理"></a>【MySQL】 连接的原理</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-MySQL基于成本的优化"><a href="#【MySQL】-MySQL基于成本的优化" class="headerlink" title="【MySQL】 MySQL基于成本的优化"></a>【MySQL】 MySQL基于成本的优化</h2><p>undefined</p><h2 id="【MySQL】-InnoDB-的统计数据收集"><a href="#【MySQL】-InnoDB-的统计数据收集" class="headerlink" title="【MySQL】 InnoDB 的统计数据收集"></a>【MySQL】 InnoDB 的统计数据收集</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-MySQL基于规则的优化"><a href="#【MySQL】-MySQL基于规则的优化" class="headerlink" title="【MySQL】 MySQL基于规则的优化"></a>【MySQL】 MySQL基于规则的优化</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-InnoDB的Buffer-Pool"><a href="#【MySQL】-InnoDB的Buffer-Pool" class="headerlink" title="【MySQL】 InnoDB的Buffer Pool"></a>【MySQL】 InnoDB的Buffer Pool</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-Explain详解"><a href="#【MySQL】-Explain详解" class="headerlink" title="【MySQL】 Explain详解"></a>【MySQL】 Explain详解</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-optimizer-trace表"><a href="#【MySQL】-optimizer-trace表" class="headerlink" title="【MySQL】 optimizer trace表"></a>【MySQL】 optimizer trace表</h2><p>undefined</p><h2 id="【MySQL】-事务"><a href="#【MySQL】-事务" class="headerlink" title="【MySQL】 事务"></a>【MySQL】 事务</h2><p>undefined</p><h2 id="【MySQL】-日志-redo"><a href="#【MySQL】-日志-redo" class="headerlink" title="【MySQL】 日志 - redo"></a>【MySQL】 日志 - redo</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-日志-undo"><a href="#【MySQL】-日志-undo" class="headerlink" title="【MySQL】 日志 - undo"></a>【MySQL】 日志 - undo</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-事务的隔离级别与-MVCC"><a href="#【MySQL】-事务的隔离级别与-MVCC" class="headerlink" title="【MySQL】 事务的隔离级别与 MVCC"></a>【MySQL】 事务的隔离级别与 MVCC</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-锁"><a href="#【MySQL】-锁" class="headerlink" title="【MySQL】 锁"></a>【MySQL】 锁</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB的MVCC实现机制</title>
      <link href="/database/mysql/mysql-innodb-de-mvcc-shi-xian-ji-zhi/"/>
      <url>/database/mysql/mysql-innodb-de-mvcc-shi-xian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-InnoDB的MVCC实现机制"><a href="#【MySQL】-InnoDB的MVCC实现机制" class="headerlink" title="【MySQL】 InnoDB的MVCC实现机制"></a>【MySQL】 InnoDB的MVCC实现机制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 InnoDB的MVCC实现机制date: 2022-12-20 17:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</code></pre><h2 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC?"></a>什么是MVCC?</h3><blockquote><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p></blockquote><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p><h3 id="什么是当前读和快照读？"><a href="#什么是当前读和快照读？" class="headerlink" title="什么是当前读和快照读？"></a>什么是当前读和快照读？</h3><p>在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p><ul><li>当前读</li></ul><p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</p><ul><li>快照读</li></ul><p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><blockquote><p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p></blockquote><h3 id="当前读，快照读和MVCC的关系"><a href="#当前读，快照读和MVCC的关系" class="headerlink" title="当前读，快照读和MVCC的关系"></a>当前读，快照读和MVCC的关系</h3><ul><li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念</li><li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</li><li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 4个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</li></ul><h3 id="MVCC能解决什么问题，好处是？"><a href="#MVCC能解决什么问题，好处是？" class="headerlink" title="MVCC能解决什么问题，好处是？"></a>MVCC能解决什么问题，好处是？</h3><h4 id="数据库并发场景"><a href="#数据库并发场景" class="headerlink" title="数据库并发场景?"></a>数据库并发场景?</h4><p>有三种, 分别为：</p><ul><li><strong>读-读</strong>：不存在任何问题，也不需要并发控制</li><li><strong>读-写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li><strong>写-写</strong>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li></ul><h4 id="MVCC带来的好处是？"><a href="#MVCC带来的好处是？" class="headerlink" title="MVCC带来的好处是？"></a>MVCC带来的好处是？</h4><p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><p>总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p><ul><li>MVCC + 悲观锁 MVCC解决读写冲突，悲观锁解决写写冲突</li><li>MVCC + 乐观锁 MVCC解决读写冲突，乐观锁解决写写冲突</li></ul><p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p><h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。</p><h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><ul><li><strong>DB_ROW_ID</strong> 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li><li><strong>DB_TRX_ID</strong> 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li><li><strong>DB_ROLL_PTR</strong> 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li><li><strong>DELETED_BIT</strong> 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul><p><img src="/attachment%5Ce118090fcf0177f0f7822e621043d9ff.png"></p><p>如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID是当前操作该记录的事务ID； 而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本；delete flag没有展示出来。</p><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>InnoDB把这些为了回滚而记录的这些东西称之为undo log。这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。undo log主要分为3种：</p><ul><li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li><li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。<ul><li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul></li></ul><p>对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：</p><ul><li>比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL</li></ul><p><img src="/attachment%5C32b2e59352be8b865dedc27e777bd42c.png"></p><ul><li>现在来了一个事务1对该记录的name做出了修改，改为Tom<ul><li>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</li><li>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</li><li>事务提交后，释放锁</li></ul></li></ul><p><img src="/attachment%5Cb3044c19328d0bc158495ef9975fa0f8.png"></p><ul><li>又来了个事务2修改person表的同一个记录，将age修改为30岁<ul><li>在事务2修改该行数据时，数据库也先为该行加锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li><li>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</li><li>事务提交，释放锁</li></ul></li></ul><p><img src="/attachment%5C9b771e5c63c8522f6e4032768194a856.png"></p><p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p><h3 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h3><blockquote><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p></blockquote><p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本</p><p>在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性</p><blockquote><ul><li>trx_list 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID</li><li>up_limit_id 记录trx_list列表中事务ID最小的ID</li><li>low_limit_id ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</li></ul></blockquote><ul><li>首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li><li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li><li>判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</li></ul><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了</p><p>整体的流程是怎么样的呢？我们可以模拟一下</p><p>当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 主从复制与读写分离</title>
      <link href="/database/mysql/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/"/>
      <url>/database/mysql/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-主从复制与读写分离"><a href="#【MySQL】-主从复制与读写分离" class="headerlink" title="【MySQL】 主从复制与读写分离"></a>【MySQL】 主从复制与读写分离</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 主从复制与读写分离date: 2022-12-20 17:11tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 主从复制与读写分离</code></pre><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 : 负责将主服务器上的数据更改写入二进制日志中。</li><li>I/O 线程 : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li><li>SQL 线程 : 负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><img src="/attachment/dc7c140f0d85ed1557899540327b8f2e.png"></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于:</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="/attachment/c46d4e50028a21affc1855ecd3a6a31e.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 分库分表</title>
      <link href="/database/mysql/mysql-fen-ku-fen-biao/"/>
      <url>/database/mysql/mysql-fen-ku-fen-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-分库分表"><a href="#【MySQL】-分库分表" class="headerlink" title="【MySQL】 分库分表"></a>【MySQL】 分库分表</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 分库分表date: 2022-12-20 17:10tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 分库分表</code></pre><h2 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h2><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><h2 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h2><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><h2 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h2><ul><li>哈希取模: hash(key) % NUM_DB</li><li>范围: 可以是 ID 范围也可以是时间范围</li><li>映射表: 使用单独的一个数据库来存储映射关系</li></ul><h2 id="Sharding-存在的问题及解决方案"><a href="#Sharding-存在的问题及解决方案" class="headerlink" title="Sharding 存在的问题及解决方案"></a>Sharding 存在的问题及解决方案</h2><h3 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h3><p>使用分布式事务来解决，比如 XA 接口。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。</p><h3 id="ID-唯一性"><a href="#ID-唯一性" class="headerlink" title="ID 唯一性"></a>ID 唯一性</h3><ul><li>使用全局唯一 ID: GUID</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 性能优化</title>
      <link href="/database/mysql/mysql-xing-neng-you-hua/"/>
      <url>/database/mysql/mysql-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-性能优化"><a href="#【MySQL】-性能优化" class="headerlink" title="【MySQL】 性能优化"></a>【MySQL】 性能优化</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 性能优化date: 2022-12-20 16:15tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 性能优化</code></pre><h2 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有:</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h3><ul><li>只返回必要的列: 最好不要使用 SELECT * 语句。</li><li>只返回必要的行: 使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id="减少服务器端扫描的行数"><a href="#减少服务器端扫描的行数" class="headerlink" title="减少服务器端扫描的行数"></a>减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><pre><code class="line-numbers language-sql">rows_affected = 0do {    rows_affected = do_query(    "DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")} while rows_affected &gt; 0</code></pre><h3 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><pre><code class="line-numbers language-sql">SELECT * FROM tabJOIN tag_post ON tag_post.tag_id=tag.idJOIN post ON tag_post.post_id=post.idWHERE tag.tag='mysql';</code></pre><pre><code class="line-numbers language-sql">SELECT * FROM tag WHERE tag='mysql';SELECT * FROM tag_post WHERE tag_id=1234;SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 索引</title>
      <link href="/database/mysql/mysql-suo-yin/"/>
      <url>/database/mysql/mysql-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-索引"><a href="#【MySQL】-索引" class="headerlink" title="【MySQL】 索引"></a>【MySQL】 索引</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 索引date: 2022-12-20 16:14tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>MySQL索引是在<strong>存储引擎层</strong>实现的，不同存储引擎具有不同的索引类型和实现方式。<ul><li><strong>B+Tree索引</strong>是大多数MySQL存储引擎的默认索引类型。它可以用于查找、排序和分组，适用于全键值、键值范围和键前缀查找。主索引是<strong>聚簇索引</strong>，辅助索引的叶子节点记录着主键的值。</li><li>哈希索引具有快速的查找速度，但失去了有序性，只支持精确查找，无法用于排序和分组。InnoDB存储引擎支持<strong>自适应哈希索引</strong>，在B+Tree索引之上创建哈希索引以提高查找速度。</li><li><strong>全文索引</strong>用于查找文本中的关键词，支持MATCH AGAINST语法。一般使用倒排索引实现。MyISAM和InnoDB存储引擎均支持全文索引。</li><li><strong>空间数据索引</strong>(R-Tree)用于地理数据存储，支持多维度组合查询，必须使用GIS函数来维护数据。只有MyISAM存储引擎支持空间数据索引。</li></ul></li><li>索引优化包括使用<strong>独立的列</strong>、<strong>多列索引</strong>、<strong>选择合适的索引顺序</strong>、<strong>使用前缀索引</strong>和<strong>覆盖索引</strong>等策略，以提高查询性能和减少数据访问量。</li><li>索引的优点包括<strong>减少扫描的数据行数</strong>、<strong>避免排序和分组操作</strong>、<strong>减少随机I/O操作</strong>等。</li><li>索引适用于中到大型表，对于小型表和特大型表需要综合考虑效率和成本，并可能使用其他技术如分区来提升查询性能。</li></ul><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><h3 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h3><p>让选择性最强的索引列放在前面，索引的选择性是指: 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>对于前缀长度的选取需要根据索引选择性来确定。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点:</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎(例如 MyISAM)在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用(通常比较费时)。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。</li><li>将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。</li></ul><h2 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li><li>对于中到大型的表，索引就非常有效。</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 B+树索引</title>
      <link href="/database/mysql/mysql-b-shu-suo-yin/"/>
      <url>/database/mysql/mysql-b-shu-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-B-树索引"><a href="#【MySQL】-B-树索引" class="headerlink" title="【MySQL】 B+树索引"></a>【MySQL】 B+树索引</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 B+树索引date: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 B+树索引</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/5e8716f5b84177f30a945ea56fee30bd.png"></p><ol><li>InnoDB中的索引方案：<ul><li>使用页作为存储单位。</li><li>目录项记录存储目录项的页，具有不同的record_type和列。</li><li>用户记录存放在B+树的最底层节点。</li><li><strong>聚簇索引</strong>：主键值搜索时有效，叶子节点存储完整的用户记录。</li><li><strong>二级索引</strong>：通过非主键列搜索，需要在聚簇索引中查找完整记录。</li><li><strong>联合索引</strong>：以多个列的大小作为排序规则建立索引。</li></ul></li><li>InnoDB的B+树索引注意事项：<ul><li><strong>根页面不移动</strong>。</li><li><strong>内节点中目录项记录的唯一性</strong>。</li><li><strong>页面最少存储2条记录</strong>。</li></ul></li><li>索引的使用</li><li>B+ 树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li><li>B+ 树索引适用于下边这些情况：<ul><li><strong>全值匹配</strong></li><li><strong>匹配左边的列</strong></li><li><strong>匹配范围值</strong></li><li><strong>精确匹配某一列并范围匹配另外一列</strong></li><li><strong>用于排序</strong></li><li><strong>用于分组</strong></li></ul></li><li>在使用索引时需要注意下边这些事项：<ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT 属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</li></ul></li></ol><h2 id="没有索引的查找"><a href="#没有索引的查找" class="headerlink" title="没有索引的查找"></a>没有索引的查找</h2><h3 id="在一个页中的查找"><a href="#在一个页中的查找" class="headerlink" title="在一个页中的查找"></a>在一个页中的查找</h3><ul><li>以主键为搜索条件<br>可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li><li>以其他列作为搜索条件<br>只能从最小记录开始依次遍历单链表中的每条记录</li></ul><h3 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h3><p>分为两个步骤</p><ol><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。</li></ol><p>由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>index_demo 举例</p><p><img src="/attachment/53e7396e9df54ca7190cd8b1be8e8e94.png"></p><ul><li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、2 表示最小记录、3 表示最大记录、1 我们还没用过，等会再说～</li><li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</li><li>各个列的值：这里只记录在index_demo 表中的三个列，分别是c1 、c2 和c3 。</li><li>其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><h3 id="一个简单的索引方案"><a href="#一个简单的索引方案" class="headerlink" title="一个简单的索引方案"></a>一个简单的索引方案</h3><p>新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着</p><p>通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为页分裂。</p><p><img src="/attachment/3032ab03a12c806ba14dace97835f1e1.png"></p><p><img src="/attachment/3d9d70c7b97da1939ace1387b2af92ed.png"></p><h3 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h3><p>InnoDB 是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB 的连续存储空间</p><p>复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<strong>目录项记录</strong></p><ul><li>目录项记录和普通的用户记录的不同点：</li><li>目录项记录的record_type 值是1，而普通用户记录的record_type 值是0。</li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB 自己添加的隐藏列。</li><li>还记得我们之前在唠叨记录头信息的时候说过一个叫min_rec_mask 的属性么，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask 值为1 ，其他别的记录的min_rec_mask 值都是0 。</li></ul><p><strong>实际用户记录其实都存放在B+树的最底层的节点上</strong><br>非叶子节点存储目录项</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p><strong>只能在搜索条件是主键值时才能发挥作用</strong></p><p>B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义</li></ol><ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul><ol start="2"><li>B+ 树的叶子节点存储的是完整的用户记录。</li></ol><p>把具有这两种特性的B+ 树称为<strong>聚簇索引</strong>, 所有完整的用户记录都存放在这个聚簇索引的叶子节点处。</p><p>InnoDB 存储引擎会自动的为我们创建聚簇索引，<br>在InnoDB 存储引擎中， 聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。</p><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>这个B+ 树与上边介绍的聚簇索引有几处不同</p><ul><li>使用记录c2 列的大小进行记录和页的排序，这包括三个方面的含义：<ul><li>页内的记录是按照c2 列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的c2 列大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2 列大小顺序排成一个双向链表。</li></ul></li><li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是<strong>c2列+主键这两个列的值</strong>。</li><li>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。</li></ul><p>如果我们现在想通过c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个B+ 树了。</p><ol><li>确定目录项记录页</li></ol><ul><li>根据根页面，也就是页44 ，可以快速定位到目录项记录所在的页为页42 （因为2 &lt; 4 &lt; 9 ）。</li></ul><ol start="2"><li>通过目录项记录页确定用户记录真实所在的页。</li></ol><ul><li>在页42 中可以快速定位到实际存储用户记录的页，但是由于c2 列并没有唯一性约束，所以c2 列值为4 的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4 ，所以确定实际存储用户记录的页在页34 和页35 中。</li></ul><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录。</li></ol><ul><li>到页34 和页35 中定位到具体的记录。</li></ul><ol start="4"><li>但是这个B+ 树的叶子节点中的记录只存储了c2 和c1 （也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li></ol><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>同时以多个列的大小作为排序规则，也就是同时为多个列建立索引</p><ul><li>先把各个记录和页按照c2 列进行排序。</li><li>在记录的c2 列相同的情况下，采用c3 列进行排序</li></ul><p><img src="/attachment/5e8716f5b84177f30a945ea56fee30bd.png"></p><ul><li>每条目录项记录都由c2 、c3 、页号这三个部分组成，各条记录先按照c2 列的值进行排序，如果记录的c2 列相同，则按照c3 列的值进行排序。</li><li>B+ 树叶子节点处的用户记录由c2 、c3 和主键c1 列组成。</li></ul><p>以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，，不同点如下</p><ul><li>建立联合索引只会建立如上图一样的1棵B+ 树。</li><li>为c2和c3列分别建立索引会分别以c2 和c3 列的大小为排序规则建立2棵B+ 树。</li></ul><h3 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h3><ul><li>根页面万年不动窝</li></ul><p>一个B+树索引的根节点自诞生之日起，便不会再移动</p><ul><li>内节点中目录项记录的唯一性</li></ul><p>B+ 树索引的内节点中目录项记录的内容是索引列 + 页号的搭配</p><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是<strong>唯一</strong>的。</p><p>对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的</p><ul><li><p>索引列的值</p></li><li><p>主键值</p></li><li><p>页号</p></li><li><p>一个页面最少存储2条记录</p></li></ul><h3 id="MyISAM中的索引方案简单介绍"><a href="#MyISAM中的索引方案简单介绍" class="headerlink" title="MyISAM中的索引方案简单介绍"></a>MyISAM中的索引方案简单介绍</h3><p>MyISAM 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p><p><img src="/attachment/09cb1fba274d4c535a4d2e97eb335ad1.png"></p><ul><li>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。</li><li>使用MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。 MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 行号的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！ <strong>MyISAM 中建立的索引相当于全部都是二级索引！</strong></li></ul><h2 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h2><ul><li>每个索引都对应一棵B+ 树， B+ 树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+ 树的叶子节点，所有目录项记录都存储在内节点。</li><li>InnoDB 存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li><li>我们可以为自己感兴趣的列建立二级索引， 二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li><li>B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li><li>通过索引查找记录是从B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory （页目录），所以在这些页面中的查找非常快。</li></ul><h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><p><strong>空间上的代价</strong></p><p>每一棵B+ 树的每一个节点都是一个数据页，一个页默认会占用16KB 的存储空间，一棵很大的B+ 树由许多数据页组成，那可是很大的一片存储空间</p><p><strong>时间上的代价</strong></p><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+ 树索引</p><h3 id="B-树索引适用的条件"><a href="#B-树索引适用的条件" class="headerlink" title="B+树索引适用的条件"></a>B+树索引适用的条件</h3><p><img src="/attachment/d558ddd7a59fdd09e941a154b8b154bb.png"></p><p>从图中可以看出，这个idx_name_birthday_phone_number 索引对应的B+ 树中页面和记录的排序方式就是这样的：</p><ul><li>先按照name 列的值进行排序。</li><li>如果name 列的值相同，则按照birthday 列的值进行排序。</li><li>如果birthday 列的值也相同，则按照phone_number 的值进行排序。</li></ul><p>因为只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找。</p><h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><pre><code class="line-numbers language-sql">SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';</code></pre><ul><li>因为B+ 树的数据页和记录先是按照name 列的值进行排序的，所以先可以很快定位name 列的值是Ashburn的记录位置。</li><li>在name 列相同的记录里又是按照birthday 列的值进行排序的，所以在name 列的值是Ashburn 的记录里又可以快速定位birthday 列的值是’1990-09-27’ 的记录。</li><li>如果很不幸， name 和birthday 列的值都是相同的，那记录是按照phone_number 列的值排序的，所以联合索引中的三个列都可能被用到。</li></ul><p>WHERE 子句中的几个搜索条件的顺序对查询结果有啥影响么？</p><p><strong>查询优化器</strong></p><p>分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。</p><h4 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h4><p>下边的语句就用不到这个B+ 树索引</p><pre><code class="line-numbers language-sql">SELECT * FROM person_info WHERE birthday = '1990-09-27';</code></pre><p>B+ 树的数据页和记录先是按照name 列的值排序的，在name 列的值相同的情况下才使用birthday 列进行排序，也就是说name 列的值不同的记录中birthday 的值可能是无序的。</p><p><strong>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</strong></p><h4 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h4><p>一个排好序的字符串列其实有这样的特点：</p><ul><li>先按照字符串的第一个字符进行排序。</li><li>如果第一个字符相同再按照第二个字符进行排序。</li><li>如果第二个字符相同再按照第三个字符进行排序，依此类推。</li></ul><h4 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h4><p>所有记录都是按照索引列的值从小到大的顺序排好序的</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-sql">SELECT * FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlow';</code></pre><hr><ol><li>找到name 值为Asa 的记录。</li><li>找到name 值为Barlow 的记录。</li><li>哦啦，由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来喽～</li><li>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</li></ol></div><p><strong>如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+ 树索引</strong></p><h4 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h4><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找</p><pre><code class="line-numbers language-sql">SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday &gt; '1980-01-01' AND birthday &lt; '2000-12-31' AND phone_number &gt; '15100000000';</code></pre><p>这个查询的条件可以分为3个部分：</p><ol><li>name = ‘Ashburn’ ，对name 列进行精确查找，当然可以使用B+ 树索引了。</li><li>birthday &gt; ‘1980-01-01’ AND birthday &lt; ‘2000-12-31’ ，由于name 列是精确查找，所以通过name = ‘Ashburn’ 条件查找后得到的结果的name 值都是相同的，它们会再按照birthday 的值进行排序。所以此时对birthday 列进行范围查找是可以用到B+ 树索引的。</li><li>phone_number &gt; ‘15100000000’ ，通过birthday 的范围查找的记录的birthday 的值可能不同，所以这个条件无法再利用B+ 树索引了，只能遍历上一步查询得到的记录。</li></ol><h4 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h4><h5 id="使用联合索引进行排序注意事项"><a href="#使用联合索引进行排序注意事项" class="headerlink" title="使用联合索引进行排序注意事项"></a>使用联合索引进行排序注意事项</h5><p>ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出, 否则索引失效</p><h5 id="不可以使用索引进行排序的几种情况"><a href="#不可以使用索引进行排序的几种情况" class="headerlink" title="不可以使用索引进行排序的几种情况"></a>不可以使用索引进行排序的几种情况</h5><p><strong>ASC、DESC混用</strong></p><p><strong>WHERE子句中出现非排序使用到的索引列</strong></p><p><strong>排序列包含非同一个索引的列</strong></p><p><strong>排序列使用了复杂的表达式</strong></p><h4 id="用于分组"><a href="#用于分组" class="headerlink" title="用于分组"></a>用于分组</h4><p>分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组</p><h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><p>在使用idx_name_birthday_phone_number 索引进行查询时大致可以分为这两个步骤</p><ol><li>从索引idx_name_birthday_phone_number 对应的B+ 树中取出name 值在Asa ～ Barlow 之间的用户记录。</li><li>由于索引idx_name_birthday_phone_number 对应的B+ 树用户记录中只包含name 、birthday 、phone_number 、id 这4个字段，而查询列表是* ，意味着要查询表中所有字段，也就是还要包括country字段。这时需要把从上一步中获取到的每一条记录的id 字段都到聚簇索引对应的B+ 树中找到完整的用户记录，也就是我们通常所说的回表，然后把完整的用户记录返回给查询用户。</li></ol><p><strong>需要回表的记录越多，使用二级索引的性能就越低</strong></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>最好在查询列表里只包含索引列</p><p>我们很不鼓励用* 号作为查询列表，最好把我们需要查询的列依次标明。</p><h3 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h3><p><strong>只为用于搜索、排序或分组的列创建索引</strong></p><p><strong>考虑列的基数</strong></p><p><strong>索引列的类型尽量小</strong></p><p><strong>索引字符串值的前缀</strong></p><p>只对字符串的前几个字符进行索引</p><p>只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</p><p><strong>让索引列在比较表达式中单独出现</strong></p><p><strong>主键插入顺序</strong></p><p><strong>冗余和重复索引</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB</title>
      <link href="/database/mysql/mysql-innodb/"/>
      <url>/database/mysql/mysql-innodb/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-InnoDB"><a href="#【MySQL】-InnoDB" class="headerlink" title="【MySQL】 InnoDB"></a>【MySQL】 InnoDB</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 InnoDBdate: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description:  MySQL 默认的事务型存储引擎，**只有在需要它不支持的特性时，才考虑使用其它存储引擎。**</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>InnoDB是MySQL的默认事务型存储引擎，除非需要其他引擎所支持的特性，否则应该优先考虑使用InnoDB。</p><h3 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h3><p><img src="/attachment/ffcf84f82ac6280384c56151ffc2bd25.png"></p><ol><li>InnoDB将数据划分为以页为单位的基本交互单元，页的大小通常为<strong>16KB</strong>。</li><li>行格式是指以<strong>记录</strong>为单位向表中<strong>插入数据</strong>的方式，也被称为记录格式。InnoDB支持多种行格式，包括<strong>Compact</strong>、<strong>Redundant</strong>、<strong>Dynamic</strong>和<strong>Compressed</strong>。</li><li>COMPACT行格式是InnoDB中的一种行格式，记录的<strong>额外信息</strong>包括<strong>变长字段长度列表</strong>和<strong>NULL值列表</strong>。变长字段长度列表存储了<strong>变长字段的真实数据占用的字节长度</strong>，NULL值列表表示记录中<strong>允许存储NULL值的列</strong>。<ol><li><strong>记录头信息</strong>是固定的5个字节，包含了记录的一些<strong>标识信息</strong>，如<strong>是否被删除</strong>、<strong>记录的拥有者数量</strong>等。</li><li>记录的<strong>真实数据</strong>包括<strong>隐藏列</strong>和<strong>用户自定义列</strong>，隐藏列包括<strong>row id</strong>、<strong>transaction_id</strong>和<strong>roll_pointer</strong>。<ol><li>InnoDB对主键的生成策略是优先使用用户自定义主键，如果没有定义主键则选择Unique键，如果连Unique键都没有则默认添加一个名为row_id的隐藏列作为主键。</li></ol></li><li>CHAR(M)列的存储格式取决于采用的字符集，定长字符集不会被加到变长字段长度列表，而变长字符集会被加到变长字段长度列表。</li></ol></li><li>REDUNDANT行格式是InnoDB中的另一种行格式，包括<strong>字段长度偏移列表</strong>和<strong>记录头信息</strong>。字段长度偏移列表按<strong>逆序</strong>存储了记录中<strong>各列的长度信息</strong>。</li><li>行溢出数据指<strong>记录中超出页空间限制的部分</strong>，如VARCHAR(M)类型的数据。行溢出数据存储在其他页中，存储在记录中的是该列的部分数据和指向溢出页的地址。</li><li><strong>DYNAMIC</strong>和<strong>COMPRESSED</strong>行格式是InnoDB中的其他行格式，它们在处理行溢出数据时与COMPACT和REDUNDANT有所不同，DYNAMIC和COMPRESSED行格式会将所有字节存储在其他页面中，并在记录的真实数据处存储其他页面的地址。COMRESSED行格式还使用<strong>压缩算法</strong>对页面进行压缩以节省空间。</li></ol><h3 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h3><p><img src="/attachment/a31994d655b51a3ad784cdb78a37cdec.png"></p><ol><li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于<strong>存放记录</strong>的页叫做<strong>数据页</strong>。</li><li>一个数据页可以被大致划分为7个部分，分别是<ul><li><strong>File Header</strong> ，表示<strong>页的一些通用信息</strong>，占固定的38字节。</li><li><strong>Page Header</strong> ，表示<strong>数据页专有的一些信息</strong>，占固定的56个字节。</li><li><strong>Infimum + Supremum</strong> ，两个<strong>虚拟的伪记录</strong>，分别表示页中的<strong>最小和最大记录</strong>，占固定的26 个字节。</li><li><strong>User Records</strong> ：<strong>真实存储我们插入的记录</strong>的部分，大小不固定。</li><li><strong>Free Space</strong> ：<strong>页中尚未使用的部分</strong>，大小不确定。</li><li><strong>Page Directory</strong> ：<strong>页中的某些记录相对位置</strong>，也就是<strong>各个槽在页面中的地址偏移量</strong>，大小不固定，插入的记录越多，这个部分占用的空间越多。</li><li><strong>File Trailer</strong> ：用于<strong>检验页是否完整</strong>的部分，占用固定的8个字节。</li></ul></li><li>每个记录的头信息中都有一个<strong>next_record</strong> 属性，从而使页中的所有记录串联成一个单链表。</li><li>InnoDB 会为把<strong>页中的记录</strong>划分为若干个<strong>组</strong>，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory 中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul><li>通过<strong>二分法</strong>确定该记录所在的槽。</li><li>通过记录的<strong>next_record属性遍历</strong>该槽所在的组中的各个记录。</li></ul></li><li>每个数据页的File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<strong>双链表</strong>。</li><li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的<strong>校验和</strong>和页面最后修改时<strong>对应的LSN 值</strong>，如果首部和尾部的校验和和LSN 值校验不成功的话，就说明同步过程出现了问题。</li></ol><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p> MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎。</strong></p><p>将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16KB。</p><h2 id="行格式-1"><a href="#行格式-1" class="headerlink" title="行格式"></a>行格式</h2><p>以<strong>记录</strong>为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为<strong>行格式</strong>或者<strong>记录格式</strong>。</p><p>分别是Compact、Redundant、Dynamic和Compressed行格式</p><h3 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h3><p><img src="/attachment/ffcf84f82ac6280384c56151ffc2bd25.png"></p><h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>服务器为了描述这条记录而不得不额外添加的一些信息</p><h5 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h5><p>变长字段占用的存储空间: </p><ol><li>真正的数据内容</li><li>占用的字节数</li></ol><p>把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序<strong>逆序</strong>存放</p><p>表示真实数据占用的字节数, InnoDB 有它的一套规则，我们首先声明一下W 、M 和L 的意思：</p><ul><li>假设某个字符集中表示一个字符最多需要使用的字节数为W, 如 utf-8 W=3</li><li>对于变长类型VARCHAR(M) 来说，这种类型表示能存储最多M 个字符, 这个类型能表示的字符串最多占用的字节数就是M×W</li><li>假设它实际存储的字符串占用的字节数是L 。</li></ul><p><strong>规则</strong></p><ul><li>如果M×W &lt;= 255 ，那么使用1个字节来表示真正字符串占用的字节数。</li><li>如果M×W &gt; 255 ，则分为两种情况：<ul><li>如果L &lt;= 127 ，则用1个字节来表示真正字符串占用的字节数。</li><li>如果L &gt; 127 ，则用2个字节来表示真正字符串占用的字节数。</li></ul></li></ul><p>总结一下就是说：如果该可变字段允许存储的最大字节数（ M×W ）超过255字节并且真实存储的字节数（ L ）超过127字节，则使用2个字节，否则使用1个字节。</p><p><strong>变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的</strong></p><h5 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h5><ul><li>首先统计表中允许存储NULL 的列有哪些。</li><li>如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列</li><li>MySQL 规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0 。</li></ul><h5 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h5><p>固定的5 个字节组成。5 个字节也就是40 个二进制位，不同的位代表不同的意思</p><p><img src="/attachment/92b510b3a75ffc30bdf391748efce9ac.png"></p><table><thead><tr><th>名称</th><th>大小(单位: bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>“表示当前记录的类型,0表示普通记录,1表示B+树非叶子节点记录,2表示最小记录,3 表示最大记录”</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>MySQL 会为每个记录默认的添加一些列（也称为隐藏列）</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row id</td><td>否</td><td>6字节</td><td>“行ID,唯一标识一条记录”</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p><strong>InnoDB 表对主键的生成策略</strong></p><ul><li>优先使用用户自定义主键作为主键</li><li>，如果用户没有定义主键，则选取一个Unique 键作为主键</li><li>如果表中连Unique 键都没有定义的话，则InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键</li></ul><p><strong>InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的</strong></p><p><img src="/attachment/164897cb2e3fc44d89528b0d3cf79ca4.png"></p><h4 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h4><p>对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，<br>而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</p><h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p><img src="/attachment/c8a585e1b88c21da69c71bd0d5b6d2ac.png"></p><p><img src="/attachment/e615d50c68ae175b01974487ee04f066.png"></p><p><img src="/attachment/58357277011ad88f08775b314c6f05a1.png"></p><h4 id="字段长度偏移列表"><a href="#字段长度偏移列表" class="headerlink" title="字段长度偏移列表"></a>字段长度偏移列表</h4><ul><li>Redundant 行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表</li><li>多了个偏移两个字，这意味着计算列值长度的方式不像Compact 行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。</li></ul><h4 id="记录头信息-1"><a href="#记录头信息-1" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>Redundant 行格式的记录头信息占用6 字节， 48 个二进制位</p><h5 id="Redundant-行格式中NULL-值的处理"><a href="#Redundant-行格式中NULL-值的处理" class="headerlink" title="Redundant 行格式中NULL 值的处理"></a>Redundant 行格式中NULL 值的处理</h5><p>字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为NULL 的依据，该比特位也可以被称之为NULL比特位。</p><p>在解析一条记录的某个列时，首先看一下该列对应的偏移量的NULL比特位是不是为1 ，如果为1 ，那么该列的值就是NULL ，否则不是NULL 。</p><h5 id="CHAR-M-列的存储格式-1"><a href="#CHAR-M-列的存储格式-1" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h5><p>只要是使用CHAR(M) 类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和M 的乘积。</p><h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><h5 id="VARCHAR-M-最多能存储的数据"><a href="#VARCHAR-M-最多能存储的数据" class="headerlink" title="VARCHAR(M)最多能存储的数据"></a>VARCHAR(M)最多能存储的数据</h5><p>M 最大值是 65535 / W</p><h5 id="记录中的数据太多产生的溢出"><a href="#记录中的数据太多产生的溢出" class="headerlink" title="记录中的数据太多产生的溢出"></a>记录中的数据太多产生的溢出</h5><p>在本记录的真实数据处只会存储该列的前768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做<strong>行溢出</strong>，存储超出768 字节的那些页面也被称为<strong>溢出页</strong>。</p><p><img src="/attachment/fa846e68587c3abb51a847d2138c0d10.png"></p><h5 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h5><p>MySQL 中规定一个页中至少存放两行记录</p><p>一个行中存储了很大的数据时，可能发生行溢出的现象</p><h3 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h3><p>版本是5.7 ，它的默认行格式就是<strong>Dynamic</strong></p><p>这俩行格式和Compact 行格式挺像，只不过在处理行溢出数据时有点儿分歧<br>把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址</p><p><img src="/attachment/65e9f4a9a902df32abf850d2fc6caaba.png"></p><p>Compressed 行格式和Dynamic 不同的一点是， Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间。</p><h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><h3 id="不同类型的页简介"><a href="#不同类型的页简介" class="headerlink" title="不同类型的页简介"></a>不同类型的页简介</h3><p>一个页的大小一般是16KB</p><p>InnoDB 为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE 信息的页，存放undo 日志信息的页等等等等</p><p>存放记录的页为索引（ INDEX ）页</p><h3 id="数据页结构的快速浏览"><a href="#数据页结构的快速浏览" class="headerlink" title="数据页结构的快速浏览"></a>数据页结构的快速浏览</h3><p><img src="/attachment/a31994d655b51a3ad784cdb78a37cdec.png"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56 字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td>26字节</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8 字节</td><td>校验页是否完整</td></tr></tbody></table><h3 id="记录在页中的存储"><a href="#记录在页中的存储" class="headerlink" title="记录在页中的存储"></a>记录在页中的存储</h3><p><img src="/attachment/f7714d3da222a5413d0ae4326b8fb6b5.png"></p><h4 id="记录头信息的秘密"><a href="#记录头信息的秘密" class="headerlink" title="记录头信息的秘密"></a>记录头信息的秘密</h4><ul><li>delete_mask</li></ul><p>这个属性标记着当前记录是否被删除，占用1个二进制位，值为0 的时候代表记录并没有被删除，为1 的时候代表记录被删除掉了。</p><p>这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗</p><p>所有被删除掉的记录都会组成一个所谓的<strong>垃圾链表</strong>，在这个链表中的记录占用的空间称之为所谓的<strong>可重用空间</strong>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><ul><li>min_rec_mask</li></ul><p>B+树的每层非叶子节点中的最小记录都会添加该标记</p><ul><li>heap_no</li></ul><p>自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<strong>伪记录</strong>或者<strong>虚拟记录</strong></p><p>这两个伪记录一个代表<strong>最小记录</strong>，一个代表<strong>最大记录</strong></p><p>最小记录和最大记录的heap_no 值分别是0 和1</p><ul><li>record_type</li></ul><p>表示当前记录的类型</p><p>0 表示普通记录<br>1 表示B+树非叶节点记录 (目录项记录)<br>2 表示最小记录<br>3 表示最大记录</p><ul><li>next_record</li></ul><p>从当前记录的真实数据到下一条记录的真实数据的地址偏移量</p><p>下一条记录指得是按照主键值由小到大的顺序的下一条记录</p><p>规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）</p><h3 id="Page-Directory（页目录）"><a href="#Page-Directory（页目录）" class="headerlink" title="Page Directory（页目录）"></a>Page Directory（页目录）</h3><ol><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory ，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为槽（英文名： Slot ），所以这个页面目录就是由槽组成的。</li></ol><p>对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1<del>8 条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。</p><p><strong>分组是按照下边的步骤进行的</strong></p><p>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。<br>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。<br>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</p><p><strong>在一个数据页中查找指定主键值的记录的过程分为两步</strong></p><ol><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li><li>通过记录的next_record 属性遍历该槽所在的组中的各个记录。</li></ol><h3 id="Page-Header（页面头部）"><a href="#Page-Header（页面头部）" class="headerlink" title="Page Header（页面头部）"></a>Page Header（页面头部）</h3><p>Page Header 是专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽</p><table><thead><tr><th>名称</th><th>描述</th><th>占用空间大小</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE HEAP_TOP</td><td>2字节</td><td>“还未使用的空间最小地址,也就是说从该地址之后就是Free Space”</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量(包括最小和最大记录以及标记为删除的记录)</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>“第一个已经标记为删除的记录地址(各个已删除的记录通过next_record 也会组成一个单链表,这个单链表中的记录可以被重新利用)”</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量(不包括最小和最大记录以及被标记为删除的记录)</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>“修改当前页的最大事务ID,该值仅在二级索引中定义”</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>“索引ID,表示当前页属于哪个索引”</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10 字节</td><td>“B+树叶子段的头部信息,仅在B+树的Root顷定义”</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10 字节</td><td>“B+树非叶子段的头部信息,仅在B+树的Root页定义”</td></tr></tbody></table><ul><li>PAGE_DIRECTION</li></ul><p>新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION 。</p><ul><li>PAGE_N_DIRECTION</li></ul><p>InnoDB 会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION 这个状态表示</p><h3 id="File-Header（文件头部）"><a href="#File-Header（文件头部）" class="headerlink" title="File Header（文件头部）"></a>File Header（文件头部）</h3><p>描述了一些针对各种页都通用的一些信息</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4字节</td><td>页的校验和 (checksum值)</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号</td></tr><tr><td>FIL_PAGE PREV</td><td>4字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL PAGE LSN</td><td>8字节</td><td>页面被最后修改时对应的日志序列位置(英文名是:Log Sequence Number)</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE FILE FLUSH LSN</td><td>8字节</td><td>“仅在系统表空间的一个页中定义,代表文件至少被刷新到了对应的LSN值”</td></tr><tr><td>FIL_ PAGE ARCH_ LOG NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li>FIL_PAGE_SPACE_OR_CHKSUM</li></ul><p>当前页面的校验和（checksum）</p><ul><li>FIL_PAGE_OFFSET</li></ul><p>每一个页都有一个单独的页号，就跟你的身份证号码一样， InnoDB 通过页号来可以唯一定位一个页。</p><ul><li>FIL_PAGE_TYPE</li></ul><p>这个代表当前页的类型</p><ul><li>FIL_PAGE_PREV 和FIL_PAGE_NEXT</li></ul><p>FIL_PAGE_PREV 和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号</p><p>并不是所有类型的页都有上一个和下一个页的属性</p><h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>每个页的尾部都加了一个File Trailer 部分</p><ul><li>前4个字节代表页的校验和</li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 存储引擎</title>
      <link href="/database/mysql/mysql-cun-chu-yin-qing/"/>
      <url>/database/mysql/mysql-cun-chu-yin-qing/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-存储引擎"><a href="#【MySQL】-存储引擎" class="headerlink" title="【MySQL】 存储引擎"></a>【MySQL】 存储引擎</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 存储引擎date: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 存储引擎</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>并发</td><td>支持行级锁</td><td>只支持表级锁</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>备份</td><td>支持在线热备份</td><td>不支持</td></tr><tr><td>崩溃恢复</td><td>崩溃后损坏概率低且恢复速度较快</td><td>崩溃后损坏概率高且恢复速度较慢</td></tr><tr><td>其它特性</td><td>较多优化，聚簇索引，MVCC，预测性读等</td><td>压缩表，空间数据索引等</td></tr></tbody></table><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎。</strong></p><p>将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB</p><p>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p><strong>不支持事务。</strong></p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键: InnoDB 支持外键。</li><li>备份: InnoDB 支持在线热备份。</li><li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性: MyISAM 支持压缩表和空间数据索引。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 字符集</title>
      <link href="/database/mysql/mysql-zi-fu-ji/"/>
      <url>/database/mysql/mysql-zi-fu-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-字符集"><a href="#【MySQL】-字符集" class="headerlink" title="【MySQL】 字符集"></a>【MySQL】 字符集</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 字符集date: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 字符集</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>MySQL有四个级别的字符集和比较规则：<strong>服务器级别</strong>、<strong>数据库级别</strong>、<strong>表级别</strong>和<strong>列级别</strong>。</li><li>服务器级别包括character_set_server（字符集）和collation_server（比较规则）。</li><li>数据库级别包括character_set_database（当前数据库字符集）和collation_database（当前数据库比较规则）。</li><li>在创建或修改数据库时，可以指定字符集和比较规则，使用CREATE DATABASE和ALTER DATABASE语句。</li><li>表级别包括在创建或修改表时指定字符集和比较规则，使用CREATE TABLE和ALTER TABLE语句。</li><li>列级别包括在创建或修改列时指定字符集和比较规则，使用CREATE TABLE和ALTER TABLE语句。</li><li>在请求发送到服务器并接收结果的过程中，涉及字符集转换：<ul><li><strong>客户端</strong>使用<strong>操作系统</strong>的字符集编码请求字符串，并将其作为字节串发送给服务器。</li><li><strong>服务器</strong>使用<strong>character_set_client</strong>字符集解码接收到的字节串，并按照character_set_connection字符集编码。</li><li>如果character_set_connection字符集与操作的列使用的字符集相同，则直接进行操作；否则，需要将请求中的字符串从character_set_connection字符集转换为列使用的字符集后再进行操作。</li><li>从列获取的字节串将根据character_set_results字符集转换，并发送给客户端。</li><li>客户端使用操作系统的字符集解析接收到的结果集字节串。</li></ul></li></ul><p><img src="/attachment/f96efaf8bd9a6c3dd355cf4bdd82ebd7.png"></p><h2 id="MySQL-的四个级别的字符集和比较规则"><a href="#MySQL-的四个级别的字符集和比较规则" class="headerlink" title="MySQL 的四个级别的字符集和比较规则"></a>MySQL 的四个级别的字符集和比较规则</h2><h3 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h3><p>character_set_server 表示服务器级别的字符集， collation_server 表示服务器级别的比较规则。</p><h3 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h3><p>character_set_database 表示当前数据库的字符集， collation_database 表示当前数据库的比较规则。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">创建指定字符集和比较规则</p><pre><code class="language-java">CREATE DATABASE 【数据库名】[[DEFAULT] CHARACTER SET 【字符集名称】][[DEFAULT] COLLATIE 【比较规则名称】];</code></pre></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">修改指定字符集和比较规则</p><pre><code class="language-java">ALTER DATABASE 【数据库名】[[DEFAULT] CHARACTER SET 【字符集名称】][[DEFAULT] COLLATIE 【比较规则名称】];</code></pre></div><h3 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">创建指定表字符集和比较规则</p><pre><code class="language-java">CREATE TABLE 【表名】[[DEFAULT] CHARACTER SET 【字符集名称】][[DEFAULT] COLLATIE 【比较规则名称】];</code></pre></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">修改指定表字符集和比较规则</p><pre><code class="language-java">ALTER TABLE 【表名】[[DEFAULT] CHARACTER SET 【字符集名称】][[DEFAULT] COLLATIE 【比较规则名称】];</code></pre></div><h3 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">创建指定列字符集和比较规则</p><pre><code class="language-java">CREATE TABLE 【表名】 (【列名】【字符串类型】 [ CHARACTER SET 【字符集名称】] [ COLLATIE 【比较规则名称】],...)</code></pre></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">修改指定列字符集和比较规则</p><pre><code class="language-java">ALTER TABLE 【表名】 MODIFY【列名】【字符串类型】 [ CHARACTER SET 【字符集名称】] [ COLLATIE 【比较规则名称】];</code></pre></div><h2 id="从发送请求到接收结果过程中发生的字符集转换"><a href="#从发送请求到接收结果过程中发生的字符集转换" class="headerlink" title="从发送请求到接收结果过程中发生的字符集转换"></a>从发送请求到接收结果过程中发生的字符集转换</h2><ol><li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li><li>服务器将客户端发送来的字节串采用character_set_client 代表的字符集进行解码，将解码后的字符串再按照character_set_connection 代表的字符集进行编码。</li><li>如果character_set_connection 代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从character_set_connection 代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li><li>将从某个列获取到的字节串从该列使用的字符集转换为character_set_results 代表的字符集后发送到客户端。</li><li>客户端使用操作系统的字符集解析收到的结果集字节串。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 数据目录</title>
      <link href="/database/mysql/mysql-shu-ju-mu-lu/"/>
      <url>/database/mysql/mysql-shu-ju-mu-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-数据目录"><a href="#【MySQL】-数据目录" class="headerlink" title="【MySQL】 数据目录"></a>【MySQL】 数据目录</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 数据目录date: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 数据目录</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>表空间类型：<ul><li><strong>系统表空间（system tablespace）</strong>：对应文件系统上的一个或多个实际文件，InnoDB使用名为ibdata1的文件来存储数据。</li><li><strong>独立表空间（file-per-table tablespace）</strong>：为每个表创建一个独立的表空间，表空间文件与表名相同，使用.ibd扩展名。</li><li><strong>其他类型的表空间</strong>：通用表空间、undo表空间、临时表空间。</li></ul></li><li>其他文件：<ul><li>服务器进程文件</li><li>服务器日志文件</li><li>默认/自动生成的SSL和RSA证书和密钥文件</li></ul></li><li>文件系统对数据库的影响：<ul><li>数据库和表名称长度限制</li><li>特殊字符的问题</li><li>文件长度受文件系统最大长度限制</li></ul></li><li>MySQL系统数据库简介：<ul><li>mysql数据库：存储<strong>用户账户和权限信息</strong>、<strong>存储过程</strong>、<strong>事件的定义信息</strong>、<strong>日志信息</strong>、<strong>帮助信息</strong>、<strong>时区信息</strong>等。</li><li>information_schema数据库：保存其他数据库的信息和元数据。</li><li>performance_schema数据库：保存MySQL服务器运行过程中的状态信息。</li><li>sys数据库：通过<strong>视图</strong>将information_schema和performance_schema结合起来，<strong>提供更方便的性能信息</strong>。</li></ul></li></ul><h2 id="表空间类型"><a href="#表空间类型" class="headerlink" title="表空间类型"></a>表空间类型</h2><h3 id="系统表空间（system-tablespace）"><a href="#系统表空间（system-tablespace）" class="headerlink" title="系统表空间（system tablespace）"></a>系统表空间（system tablespace）</h3><p>对应文件系统上一个或多个实际的文件</p><p>InnoDB 会在数据目录下创建一个名为ibdata1， 大小为12M 的文件</p><p>从MySQL5.5.7到MySQL5.6.6之间的各个版本中，表中的数据都会被默认存储到这个 系统表空间。</p><h3 id="独立表空间-file-per-table-tablespace"><a href="#独立表空间-file-per-table-tablespace" class="headerlink" title="独立表空间(file-per-table tablespace)"></a>独立表空间(file-per-table tablespace)</h3><p>为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。</p><p>使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个.ibd 的扩展名而已</p><h3 id="其他类型的表空间"><a href="#其他类型的表空间" class="headerlink" title="其他类型的表空间"></a>其他类型的表空间</h3><p>通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）</p><h3 id="其他的文件"><a href="#其他的文件" class="headerlink" title="其他的文件"></a>其他的文件</h3><ul><li>服务器进程文件</li><li>服务器日志文件</li><li>默认/自动生成的SSL和RSA证书和密钥文件</li></ul><h2 id="文件系统对数据库的影响"><a href="#文件系统对数据库的影响" class="headerlink" title="文件系统对数据库的影响"></a>文件系统对数据库的影响</h2><h3 id="文件系统的一些制约"><a href="#文件系统的一些制约" class="headerlink" title="文件系统的一些制约"></a>文件系统的一些制约</h3><ul><li>数据库名称和表名称不得超过文件系统所允许的最大长度。</li><li>特殊字符的问题</li><li>文件长度受文件系统最大长度限制</li></ul><h2 id="MySQL系统数据库简介"><a href="#MySQL系统数据库简介" class="headerlink" title="MySQL系统数据库简介"></a>MySQL系统数据库简介</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul><li>核心</li><li>存储了MySQL的<ul><li>用户账户和权限信息，</li><li>一些存储过程、</li><li>事件的定义信息，</li><li>一些运行过程中产生的日志信息，</li><li>一些帮助信息</li><li>以及时区信息等。</li></ul></li></ul><h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h3><p>保存着MySQL服务器维护的所有其他数据库的信息<br>一些描述性信息，有时候也称之为<strong>元数据</strong>。</p><h3 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance_schema"></a>performance_schema</h3><p>主要保存MySQL服务器运行过程中的一些状态信息</p><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>通过视图的形式把information_schema 和performance_schema 结合起来<br>更方便的了解MySQL服务器的一些性能信息</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 数据类型</title>
      <link href="/database/mysql/mysql-shu-ju-lei-xing/"/>
      <url>/database/mysql/mysql-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="【MySQL】-数据类型"><a href="#【MySQL】-数据类型" class="headerlink" title="【MySQL】 数据类型"></a>【MySQL】 数据类型</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 数据类型date: 2022-12-20 16:11tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 数据类型</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>整型字段类型包括：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。较小的整型类型通常更好，INT(11) 中的数字<strong>仅规定显示字符的个数</strong>。</li><li>浮点数字段类型包括：FLOAT、DOUBLE、DECIMAL。DECIMAL的计算比浮点类型更昂贵。</li><li>字符串字段类型包括：CHAR、VARCHAR。VARCHAR是变长类型，节省空间，但在UPDATE时可能会导致<strong>行变长</strong>。VARCHAR会保留末尾空格，而CHAR会删除。</li><li>时间和日期字段类型包括：DATETIME、TIMESTAMP。DATETIME保存从1001年到9999年的日期和时间，精度为秒。TIMESTAMP保存从1970年到2038年的秒数，与时区相关。</li></ul><p>在选择优化数据类型时，更小的类型通常更好。使用简单的类型，避免使用NULL。对于字符串类型，根据需求选择VARCHAR或CHAR。对于标识符，整数类型通常是最佳选择，避免使用字符串类型。</p><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul><li><code>TINYINT</code>:  8位存储空间</li><li><code>SMALLINT</code>: 16位存储空间</li><li><code>MEDIUMINT</code>: 24位存储空间</li><li><code>INT</code>: 32位存储空间</li><li><code>BIGINT</code>: 64位存储空间</li></ul><p>一般情况下越小的列越好。</p><p>INT(11) 中的数字<strong>只是规定了交互工具显示字符的个数</strong>，对于存储和计算来说是没有意义的。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul><li><code>FLOAT</code> 为浮点类型</li><li><code>DOUBLE</code> 为浮点类型</li><li><code>DECIMAL</code> 为高精度小数类型</li></ul><p>CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><code>CHAR</code>: 定长</li><li><code>VARCHAR</code>: 变长</li></ul><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p>MySQL 提供了两种相似的日期时间类型: <code>DATETIME</code> 和 <code>TIMESTAMP</code>。</p><h4 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h4><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值</p><h4 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h4><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h2 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h2><ul><li>更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少；</li><li>简单就好；例如，整形比字符串操作代价更低；实用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等；</li><li>尽量避免NULL；如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><h4 id="VARCHAR-和-CHAR"><a href="#VARCHAR-和-CHAR" class="headerlink" title="VARCHAR 和 CHAR"></a>VARCHAR 和 CHAR</h4><p>VARCHAR是最常见的字符串类型。VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p><p>下面这些情况使用VARCHAR是合适的：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p><p>当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。</p><p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片（行间碎片？）。</p><h4 id="VARCHAR-5-和VARCHAR-200"><a href="#VARCHAR-5-和VARCHAR-200" class="headerlink" title="VARCHAR(5)和VARCHAR(200)"></a>VARCHAR(5)和VARCHAR(200)</h4><blockquote><p>使用VARCHAR(5)和VARCHAR(200)存储”hello”的空间开销是一样的。那么使用更短的列有什么优势吗？</p></blockquote><p>事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。</p><p>所以最好的策略是只分配真正需要的空间。</p><h4 id="BLOB-和-TEXT"><a href="#BLOB-和-TEXT" class="headerlink" title="BLOB 和 TEXT"></a>BLOB 和 TEXT</h4><p>BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。</p><p>与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p><p>MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。</p><h3 id="选择表示符（identifier）"><a href="#选择表示符（identifier）" class="headerlink" title="选择表示符（identifier）"></a>选择表示符（identifier）</h3><p>整数类型通常是标识列的最佳选择，因为它们很快并且可以使用AUTO_INCREMENT。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。 对于完全随机的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：</p><ul><li>因为插入值会随机的写入到索引的不同位置，所以使得INSERT语句更慢。这会导致叶分裂、磁盘随机访问。</li><li>SELECT语句会变的更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。</li><li>随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 权限管理</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-quan-xian-guan-li/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-quan-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="【SQL-语言】-权限管理"><a href="#【SQL-语言】-权限管理" class="headerlink" title="【SQL 语言】 权限管理"></a>【SQL 语言】 权限管理</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【SQL 语言】 权限管理date: 2022-12-20 16:09tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 【SQL 语言】 权限管理</code></pre><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><pre><code class="line-numbers language-sql">USE mysql;SELECT user FROM user;</code></pre><p><strong>创建账户</strong></p><p>新创建的账户没有任何权限。</p><pre><code class="line-numbers language-sql">CREATE USER myuser IDENTIFIED BY 'mypassword';</code></pre><p><strong>修改账户名</strong></p><pre><code class="line-numbers language-sql">RENAME myuser TO newuser;</code></pre><p><strong>删除账户</strong></p><pre><code class="line-numbers language-sql">DROP USER myuser;</code></pre><p><strong>查看权限</strong></p><pre><code class="line-numbers language-sql">SHOW GRANTS FOR myuser;</code></pre><p><strong>授予权限</strong></p><p>账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名</p><p><strong>删除权限</strong></p><p>GRANT 和 REVOKE 可在几个层次上控制访问权限:</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><pre><code class="line-numbers language-sql">REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;</code></pre><p><strong>更改密码</strong></p><p>必须使用 <code>Password()</code> 函数</p><pre><code class="line-numbers language-sql">SET PASSWROD FOR myuser = Password('new_password');</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 字符集</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-zi-fu-ji/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-zi-fu-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="【SQL-语言】-字符集"><a href="#【SQL-语言】-字符集" class="headerlink" title="【SQL 语言】 字符集"></a>【SQL 语言】 字符集</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【SQL 语言】 字符集date: 2022-12-20 16:08tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 字符集为字母和符号的集合</code></pre><p>基本术语:</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定:</p><pre><code class="line-numbers language-sql">CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;</code></pre><p>可以在排序、分组时指定校对:</p><pre><code class="line-numbers language-sql">SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 事务管理</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-shi-wu-guan-li/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-shi-wu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="【SQL-语言】-事务管理"><a href="#【SQL-语言】-事务管理" class="headerlink" title="【SQL 语言】 事务管理"></a>【SQL 语言】 事务管理</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【SQL 语言】 事务管理date: 2022-12-20 16:07tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 事务(transaction)指一组 SQL 语句</code></pre><p>基本术语:</p><ul><li>事务(transaction)指一组 SQL 语句；</li><li>回退(rollback)指撤销指定 SQL 语句的过程；</li><li>提交(commit)指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点(savepoint)指事务处理中设置的临时占位符(placeholder)，你可以对它发布回退(与回退整个事务处理不同)。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><pre><code class="line-numbers language-sql">START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 游标</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-you-biao/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-you-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【SQL-语言】-游标"><a href="#【SQL-语言】-游标" class="headerlink" title="【SQL 语言】 游标"></a>【SQL 语言】 游标</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【SQL 语言】 游标date: 2022-12-20 16:05tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</code></pre><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤:</p><ul><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ul><pre><code class="line-numbers language-sql">delimiter //create procedure myprocedure(out ret int)    begin        declare done boolean default 0;        declare mycursor cursor for        select col1 from mytable;        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1        declare continue handler for sqlstate '02000' set done = 1;        open mycursor;        repeat            fetch mycursor into ret;            select ret;        until done end repeat;        close mycursor;    end // delimiter ;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 存储过程</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-cun-chu-guo-cheng/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-cun-chu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="【SQL-语言】-存储过程"><a href="#【SQL-语言】-存储过程" class="headerlink" title="【SQL 语言】 存储过程"></a>【SQL 语言】 存储过程</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【SQL 语言】 存储过程date: 2022-12-20 16:02tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 存储过程可以看成是对一系列 SQL 操作的批处理。</code></pre><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p><p>使用存储过程的好处:</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><pre><code class="line-numbers language-sql">delimiter //create procedure myprocedure( out ret int )    begin        declare y int;        select sum(col1)        from mytable        into y;        select y*y into ret;    end //delimiter ;</code></pre><pre><code class="line-numbers language-sql">call myprocedure(@ret);select @ret;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 视图</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-shi-tu/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-shi-tu/</url>
      
        <content type="html"><![CDATA[<h1 id="【SQL-语言】-视图"><a href="#【SQL-语言】-视图" class="headerlink" title="【SQL 语言】 视图"></a>【SQL 语言】 视图</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【SQL 语言】 视图date: 2022-12-20 15:59tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处:</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><pre><code class="line-numbers language-sql">CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_colFROM mytableWHERE col5 = val;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 DML</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-dml/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-dml/</url>
      
        <content type="html"><![CDATA[<h1 id="【SQL-语言】-DML"><a href="#【SQL-语言】-DML" class="headerlink" title="【SQL 语言】 DML"></a>【SQL 语言】 DML</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【SQL 语言】 DMLdate: 2022-12-20 15:41tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句，通常是数据库专用编程语言之中的一个子集，例如在信息软件产业通行标准的SQL语言中，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入(意指新增或创建)、更新(修改)与删除(销毁)。在使用数据库的系统开发过程中，其中应用程序必然会使用的指令；而加上 SQL的SELECT语句，欧美地区的开发人员把这四种指令，以“CRUD”(分别为 Create, Read, Update, Delete英文四前缀字母缩略的术语)来称呼；而亚洲地区使用汉语的开发人员，或可能以四个汉字：增 查 改 删 来略称。</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句，通常是数据库专用编程语言之中的一个子集，例如在信息软件产业通行标准的SQL语言中，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入(意指新增或创建)、更新(修改)与删除(销毁)。在使用数据库的系统开发过程中，其中应用程序必然会使用的指令；而加上 SQL的SELECT语句，欧美地区的开发人员把这四种指令，以“CRUD”(分别为 Create, Read, Update, Delete英文四前缀字母缩略的术语)来称呼；而亚洲地区使用汉语的开发人员，或可能以四个汉字：增 查 改 删来略称。</p><h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><p>DML 的主要功能即是访问数据，因此其语法都是以读取与写入数据库为主，除了INSERT以外，其他指令都可能需搭配WHERE指令来过滤数据范围，或是不加WHERE指令来访问全部的数据。 </p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>主条目：SELECT<br>SELECT是SQL数据操纵语言(DML)中用于查询表格内字段数据的指令，可搭配条件限制的子句(如where)或排列顺序的子句(如order)来获取查询结果。</p><pre><code class="line-numbers language-sql">SELECT select_list[ INTO new_table ]FROM table_source[ WHERE search_condition ][ GROUP BY group_by_expression ][ HAVING search_condition ][ ORDER BY order_expression [ ASC | DESC ] ]</code></pre><h4 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h4><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><pre><code class="line-numbers language-sql">SELECT DISTINCT col1, col2FROM mytable;</code></pre><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>主条目：INSERT<br>INSERT 是将数据插入到数据库对象中的指令，可以插入数据的数据库对象有数据表以及可更新查看表两种。</p><p><strong>普通插入</strong></p><pre><code class="line-numbers language-sql">INSERT INTO mytable(col1, col2)VALUES(val1, val2);</code></pre><p><strong>插入检索出来的数据</strong></p><pre><code class="line-numbers language-sql">INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2;</code></pre><p><strong>将一个表的内容插入到一个新表</strong></p><pre><code class="line-numbers language-sql">CREATE TABLE newtable ASSELECT * FROM mytable;</code></pre><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>主条目：UPDATE<br>UPDATE 指令是依给定条件，将匹配条件的数据表中的数据更新为新的数值。</p><pre><code class="line-numbers language-sql">UPDATE mytableSET col = valWHERE id = 1;</code></pre><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>主条目：DELETE<br>DELETE 指令为自数据库对象中删除数据的指令。</p><pre><code class="line-numbers language-sql">DELETE FROM mytableWHERE id = 1;</code></pre><p><strong>TRUNCATE TABLE 可以清空表，也就是删除所有行。</strong></p><pre><code class="line-numbers language-sql">TRUNCATE TABLE mytable;</code></pre><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>ASC : 升序(默认)</li><li>DESC : 降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式:</p><pre><code class="line-numbers language-sql">SELECT *FROM mytableORDER BY col1 DESC, col2 ASC;</code></pre><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;&gt; !=</td><td>不等于</td></tr><tr><td>&lt;= !&gt;</td><td>小于等于</td></tr><tr><td>&gt;= !&lt;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在两个值之间</td></tr><tr><td>IS NULL</td><td>为 NULL 值</td></tr></tbody></table><p>应该注意到，NULL 与 0、空字符串都不同。</p><p><strong>AND 和 OR 用于连接多个过滤条件</strong>。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN 操作符用于匹配一组值</strong>，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT 操作符用于否定一个条件</strong>。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><code>% 匹配 &gt;=0 个任意字符</code>；</li><li><code>_ 匹配 ==1 个任意字符</code>；</li><li><code>[ ] 可以匹配集合内的字符</code>，例如 <code>[ab]</code> 将匹配字符 a 或者 b。</li><li><code>脱字符 ^ 可以对其进行否定</code>，也就是不匹配集合内的字符。</li></ul><p>使用 Like 来进行通配符匹配。</p><pre><code class="line-numbers language-sql">SELECT *FROM mytableWHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本</code></pre><p><strong>不要滥用通配符，通配符位于开头处匹配会非常慢。</strong></p><h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h3><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且<strong>转换和格式化后的数据量更少的话可以减少网络通信量</strong>。</p><p>计算字段通常需要使用 <strong>AS 来取别名</strong>，否则输出的时候字段名为计算表达式。</p><pre><code class="line-numbers language-sql">SELECT col1 * col2 AS aliasFROM mytable;</code></pre><p><strong>CONCAT() 用于连接两个字段</strong>。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。</p><pre><code class="line-numbers language-sql">SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_colFROM mytable;</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p><pre><code class="line-numbers language-sql">SELECT AVG(DISTINCT col1) AS avg_colFROM mytable;</code></pre><h4 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>LEFT()</td><td>左边的字符</td></tr><tr><td>RIGHT()</td><td>右边的字符</td></tr><tr><td>LOWER()</td><td>转换为小写字符</td></tr><tr><td>UPPER()</td><td>转换为大写字符</td></tr><tr><td>LTRIM()</td><td>去除左边的空格</td></tr><tr><td>RTRIM()</td><td>去除右边的空格</td></tr><tr><td>LENGTH()</td><td>长度</td></tr><tr><td>SOUNDEX()</td><td>转换为语音值</td></tr></tbody></table><p>其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。</p><pre><code class="line-numbers language-sql">SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple')</code></pre><h4 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h4><ul><li>日期格式: YYYY-MM-DD</li><li>时间格式: HH:MM:SS</li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期(天、周等)</td></tr><tr><td>AddTime()</td><td>增加一个时间(时、分等)</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table><h4 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><pre><code class="line-numbers language-sql">SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num;</code></pre><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><pre><code class="line-numbers language-sql">SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING num &gt;= 2;</code></pre><p>分组规定:</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件:</p><pre><code class="line-numbers language-sql">SELECT cust_name, (SELECT COUNT(*)                   FROM Orders                   WHERE Orders.cust_id = Customers.cust_id)                   AS orders_numFROM CustomersORDER BY cust_name;</code></pre><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><pre><code class="line-numbers language-sql">SELECT A.value, B.valueFROM tablea AS A INNER JOIN tableb AS BON A.key = B.key;</code></pre><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><pre><code class="line-numbers language-sql">SELECT A.value, B.valueFROM tablea AS A, tableb AS BWHERE A.key = B.key;</code></pre><p>在没有条件语句的情况下返回笛卡尔积。</p><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><pre><code class="line-numbers language-sql">SELECT nameFROM employeeWHERE department = (      SELECT department      FROM employee      WHERE name = "Jim");</code></pre><p>自连接版本</p><pre><code class="line-numbers language-sql">SELECT e1.nameFROM employee AS e1 INNER JOIN employee AS e2ON e1.department = e2.department      AND e2.name = "Jim";</code></pre><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别: <strong>内连接提供连接的列，而自然连接自动连接所有同名列。</strong></p><pre><code class="line-numbers language-sql">SELECT A.value, B.valueFROM tablea AS A NATURAL JOIN tableb AS B;</code></pre><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接<strong>保留了没有关联的那些行</strong>。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>使用 <strong>UNION 来组合两个查询</strong>，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><pre><code class="line-numbers language-sql">SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 DDL</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-ddl/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-ddl/</url>
      
        <content type="html"><![CDATA[<h1 id="【SQL-语言】-DDL"><a href="#【SQL-语言】-DDL" class="headerlink" title="【SQL 语言】 DDL"></a>【SQL 语言】 DDL</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【SQL 语言】 DDLdate: 2022-12-20 15:24tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_语言categories:  - 数据存储keywords:  - 数据存储description: 数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>定义包括结构定义、操作方法定义等。</p><p>数据库模式定义语言并非程序设计语言，DDL数据库模式定义语言是SQL语言（结构化查询语言）的组成部分。SQL语言包括四种主要程序设计语言类别的语句：数据定义语言(DDL)，数据操作语言(DML)，数据控制语言(DCL)和事务控制语言（TCL）。</p><p>DDL描述的模式，必须由计算机软件进行编译，转换为便于计算机存储、查询和操纵的格式，完成这个转换工作的程序称为模式编译器。<br>模式编译器处理模式定义主要产生两种类型的数据：数据字典以及数据类型和结构定义。</p><p>数据字典和数据库内部结构信息是创建该模式所对应的数据库的依据，根据这些信息创建每个数据库对应的逻辑结构；对数据库数据的访问、查询也根据模式信息决定数据存取的方式和类型，以及数据之间的关系和对数据的完整性约束。</p><p>数据字典是模式的内部信息表示，数据字典的存储方式对不同的DBMS各不相同。</p><p>数据类型和结构的定义，是指当应用程序与数据库连接操作时，应用程序需要了解产生和提取的数据类型和结构。是为各种宿主语言提供的用户工作区的数据类型和结构定义，使用户工作区和数据库的逻辑结构相一致，减少数据的转换过程，这种数据类型和结构的定义通常用一个头文件来实现。</p><p>数据库模式的定义通常有两种方式: 交互方式定义模式和通过数据描述语言DDL 描述文本定义模式。</p><h2 id="常见的DDL语句"><a href="#常见的DDL语句" class="headerlink" title="常见的DDL语句"></a>常见的DDL语句</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre><code class="line-numbers language-sql">CREATE {DATABASE | SCHEMA} db_name[create_specification [, create_specification] ...]create_specification:[DEFAULT] CHARACTER SET charset_name -- 字符集| [DEFAULT] COLLATE collation_name  -- 排序</code></pre><pre><code class="line-numbers language-sql">CREATE DATABASE test;USE test;</code></pre><h3 id="创建数据库表格"><a href="#创建数据库表格" class="headerlink" title="创建数据库表格"></a>创建数据库表格</h3><pre><code class="line-numbers language-sql">CREATE [TEMPORARY] TABLE tbl_name[(create_definition,...)][table_options] [select_statement]</code></pre><pre><code class="line-numbers language-sql">CREATE TABLE mytable (  id INT NOT NULL AUTO_INCREMENT,  col1 INT NOT NULL DEFAULT 1,  col2 VARCHAR(45) NULL,  col3 DATE NULL,  PRIMARY KEY (`id`));</code></pre><h3 id="修改数据库表格"><a href="#修改数据库表格" class="headerlink" title="修改数据库表格"></a>修改数据库表格</h3><pre><code class="line-numbers language-sql">ALTER TABLE tbl_namealter_specification [, alter_specification] ...alter_specification:ADD [COLUMN] column_definition [FIRST | AFTER col_name ] -- 添加列| ADD [COLUMN] (column_definition,...) -- 添加列| ADD INDEX (index_col_name,...) -- 增加索引| ADD [CONSTRAINT [symbol]]PRIMARY KEY (index_col_name,...) -- 增加主键约束| ADD [CONSTRAINT [symbol]]UNIQUE (index_col_name,...) -- 增加联合约束| ADD (index_col_name,...)  -- | ADD [CONSTRAINT [symbol]]FOREIGN KEY (index_col_name,...)[reference_definition]  -- 增加外键约束| ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT} -- 修改列| CHANGE [COLUMN] old_col_name column_definition[FIRST|AFTER col_name] -- 修改列| MODIFY [COLUMN] column_definition [FIRST | AFTER col_name] -- 修改列| DROP [COLUMN] col_name -- 删除列| DROP PRIMARY KEY -- 删除主键| DROP INDEX index_name -- 删除主键| DROP FOREIGN KEY fk_symbol -- 删除外键| DISABLE KEYS  -- 停用| ENABLE KEYS  -- 启用| RENAME [TO] new_tbl_name -- 重命名表| ORDER BY col_name  -- 排序| CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]  -- 修改字符集| [DEFAULT] CHARACTER SET charset_name [COLLATE collation_name] -- 修改字符集| DISCARD TABLESPACE  -- 丢弃表空间| IMPORT TABLESPACE  -- 引入表空间| table_options  -- 表设置</code></pre><p><strong>添加列</strong></p><pre><code class="line-numbers language-sql">ALTER TABLE mytableADD col CHAR(20);</code></pre><p><strong>修改列和属性</strong></p><pre><code class="line-numbers language-sql">---ALTER TABLE 表名 CHANGE 原字段名 新字段名 字段类型 约束条件ALTER TABLE mytable CHANGE col col1 CHAR(32) NOT NULL DEFAULT '123';</code></pre><p><strong>删除列</strong></p><pre><code class="line-numbers language-sql">ALTER TABLE mytableDROP COLUMN col;</code></pre><h3 id="删除数据库表格"><a href="#删除数据库表格" class="headerlink" title="删除数据库表格"></a>删除数据库表格</h3><pre><code class="line-numbers language-sql">DROP [TEMPORARY] TABLEtbl_name [, tbl_name] ...[RESTRICT | CASCADE]</code></pre><pre><code class="line-numbers language-sql">DROP TABLE mytable;</code></pre><h3 id="创建查询视图命令"><a href="#创建查询视图命令" class="headerlink" title="创建查询视图命令"></a>创建查询视图命令</h3><pre><code class="line-numbers language-sql">CREATE[ORREPLACE][ALGORITHM={UNDEFINED|MERGE|TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION]</code></pre><h3 id="修改查询视图命令"><a href="#修改查询视图命令" class="headerlink" title="修改查询视图命令"></a>修改查询视图命令</h3><pre><code class="line-numbers language-sql">ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION]</code></pre><h3 id="删除查询视图命令"><a href="#删除查询视图命令" class="headerlink" title="删除查询视图命令"></a>删除查询视图命令</h3><pre><code class="line-numbers language-sql">DROP VIEWview_name [, view_name] ...[RESTRICT | CASCADE]</code></pre><h3 id="删除数据表内容"><a href="#删除数据表内容" class="headerlink" title="删除数据表内容"></a>删除数据表内容</h3><pre><code class="line-numbers language-sql">TRUNCATE TABLE name [DROP/REUSE STORAGE]</code></pre><p>DROP STORAGE：显式指明释放数据表和索引的空间<br>REUSE STORAGE：显式指明不释放数据表和索引的空间</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DB SQL】 数据库系统核心知识点</title>
      <link href="/database/db-sql/db-sql-shu-ju-ku-xi-tong-he-xin-zhi-shi-dian/"/>
      <url>/database/db-sql/db-sql-shu-ju-ku-xi-tong-he-xin-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="【DB-SQL】-数据库系统核心知识点"><a href="#【DB-SQL】-数据库系统核心知识点" class="headerlink" title="【DB SQL】 数据库系统核心知识点"></a>【DB SQL】 数据库系统核心知识点</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【DB SQL】 数据库系统核心知识点date: 2022-12-20 15:21tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_SQLcategories:  - 数据存储keywords:  - 数据存储description: 【DB SQL】 数据库系统核心知识点</code></pre><blockquote><p>基于上篇数据库如何工作的基础之上，我们再来梳理下数据库系统中有哪些重要的知识点，包括：事务，并发一致性，封锁，隔离级别，多版本并发控制等。</p></blockquote><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><img src="/attachment%5Cf433648c0eba3c43c7e41ba85a824c43.png"></p><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。<br>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h4 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h4 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系:</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><p><img src="/attachment%5Cee1e1fea79addc52ab928237f5044b08.png"></p><h3 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h3 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h3><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h2 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h2><h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度: 行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h3 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>排它锁(Exclusive)，简写为 X 锁，又称写锁。</li><li>共享锁(Shared)，简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定:</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定:</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>解释如下:</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><p><strong>一级封锁协议</strong></p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><strong>三级封锁协议</strong></p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><h3 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="未提交读-READ-UNCOMMITTED"><a href="#未提交读-READ-UNCOMMITTED" class="headerlink" title="未提交读(READ UNCOMMITTED)"></a>未提交读(READ UNCOMMITTED)</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="提交读-READ-COMMITTED"><a href="#提交读-READ-COMMITTED" class="headerlink" title="提交读(READ COMMITTED)"></a>提交读(READ COMMITTED)</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h3 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读(REPEATABLE READ)"></a>可重复读(REPEATABLE READ)</h3><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><h3 id="可串行化-SERIALIZABLE"><a href="#可串行化-SERIALIZABLE" class="headerlink" title="可串行化(SERIALIZABLE)"></a>可串行化(SERIALIZABLE)</h3><p>强制事务串行执行。</p><h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul><li>系统版本号: 是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号: 事务开始时的系统版本号。</li></ul><h3 id="隐藏的列"><a href="#隐藏的列" class="headerlink" title="隐藏的列"></a>隐藏的列</h3><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:</p><ul><li>创建版本号: 指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h3 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h3><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>以下实现过程针对可重复读隔离级别。</p><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p>将当前系统版本号作为数据行快照的创建版本号。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>将当前系统版本号作为数据行快照的删除版本号。</p><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读(REPEATABLE READ)隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h3 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><h3 id="Next-Key-Locks-1"><a href="#Next-Key-Locks-1" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值: 10, 11, 13, and 20，那么就需要锁定以下区间:</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DB SQL】 关系型数据库设计流程</title>
      <link href="/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-liu-cheng/"/>
      <url>/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="【DB-SQL】-关系型数据库设计流程"><a href="#【DB-SQL】-关系型数据库设计流程" class="headerlink" title="【DB SQL】 关系型数据库设计流程"></a>【DB SQL】 关系型数据库设计流程</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【DB SQL】 关系型数据库设计流程date: 2022-12-20 15:17tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_SQLcategories:  - 数据存储keywords:  - 数据存储description: 【DB SQL】 关系型数据库设计流程</code></pre><h2 id="规范设计的6个阶段"><a href="#规范设计的6个阶段" class="headerlink" title="规范设计的6个阶段"></a>规范设计的6个阶段</h2><blockquote><p>按照规范设计的方法，考虑数据库及其应用系统开发全过程，将数据库设计分为以下6个阶段</p></blockquote><ul><li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求；</li><li><strong>概念结构设计</strong>：主要采用E-R模型进行设计，包括画E-R图；</li><li><strong>逻辑结构设计</strong>：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；</li><li><strong>数据库物理设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径；</li><li><strong>数据库的实施</strong>：包括编程、测试和试运行；</li><li><strong>数据库运行与维护</strong>：系统的运行与数据库的日常维护</li></ul><p><img src="/attachment%5Cd81dfc5266ea967661a1547dea579f34.png"></p><p>其中最为重要的是<strong>概念结构设计</strong>和<strong>逻辑结构设计</strong>，所以后面独立两个章节分别具体讲：<code>E-R图</code>和<code>结构设计流程</code>。</p><h3 id="需求分析阶段（常用自顶向下）"><a href="#需求分析阶段（常用自顶向下）" class="headerlink" title="需求分析阶段（常用自顶向下）"></a>需求分析阶段（常用自顶向下）</h3><p>调查的重点是，数据与处理。达到信息要求，处理要求，安全性和完整性要求。</p><p>分析方法常用<strong>SA(Structured  Analysis) 结构化分析方法</strong>，SA方法从最上层的系统组织结构入手，采用自顶向下，逐层分解的方式分析系统。</p><p>数据流图表达了数据和处理过程的关系，在SA方法中，处理过程的处理逻辑常常借助判定表或判定树来描述。在处理功能逐步分解的同事，系统中的数据也逐级分解，形成若干层次的数据流图。系统中的数据则借助数据字典（data dictionary，DD）来描述。数据字典是系统中各类数据描述的集合，数据字典通常包括数据项，数据结构，数据流，数据存储，和处理过程5个阶段。</p><h3 id="概念结构设计阶段（常用自底向上）"><a href="#概念结构设计阶段（常用自底向上）" class="headerlink" title="概念结构设计阶段（常用自底向上）"></a>概念结构设计阶段（常用自底向上）</h3><blockquote><p>概念结构设计是整个数据库设计的关键，它通过对用户需求进行综合，归纳与抽象，形成了一个独立于具体DBMS的概念模型。</p></blockquote><p>设计概念结构通常有四类方法：</p><ul><li>自顶向下。即首先定义全局概念结构的框架，再逐步细化。</li><li>自底向上。即首先定义各局部应用的概念结构，然后再将他们集成起来，得到全局概念结构。</li><li>逐步扩张。首先定义最重要的核心概念结构，然后向外扩张，以滚雪球的方式逐步生成其他的概念结构，直至总体概念结构。</li><li>混合策略。即自顶向下和自底向上相结合。</li></ul><h3 id="逻辑结构设计阶段（E-R图）"><a href="#逻辑结构设计阶段（E-R图）" class="headerlink" title="逻辑结构设计阶段（E-R图）"></a>逻辑结构设计阶段（E-R图）</h3><blockquote><p>逻辑结构设计是将概念结构转换为某个DBMS所支持的数据模型，并将进行优化。</p></blockquote><p>E-R图显得异常重要。大家要学会各个实体定义的属性来画出总体的E-R图。</p><p>各分E-R图之间的冲突主要有三类：属性冲突，命名冲突，和结构冲突。</p><p>E-R图向关系模型的转换，要解决的问题是如何将实体性和实体间的联系转换为关系模式，如何确定这些关系模式的属性和码。</p><h3 id="物理设计阶段"><a href="#物理设计阶段" class="headerlink" title="物理设计阶段"></a>物理设计阶段</h3><blockquote><p>物理设计是为逻辑数据结构模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。</p></blockquote><p>首先要对运行的事务详细分析，获得选择物理数据库设计所需要的参数，其次，要充分了解所用的RDBMS的内部特征，特别是系统提供的存取方法和存储结构。</p><p>常用的存取方法有三类：</p><ol><li>索引方法，目前主要是B+树索引方法。</li><li>聚簇方法（Clustering）方法。</li><li>是HASH方法。</li></ol><h3 id="数据库实施阶段"><a href="#数据库实施阶段" class="headerlink" title="数据库实施阶段"></a>数据库实施阶段</h3><p>数据库实施阶段，设计人员运营DBMS提供的数据库语言（如sql）及其宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制和调试应用程序，组织数据入库，并进行试运行。</p><h3 id="数据库运行和维护阶段"><a href="#数据库运行和维护阶段" class="headerlink" title="数据库运行和维护阶段"></a>数据库运行和维护阶段</h3><p>数据库应用系统经过试运行后，即可投入正式运行，在数据库系统运行过程中必须不断地对其进行评价，调整，修改。</p><h2 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h2><p>Entity-Relationship，有三个组成部分: 实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h3 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><img src="/attachment%5C5e3107f8b2c44173e2ff434833a8f3d1.png"></p><h3 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="/attachment%5C95c71b48ed1a97e64dd07b3a96dbaa85.png"></p><h3 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h3><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="/attachment%5Cbd8305afbe8a47b513d5fa1b78c55821.png"></p><p>一般只使用二元联系，可以把多元联系转换为二元联系。</p><p><img src="/attachment%5C40b3aa2dd4453b82e35fcb41eb7f27d9.png"></p><h3 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h3><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="/attachment%5Cab1910f1ab5b8905248a51898eed61b0.png"></p><h2 id="基于E-R图的数据库结构设计"><a href="#基于E-R图的数据库结构设计" class="headerlink" title="基于E-R图的数据库结构设计"></a>基于E-R图的数据库结构设计</h2><blockquote><p>上面6个阶段比较抽象的，来看看实际重要的基于E-R图的数据库结构设计示例吧</p></blockquote><h3 id="确定entities及relationships"><a href="#确定entities及relationships" class="headerlink" title="确定entities及relationships"></a>确定entities及relationships</h3><ul><li>明确宏观行为。数据库是用来做什么的？比如，管理雇员的信息。</li><li>确定entities。对于一系列的行为，确定所管理信息所涉及到的主题范围。这将变成table。比如，- 雇用员工，指定具体部门，确定技能等级。</li><li>确定relationships。分析行为，确定tables之间有何种关系。比如，部门与雇员之间存在一种关系。给这种关系命名。</li><li>细化行为。从宏观行为开始，现在仔细检查这些行为，看有哪些行为能转为微观行为。比如，管理雇员的信息可细化为：</li><li>增加新员工</li><li>修改存在员工信息</li><li>删除调走的员工</li><li>确定业务规则。分析业务规则，确定你要采取哪种。比如，可能有这样一种规则，一个部门有且只能有一个部门领导。这些规则将被设计到数据库的结构中。</li></ul><p>下面举个例子，需求如下： ACME是一个小公司，在5个地方都设有办事处。当前，有75名员工。公司准备快速扩大规模，划分了9个部门，每个部门都有其领导。 为有助于寻求新的员工，人事部门规划了68种技能，为将来人事管理作好准备。员工被招进时，每一种技能的专业等级都被确定。</p><h4 id="定义宏观行为"><a href="#定义宏观行为" class="headerlink" title="定义宏观行为"></a>定义宏观行为</h4><p>一些ACME公司的宏观行为包括：</p><ul><li>招聘员工</li><li>解雇员工</li><li>管理员工个人信息</li><li>管理公司所需的技能信息</li><li>管理哪位员工有哪些技能</li><li>管理部门信息</li><li>管理办事处信息</li></ul><h4 id="确定entities及relationships-1"><a href="#确定entities及relationships-1" class="headerlink" title="确定entities及relationships"></a>确定entities及relationships</h4><p>我们可以确定要存放信息的主题领域(表)及其关系，并创建一个基于宏观行为及描述的图表。 我们用方框来代表table，用菱形代表relationship。我们可以确定哪些relationship是一对多，一对一，及多对多。 这是一个E-R草图，以后会细化。</p><p><img src="/attachment%5C883866470bd662c1d3ac0eca66a0b4b6.png"></p><h4 id="细化宏观行为"><a href="#细化宏观行为" class="headerlink" title="细化宏观行为"></a>细化宏观行为</h4><p>以下微观行为基于上面宏观行为而形成：</p><ul><li>增加或删除一个员工</li><li>增加或删除一个办事处</li><li>列出一个部门中的所有员工</li><li>增加一项技能</li><li>增加一个员工的一项技能</li><li>确定一个员工的技能</li><li>确定一个员工每项技能的等级</li><li>确定所有拥有相同等级的某项技能的员工</li><li>修改员工的技能等级</li></ul><p>这些微观行为可用来确定需要哪些table或relationship。</p><h4 id="确定业务规则"><a href="#确定业务规则" class="headerlink" title="确定业务规则"></a>确定业务规则</h4><p>业务规则常用于确定一对多，一对一，及多对多关系。</p><p>相关的业务规则可能有：</p><ul><li>现在有5个办事处；最多允许扩展到10个。</li><li>员工可以改变部门或办事处</li><li>每个部门有一个部门领导</li><li>每个办事处至多有3个电话号码</li><li>每个电话号码有一个或多个扩展</li><li>员工被招进时，每一种技能的专业等级都被确定。</li><li>每位员工拥有3到20个技能</li><li>某位员工可能被安排在一个办事处，也可能不安排办事处。</li></ul><h3 id="确定所需数据"><a href="#确定所需数据" class="headerlink" title="确定所需数据"></a>确定所需数据</h3><p>要确定所需数据：</p><ul><li>确定支持数据</li><li>列出所要跟踪的所有数据。描述table(主题)的数据回答这些问题：谁，什么，哪里，何时，以及为什么</li><li>为每个table建立数据</li><li>列出每个table目前看起来合适的可用数据</li><li>为每个relationship设置数据</li><li>如果有，为每个relationship列出适用的数据</li></ul><h4 id="确定支持数据"><a href="#确定支持数据" class="headerlink" title="确定支持数据"></a>确定支持数据</h4><p>你所确定的支持数据将会成为table中的字段名。</p><p><strong>需要注意：</strong></p><ul><li>在确定支持数据时，请一定要参考你之前所确定的宏观行为，以清楚如何利用这些数据。</li><li>比如，如果你知道你需要所有员工的按姓氏排序的列表，确保你将支持数据分解为名字与姓氏，这比简单地提供一个名字会更好。</li><li>你所选择的名称最好保持一致性。这将更易于维护数据库，也更易于阅读所输出的报表。</li><li>比如，如果你在某些地方用了一个缩写名称Emp_status，你就不应该在另外一个地方使用全名(Empolyee_ID)。相反，这些名称应当是Emp_status及Emp_id。</li><li>数据是否与正确的table相对应无关紧要，你可以根据自己的喜好来定。在下节中，你会通过测试对此作出判断。</li></ul><h3 id="标准化数据"><a href="#标准化数据" class="headerlink" title="标准化数据"></a>标准化数据</h3><h4 id="标准化格式"><a href="#标准化格式" class="headerlink" title="标准化格式"></a>标准化格式</h4><p>标准化格式是标准化数据的常用测试方式。你的数据通过第一遍测试后，就被认为是达到第一标准化格式；通过第二遍测试，达到第二标准化格式；通过第三遍测试，达到第三标准化格式。</p><p>如何标准格式：</p><ol><li>列出数据</li><li>为每个表确定至少一个键。每个表必须有一个主键。</li><li>确定relationships的键。relationships的键是连接两个表的键。</li><li>检查支持数据列表中的计算数据。计算数据通常不保存在数据库中。</li><li>将数据放在第一遍的标准化格式中：</li><li>从tables及relationships除去重复的数据。</li><li>以你所除去数据创建一个或更多的tables及relationships。</li><li>将数据放在第二遍的标准化格式中：</li><li>用多于一个以上的键确定tables及relationships。</li><li>除去只依赖于键一部分的数据。</li><li>以你所除去数据创建一个或更多的tables及relationships。</li><li>将数据放在第三遍的标准化格式中：</li><li>除去那些依赖于tables或relationships中其他数据，并且不是键的数据。</li><li>以你所除去数据创建一个或更多的tables及relationships。</li></ol><h4 id="数据与键"><a href="#数据与键" class="headerlink" title="数据与键"></a>数据与键</h4><p>在你开始标准化（测试数据）前，简单地列出数据，并为每张表确定一个唯一的主键。这个键可以由一个字段或几个字段（连锁键）组成。</p><p>主键是一张表中唯一区分各行的一组字段。Employee表的主键是Employee ID字段。Works In relationship中的主键包括Office Code及Employee ID字段。给数据库中每一relationship给出一个键，从其所连接的每一个table中抽取其键产生。</p><p><strong>将数据放在第一遍的标准化格式中</strong></p><ul><li>除去重复的组</li><li>要测试第一遍标准化格式，除去重复的组，并将它们放进他们各自的一张表中。</li><li>在下面的例子中，Phone Number可以重复。（一个工作人员可以有多于一个的电话号码。）将重复的组除去，创建一个名为Telephone的新表。在Telephone与Office创建一个名为Associated With的relationship。</li></ul><p><strong>将数据放在第二遍的标准化格式中</strong></p><ul><li>除去那些不依赖于整个键的数据。</li><li>只看那些有一个以上键的tables及relationships。要测试第二遍标准化格式，除去那些不依赖于整个键的任何数据（组成键的所有字段）。</li><li>在此例中，原Employee表有一个由两个字段组成的键。一些数据不依赖于整个键；例如，department name只依赖于其中一个键（Department ID）。因此，Department ID，其他Employee数据并不依赖于它，应移至一个名为Department的新表中，并为Employee及Department建立一个名为Assigned To的relationship。</li></ul><p><strong>将数据放在第三遍的标准化格式中</strong></p><ul><li>除去那些不直接依赖于键的数据。</li><li>要测试第三遍标准化格式，除去那些不是直接依赖于键，而是依赖于其他数据的数据。</li><li>在此例中，原Employee表有依赖于其键（Employee ID）的数据。然而，office location及office phone依赖于其他字段，即Office Code。它们不直接依赖于Employee ID键。将这组数据，包括Office Code，移至一个名为Office的新表中，并为Employee及Office建立一个名为Works In的relationship。</li></ul><h4 id="考量带有数据的关系"><a href="#考量带有数据的关系" class="headerlink" title="考量带有数据的关系"></a>考量带有数据的关系</h4><p>你的一些relationship可能集含有数据。这经常发生在多对多的关系中。<br>遇到这种情况，将relationship转化为一个table。relationship的键依旧成为table中的键。</p><h4 id="考量没有数据的关系"><a href="#考量没有数据的关系" class="headerlink" title="考量没有数据的关系"></a>考量没有数据的关系</h4><p>要实现没有数据的关系，你需要定义外部键。外部键是含有另外一个表中主键的一个或多个字段。外部键使你能同时连接多表数据。</p><p>有一些基本原则能帮助你决定将这些键放在哪里：</p><p><strong>一对多</strong></p><p>在一对多关系中，“一”中的主键放在“多”中。此例中，外部键放在Employee表中。</p><p><img src="/attachment%5Cb2ea77b7822edbc50f090c3580c32633.png"></p><p><strong>一对一</strong></p><p>在一对一关系中，外部键可以放进任一表中。如果必须要放在某一边，而不能放在另一边，应该放在必须的一边。此例中，外部键（Head ID）在Department表中，因为这是必需的。</p><p><img src="/attachment%5C93347ededbb1fba9f73c99a715d9c0b1.png"></p><p><strong>多对多</strong></p><p>在多对多关系中，用两个外部键来创建一个新表。已存的旧表通过这个新表来发生联系。</p><p><img src="/attachment%5C6e7d580eb2e92c764e4b64c92ebdcb32.png"></p><h3 id="检验设计"><a href="#检验设计" class="headerlink" title="检验设计"></a>检验设计</h3><p>在你完成设计之前，你需要确保它满足你的需要。检查你在一开始时所定义的行为，确认你可以获取行为所需要的所有数据：</p><ul><li>你能找到一个路径来等到你所需要的所有信息吗？</li><li>设计是否满足了你的需要？</li><li>所有需要的数据都可用吗？ 如果你对以上的问题都回答是，你已经差不多完成设计了。</li></ul><h3 id="最终设计"><a href="#最终设计" class="headerlink" title="最终设计"></a>最终设计</h3><h4 id="设计数据库的表属性"><a href="#设计数据库的表属性" class="headerlink" title="设计数据库的表属性"></a>设计数据库的表属性</h4><p>数据库设计需要确定有什么表，每张表有什么字段。此节讨论如何指定各字段的属性。</p><p>对于每一字段，你必须决定字段名，数据类型及大小，是否允许NULL值，以及你是否希望数据库限制字段中所允许的值。</p><h4 id="选择字段名"><a href="#选择字段名" class="headerlink" title="选择字段名"></a>选择字段名</h4><p>字段名可以是字母、数字或符号的任意组合。然而，如果字段名包括了字母、数字或下划线、或并不以字母打头，或者它是个关键字（详见关键字表），那么当使用字段名称时，必须用双引号括起来。</p><p>为字段选择数据类型</p><p>SQL Anywhere支持的数据类型包括：</p><ul><li>整数（int, integer, smallint）</li><li>小数（decimal, numeric）</li><li>浮点数（float, double）</li><li>字符型（char, varchar, long varchar）</li><li>二进制数据类型（binary, long binary）</li><li>日期/时间类型（date, time, timestamp）</li><li>用户自定义类型</li></ul><h4 id="NULL与NOT-NULL"><a href="#NULL与NOT-NULL" class="headerlink" title="NULL与NOT NULL"></a>NULL与NOT NULL</h4><p>如果一个字段值是必填的，你就将此字段定义为NOT NULL。否则，字段值可以为NULL值，即可以有空值。SQL中的默认值是允许空值；你应该显示地将字段定义为NOT NULL，除非你有好理由将其设为允许空值。</p><h4 id="选择约束"><a href="#选择约束" class="headerlink" title="选择约束"></a>选择约束</h4><p>尽管字段的数据类型限制了能存在字段中的数据（例如，只能存数字或日期），你或许希望更进一步来约束其允许值。</p><p>你可以通过指定一个“CHECK”约束来限制任意字段的值。你可以使用能在WHERE子句中出现的任何有效条件来约束被允许的值，尽管大多数CHECK约束使用BETWEEN或IN条件。</p><h4 id="选择主键及外部键"><a href="#选择主键及外部键" class="headerlink" title="选择主键及外部键"></a>选择主键及外部键</h4><p>主键是唯一识别表中每一项记录的字段。如何你的表已经正确标准化，主键应当成为数据库设计的一部分。 外部键是包含另一表中主键值的一个或一组字段。外部键关系在数据库中建立了一对一及一对多关系。如果你的设计已经正确标准化，外部键应当成为数据库设计的一部分。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DB SQL】 关系型数据库设计理论</title>
      <link href="/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-li-lun/"/>
      <url>/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-li-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="【DB-SQL】-关系型数据库设计理论"><a href="#【DB-SQL】-关系型数据库设计理论" class="headerlink" title="【DB SQL】 关系型数据库设计理论"></a>【DB SQL】 关系型数据库设计理论</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【DB SQL】 关系型数据库设计理论date: 2022-12-20 15:16tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_SQLcategories:  - 数据存储keywords:  - 数据存储description: 【DB SQL】 关系型数据库设计理论</code></pre><h2 id="重要的术语"><a href="#重要的术语" class="headerlink" title="重要的术语"></a>重要的术语</h2><ul><li><strong>属性（attribute）</strong>：列的名字，上图有学号、姓名、班级、兴趣爱好、班主任、课程、授课主任、分数。</li><li><strong>依赖（relation）</strong>：列属性间存在的某种联系。</li><li><strong>元组（tuple）</strong>：每一个行，如第二行 （1301，小明，13班，篮球，王老师，英语，赵英，70） 就是一个元组</li><li><strong>表（table）</strong>：由多个属性，以及众多元组所表示的各个实例组成。</li><li><strong>模式（schema）</strong>：这里我们指逻辑结构，如 学生信息（学号，姓名，班级，兴趣爱好，班主任，课程，授课主任，分数） 的笼统表述。</li><li><strong>域（domain）</strong>：数据类型，如string、integer等，上图中每一个属性都有它的数据类型（即域）。</li><li><strong>键（key）</strong>：由关系的一个或多个属性组成，任意两个键相同的元组，所有属性都相同。需要保证表示键的属性最少。一个关系可以存在好几种键，工程中一般从这些候选键中选出一个作为主键（primary key）。</li><li><strong>候选键（candidate key）</strong>：由关系的一个或多个属性组成，候选键都具备键的特征，都有资格成为主键。</li><li><strong>超键（super key）</strong>：包含键的属性集合，无需保证属性集的最小化。每个键也是超键。可以认为是键的超集。</li><li><strong>外键（foreign key）</strong>：如果某一个关系A中的一个（组）属性是另一个关系B的键，则该（组）属性在A中称为外键。</li><li><strong>主属性（prime attribute）</strong>：所有候选键所包含的属性都是主属性。</li><li><strong>投影（projection）</strong>：选取特定的列，如将关系学生信息投影为学号、姓名即得到上表中仅包含学号、姓名的列</li><li><strong>选择（selection）</strong>：按照一定条件选取特定元组，如选择上表中分数&gt;80的元组。</li><li><strong>笛卡儿积（交叉连接Cross join）</strong>：第一个关系每一行分别与第二个关系的每一行组合。</li><li><strong>自然连接（natural join）</strong>：第一个关系中每一行与第二个关系的每一行进行匹配，如果得到有交叉部分则合并，若无交叉部分则舍弃。</li><li><strong>连接（theta join）</strong>：即加上约束条件的笛卡儿积，先得到笛卡儿积，然后根据约束条件删除不满足的元组。</li><li><strong>外连接（outer join）</strong>：执行自然连接后，将舍弃的部分也加入，并且匹配失败处的属性用NULL代替。</li><li><strong>除法运算（division）</strong>：关系R除以关系S的结果为T，则T包含所有在R但不在S中的属性，且T的元组与S的元组的所有组合在R中。</li></ul><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><blockquote><p>通过函数依赖关系，来帮助你确定表中的合理主外键等；这里只是简介，有这么个概念就可以了，因为大多数情况你不用那些所谓的推倒关系，你也是可以凭借直觉设计出来的。</p></blockquote><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><strong>冗余数据</strong>: 例如 学生-2 出现了两次。</li><li><strong>修改异常</strong>: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li><strong>删除异常</strong>: 删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li><li><strong>插入异常</strong>: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p><img src="/attachment%5C84f9ecf692044e015aaf2f014c016989.png"></p><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DB SQL】 工作原理</title>
      <link href="/database/db-sql/db-sql-gong-zuo-yuan-li/"/>
      <url>/database/db-sql/db-sql-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="【DB-SQL】-工作原理"><a href="#【DB-SQL】-工作原理" class="headerlink" title="【DB SQL】 工作原理"></a>【DB SQL】 工作原理</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【DB SQL】 工作原理date: 2022-12-20 15:06tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_SQLcategories:  - 数据存储keywords:  - 数据存储description: 【DB SQL】 工作原理</code></pre><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><img src="/attachment%5Cfbbcd1449b2c0742f5a638c62466f90e.png"></p><h2 id="数据结构及算法"><a href="#数据结构及算法" class="headerlink" title="数据结构及算法"></a>数据结构及算法</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。</p><p><strong>为什么是归并排序？</strong></p><ul><li>你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。注：这种算法叫『原地算法』(in-place algorithm)</li><li>你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。注：这种算法叫『外部排序』(external sorting)。</li><li>你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。比如，分布式合并排序是Hadoop（那个著名的大数据框架）的关键组件之一。</li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><blockquote><p>数据库中查询的时间复杂度，是我们无法使用矩阵，转而使用二叉搜索树(BST)，具体请参考： 树 - 二叉搜索树(BST)</p></blockquote><ul><li>二叉搜索树只需 log(N) 次运算，而如果你直接使用阵列则需要 N 次运算</li></ul><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><blockquote><p>查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法。</p></blockquote><p><strong>如果你在数据库中增加或删除一行</strong></p><ul><li>你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。</li><li>你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。</li></ul><p>换句话说，B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以有些人听到过使用太多索引不是个好主意这类说法。没错，你减慢了快速插入/更新/删除表中的一个行的操作，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷（在本文结尾我们会探讨这个管理器）。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>为什么不用阵列呢？</strong></p><ul><li>如果有了好的哈希函数，在哈希表里搜索的时间复杂度是 O(1)。</li><li>一个哈希表可以只装载一半到内存，剩下的哈希桶可以留在硬盘上。</li><li>用阵列的话，你需要一个连续内存空间。如果你加载一个大表，很难分配足够的连续内存空间。</li></ul><h2 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h2><p>数据库一般可以用如下图形来理解：</p><p><img src="/attachment%5C50a3eec5e9f087f44b1b09c60f04293b.png"></p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li><strong>进程管理器（process manager）</strong>：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。</li><li><strong>网络管理器（network manager）</strong>：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。</li><li><strong>文件系统管理器（File system manager）</strong>：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</li><li><strong>内存管理器（memory manager）</strong>：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。</li><li><strong>安全管理器（Security Manager）</strong>：用于对用户的验证和授权。</li><li><strong>客户端管理器（Client manager）</strong>：用于管理客户端连接。</li></ul><h3 id="查询管理器"><a href="#查询管理器" class="headerlink" title="查询管理器"></a>查询管理器</h3><ul><li><strong>查询解析器（Query parser）</strong>：用于检查查询是否合法</li><li><strong>查询重写器（Query rewriter）</strong>：用于预优化查询</li><li><strong>查询优化器（Query optimizer）</strong>：用于优化查询</li><li><strong>查询执行器（Query executor）</strong>：用于编译和执行查询</li></ul><h3 id="数据管理器"><a href="#数据管理器" class="headerlink" title="数据管理器"></a>数据管理器</h3><ul><li><strong>事务管理器（Transaction manager）</strong>：用于处理事务</li><li><strong>缓存管理器（Cache manager）</strong>：数据被使用之前置于内存，或者数据写入磁盘之前置于内存</li><li><strong>数据访问管理器（Data access manager）</strong>：访问磁盘中的数据</li></ul><h3 id="数据查询的流程"><a href="#数据查询的流程" class="headerlink" title="数据查询的流程"></a>数据查询的流程</h3><p>本章集中探讨数据库如何通过如下进程管理SQL查询的：</p><ul><li>客户端管理器</li><li>查询管理器</li><li>数据管理器（含恢复管理器）</li></ul><h2 id="客户端管理器"><a href="#客户端管理器" class="headerlink" title="客户端管理器"></a>客户端管理器</h2><p>客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB …）提供不同的方式来访问数据库。客户端管理器也提供专有的数据库访问API。</p><p><img src="/attachment%5C163228c4e655734050a80d177d6e9857.png"></p><p><strong>当你连接到数据库时：</strong></p><ul><li>管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。</li><li>然后，管理器检查是否有空闲进程（或线程）来处理你对查询。</li><li>管理器还会检查数据库是否负载很重。</li><li>管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。</li><li>然后管理器会把你的查询送给查询管理器来处理。</li><li>因为查询处理进程不是『不全则无』的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。</li><li>如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。</li></ul><h2 id="查询管理器-1"><a href="#查询管理器-1" class="headerlink" title="查询管理器"></a>查询管理器</h2><p><img src="/attachment%5C5d4489d9412056b3d5aa6fbcc76a9596.png"></p><p>这个多步骤操作过程如下：</p><ul><li>查询首先被解析并判断是否合法</li><li>然后被重写，去除了无用的操作并且加入预优化部分</li><li>接着被优化以便提升性能，并被转换为可执行代码和数据访问计划。</li><li>然后计划被编译</li><li>最后，被执行<br>这里我不会过多探讨最后两步，因为它们不太重要。</li></ul><h3 id="查询解析器"><a href="#查询解析器" class="headerlink" title="查询解析器"></a>查询解析器</h3><p>但这还不算完，解析器还会检查关键字是否使用正确的顺序，比如 WHERE 写在 SELECT 之前会被拒绝。</p><p>然后，解析器要分析查询中的表和字段，使用数据库元数据来检查：</p><ul><li>表是否存在</li><li>表的字段是否存在</li><li>对某类型字段的 运算 是否 可能（比如，你不能将整数和字符串进行比较，你不能对一个整数使用 substring() 函数）<br>接着，解析器检查在查询中你是否有权限来读取（或写入）表。再强调一次：这些权限由DBA分配。<br>在解析过程中，SQL 查询被转换为内部表示（通常是一个树）。<br>如果一切正常，内部表示被送到查询重写器。</li></ul><h3 id="查询重写器"><a href="#查询重写器" class="headerlink" title="查询重写器"></a>查询重写器</h3><p>在这一步，我们已经有了查询的内部表示，重写器的目标是：</p><ul><li>预优化查询</li><li>避免不必要的运算</li><li>帮助优化器找到合理的最佳解决方案<br>重写器按照一系列已知的规则对查询执行检测。如果查询匹配一种模式的规则，查询就会按照这条规则来重写。下面是（可选）规则的非详尽的列表：</li><li>视图合并：如果你在查询中使用视图，视图就会转换为它的 SQL 代码。</li><li>子查询扁平化：子查询是很难优化的，因此重写器会尝试移除子查询</li><li>去除不必要的运算符：比如，如果你用了 DISTINCT，而其实你有 UNIQUE 约束（这本身就防止了数据出现重复），那么 DISTINCT 关键字就被去掉了。</li><li>排除冗余的联接：如果相同的 JOIN 条件出现两次，比如隐藏在视图中的 JOIN 条件，或者由于传递性产生的无用 JOIN，都会被消除。</li><li>常数计算赋值：如果你的查询需要计算，那么在重写过程中计算会执行一次。比如 WHERE AGE &gt; 10+2 会转换为 WHERE AGE &gt; 12 ， TODATE(“日期字符串”) 会转换为 datetime 格式的日期值。</li><li>（高级）分区裁剪（Partition Pruning）：如果你用了分区表，重写器能够找到需要使用的分区。</li><li>（高级）物化视图重写（Materialized view rewrite）：如果你有个物化视图匹配查询谓词的一个子集，重写器将检查视图是否最新并修改查询，令查询使用物化视图而不是原始表。</li><li>（高级）自定义规则：如果你有自定义规则来修改查询（就像 Oracle policy），重写器就会执行这些规则。</li><li>（高级）OLAP转换：分析/加窗 函数，星形联接，ROLLUP 函数……都会发生转换（但我不确定这是由重写器还是优化器来完成，因为两个进程联系很紧，必须看是什么数据库）。</li></ul><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><ul><li>这些统计信息会帮助优化器估计查询所需的磁盘 I/O、CPU、和内存使用</li><li>统计信息必须及时更新。</li></ul><h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><blockquote><p>所有的现代数据库都在用基于成本的优化（即CBO）来优化查询。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。</p></blockquote><p>对于这些联接操作，我会专注于它们的时间复杂度，但是，数据库优化器计算的是它们的 CPU 成本、磁盘 I/O 成本、和内存需求。</p><p>大多数时候瓶颈在于磁盘 I/O 而不是 CPU 使用。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h4 id="存取路径"><a href="#存取路径" class="headerlink" title="存取路径"></a>存取路径</h4><p>在应用联接运算符（join operators）之前，你首先需要获得数据。以下就是获得数据的方法。</p><ul><li>全扫描</li><li>范围扫描</li><li>唯一扫描</li><li>根据 ROW ID 存取</li><li>其它路径</li></ul><h4 id="联接运算符"><a href="#联接运算符" class="headerlink" title="联接运算符"></a>联接运算符</h4><p>3个个常用联接运算符：合并联接（Merge join），哈希联接（Hash Join）和嵌套循环联接（Nested Loop Join）。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">内关系和外关系（ inner relation and outer relation）</p><ul><li>一个表</li><li>一个索引</li><li>上一个运算的中间结果（比如上一个联接运算的结果）</li></ul><p>当你联接两个关系时，联接算法对两个关系的处理是不同的。在本文剩余部分，我将假定：</p><ul><li>外关系是左侧数据集</li><li>内关系是右侧数据集</li></ul><p>比如， A JOIN B 是 A 和 B 的联接，这里 A 是外关系，B 是内关系。</p><p>多数情况下， A JOIN B 的成本跟 B JOIN A 的成本是不同的。</p></div><h5 id="嵌套循环联接"><a href="#嵌套循环联接" class="headerlink" title="嵌套循环联接"></a>嵌套循环联接</h5><blockquote><p>嵌套循环联接是最简单的。</p></blockquote><p><img src="/attachment%5C9a73596fb97e95c90a2df623dc60d5dd.png"></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">算法实现</p><ul><li>针对外关系的每一行，查看内关系里的所有行来寻找匹配的行</li></ul><pre><code class="language-c">nested_loop_join(array outer, array inner)  for each row a in outer    for each row b in inner      if (match_join_condition(a,b))        write_result_in_output(a,b)      end if    end for   end for</code></pre><p>由于这是个双迭代，时间复杂度是 O(N*M)。</p><p>由于这个算法非常简单，下面这个版本在内关系太大无法装入内存时，对磁盘 I/O 更加有利。原因如下：</p><ul><li>为了避免逐行读取两个关系，</li><li>你可以成簇读取，把（两个关系里读到的）两簇数据行保存在内存里，</li><li>比较两簇数据，保留匹配的，</li><li>然后从磁盘加载新的数据簇来继续比较</li><li>直到加载了所有数据。</li></ul><pre><code class="language-c">// improved version to reduce the disk I/O.nested_loop_join_v2(file outer, file inner)  for each bunch ba in outer  // ba is now in memory    for each bunch bb in inner        // bb is now in memory        for each row a in ba          for each row b in bb            if (match_join_condition(a,b))              write_result_in_output(a,b)            end if          end for       end for    end for   end for</code><p><code class="language-c"></code></p></pre><p></p></div><h4 id="哈希联接"><a href="#哈希联接" class="headerlink" title="哈希联接"></a>哈希联接</h4><p>哈希联接更复杂，不过在很多场合比嵌套循环联接成本低。</p><p><img src="/attachment%5C918399908529d8ba5054b06dc01fd17b.png"></p><p>哈希联接的原理是：</p><ul><li>读取内关系的所有元素</li><li>在内存里建一个哈希表</li><li>逐条读取外关系的所有元素 +（用哈希表的哈希函数）计算每个元素的哈希值，来查找内关系里相关的哈希桶内</li><li>是否与外关系的元素匹配。</li></ul><p>在时间复杂度方面我需要做些假设来简化问题：</p><ul><li>内关系被划分成 X 个哈希桶</li><li>哈希函数几乎均匀地分布每个关系内数据的哈希值，就是说哈希桶大小一致。</li><li>外关系的元素与哈希桶内的所有元素的匹配，成本是哈希桶内元素的数量。</li></ul><p>时间复杂度是 (M/X) * N + 创建哈希表的成本(M) + 哈希函数的成本 * N 。如果哈希函数创建了足够小规模的哈希桶，那么复杂度就是 O(M+N)。</p><p>还有个哈希联接的版本，对内存有利但是对磁盘 I/O 不够有利。 这回是这样的：</p><ul><li>计算内关系和外关系双方的哈希表</li><li>保存哈希表到磁盘</li><li>然后逐个哈希桶比较（其中一个读入内存，另一个逐行读取）。</li></ul><h5 id="合并联接"><a href="#合并联接" class="headerlink" title="合并联接"></a>合并联接</h5><blockquote><p>合并联接是唯一产生排序的联接算法。</p></blockquote><ol><li>（可选）排序联接运算：两个输入源都按照联接关键字排序。</li><li>合并联接运算：排序后的输入源合并到一起。</li></ol><ul><li>排序<ul><li>如果表内部就是有序的，比如联接条件里一个索引组织表(index-organized table)</li><li>如果关系是联接条件里的一个索引</li><li>如果联接应用在一个查询中已经排序的中间结果</li></ul></li><li>合并联接</li></ul><p><img src="/attachment%5Cfe166576c0204dd204b132f689f31b6e.png"></p><p>这部分与我们研究过的合并排序中的合并运算非常相似。不过这一次呢，我们不是从两个关系里挑选所有元素，而是只挑选相同的元素。道理如下：</p><ul><li>在两个关系中，比较当前元素（当前=头一次出现的第一个）</li><li>如果相同，就把两个元素都放入结果，再比较两个关系里的下一个元素</li><li>如果不同，就去带有最小元素的关系里找下一个元素（因为下一个元素可能会匹配）</li><li>重复 1、2、3步骤直到其中一个关系的最后一个元素。</li></ul><p><strong>哪个算法最好</strong></p><ul><li>空闲内存：没有足够的内存的话就跟强大的哈希联接拜拜吧（至少是完全内存中哈希联接）。</li><li>两个数据集的大小。比如，如果一个大表联接一个很小的表，那么嵌套循环联接就比哈希联接快，因为后者有创建哈希的高昂成本；如果两个表都非常大，那么嵌套循环联接CPU成本就很高昂。</li><li>是否有索引：有两个 B+树索引的话，聪明的选择似乎是合并联接。</li><li>结果是否需要排序：即使你用到的是未排序的数据集，你也可能想用成本较高的合并联接（带排序的），因为最终得到排序的结果后，你可以把它和另一个合并联接串起来（或者也许因为查询用 ORDER BY/GROUP BY/DISTINCT 等操作符隐式或显式地要求一个排序结果）。</li><li>关系是否已经排序：这时候合并联接是最好的候选项。</li><li>联接的类型：是等值联接（比如 tableA.col1 = tableB.col2 ）？ 还是内联接？外联接？笛卡尔乘积？或者自联接？有些联接在特定环境下是无法工作的。</li><li>数据的分布：如果联接条件的数据是倾斜的（比如根据姓氏来联接人，但是很多人同姓），用哈希联接将是个灾难，原因是哈希函数将产生分布极不均匀的哈希桶。</li><li>如果你希望联接操作使用多线程或多进程。</li></ul><h4 id="查询计划缓存"><a href="#查询计划缓存" class="headerlink" title="查询计划缓存"></a>查询计划缓存</h4><p>由于创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存，来避免重复计算。这个话题比较大，因为数据库需要知道什么时候更新过时的计划。办法是设置一个上限，如果一个表的统计变化超过了上限，关于该表的查询计划就从缓存中清除。</p><h3 id="查询执行器"><a href="#查询执行器" class="headerlink" title="查询执行器"></a>查询执行器</h3><p>在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符 (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。为了获得和写入数据，查询执行器与数据管理器交互，本文下一部分来讨论数据管理器。</p><h2 id="数据管理器-1"><a href="#数据管理器-1" class="headerlink" title="数据管理器"></a>数据管理器</h2><p><img src="/attachment%5Caf894784e841229c3fb6ca65f2310723.png"></p><p>在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。但是有 2 个问题：</p><ul><li>关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。</li><li>数据提取是数据库中速度最慢的操作，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。</li></ul><h3 id="缓存管理器"><a href="#缓存管理器" class="headerlink" title="缓存管理器"></a>缓存管理器</h3><blockquote><p>数据库的主要瓶颈是磁盘 I/O。为了提高性能，现代数据库使用缓存管理器。</p></blockquote><p><img src="/attachment%5C81abc6005712f0dc391185442b6a5cd0.png"></p><p>查询执行器不会直接从文件系统拿数据，而是向缓存管理器要。缓存管理器有一个内存缓存区，叫做缓冲池，从内存读取数据显著地提升数据库性能。</p><h4 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h4><p>缓存管理器在缓冲池里保存所有的这些数据。为了确定一条数据是否有用，缓存管理器给缓存的数据添加了额外的信息（叫闩锁）。</p><h4 id="缓冲区置换策略"><a href="#缓冲区置换策略" class="headerlink" title="缓冲区置换策略"></a>缓冲区置换策略</h4><blockquote><p>多数现代数据库(至少 SQL Server, MySQL, Oracle 和 DB2)使用 LRU 算法。</p></blockquote><h4 id="写缓冲区"><a href="#写缓冲区" class="headerlink" title="写缓冲区"></a>写缓冲区</h4><p>缓冲区保存的是页（最小的数据单位）而不是行（逻辑上/人类习惯的观察数据的方式）。</p><h3 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h3><p>一个ACID事务是一个工作单元，它要保证4个属性：</p><ul><li>原子性（Atomicity）: 事务『要么全部完成，要么全部取消』，即使它持续运行10个小时。如果事务崩溃，状态回到事务之前（事务回滚）。</li><li>一致性（Consistency）: 只有合法的数据（依照关系约束和函数约束）能写入数据库，一致性与原子性和隔离性有关。</li><li>隔离性（Isolation）: 如果2个事务 A 和 B 同时运行，事务 A 和 B 最终的结果是相同的，不管 A 是结束于 B 之前/之后/运行期间。</li><li>持久性（Durability）: 一旦事务提交（也就是成功执行）,不管发生什么（崩溃或者出错），数据要保存在数据库中。</li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>确保隔离性、一致性和原子性的真正问题是对相同数据的写操作（增、更、删）：</p><ul><li>如果所有事务只是读取数据，它们可以同时工作，不会更改另一个事务的行为。</li><li>如果（至少）有一个事务在修改其他事务读取的数据，数据库需要找个办法对其它事务隐藏这种修改。而且，它还需要确保这个修改操作不会被另一个看不到这些数据修改的事务擦除。</li></ul><p>这个问题叫并发控制。</p><h3 id="锁管理器"><a href="#锁管理器" class="headerlink" title="锁管理器"></a>锁管理器</h3><p>多数数据库使用锁和/或数据版本控制。</p><h3 id="日志管理器"><a href="#日志管理器" class="headerlink" title="日志管理器"></a>日志管理器</h3><p>数据库把数据保存在内存缓冲区内。但如果当事务提交时服务器崩溃，崩溃时还在内存里的数据会丢失，这破坏了事务的持久性。你可以把所有数据都写在磁盘上，但是如果服务器崩溃，最终数据可能只有部分写入磁盘，这破坏了事务的原子性。</p><p>事务作出的任何修改必须是或者撤销，或者完成。</p><ul><li>影子副本/页（Shadow copies/pages）</li><li>事务日志（Transaction log）</li></ul><h4 id="WAL（预写式日志）"><a href="#WAL（预写式日志）" class="headerlink" title="WAL（预写式日志）"></a>WAL（预写式日志）</h4><p>影子副本/页在运行较多事务的大型数据库时制造了大量磁盘开销，所以现代数据库使用事务日志。事务日志必须保存在稳定的存储上</p><p>多数数据库（至少是Oracle,SQL Server,DB2,PostgreSQL, MySQL 和SQLite) 使用预写日志协议（Write-Ahead Logging protocol ，WAL）来处理事务日志。WAL协议有 3 个规则：</p><ul><li>每个对数据库的修改都产生一条日志记录，在数据写入磁盘之前日志记录必须写入事务日志。</li><li>日志记录必须按顺序写入；记录 A 发生在记录 B 之前，则 A 必须写在 B 之前。</li><li>当一个事务提交时，在事务成功之前，提交顺序必须写入到事务日志。</li></ul><p><img src="/attachment%5C8e3558d83703552ed6f6388350cc4f2f.png"></p><h4 id="ARIES"><a href="#ARIES" class="headerlink" title="ARIES"></a>ARIES</h4><blockquote><p>IBM 研究人员『发明』了WAL的增强版，叫 ARIES。ARIES 或多或少地在现代数据库中使用，逻辑未必相同，但AIRES背后的概念无处不在。ARIES 代表『数据库恢复原型算法』（Algorithms forRecovery andIsolationExploitingSemantics）。</p></blockquote><p>这个技术要达到一个双重目标：</p><ul><li>写日志的同时保持良好性能</li><li>快速和可靠的数据恢复</li></ul><p>有多个原因让数据库不得不回滚事务：</p><ul><li>因为用户取消</li><li>因为服务器或网络故障</li><li>因为事务破坏了数据库完整性（比如一个列有唯一性约束而事务添加了重复值）</li><li>因为死锁</li></ul><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>事务的每一个操作（增/删/改）产生一条日志，由如下内容组成：</p><ul><li>LSN：一个唯一的日志序列号（Log Sequence Number）。LSN是按时间顺序分配的，这意味着如果操作 A 先于操作 B，log A 的 LSN 要比 log B 的 LSN 小。</li><li>TransID：产生操作的事务ID。</li><li>PageID：被修改的数据在磁盘上的位置。磁盘数据的最小单位是页，所以数据的位置就是它所处页的位置。</li><li>PrevLSN：同一个事务产生的上一条日志记录的链接。</li><li>UNDO：取消本次操作的方法。比如，如果操作是一次更新，UNDO将或者保存元素更新前的值/状态（物理UNDO），或者回到原来状态的反向操作（逻辑UNDO, 只使用逻辑UNDO，因为处理物理UNDO太过混乱了)。</li><li>REDO：重复本次操作的方法。 同样的，有 2 种方法：或者保存操作后的元素值/状态，或者保存操作本身以便重复。</li><li>…：（供您参考，一个 ARIES 日志还有 2 个字段：UndoNxtLSN 和 Type）。</li></ul><p><img src="/attachment%5Cb1344a43d057400787187307301a1e47.png"></p><h4 id="日志缓冲区"><a href="#日志缓冲区" class="headerlink" title="日志缓冲区"></a>日志缓冲区</h4><blockquote><p>为了防止写日志成为主要的瓶颈，数据库使用了日志缓冲区。</p></blockquote><p><img src="/attachment%5C8b05656facd850eee123d6e1b0793c58.png"></p><p>当查询执行器要求做一次修改：</p><ul><li>缓存管理器将修改存入自己的缓冲区；</li><li>日志管理器将相关的日志存入自己的缓冲区；</li><li>到了这一步，查询执行器认为操作完成了（因此可以请求做另一次修改）；</li><li>接着（不久以后）日志管理器把日志写入事务日志，什么时候写日志由某算法来决定。</li><li>接着（不久以后）缓存管理器把修改写入磁盘，什么时候写盘由某算法来决定。</li></ul><p>当事务提交，意味着事务每一个操作的5个步骤都完成了。</p><h4 id="STEAL-和-FORCE-策略"><a href="#STEAL-和-FORCE-策略" class="headerlink" title="STEAL 和 FORCE 策略"></a>STEAL 和 FORCE 策略</h4><p>下面是这些策略对恢复的影响：</p><ul><li>STEAL/NO-FORCE 需要 UNDO 和 REDO: 性能高，但是日志和恢复过程更复杂 (比如 ARIES)。多数数据库选择这个策略。 注：这是我从多个学术论文和教程里看到的，但并没有看到官方文档里显式说明这一点。</li><li>STEAL/ FORCE 只需要 UNDO.</li><li>NO-STEAL/NO-FORCE 只需要 REDO.</li><li>NO-STEAL/FORCE 什么也不需要: 性能最差，而且需要巨大的内存。</li></ul><h4 id="关于恢复"><a href="#关于恢复" class="headerlink" title="关于恢复"></a>关于恢复</h4><p>ARIES从崩溃中恢复有三个阶段：</p><ol><li>分析阶段：恢复进程读取全部事务日志，来重建崩溃过程中所发生事情的时间线，决定哪个事务要回滚（所有未提交的事务都要回滚）、崩溃时哪些数据需要写盘。</li><li>Redo阶段：这一关从分析中选中的一条日志记录开始，使用 REDO 来将数据库恢复到崩溃之前的状态。<ul><li>在REDO阶段，REDO日志按照时间顺序处理（使用LSN）。</li><li>对每一条日志，恢复进程需要读取包含数据的磁盘页LSN。</li><li>如果LSN（磁盘页）&gt;= LSN（日志记录），说明数据已经在崩溃前写到磁盘（但是值已经被日志之后、崩溃之前的某个操作覆盖），所以不需要做什么。</li><li>如果LSN（磁盘页）&lt; LSN（日志记录），那么磁盘上的页将被更新。</li><li>即使将被回滚的事务，REDO也是要做的，因为这样简化了恢复过程（但是我相信现代数据库不会这么做的）。</li></ul></li><li>Undo阶段：这一阶段回滚所有崩溃时未完成的事务。回滚从每个事务的最后一条日志开始，并且按照时间倒序处理UNDO日志（使用日志记录的PrevLSN）。</li></ol><p>恢复过程中，事务日志必须留意恢复过程的操作，以便写入磁盘的数据与事务日志相一致。一个解决办法是移除被取消的事务产生的日志记录，但是这个太困难了。相反，ARIES在事务日志中记录补偿日志，来逻辑上删除被取消的事务的日志记录。</p><p>当事务被『手工』取消，或者被锁管理器取消（为了消除死锁），或仅仅因为网络故障而取消，那么分析阶段就不需要了。对于哪些需要 REDO 哪些需要 UNDO 的信息在 2 个内存表中：</p><ul><li>事务表（保存当前所有事务的状态）</li><li>脏页表（保存哪些数据需要写入磁盘）</li></ul><p>当新的事务产生时，这两个表由缓存管理器和事务管理器更新。因为是在内存中，当数据库崩溃时它们也被破坏掉了。</p><p>分析阶段的任务就是在崩溃之后，用事务日志中的信息重建上述的两个表。为了加快分析阶段，ARIES提出了一个概念：检查点（check point），就是不时地把事务表和脏页表的内容，还有此时最后一条LSN写入磁盘。那么在分析阶段当中，只需要分析这个LSN之后的日志即可。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="/design/xing-wei-mo-shi/fang-wen-zhe-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/fang-wen-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 访问者模式date: 2022-12-19 21:49tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/访问者模式categories:  - 设计keywords:  - 设计模式/行为模式/访问者模式description: 在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</code></pre><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p><p><img src="/attachment/ce651117e8dc05295b0dc04f6d055a39.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>主要将数据结构与数据操作分离。</p><p><strong>主要解决：</strong><br>稳定的数据结构和易变的操作耦合问题。</p><p><strong>何时使用：</strong><br>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作 “污染” 这些对象的类，使用访问者模式将这些封装到类中。</p><p><strong>如何解决：</strong><br>在被访问的类里面加一个对外提供接待访问者的接口。</p><p><strong>关键代码：</strong><br>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p><p><strong>应用实例：</strong><br>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p><p><strong>优点：</strong><br>1、符合单一职责原则。<br>2、优秀的扩展性。<br>3、灵活性。</p><p><strong>缺点：</strong><br>1、具体元素对访问者公布细节，违反了迪米特原则。<br>2、具体元素变更比较困难。<br>3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p><p><strong>使用场景：</strong><br>1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。<br>2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作 “污染” 这些对象的类，也不希望在增加新操作时修改这些类。</p><p><strong>注意事项：</strong>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/11e1e758a2185ce0424009759d5f5b80.png"></p><ol><li>访问者 （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。</li><li>具体访问者 （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。</li><li>元素 （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。</li><li>具体元素 （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。</li><li>客户端 （Client） 通常会作为集合或其他复杂对象 （例如一个组合树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作。</code></pre><pre><code class="line-numbers language-ad-bug">title:  可使用访问者模式来清理辅助行为的业务逻辑。该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。你可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>在访问者接口中声明一组 “访问” 方法， 分别对应程序中的每个具体元素类。</li><li>声明元素接口。 如果程序中已有元素类层次接口， 可在层次结构基类中添加抽象的 “接收” 方法。 该方法必须接受访问者对象作为参数。</li><li>在所有具体元素类中实现接收方法。 这些方法必须将调用重定向到当前元素对应的访问者对象中的访问者方法上。</li><li>元素类只能通过访问者接口与访问者进行交互。 不过访问者必须知晓所有的具体元素类， 因为这些类在访问者方法中都被作为参数类型引用。</li><li>为每个无法在元素层次结构中实现的行为创建一个具体访问者类并实现所有的访问者方法。<br>你可能会遇到访问者需要访问元素类的部分私有成员变量的情况。 在这种情况下， 你要么将这些变量或方法设为公有， 这将破坏元素的封装； 要么将访问者类嵌入到元素类中。 后一种方式只有在支持嵌套类的编程语言中才可能实现。</li><li>客户端必须创建访问者对象并通过 “接收” 方法将其传递给元素。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/9828a2ea092e7d8413d955c607a751fe.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 开闭原则。 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。- 单一职责原则。 可将同一行为的不同版本移到同一个类中。- 访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者。</li><li>在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>你可以将[[访问者模式]]视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。</p><p>你可以使用[[访问者模式]]对整个[[组合模式]]树执行操作。</p><p>可以同时使用[[访问者模式]]和[[迭代器模式]]来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/访问者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/design/xing-wei-mo-shi/mo-ban-fang-fa-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/mo-ban-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 模板方法模式date: 2022-12-19 21:46tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/模板方法模式categories:  - 设计keywords:  - 设计模式/行为模式/模板方法模式description: 模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</code></pre><p>模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p><p><img src="/attachment/ef4a4102de7e72098d6fdde8ae34dc26.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决：</strong><br>一些方法通用，却在每一个子类都重新写了这一方法。</p><p><strong>何时使用：</strong><br>有一些通用的方法。</p><p><strong>如何解决：</strong><br>将这些通用算法抽象出来。</p><p><strong>关键代码：</strong><br>在抽象类实现，其他步骤在子类实现。</p><p><strong>应用实例：</strong><br>1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。<br>2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。<br>3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p><p><strong>优点：</strong><br>1、封装不变部分，扩展可变部分。<br>2、提取公共代码，便于维护。<br>3、行为由父类控制，子类实现。</p><p><strong>缺点：</strong><br>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p><strong>使用场景：</strong><br>1、有多个子类共有的方法，且逻辑相同。<br>2、重要的、复杂的方法，可以考虑作为模板方法。</p><p><strong>注意事项：</strong><br>为防止恶意操作，一般模板方法都加上 final 关键词。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/062cebf2d99efb8d9dacd145325e5571.png"></p><p>抽象类 （AbstractClass） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 抽象类型， 也可以提供一些默认实现。</p><p>具体类 （ConcreteClass） 可以重写所有步骤， 但不能重写模板方法自身。</p><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。 在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>分析目标算法， 确定能否将其分解为多个步骤。 从所有子类的角度出发， 考虑哪些步骤能够通用， 哪些步骤各不相同。</li><li>创建抽象基类并声明一个模板方法和代表算法步骤的一系列抽象方法。 在模板方法中根据算法结构依次调用相应步骤。 可用 final最终修饰模板方法以防止子类对其进行重写。</li><li>虽然可将所有步骤全都设为抽象类型， 但默认实现可能会给部分步骤带来好处， 因为子类无需实现那些方法。</li><li>可考虑在算法的关键步骤之间添加钩子。</li><li>为每个算法变体新建一个具体子类， 它必须实现所有的抽象步骤， 也可以重写部分可选步骤。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。- 你可将重复代码提取到一个超类中。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>部分客户端可能会受到算法框架的限制。</li><li>通过子类抑制默认步骤实现可能会导致违反里氏替换原则。</li><li>模板方法中的步骤越多， 其维护工作就可能会越困难。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[../创建模式/工厂方法模式]]是[[模板方法模式]]的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。</p><p>[[模板方法模式]]基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/模板方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/design/xing-wei-mo-shi/ce-lue-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/ce-lue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 策略模式date: 2022-12-19 21:43tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/策略模式categories:  - 设计keywords:  - 设计模式/行为模式/策略模式description: 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</code></pre><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><p><img src="/attachment/d4d4873421e39b4d0ad4eb9cdf5ef228.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>定义一系列的算法, 把它们一个个封装起来, 并且使它们可相互替换。</p><p><strong>主要解决：</strong><br>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p><strong>何时使用：</strong><br>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p><strong>如何解决：</strong><br>将这些算法封装成一个一个的类，任意地替换。</p><p><strong>关键代码：</strong><br>实现同一个接口。</p><p><strong>应用实例：</strong><br>1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。<br>2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。<br>3、JAVA AWT 中的 LayoutManager。</p><p><strong>优点：</strong><br>1、算法可以自由切换。<br>2、避免使用多重条件判断。<br>3、扩展性良好。</p><p><strong>缺点：</strong><br>1、策略类会增多。<br>2、所有策略类都需要对外暴露。</p><p><strong>使用场景：</strong><br>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br>2、一个系统需要动态地在几种算法中选择一种。<br>3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p><strong>注意事项：</strong><br>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/2c38a30307476b9a217a4fbdb03068a6.png"></p><ol><li>上下文 （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。</li><li>策略 （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。</li><li>具体策略 （Concrete Strategies） 实现了上下文所用算法的各种不同变体。</li><li>当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。</li><li>客户端 （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象， 从而以间接方式在运行时更改对象行为。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。策略模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。策略模式让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来。 不同客户端可通过一个简单接口执行算法， 并能在运行时进行切换。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。 策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。 原始对象并不实现所有算法的变体， 而是将执行工作委派给其中的一个独立算法对象。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>从上下文类中找出修改频率较高的算法 （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。</li><li>声明该算法所有变体的通用策略接口。</li><li>将算法逐一抽取到各自的类中， 它们都必须实现策略接口。</li><li>在上下文类中添加一个成员变量用于保存对于策略对象的引用。 然后提供设置器以修改该成员变量。 上下文仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口来让策略访问其数据。</li><li>客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以在运行时切换对象内的算法。- 你可以将算法的实现和使用算法的代码隔离开来。- 你可以使用组合来代替继承。- 开闭原则。 你无需对上下文进行修改就能够引入新的策略。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。</li><li>客户端必须知晓策略间的不同——它需要选择合适的策略。</li><li>许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[桥接模式]]、 [[状态模式]]和[[策略模式]] （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于[[组合模式]]——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p><p>[[命令模式]]和[[策略模式]]看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。</p><pre><code>你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</code></pre><p>[[装饰模式]]可让你更改对象的外表， 策略则让你能够改变其本质。</p><p>[[模板方法模式]]基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。</p><p>[[状态模式]]可被视为[[策略模式]]的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/design/xing-wei-mo-shi/zhuang-tai-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/zhuang-tai-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 状态模式date: 2022-12-19 21:40tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/状态模式categories:  - 设计keywords:  - 设计模式/行为模式/状态模式description: 状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</code></pre><p>状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><p><img src="/attachment/5480f69319feb93834a7084f1c35784b.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p><strong>主要解决：</strong><br>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p><p><strong>何时使用：</strong><br>代码中包含大量与对象状态有关的条件语句。</p><p><strong>如何解决：</strong><br>将各种具体的状态类抽象出来。</p><p><strong>关键代码：</strong><br>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p><p><strong>应用实例：</strong><br>1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。<br>2、曾侯乙编钟中，’钟是抽象接口’,’钟 A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p><p><strong>优点：</strong><br>1、封装了转换规则。<br>2、枚举可能的状态，在枚举状态之前需要确定状态种类。<br>3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。<br>4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。<br>5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p><p><strong>缺点：</strong><br>1、状态模式的使用必然会增加系统类和对象的个数。<br>2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。<br>3、状态模式对 “开闭原则” 的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p><p><strong>使用场景：</strong><br>1、行为随状态改变而改变的场景。<br>2、条件、分支语句的代替者。</p><p><strong>注意事项：</strong><br>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/19e6a72361e8ea0e8ae8b94febd2bd35.png"></p><ol><li>上下文 （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。</li><li>状态 （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。</li><li>具体状态 （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。</li><li>状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。</li><li>上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title:  如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。</code></pre><pre><code class="line-numbers language-ad-bug">title:  如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。 状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>确定哪些类是上下文。 它可能是包含依赖于状态的代码的已有类； 如果特定于状态的代码分散在多个类中， 那么它可能是一个新的类。</li><li>声明状态接口。 虽然你可能会需要完全复制上下文中声明的所有方法， 但最好是仅把关注点放在那些可能包含特定于状态的行为的方法上。</li><li>为每个实际状态创建一个继承于状态接口的类。 然后检查上下文中的方法并将与特定状态相关的所有代码抽取到新建的类中。<br>在将代码移动到状态类的过程中， 你可能会发现它依赖于上下文中的一些私有成员。 你可以采用以下几种变通方式：<ul><li>将这些成员变量或方法设为公有。</li><li>将需要抽取的上下文行为更改为上下文中的公有方法， 然后在状态类中调用。 这种方式简陋却便捷， 你可以稍后再对其进行修补。</li><li>将状态类嵌套在上下文类中。 这种方式需要你所使用的编程语言支持嵌套类。</li></ul></li><li>在上下文类中添加一个状态接口类型的引用成员变量， 以及一个用于修改该成员变量值的公有设置器。</li><li>再次检查上下文中的方法， 将空的条件语句替换为相应的状态对象方法。</li><li>为切换上下文状态， 你需要创建某个状态类实例并将其传递给上下文。 你可以在上下文、 各种状态或客户端中完成这项工作。 无论在何处完成这项工作， 该类都将依赖于其所实例化的具体类。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 单一职责原则。 将与特定状态相关的代码放在单独的类中。- 开闭原则。 无需修改已有状态类和上下文就能引入新状态。- 通过消除臃肿的状态机条件语句简化上下文代码。 </code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[桥接模式]]、 [[状态模式]]和[[策略模式]] （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p><p>状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/状态模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/design/xing-wei-mo-shi/guan-cha-zhe-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 观察者模式date: 2022-12-19 21:37tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/观察者模式categories:  - 设计keywords:  - 设计模式/行为模式/观察者模式description: 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</code></pre><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><p><img src="/attachment/b925f92877bf0347880b1c8e702607a3.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>主要解决：</strong><br>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>何时使用：</strong><br>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p><strong>如何解决：</strong><br>使用面向对象技术，可以将这种依赖关系弱化。</p><p><strong>关键代码：</strong><br>在抽象类里有一个 ArrayList 存放观察者们。</p><p><strong>应用实例：</strong><br>1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。<br>2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><p><strong>优点：</strong><br>1、观察者和被观察者是抽象耦合的。<br>2、建立一套触发机制。</p><p><strong>缺点：</strong><br>1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。<br>2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。<br>3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>使用场景：</strong></p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><p><strong>注意事项：</strong><br>1、JAVA 中已经有了对观察者模式的支持类。<br>2、避免循环引用。<br>3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/472ab2bb6db239edc1f3dda0b83e5fff.png"></p><ol><li>发布者 （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</li><li>当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。</li><li>订阅者 （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 update更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。</li><li>具体订阅者 （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。</li><li>订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。</li><li>客户端 （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title:  当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。订阅列表是动态的， 因此订阅者可随时加入或离开该列表。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>仔细检查你的业务逻辑， 试着将其拆分为两个部分： 独立于其他代码的核心功能将作为发布者； 其他代码则将转化为一组订阅类。</li><li>声明订阅者接口。 该接口至少应声明一个 update方法。</li><li>声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 记住发布者必须仅通过订阅者接口与它们进行交互。</li><li>确定存放实际订阅列表的位置并实现订阅方法。 通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。<br>但是， 如果你需要在现有的类层次结构中应用该模式， 则可以考虑使用组合的方式： 将订阅逻辑放入一个独立的对象， 然后让所有实际订阅者使用该对象。</li><li>创建具体发布者类。 每次发布者发生了重要事件时都必须通知所有的订阅者。</li><li>在具体订阅者类中实现通知更新的方法。 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。<br>但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。</li><li>客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/056e44738d89cf4428724b1c1e114548.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点-  开闭原则。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。- 你可以在运行时建立对象之间的联系。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>订阅者的通知顺序是随机的。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[责任链模式]]、 [[命令模式]]、 [[中介者模式]]和[[观察者模式]]用于处理请求发送者和接收者之间的不同连接方式：</p><pre><code>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。命令在发送者和请求者之间建立单向连接。中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。观察者允许接收者动态地订阅或取消接收请求。中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。</code></pre><p>[[中介者模式]]的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 [[观察者模式]]的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。</p><p>有一种流行的[[中介者模式]]实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。</p><p>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。</p><p>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/design/xing-wei-mo-shi/bei-wang-lu-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/bei-wang-lu-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 备忘录模式date: 2022-12-19 21:33tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/备忘录模式categories:  - 设计keywords:  - 设计模式/行为模式/备忘录模式description: 备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</code></pre><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p><p><img src="/attachment/f3ec693bfe744af78fab579df9bbe285.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p><strong>主要解决：</strong><br>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p><strong>何时使用：</strong><br>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有 “后悔药” 可吃。</p><p><strong>如何解决：</strong><br>通过一个备忘录类专门存储对象状态。</p><p><strong>关键代码：</strong><br>客户不与备忘录类耦合，与备忘录管理类耦合。</p><p><strong>应用实例：</strong><br>1、后悔药。<br>2、打游戏时的存档。<br>3、Windows 里的 ctrl + z。<br>4、IE 中的后退。<br>5、数据库的事务管理。</p><p><strong>优点：</strong><br>1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。<br>2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p><p><strong>缺点：</strong><br>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p><strong>使用场景：</strong><br>1、需要保存 / 恢复数据的相关状态场景。<br>2、提供一个可回滚的操作。</p><p><strong>注意事项：</strong><br>1、为了符合迪米特原则，还要增加一个管理备忘录的类。<br>2、为了节约内存，可使用原型模式 + 备忘录模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/efea4be20c63f66e38b83d11f1c52cbb.png"></p><ol><li>原发器 （Originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。</li><li>备忘录 （Memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。</li><li>负责人 （Caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。<br>负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。</li><li>在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title:  当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式， 但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>确定担任原发器角色的类。 重要的是明确程序使用的一个原发器中心对象， 还是多个较小的对象。</li><li>创建备忘录类。 逐一声明对应每个原发器成员变量的备忘录成员变量。</li><li>将备忘录类设为不可变。 备忘录只能通过构造函数一次性接收数据。 该类中不能包含设置器。</li><li>如果你所使用的编程语言支持嵌套类， 则可将备忘录嵌套在原发器中； 如果不支持， 那么你可从备忘录类中抽取一个空接口， 然后让其他所有对象通过接口来引用备忘录。 你可在该接口中添加一些元数据操作， 但不能暴露原发器的状态。</li><li>在原发器中添加一个创建备忘录的方法。 原发器必须通过备忘录构造函数的一个或多个实际参数来将自身状态传递给备忘录。<br>该方法返回结果的类型必须是你在上一步中抽取的接口 （如果你已经抽取了）。 实际上， 创建备忘录的方法必须直接与备忘录类进行交互。</li><li>在原发器类中添加一个用于恢复自身状态的方法。 该方法接受备忘录对象作为参数。 如果你在之前的步骤中抽取了接口， 那么可将接口作为参数的类型。 在这种情况下， 你需要将输入对象强制转换为备忘录， 因为原发器需要拥有对该对象的完全访问权限。</li><li>无论负责人是命令对象、 历史记录或其他完全不同的东西， 它都必须要知道何时向原发器请求新的备忘录、 如何存储备忘录以及何时使用特定备忘录来对原发器进行恢复。</li><li>负责人与原发器之间的连接可以移动到备忘录类中。 在本例中， 每个备忘录都必须与创建自己的原发器相连接。 恢复方法也可以移动到备忘录类中， 但只有当备忘录类嵌套在原发器中， 或者原发器类提供了足够多的设置器并可对其状态进行重写时， 这种方式才能实现。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/b3662d68fb05907b3cf9e194aba01d92.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以在不破坏对象封装情况的前提下创建对象状态快照。- 你可以通过让负责人维护原发器状态历史记录来简化原发器代码。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。</li><li>负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录。</li><li>绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>你可以同时使用[[命令模式]]和[[备忘录模式]]来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。</p><p>你可以同时使用[[备忘录模式]]和[[迭代器模式]]来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p><p>有时候[[../创建模式/原型模式]]可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/备忘录模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/design/xing-wei-mo-shi/zhong-jie-zhe-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/zhong-jie-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 中介者模式date: 2022-12-19 21:30tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/中介者模式categories:  - 设计keywords:  - 设计模式/行为模式/中介者模式description: 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</code></pre><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p><p><img src="/attachment/35a3bf0d36391e0981a58503eee067e0.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><strong>主要解决：</strong><br>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><p><strong>何时使用：</strong><br>多个类相互耦合，形成了网状结构。</p><p><strong>如何解决：</strong><br>将上述网状结构分离为星型结构。</p><p><strong>关键代码：</strong><br>对象 Colleague 之间的通信封装到一个类中单独处理。</p><p><strong>应用实例：</strong><br>1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。<br>2、机场调度系统。<br>3、MVC 框架，其中 C（控制器）就是 M（模型）和 V（视图）的中介者。</p><p><strong>优点：</strong><br>1、降低了类的复杂度，将一对多转化成了一对一。<br>2、各个类之间的解耦。<br>3、符合迪米特原则。</p><p><strong>缺点：</strong><br>中介者会庞大，变得复杂难以维护。</p><p><strong>使用场景：</strong><br>1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。<br>2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p><p><strong>注意事项：</strong><br>不应当在职责混乱的时候使用。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/ef12613ae61b98ed85c07d2601258b58.png"></p><ol><li>组件 （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</li><li>中介者 （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。</li><li>具体中介者 （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。</li><li>组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。</li></ol><p>对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。</p><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title:  当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。应用中介者模式后， 每个组件不再知晓其他组件的情况。 尽管这些组件无法直接交流， 但它们仍可通过中介者对象进行间接交流。 如果你希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。</code></pre><pre><code class="line-numbers language-ad-bug">title:  如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>找到一组当前紧密耦合， 且提供其独立性能带来更大好处的类 （例如更易于维护或更方便复用）。</li><li>声明中介者接口并描述中介者和各种组件之间所需的交流接口。 在绝大多数情况下， 一个接收组件通知的方法就足够了。<br> 如果你希望在不同情景下复用组件类， 那么该接口将非常重要。 只要组件使用通用接口与其中介者合作， 你就能将该组件与不同实现中的中介者进行连接。</li><li>实现具体中介者类。 该类可从自行保存其下所有组件的引用中受益。</li><li>你可以更进一步， 让中介者负责组件对象的创建和销毁。 此后， 中介者可能会与工厂或外观类似。</li><li>组件必须保存对于中介者对象的引用。 该连接通常在组件的构造函数中建立， 该函数会将中介者对象作为参数传递。</li><li>修改组件代码， 使其可调用中介者的通知方法， 而非其他组件的方法。 然后将调用其他组件的代码抽取到中介者类中， 并在中介者接收到该组件通知时执行这些代码。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 单一职责原则。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。- 开闭原则。 你无需修改实际组件就能增加新的中介者。- 你可以减轻应用中多个组件间的耦合情况。- 你可以更方便地复用各个组件。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>一段时间后， 中介者可能会演化成为上帝对象。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[责任链模式]]、 [[命令模式]]、 [[中介者模式]]和[[观察者模式]]用于处理请求发送者和接收者之间的不同连接方式：</p><pre><code>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。命令在发送者和请求者之间建立单向连接。中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。观察者允许接收者动态地订阅或取消接收请求。外观模式和中介者的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。</code></pre><p>中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。</p><p>有一种流行的[[中介者模式]]实现方式依赖于[[观察者模式]]。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。</p><p>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。</p><p>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/中介者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/design/xing-wei-mo-shi/die-dai-qi-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/die-dai-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 迭代器模式date: 2022-12-19 21:26tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/迭代器模式categories:  - 设计keywords:  - 设计模式/行为模式/迭代器模式description: 迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</code></pre><p>迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p><p><img src="/attachment/e49b4c0b979672f4840ca69ada9523eb.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p><strong>主要解决：</strong><br>不同的方式来遍历整个整合对象。</p><p><strong>何时使用：</strong><br>遍历一个聚合对象。</p><p><strong>如何解决：</strong><br>把在元素之间游走的责任交给迭代器，而不是聚合对象。</p><p><strong>关键代码：</strong><br>定义接口：hasNext, next。</p><p><strong>应用实例：</strong><br>JAVA 中的 iterator。</p><p><strong>优点：</strong><br>1、它支持以不同的方式遍历一个聚合对象。<br>2、迭代器简化了聚合类。<br>3、在同一个聚合上可以有多个遍历。<br>4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p><p><strong>缺点：</strong><br>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p><p><strong>使用场景：</strong><br>1、访问一个聚合对象的内容而无须暴露它的内部表示。<br>2、需要为聚合对象提供多种遍历方式。<br>3、为遍历不同的聚合结构提供一个统一的接口。</p><p><strong>注意事项：</strong><br>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/9617a74a1781ae4e7f5d0f575fbd7f6b.png"></p><ol><li>迭代器 （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</li><li>具体迭代器 （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</li><li>集合 （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</li><li>具体集合 （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</li><li>客户端 （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。</li></ol><p>客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</p><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。 迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</code></pre><pre><code class="line-numbers language-ad-bug">title: 使用该模式可以减少程序中重复的遍历代码。重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>声明迭代器接口。 该接口必须提供至少一个方法来获取集合中的下个元素。 但为了使用方便， 你还可以添加一些其他方法， 例如获取前一个元素、 记录当前位置和判断迭代是否已结束。</li><li>声明集合接口并描述一个获取迭代器的方法。 其返回值必须是迭代器接口。 如果你计划拥有多组不同的迭代器， 则可以声明多个类似的方法。</li><li>为希望使用迭代器进行遍历的集合实现具体迭代器类。 迭代器对象必须与单个集合实体链接。 链接关系通常通过迭代器的构造函数建立。</li><li>在你的集合类中实现集合接口。 其主要思想是针对特定集合为客户端代码提供创建迭代器的快捷方式。 集合对象必须将自身传递给迭代器的构造函数来创建两者之间的链接。</li><li>检查客户端代码， 使用迭代器替代所有集合遍历代码。 每当客户端需要遍历集合元素时都会获取一个新的迭代器。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。- 开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。- 你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。- 相似的， 你可以暂停遍历并在需要时继续。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</li><li>对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>你可以使用[[迭代器模式]]来遍历组合模式树。</p><p>你可以同时使用[[../创建模式/工厂方法模式]]和[[迭代器模式]]来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p><p>你可以同时使用[[备忘录模式]]和[[迭代器模式]]来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p><p>可以同时使用[[访问者模式]]和[[迭代器模式]]来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/迭代器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/design/xing-wei-mo-shi/ming-ling-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/ming-ling-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 命令模式date: 2022-12-19 21:21tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/命令模式categories:  - 设计keywords:  - 设计模式/行为模式/命令模式description: 命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</code></pre><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p><img src="/attachment/be55497ca22c90f2aa529c9b0958cbf8.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p><strong>主要解决：</strong><br>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><p><strong>何时使用：</strong><br>在某些场合，比如要对行为进行 “记录、撤销 / 重做、事务” 等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将 “行为请求者” 与 “行为实现者” 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><p><strong>如何解决：</strong><br>通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。</p><p><strong>关键代码：</strong><br>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p><p><strong>应用实例：</strong><br>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p><p><strong>优点：</strong></p><ol><li>降低了系统耦合度。 </li><li>新的命令可以很容易添加到系统中去。</li></ol><p><strong>缺点：</strong><br>使用命令模式可能会导致某些系统有过多的具体命令类。</p><p><strong>使用场景：</strong><br>认为是命令的地方都可以使用命令模式，比如： </p><ol><li>GUI 中每一个按钮都是一条命令。 </li><li>模拟 CMD。</li></ol><p><strong>注意事项：</strong><br>系统需要支持命令的撤销 (Undo) 操作和恢复 (Redo) 操作，也可以考虑使用命令模式，见命令模式的扩展。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/3a1d92b98e66b8eb63bc0b64f2ba2f63.png"></p><ol><li>发送者 （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</li><li>命令 （Command） 接口通常仅声明一个执行命令的方法。</li><li>具体命令 （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。<br>接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。</li><li>接收者 （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</li><li>客户端 （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 如果你需要通过操作来参数化对象， 可使用命令模式。命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。举个例子： 你正在开发一个 GUI 组件 （例如上下文菜单）， 你希望用户能够配置菜单项， 并在点击菜单项时触发操作。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果你想要实现操作回滚功能， 可使用命令模式。尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。其次， 备份状态可能会占用大量内存。 因此， 有时你需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>明仅有一个执行方法的命令接口。</li><li>取请求并使之成为实现命令接口的具体命令类。 每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。 所有这些变量的数值都必须通过命令构造函数进行初始化。</li><li>到担任发送者职责的类。 在这些类中添加保存命令的成员变量。 发送者只能通过命令接口与其命令进行交互。 发送者自身通常并不创建命令对象， 而是通过客户端代码获取。</li><li>改发送者使其执行命令， 而非直接将请求发送给接收者。</li><li>户端必须按照以下顺序来初始化对象：<ul><li>创建接收者。</li><li>创建命令， 如有需要可将其关联至接收者。</li><li>创建发送者并将其与特定命令关联。</li></ul></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/f339c7940b920d19fb048b78920ed6ab.png"></p><p><img src="/attachment/f1160fdf69eb269a6fa1c7e6f57cce32.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 单一职责原则。 你可以解耦触发和执行操作的类。- 开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。- 你可以实现撤销和恢复功能。- 你可以实现操作的延迟执行。- 你可以将一组简单命令组合成一个复杂命令。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[责任链模式]]、 [[命令模式]]、 [[中介者模式]]和[[观察者模式]]用于处理请求发送者和接收者之间的不同连接方式：</p><pre><code>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。命令在发送者和请求者之间建立单向连接。中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。观察者允许接收者动态地订阅或取消接收请求。责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。</code></pre><p>还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</p><p>你可以同时使用命令和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。</p><p>[[命令模式]]和[[策略模式]]看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。</p><pre><code>你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</code></pre><p>[[../创建模式/原型模式]]可用于保存命令的历史记录。</p><p>你可以将[[访问者模式]]视为[[命令模式]]的加强版本， 其对象可对不同类的多种对象执行操作。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/命令模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/design/xing-wei-mo-shi/ze-ren-lian-mo-shi/"/>
      <url>/design/xing-wei-mo-shi/ze-ren-lian-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 责任链模式date: 2022-12-19 21:18tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/行为模式/责任链模式categories:  - 设计keywords:  - 设计模式/行为模式/责任链模式description: 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</code></pre><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p><img src="/attachment/153ca09a5d5bcf63c0cfb9b8a654e860.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决：</strong><br>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用：</strong><br>在处理消息的时候以过滤很多道。</p><p><strong>如何解决：</strong><br>拦截的类都实现统一接口。</p><p><strong>关键代码：</strong><br>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p><strong>应用实例：</strong></p><ol><li>红楼梦中的 “击鼓传花”。 </li><li>JS 中的事件冒泡。</li><li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li></ol><p><strong>优点：</strong></p><ol><li>降低耦合度。它将请求的发送者和接收者解耦。</li><li>简化了对象。使得对象不需要知道链的结构。 </li><li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 </li><li>增加新的请求处理类很方便。</li></ol><p><strong>缺点：</strong> </p><ol><li>不能保证请求一定被接收。 </li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 </li><li>可能不容易观察运行时的特征，有碍于除错。</li></ol><p><strong>使用场景：</strong> </p><ol><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 </li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求。</li></ol><p><strong>注意事项：</strong><br>在 JAVA WEB 中遇到很多应用。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/253a3de52c412caa2fd1d541da891dcc.png"></p><ol><li>处理者 （Handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</li><li>基础处理者 （Base Handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。</li><li>通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。</li><li>具体处理者 （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。</li><li>处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。</li><li>客户端 （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。</li></ol><p><img src="/attachment/2bf20c63ac8ac185af2c066c344d3d05.png"></p><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。 该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当必须按顺序执行多个处理者时， 可以使用该模式。无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>声明处理者接口并描述请求处理方法的签名。<br> 确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</li><li>为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。<br> 该类需要有一个成员变量来存储指向链上下个处理者的引用。 你可以将其设置为不可变类。 但如果你打算在运行时对链进行改变， 则需要定义一个设定方法来修改引用成员变量的值。<br> 为了使用方便， 你还可以实现处理方法的默认行为。 如果还有剩余对象， 该方法会将请求传递给下个对象。 具体处理者还能够通过调用父对象的方法来使用这一行为。</li><li>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：<ul><li>是否自行处理这个请求。</li><li>是否将该请求沿着链进行传递。</li></ul></li><li>客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。</li><li>客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。</li><li>由于链的动态性， 客户端需要准备好处理以下情况：<ul><li>链中可能只有单个链接。</li><li>部分请求可能无法到达链尾。</li><li>其他请求可能直到链尾都未被处理。</li></ul></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/96993806650bc5c527b7eea582ad4710.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以控制请求处理的顺序。- 单一职责原则。 你可对发起操作和执行操作的类进行解耦。- 开闭原则。 你可以在不更改现有代码的情况下在程序中新增处理者。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>部分请求可能未被处理。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[责任链模式]]、 [[命令模式]]、 [[中介者模式]]和[[观察者模式]]用于处理请求发送者和接收者之间的不同连接方式：</p><pre><code>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。命令在发送者和请求者之间建立单向连接。中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。观察者允许接收者动态地订阅或取消接收请求。责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</code></pre><p>[[责任链模式]]的管理者可使用[[命令模式]]实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。</p><p>还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</p><p>[[责任链模式]]和[[装饰模式]]的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p><p>[[责任链模式]]的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/行为模式/责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/design/jie-gou-mo-shi/dai-li-mo-shi/"/>
      <url>/design/jie-gou-mo-shi/dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 代理模式date: 2022-12-19 21:13tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/结构模式/代理模式categories:  - 设计keywords:  - 设计模式/结构模式/代理模式description: 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</code></pre><blockquote><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><p><img src="/attachment/95a6d1b2876516d92224067cfc4c9b0e.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决：</strong><br>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p><strong>何时使用：</strong><br>想在访问一个类时做一些控制。</p><p><strong>如何解决：</strong><br>增加中间层。</p><p><strong>关键代码：</strong><br>实现与被代理类组合。</p><p><strong>应用实例：</strong> </p><ol><li>Windows 里面的快捷方式。 </li><li>猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 </li><li>买火车票不一定在火车站买，也可以去代售点。 </li><li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 </li><li>spring aop。</li></ol><p><strong>优点：</strong> </p><ol><li>职责清晰。 </li><li>高扩展性。 </li><li>智能化。</li></ol><p><strong>缺点：</strong> </p><ol><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 </li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ol><p><strong>使用场景：</strong><br>按职责来划分，通常有以下使用场景： </p><ol><li>远程代理。 </li><li>虚拟代理。 </li><li>Copy-on-Write 代理。 </li><li>保护（Protect or Access）代理。 </li><li>Cache 代理。 </li><li>防火墙（Firewall）代理。</li><li>同步化（Synchronization）代理。 </li><li>智能引用（Smart Reference）代理。</li></ol><p><strong>注意事项：</strong> </p><ol><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 </li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ol><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/ee349077e36e6447162915379b2a62c7.png"></p><ol><li>服务接口 （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</li><li>服务 （Service） 类提供了一些实用的业务逻辑。</li><li>代理 （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。<br> 通常情况下， 代理会对其服务对象的整个生命周期进行管理。</li><li>客户端 （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。 你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</code></pre><pre><code class="line-numbers language-ad-bug">title: 访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。 代理可仅在客户端凭据满足要求时将请求传递给服务对象。</code></pre><pre><code class="line-numbers language-ad-bug">title:  本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。 在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</code></pre><pre><code class="line-numbers language-ad-bug">title:  记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</code></pre><pre><code class="line-numbers language-ad-bug">title:  缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。 代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</code></pre><pre><code class="line-numbers language-ad-bug">title: 智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。</li><li>创建代理类， 其中必须包含一个存储指向服务的引用的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。</li><li>根据需求实现代理方法。 在大部分情况下， 代理在完成一些任务后应将工作委派给服务对象。</li><li>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。</li><li>可以考虑为服务对象实现延迟初始化。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以在客户端毫无察觉的情况下控制服务对象。- 如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。- 即使服务对象还未准备好或不存在， 代理也可以正常工作。- 开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>代码可能会变得复杂， 因为需要新建许多类。</li><li>服务响应可能会延迟。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[适配器模式]]能为被封装对象提供不同的接口， [[代理模式]]能为对象提供相同的接口， [[装饰模式]]则能为对象提供加强的接口。</p><p>[[外观模式]]与[[代理模式]]的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p><p>[[装饰模式]]和[[代理模式]]有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/结构模式/代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/design/jie-gou-mo-shi/xiang-yuan-mo-shi/"/>
      <url>/design/jie-gou-mo-shi/xiang-yuan-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 享元模式date: 2022-12-19 21:09tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/结构模式/享元模式categories:  - 设计keywords:  - 设计模式/结构模式/享元模式description: 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</code></pre><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。<br>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。</p><p><img src="/attachment/744e3c99d2bf75d1166c57f91d2a6668.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>运用共享技术有效地支持大量细粒度的对象。</p><p><strong>主要解决：</strong><br>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p><strong>何时使用：</strong></p><ol><li>系统中有大量对象。 </li><li>这些对象消耗大量内存。 </li><li>这些对象的状态大部分可以外部化。</li><li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。</li><li>系统不依赖于这些对象身份，这些对象是不可分辨的。</li></ol><p><strong>如何解决：</strong><br>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p><p><strong>关键代码：</strong><br>用 HashMap 存储这些对象。</p><p><strong>应用实例：</strong></p><ol><li>JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 </li><li>数据库的数据池。</li></ol><p><strong>优点：</strong><br>大大减少对象的创建，降低系统的内存，使效率提高。</p><p><strong>缺点：</strong><br>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p><p><strong>使用场景：</strong> </p><ol><li>系统有大量相似对象。</li><li>需要缓冲池的场景。</li></ol><p><strong>注意事项：</strong></p><ol><li>注意划分外部状态和内部状态，否则可能会引起线程安全问题。</li><li>这些类必须有一个工厂对象加以控制。</li></ol><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/bcbfc5d04372be97ae741a09c73a6c7f.png"></p><p>1.享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。<br>2. <strong>享元</strong> （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。<br>3. <strong>情景</strong> （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。<br>4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。<br>5. <strong>客户端</strong> （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。<br>6. <strong>享元工厂</strong> （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</p><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：- 程序需要生成数量巨大的相似对象- 这将耗尽目标设备的所有内存- 对象中包含可抽取且能在多个对象间共享的重复状态。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>将需要改写为享元的类成员变量拆分为两个部分：<ol><li>内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。</li><li>外在状态： 包含每个对象各自不同的情景数据的成员变量</li></ol></li><li>保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。</li><li>找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。</li><li>你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。</li><li>客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/651673e49a27def96ecc24f09eb3101a.png"></p><p><img src="/attachment/220ba47f711d5af6b6266c310e1edcc1.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 如果程序中有很多相似对象， 那么你将可以节省大量内存。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。</li><li>代码会变得更加复杂。 团队中的新成员总是会问： “为什么要像这样拆分一个实体的状态？”。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>你可以使用[[享元模式]]实现[[组合模式]]树的共享叶节点以节省内存。</p><p>[[享元模式]]展示了如何生成大量的小型对象， [[外观模式]]则展示了如何用一个对象来代表整个子系统。</p><p>如果你能将对象的所有共享状态简化为一个享元对象， 那么[[享元模式]]就和[[../创建模式/单例模式]]类似了。 但这两个模式有两个根本性的不同。</p><p>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。<br>单例对象可以是可变的。 享元对象是不可变的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/结构模式/享元模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/design/jie-gou-mo-shi/wai-guan-mo-shi/"/>
      <url>/design/jie-gou-mo-shi/wai-guan-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 外观模式date: 2022-12-19 21:03tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/结构模式/外观模式categories:  - 设计keywords:  - 设计模式/结构模式/外观模式description: 外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</code></pre><p>外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p><p><img src="/attachment/8ada02ceb95d0098e9bf68c2d8ccb017.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>主要解决：</strong><br>降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。</p><p><strong>何时使用：</strong> </p><ol><li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个 “接待员” 即可。 </li><li>定义系统的入口。</li></ol><p><strong>如何解决：</strong><br>客户端不与系统耦合，外观类与系统耦合。</p><p><strong>关键代码：</strong><br>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p><p><strong>应用实例：</strong> </p><ol><li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</li><li>JAVA 的三层开发模式。</li></ol><p><strong>优点：</strong> </p><ol><li>减少系统相互依赖。</li><li>提高灵活性。 </li><li>提高了安全性。</li></ol><p><strong>缺点：</strong><br>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p><p><strong>使用场景：</strong> </p><ol><li>为复杂的模块或子系统提供外界访问的模块。 </li><li>子系统相对独立。 </li><li>预防低水平人员带来的风险。</li></ol><p><strong>注意事项：</strong><br>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/3efadb121927468604e1acb200223557.png"></p><ol><li>外观 （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</li><li>创建附加外观 （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</li><li>复杂子系统 （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</li><li>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</li><li>客户端 （Client） 使用外观代替对子系统对象的直接调用。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果需要将子系统组织为多层结构， 可以使用外观。创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与中介者模式非常相似。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>考虑能否在现有子系统的基础上提供一个更简单的接口。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。</li><li>在一个新的外观类中声明并实现该接口。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化， 也没有对其后续生命周期进行管理， 那么外观必须完成此类工作。</li><li>如果要充分发挥这一模式的优势， 你必须确保所有客户端代码仅通过外观来与子系统进行交互。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。</li><li>如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/3eaaa1d2b1ad81df39abfdbb5c94a3d5.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以让自己的代码独立于复杂子系统。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>外观可能成为与程序中所有类都耦合的上帝对象。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[外观模式]]为现有对象定义了一个新接口， [[适配器模式]]则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p><p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用[[../创建模式/抽象工厂模式]]来代替[[外观模式]]。</p><p>[[享元模式]]展示了如何生成大量的小型对象， [[外观模式]]则展示了如何用一个对象来代表整个子系统。</p><p>[[外观模式]]和[[中介者模式]]的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。</p><p>[[外观模式]]为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。<br>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。<br>外观类通常可以转换为[[../创建模式/单例模式]]类， 因为在大部分情况下一个外观对象就足够了。</p><p>外观与[[代理模式]]的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/结构模式/外观模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="/design/jie-gou-mo-shi/zhuang-shi-mo-shi/"/>
      <url>/design/jie-gou-mo-shi/zhuang-shi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 装饰模式date: 2022-12-19 20:54tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/结构模式/装饰模式categories:  - 设计keywords:  - 设计模式/结构模式/装饰模式description: 装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</code></pre><p>装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><p><img src="/attachment/feff3fd7c1b6c6f449956f4b30cc1ef9.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p><strong>主要解决：</strong><br>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p><strong>何时使用：</strong><br>在不想增加很多子类的情况下扩展类。</p><p><strong>如何解决：</strong><br>将具体功能职责划分，同时继承装饰者模式。</p><p><strong>关键代码：</strong></p><ol><li>Component 类充当抽象角色，不应该具体实现。 </li><li>修饰类引用和继承 Component 类，具体扩展类重写父类方法。</li></ol><p><strong>应用实例：</strong></p><ol><li>孙悟空有 72 变，当他变成 “庙宇” 后，他的根本还是一只猴子，但是他又有了庙宇的功能。 </li><li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li></ol><p><strong>优点：</strong><br>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p><strong>缺点：</strong><br>多层装饰比较复杂。</p><p><strong>使用场景：</strong> </p><ol><li>扩展一个类的功能。 </li><li>动态增加功能，动态撤销。</li></ol><p><strong>注意事项：</strong><br>可代替继承。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/8784dc5afa22d597e1266b80ec54168e.png"></p><ol><li>部件 （Component） 声明封装器和被封装对象的公用接口。</li><li>具体部件 （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</li><li>基础装饰 （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</li><li>具体装饰类 （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</li><li>客户端 （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。许多编程语言使用 final最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</li><li>找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。</li><li>创建一个具体组件类， 并定义其基础行为。</li><li>创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。</li><li>确保所有类实现组件接口。</li><li>将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。</li><li>客户端代码负责创建装饰并将其组合成客户端所需的形式。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/f5f7aafc41bbe235668bcb1a1716f6ee.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你无需创建新子类即可扩展对象的行为。- 你可以在运行时添加或删除对象的功能。- 你可以用多个装饰封装对象来组合几种行为。- 单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>在封装器栈中删除特定封装器比较困难。</li><li>实现行为不受装饰栈顺序影响的装饰比较困难。</li><li>各层的初始化配置代码看上去可能会很糟糕。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[适配器模式]]可以对已有对象的接口进行修改， [[装饰模式]]则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p><p>[[适配器模式]]能为被封装对象提供不同的接口， [[代理模式]]能为对象提供相同的接口，[[装饰模式]]则能为对象提供加强的接口。</p><p>[[责任链模式]]和[[装饰模式]]的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p><p>责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p><p>组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p><p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p><p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p><p>大量使用[[组合模式]]和[[装饰模式]]的设计通常可从对于[[../创建模式/原型模式]]的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p><p>[[装饰模式]]可让你更改对象的外表， [[策略模式]]则让你能够改变其本质。</p><p>[[装饰模式]]和[[代理模式]]有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/结构模式/装饰模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/design/jie-gou-mo-shi/zu-he-mo-shi/"/>
      <url>/design/jie-gou-mo-shi/zu-he-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 组合模式date: 2022-12-14 15:45tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/结构模式/组合模式categories:  - 设计keywords:  - 设计模式/结构模式/组合模式description: 组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</code></pre><p>组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p><p><img src="/attachment/ef56d205ce0cd5c58b673610f713237d.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>将对象组合成树形结构以表示 “部分 - 整体” 的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>主要解决：</strong><br>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><p><strong>何时使用：</strong> </p><ol><li>您想表示对象的部分 - 整体层次结构（树形结构）。</li><li>您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li></ol><p><strong>如何解决：</strong><br>树枝和叶子实现统一接口，树枝内部组合该接口。</p><p><strong>关键代码：</strong><br>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p><strong>应用实例：</strong></p><ol><li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 </li><li>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li></ol><p><strong>优点：</strong> </p><ol><li>高层模块调用简单。</li><li>节点自由增加。</li></ol><p><strong>缺点：</strong><br>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>使用场景：</strong><br>部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p><strong>注意事项：</strong><br>定义时为具体类。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/2845838d7ac97bb2cfaf8f7b2b1b40d3.png"></p><ol><li>组件 （Component） 接口描述了树中简单项目和复杂项目所共有的操作。</li><li>叶节点 （Leaf） 是树的基本结构， 它不包含子项目。</li><li>一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</li><li>容器 （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。</li><li>容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</li><li>客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 如果你需要实现树状对象结构， 可以使用组合模式。组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</li><li>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</li><li>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</li><li>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。<ol><li>实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</li></ol></li><li>最后， 在容器中定义添加和删除子元素的方法。</li></ol><p>记住， 这些操作可在组件接口中声明。 这将会违反接口隔离原则， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/4846fa502c917feef0522c70f132ad8d.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点-  你可以利用多态和递归机制更方便地使用复杂树结构。- 开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[桥接模式]]、 [[状态模式]]和[[策略模式]] （在某种程度上包括[[适配器模式]]） 模式的接口非常相似。 实际上， 它们都基于[[组合模式]]——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p><p>你可以在创建复杂组合树时使用[[../创建模式/生成器模式]]， 因为这可使其构造步骤以递归的方式运行。</p><p>[[责任链模式]]通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p><p>你可以使用[[迭代器模式]]来遍历组合树。</p><p>你可以使用[[访问者模式]]对整个组合树执行操作。</p><p>你可以使用[[享元模式]]实现组合树的共享叶节点以节省内存。</p><p>[[组合模式]]和[[装饰模式]]的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p><p>[[装饰模式]]似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p><p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p><p>大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/结构模式/组合模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/design/jie-gou-mo-shi/qiao-jie-mo-shi/"/>
      <url>/design/jie-gou-mo-shi/qiao-jie-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 桥接模式date: 2022-12-14 15:41tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/结构模式/桥接模式categories:  - 设计keywords:  - 设计模式/结构模式/桥接模式description: 桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</code></pre><blockquote><p> 桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p></blockquote><p><img src="/attachment/2dd64841591c3e2ced600d898e6b89cb.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p><strong>主要解决：</strong><br>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p><p><strong>何时使用：</strong><br>实现系统可能有多个角度分类，每一种角度都可能变化。</p><p><strong>如何解决：</strong><br>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p><p><strong>关键代码：</strong><br>抽象类依赖实现类。</p><p><strong>应用实例：</strong></p><ol><li>猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 </li><li>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</li></ol><p><strong>优点：</strong></p><ol><li>抽象和实现的分离。</li><li>优秀的扩展能力。</li><li>实现细节对客户透明。</li></ol><p><strong>缺点：</strong><br>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>使用场景：</strong> </p><ol><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 </li><li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li></ol><p><strong>注意事项：</strong><br>对于两个独立变化的维度，使用桥接模式再适合不过了。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/4221a336f0d259c9a28af2d6074c95a7.png"></p><ol><li>抽象部分 （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</li><li>实现部分 （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。</li><li>抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。</li><li>具体实现 （Concrete Implementations） 中包括特定于平台的代码。</li><li>精确抽象 （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</li><li>通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。 类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果你希望在几个独立维度上扩展一个类， 可使用该模式。桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</code></pre><pre><code class="line-numbers language-ad-bug">title:  如果你需要在运行时切换不同实现方法， 可使用桥接模式。当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</li><li>了解客户端的业务需求， 并在抽象基类中定义它们。</li><li>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</li><li>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</li><li>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</li><li>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</li><li>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/f26b68b495269b46c72a5ac831442e1c.png"></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">示例</p><p>collapse: closed</p><p><img src="https://img2022.cnblogs.com/blog/1459011/202203/1459011-20220318232341446-871797952.png" alt></p><p>抽象化角色：</p><pre><code class="language-java">package com.charon.bridge;<p>/**</p><ul><li><p>@className: Brand</p></li><li><p>@description: 抽象化产品角色</p></li><li><p>@author: charon</p></li><li><p>@create: 2022-03-18 22:51<br> */<br>public interface Brand {<br> void open();</p><p> void close();</p><p> void call();</p></li></ul></code><p><code class="language-java">}<br></code></p></pre><p></p><p>扩展抽象化角色：</p><pre><code class="language-java">package com.charon.bridge;<p>/**</p><ul><li><p>@className: Vivo</p></li><li><p>@description:</p></li><li><p>@author: charon</p></li><li><p>@create: 2022-03-18 22:55<br> */<br>public class Vivo implements Brand {<br> @Override<br> public void open() {<br> System.out.println("vivo手机开机了。。。。");<br> }</p><p> @Override<br> public void close() {<br> System.out.println("vivo手机关机了。。。。");<br> }</p><p> @Override<br> public void call() {<br> System.out.println("vivo手机打电话。。。。");<br> }</p></li></ul><p>}</p><p>package com.charon.bridge;</p><p>/**</p><ul><li><p>@className: XiaoMi</p></li><li><p>@description:</p></li><li><p>@author: charon</p></li><li><p>@create: 2022-03-18 22:56<br> */<br>public class XiaoMi implements Brand{<br> @Override<br> public void open() {<br> System.out.println("小米手机开机了。。。。");<br> }</p><p> @Override<br> public void close() {<br> System.out.println("小米手机关机了。。。。");<br> }</p><p> @Override<br> public void call() {<br> System.out.println("小米手机打电话。。。。");<br> }</p></li></ul></code><p><code class="language-java">}<br></code></p></pre><p></p><p>实现化角色：</p><pre><code class="language-java">package com.charon.bridge;<p>/**</p><ul><li><p>@className: Phone</p></li><li><p>@description: 实现化角色</p></li><li><p>@author: charon</p></li><li><p>@create: 2022-03-18 22:52<br> */<br>public abstract class Phone {</p><p> private Brand brand;</p><p> public Phone(Brand brand) {<br> this.brand = brand;<br> }</p><p> protected void open(){<br>   this.brand.open();<br> }</p><p> protected void call(){<br> this.brand.call();<br> }</p><p> protected void close(){<br> this.brand.close();<br> }</p></li></ul></code><p><code class="language-java">}<br></code></p></pre><p></p><p>具体实现化角色：</p><pre><code class="language-java">package com.charon.bridge;<p>/**</p><ul><li><p>@className: FoldedPhone</p></li><li><p>@description:</p></li><li><p>@author: charon</p></li><li><p>@create: 2022-03-18 22:57<br> */<br>public class FoldedPhone extends Phone{<br> public FoldedPhone(Brand brand) {<br> super(brand);<br> }</p><p> @Override<br> protected void open(){<br> super.open();<br> System.out.println("折叠样式手机开机。。。。");<br> }</p><p> @Override<br> protected void call(){<br> super.call();<br> System.out.println("折叠样式手机打电话。。。。");<br> }</p><p> @Override<br> protected void close(){<br> super.close();<br> System.out.println("折叠样式手机关机。。。。");<br> }</p></li></ul><p>}</p><p>package com.charon.bridge;</p><p>/**</p><ul><li><p>@className: UpRightPhone</p></li><li><p>@description:</p></li><li><p>@author: charon</p></li><li><p>@create: 2022-03-18 22:59<br> */<br>public class UpRightPhone extends Phone{</p><p> public UpRightPhone(Brand brand) {<br> super(brand);<br> }</p><p> @Override<br> protected void open(){<br> super.open();<br> System.out.println("直立样式手机开机。。。。");<br> }</p><p> @Override<br> protected void call(){<br> super.call();<br> System.out.println("直立样式手机打电话。。。。");<br> }</p><p> @Override<br> protected void close(){<br> super.close();<br> System.out.println("直立样式手机关机。。。。");<br> }</p></li></ul></code><p><code class="language-java">}<br></code></p></pre><p></p><p>测试：</p><pre><code class="language-java">package com.charon.bridge;<p>/**</p><ul><li>@className: Client</li><li>@description:</li><li>@author: charon</li><li>@create: 2022-03-18 22:51<br> */<br>public class Client {<br> public static void main(String[] args) {<br> // 获取折叠样式手机（品牌+样式）<br> FoldedPhone xiaomiFoldedPhone = new FoldedPhone(new XiaoMi());<br> xiaomiFoldedPhone.open();<br> xiaomiFoldedPhone.call();<br> xiaomiFoldedPhone.close();<br><br> UpRightPhone xiaomiUpRightPhone = new UpRightPhone(new XiaoMi());<br> xiaomiUpRightPhone.open();<br> xiaomiUpRightPhone.call();<br> xiaomiUpRightPhone.close();<br> }</li></ul></code><p><code class="language-java">}<br></code></p></pre><p></p></div><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以创建与平台无关的类和程序。- 客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。- 开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。- 单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>对高内聚的类使用该模式可能会让代码更加复杂。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[桥接模式]]通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， [[适配器模式]]通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p><p>[[桥接模式]]、 [[状态模式]]和[[策略模式]] （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p><p>你可以将[[../创建模式/抽象工厂模式]]和[[桥接模式]]搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p><p>你可以结合使用[[../创建模式/生成器模式]]和[[桥接模式]]： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/结构模式/桥接模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/design/jie-gou-mo-shi/gua-pei-qi-mo-shi/"/>
      <url>/design/jie-gou-mo-shi/gua-pei-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 适配器模式date: 2022-12-14 15:38tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/结构模式/适配器模式categories:  - 设计keywords:  - 设计模式/结构模式/适配器模式description: 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</code></pre><blockquote><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。<br>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p></blockquote><p><img src="/attachment/52ba9c482f5e1f15c45877ff400ee893.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决：</strong><br>主要解决在软件系统中，常常要将一些 “现存的对象” 放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用：</strong> </p><ol><li>系统需要使用现有的类，而此类的接口不符合系统的需要。 </li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 </li><li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li></ol><p><strong>如何解决：</strong><br>继承或依赖（推荐）。</p><p><strong>关键代码：</strong><br>适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>应用实例：</strong></p><ol><li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 </li><li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 </li><li>在 LINUX 上运行 WINDOWS 程序。 </li><li>JAVA 中的 jdbc。</li></ol><p><strong>优点：</strong> </p><ol><li>可以让任何两个没有关联的类一起运行。 </li><li>提高了类的复用。 </li><li>增加了类的透明度。</li><li>灵活性好。</li></ol><p><strong>缺点：</strong> </p><ol><li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 </li><li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li></ol><p><strong>使用场景：</strong><br>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项：</strong><br>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p><img src="/attachment/f7d18262ee4376ce06a62836f6b51ab1.png"></p><ol><li>客户端 （Client） 是包含当前程序业务逻辑的类。</li><li>客户端接口 （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。</li><li>服务 （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。</li><li>适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</li><li>客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</li></ol><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>这一实现使用了继承机制： 适配器同时继承两个对象的接口。 请注意， 这种方式仅能在支持多重继承的编程语言中实现， 例如 C++。</p><p><img src="/attachment/2710483c73d9932eee740f1965a790d8.png"></p><ol><li>类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>确保至少有两个类的接口不兼容：<ul><li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。</li><li>一个或多个将受益于使用服务类的客户端类。</li></ul></li><li>声明客户端接口， 描述客户端如何与服务交互。</li><li>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</li><li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li><li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li><li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。</p><p>我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p><p>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。</p><p>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo 类使用 AudioPlayer 类来播放各种格式。</p><p><img src="/attachment/5dc2e33cd6ff2cc8e3dcbf8e28bad1d2.png"></p><h3 id="类适配器-1"><a href="#类适配器-1" class="headerlink" title="类适配器:"></a>类适配器:</h3><p>因为 Adapter 类既继承了 Adaptee （被适配类），也实现了 Target 接口（因为 Java 不支持多继承，所以这样来实现）所以被称为类适配器</p><p>实例 (以插网线上网举例）：</p><p>1）首先我们拥有一根网线, 他有上网的功能，但是它的接口与电脑不匹配</p><pre><code class="line-numbers language-java">//要适配的类：网线public class Adaptee { &nbsp; &nbsp;//功能：上网 &nbsp; &nbsp;public void request(){ &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("链接网线上网"); &nbsp;  }}</code></pre><p>2）因此我们定义了一个 usb 接口，也就是上面提到的目标接口（Target）</p><pre><code class="line-numbers language-java">//接口转换器的抽象实现public interface NetToUsb { &nbsp; &nbsp;//作用：处理请求，网线=&gt;usb &nbsp; &nbsp;public void handleRequest();}</code></pre><ol start="3"><li>定义一个适配器继承着网线，连接着 usb 接口</li></ol><pre><code class="line-numbers language-java">//真正的适配器，余姚链接usb,连接网线public class Adapter extends Adaptee implements NetToUsb { &nbsp; &nbsp;@Override &nbsp; &nbsp;public void handleRequest() { &nbsp; &nbsp; &nbsp; &nbsp;super.request();//可以上网了 &nbsp;  }}</code></pre><p>4）上网的具体实现</p><pre><code class="line-numbers language-java">//客户端类：想上网，插不上网线public class Computer { &nbsp; &nbsp;//电脑需要连接上转接器才可以上网 &nbsp; &nbsp;public void net(NetToUsb adapter){ &nbsp; &nbsp; &nbsp; &nbsp;//上网的具体实现：找一个转接头 &nbsp; &nbsp; &nbsp; &nbsp;adapter.handleRequest(); &nbsp;  } &nbsp; &nbsp;public static void main(String[] args) { &nbsp; &nbsp; &nbsp; &nbsp;//电脑，适配器，网线 &nbsp; &nbsp; &nbsp; &nbsp;Computer computer = new Computer();//电脑 &nbsp; &nbsp; &nbsp; &nbsp;Adapter adapter = new Adapter();//转接器 &nbsp; &nbsp; &nbsp; &nbsp;computer.net(adapter);//电脑直接连接转接器就可以 &nbsp;  }}</code></pre><h3 id="对象适配器-1"><a href="#对象适配器-1" class="headerlink" title="对象适配器:"></a>对象适配器:</h3><p>不是使用多继承或继承再实现的方式，而是使用直接关联，或者称为委托的方式</p><ol><li>更改适配器为如下代码</li></ol><pre><code class="line-numbers language-java">public class Adapter2 implements NetToUsb { &nbsp; &nbsp;private Adaptee adaptee; &nbsp; &nbsp;public Adapter2(Adaptee adaptee){ &nbsp; &nbsp; &nbsp; &nbsp;this.adaptee = adaptee; &nbsp;  } &nbsp; &nbsp;@Override &nbsp; &nbsp;public void handleRequest() { &nbsp; &nbsp; adaptee.request();;//可以上网了 &nbsp;  }}</code></pre><p>2）此时的客户端中，转接器需要分别连接网线和电脑</p><pre><code class="line-numbers language-java">//客户端类：想上网，插不上网线public class Computer { &nbsp; &nbsp;//电脑需要连接上转接器才可以上网 &nbsp; &nbsp;public void net(NetToUsb adapter){ &nbsp; &nbsp; &nbsp; &nbsp;//上网的具体实现：找一个转接头 &nbsp; &nbsp; &nbsp; &nbsp;adapter.handleRequest(); &nbsp;  } &nbsp; &nbsp;public static void main(String[] args) { &nbsp; &nbsp; &nbsp; &nbsp;//电脑，适配器，网线 &nbsp; &nbsp; &nbsp; &nbsp;Computer computer = new Computer();//电脑 &nbsp; &nbsp; &nbsp; &nbsp;Adaptee adaptee = new Adaptee();//网线 &nbsp; &nbsp; &nbsp; &nbsp;Adapter2 adapter2 = new Adapter2(adaptee);//转接器 &nbsp; &nbsp; &nbsp; &nbsp;computer.net(adapter2); &nbsp;  }}</code></pre><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点-  单一职责原则你可以将接口或数据转换代码从程序主要业务逻辑中分离。- 开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[桥接模式]]通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， [[适配器模式]]通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p><p>[[适配器模式]]可以对已有对象的接口进行修改， [[装饰模式]]则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p><p>[[适配器模式]]能为被封装对象提供不同的接口， [[代理模式]]能为对象提供相同的接口， [[装饰模式]]则能为对象提供加强的接口。</p><p>[[外观模式]]为现有对象定义了一个新接口， [[适配器模式]]则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p><p>[[桥接模式]]、 [[状态模式]]和[[策略模式]] （在某种程度上包括[[适配器模式]]） 模式的接口非常相似。 实际上， 它们都基于[[组合模式]]——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/结构模式/适配器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/design/chuang-jian-mo-shi/yuan-xing-mo-shi/"/>
      <url>/design/chuang-jian-mo-shi/yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 原型模式date: 2022-12-14 15:35tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/创建模式/原型模式categories:  - 设计keywords:  - 设计模式/创建模式/原型模式description: 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</code></pre><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p> 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><p><img src="/attachment/763537be02fd82c6297b7845e926b6b1.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><strong>主要解决：</strong><br>在运行期建立和删除原型。</p><p><strong>何时使用：</strong> </p><ol><li>当一个系统应该独立于它的产品创建，构成和表示时。</li><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li><li>为了避免创建一个与产品类层次平行的工厂类层次时。 </li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ol><p><strong>如何解决：</strong><br>利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p><p><strong>关键代码：</strong> </p><ol><li>实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 </li><li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些 “易变类” 拥有稳定的接口。</li></ol><p><strong>应用实例：</strong></p><ol><li>细胞分裂。 </li><li>JAVA 中的 Object clone() 方法。</li></ol><p><strong>优点：</strong> </p><ol><li>性能提高。 </li><li>逃避构造函数的约束。</li></ol><p><strong>缺点：</strong> </p><ol><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 </li><li>必须实现 Cloneable 接口。</li></ol><p><strong>使用场景：</strong> </p><ol><li>资源优化场景。 </li><li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 </li><li>性能和安全要求的场景。 </li><li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 </li><li>一个对象多个修改者的场景。 </li><li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 </li><li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</li></ol><p><strong>注意事项：</strong><br>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/c52b00868403e629cd74fef62817e7fa.png"></p><ol><li>原型 （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。</li><li>具体原型 （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li><li>客户端 （Client） 可以复制实现了原型接口的任何对象。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title:  如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。 这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。</code></pre><pre><code class="line-numbers language-ad-bug">title:  如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>创建原型接口， 并在其中声明 克隆 方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。</li><li>原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。</li><li>如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。</li><li>克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 否则， 克隆方法可能会生成父类的对象。</li><li>你还可以创建一个中心化原型注册表， 用于存储常用原型。</li><li>你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。</li></ol><p>最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/cd23eeb5f846f142a80304ae0a26e712.png"></p><pre><code class="line-numbers language-java">import java.util.Hashtable; public class ShapeCache {       private static Hashtable&lt;String, Shape&gt; shapeMap       = new Hashtable&lt;String, Shape&gt;();    public static Shape getShape(String shapeId) {      Shape cachedShape = shapeMap.get(shapeId);      return (Shape) cachedShape.clone();   }    // 对每种形状都运行数据库查询，并创建该形状   // shapeMap.put(shapeKey, shape);   // 例如，我们要添加三种形状   public static void loadCache() {      Circle circle = new Circle();      circle.setId("1");      shapeMap.put(circle.getId(),circle);       Square square = new Square();      square.setId("2");      shapeMap.put(square.getId(),square);       Rectangle rectangle = new Rectangle();      rectangle.setId("3");      shapeMap.put(rectangle.getId(),rectangle);   }}</code></pre><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以克隆对象， 而无需与它们所属的具体类相耦合。- 你可以克隆预生成原型， 避免反复运行初始化代码。- 你可以更方便地生成复杂对象。- 你可以用继承以外的方式来处理复杂对象的不同配置。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>克隆包含循环引用的复杂对象可能会非常麻烦。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>在许多设计工作的初期都会使用[[工厂方法模式]] （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[[抽象工厂模式]]、 [[原型模式]]或[[生成器模式]] （更灵活但更加复杂）。</p><p>[[抽象工厂模式]]通常基于一组工厂方法， 但你也可以使用[[原型模式]]来生成这些类的方法。</p><p>[[原型模式]]可用于保存[[命令模式]]的历史记录。</p><p>大量使用[[组合模式]]和[[装饰模式]]的设计通常可从对于[[原型模式]]的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p><p>[[原型模式]]并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 [[工厂方法模式]]基于继承， 但是它不需要初始化步骤。</p><p>有时候[[原型模式]]可以作为[[备忘录模式]]的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</p><p>[[抽象工厂模式]]、 [[生成器模式]]和[[原型模式]]都可以用[[单例模式]]来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/创建模式/原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成器模式</title>
      <link href="/design/chuang-jian-mo-shi/sheng-cheng-qi-mo-shi/"/>
      <url>/design/chuang-jian-mo-shi/sheng-cheng-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 生成器模式date: 2022-12-14 15:32tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/创建模式/生成器模式categories:  - 设计keywords:  - 设计模式/创建模式/生成器模式description: 生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</code></pre><blockquote><p>生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p></blockquote><p><img src="/attachment/d6a54b64446e8292a9f2a61c2ea77702.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决：</strong><br>主要解决在软件系统中，有时候面临着 “一个复杂对象” 的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用：</strong><br>一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决：</strong><br>将变与不变分离开。</p><p><strong>关键代码：</strong><br>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong></p><ol><li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的 “套餐”。 </li><li>JAVA 中的 StringBuilder。</li></ol><p><strong>优点：</strong></p><ol><li>建造者独立，易扩展。</li><li>便于控制细节风险。</li></ol><p><strong>缺点：</strong> </p><ol><li>产品必须有共同点，范围有限制。 </li><li>如内部变化复杂，会有很多的建造类。</li></ol><p><strong>使用场景：</strong> </p><ol><li>需要生成的对象具有复杂的内部结构。 </li><li>需要生成的对象内部属性本身相互依赖。</li></ol><p><strong>注意事项：</strong><br>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/f7fc3202bba4103d382d06422dad7cad.png"></p><ol><li>生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</li><li>具体生成器 （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</li><li>产品 （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</li><li>主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</li><li>客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。</code></pre><pre><code class="line-numbers language-ad-bug">title: 当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。</code></pre><pre><code class="line-numbers language-ad-bug">title: 使用生成器构造组合树或其他复杂对象。生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。</li><li>在基本生成器接口中声明这些步骤。</li><li>为每个形式的产品创建具体生成器类， 并实现其构造步骤。<br> 不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。</li><li>考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式。</li><li>客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。</li><li>只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo 类使用 MealBuilder 来创建一个 Meal。</p><p><img src="/attachment/f86d01824d61a10c2bb302fef0977b7f.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。- 生成不同形式的产品时， 你可以复用相同的制造代码。- 单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>在许多设计工作的初期都会使用[[工厂方法模式]] （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[[抽象工厂模式]]、 [[原型模式]]或[[生成器模式]] （更灵活但更加复杂）。</p><p>[[生成器模式]]重点关注如何分步生成复杂对象。 [[抽象工厂模式]]专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。</p><p>你可以在创建复杂[[组合模式]]树时使用[[生成器模式]]， 因为这可使其构造步骤以递归的方式运行。</p><p>你可以结合使用[[生成器模式]]和[[桥接模式]]： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p><p>[[抽象工厂模式]]、 [[生成器模式]]和[[原型模式]]都可以用[[单例模式]]来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/创建模式/生成器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/design/chuang-jian-mo-shi/dan-li-mo-shi/"/>
      <url>/design/chuang-jian-mo-shi/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 单例模式date: 2022-12-14 15:28tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/创建模式/单例模式categories:  - 设计keywords:  - 设计模式/创建模式/单例模式description: 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</code></pre><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><img src="/attachment/b50e274b13262e647cbab1008b1c3b7b.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong><br>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong><br>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong><br>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong><br>构造函数是私有的。</p><p><strong>应用实例：</strong> </p><ol><li>一个班级只有一个班主任。</li><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ol><p><strong>优点：</strong> </p><ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol><p><strong>缺点：</strong> </p><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong> </p><ol><li>要求生产唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li></ol><p><strong>注意事项：</strong><br>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/12418ebe409c2808019ca79f4c89e5a8.png"></p><ol><li>单例 （Singleton） 类声明了一个名为 getInstance获取实例的静态方法来返回其所属类的一个相同实例。</li></ol><p>单例的构造函数必须对客户端 （Client） 代码隐藏。 调用获取实例方法必须是获取单例对象的唯一方式。</p><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title:  如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果你需要更加严格地控制全局变量， 可以使用单例模式。单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例方法， 即 getInstance 中的代码即可实现。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>在类中添加一个私有静态成员变量用于保存单例实例。</li><li>声明一个公有静态构建方法用于获取单例实例。</li><li>在静态方法中实现”延迟初始化”。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</li><li>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</li><li>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。</li></ol><h3 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h3><p><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全</strong>：否<br><strong>实现难度</strong>：易</p><p><strong>描述</strong>：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><pre><code class="line-numbers language-java">public class Singleton {      private static Singleton instance;      private Singleton (){}        public static Singleton getInstance() {          if (instance == null) {              instance = new Singleton();          }          return instance;      }  }</code></pre><p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</p><h3 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h3><p><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：易<br><strong>描述</strong>：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点</strong>：第一次调用才初始化，避免内存浪费。<br><strong>缺点</strong>：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</p><p>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><pre><code class="line-numbers language-java">public class Singleton {      private static Singleton instance;      private Singleton (){}      public static synchronized Singleton getInstance() {          if (instance == null) {              instance = new Singleton();          }          return instance;      }  }</code></pre><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>是否 Lazy 初始化</strong>：否<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：易<br><strong>描述</strong>：这种方式比较常用，但容易产生垃圾对象。<br><strong>优点</strong>：没有加锁，执行效率会提高。<br><strong>缺点</strong>：类加载时就初始化，浪费内存。</p><p>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><pre><code class="line-numbers language-java">public class Singleton {      private static Singleton instance = new Singleton();      private Singleton (){}      public static Singleton getInstance() {          return instance;      }  }</code></pre><h3 id="双检锁-x2F-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-x2F-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p><strong>JDK 版本</strong>：JDK1.5 起<br><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：较复杂<br><strong>描述</strong>：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><p>getInstance() 的性能对应用程序很关键。</p><pre><code class="line-numbers language-java">public class Singleton {      private volatile static Singleton singleton;      private Singleton (){}      public static Singleton getSingleton() {      if (singleton == null) {          synchronized (Singleton.class) {              if (singleton == null) {                  singleton = new Singleton();              }          }      }      return singleton;      }  }</code></pre><h3 id="登记式-x2F-静态内部类"><a href="#登记式-x2F-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h3><p><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：一般<br><strong>描述</strong>：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p><p>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><pre><code class="line-numbers language-java">public class Singleton {      private static class SingletonHolder {      private static final Singleton INSTANCE = new Singleton();      }      private Singleton (){}      public static final Singleton getInstance() {          return SingletonHolder.INSTANCE;      }  }</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong>JDK 版本</strong>：JDK1.5 起<br><strong>是否 Lazy 初始化</strong>：否<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：易<br><strong>描述</strong>：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p><pre><code class="line-numbers language-java">public enum Singleton {      INSTANCE;      public void whateverMethod() {      }  }</code></pre><h3 id="经验之谈："><a href="#经验之谈：" class="headerlink" title="经验之谈："></a>经验之谈：</h3><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/8bbadcbae48a626e2a2a4d1a58c06d9f.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以保证一个类只有一个实例。- 你获得了一个指向该实例的全局访问节点。- 仅在首次请求单例对象时对其进行初始化。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><ul><li>违反了单一职责原则。 该模式同时解决了两个问题。</li><li>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li><li>该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li><li>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li></ul></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>[[外观模式]]类通常可以转换为[[单例模式]]类， 因为在大部分情况下一个外观对象就足够了。</p><p>如果你能将对象的所有共享状态简化为一个享元对象， 那么[[享元模式]]就和[[单例模式]]类似了。 但这两个模式有两个根本性的不同。</p><p>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。<br>[[单例模式]]对象可以是可变的。 享元对象是不可变的。<br>抽象工厂模式、 生成器模式和原型模式都可以用[[单例模式]]来实现。<br>[[抽象工厂模式]]、[[生成器模式]]和[[原型模式]]都可以用[[单例模式]]来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/创建模式/单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/design/chuang-jian-mo-shi/chou-xiang-gong-han-mo-shi/"/>
      <url>/design/chuang-jian-mo-shi/chou-xiang-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 抽象工厂模式date: 2022-12-14 15:24tags:  - categories:  - keywords:  - description: </code></pre><p> 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p><img src="/attachment/54a6b8766292598211bf678283907eaa.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决：</strong><br>主要解决接口选择的问题。</p><p><strong>何时使用：</strong><br>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决：</strong><br>在一个产品族里面，定义多个产品。</p><p><strong>关键代码：</strong><br>在一个工厂里聚合多个同类产品。</p><p><strong>应用实例：</strong><br>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p><strong>优点：</strong><br>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong><br>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong><br>1、QQ 换皮肤，一整套一起换。<br>2、生成不同操作系统的程序。</p><p><strong>注意事项：</strong><br>产品族难扩展，产品等级易扩展。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/e18277db86f7e0b16132726eb2b965d3.png"></p><ol><li><code>抽象产品</code> （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。</li><li><code>具体产品</code> （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。</li><li><code>抽象工厂</code> （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。</li><li><code>具体工厂</code> （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</li><li>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的_抽象_产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 <code>客户端</code> （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title: 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。- 如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。- 在设计良好的程序中， 每个类仅负责一件事。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>以不同的产品类型与产品变体为维度绘制矩阵。</li><li>为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。</li><li>声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。</li><li>为每种产品变体实现一个具体工厂类。</li><li>在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。</li><li>找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/d6962901a86fe54a94e36e4402ce6b1e.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-check">title: 优点- 你可以确保同一工厂生成的产品相互匹配。- 你可以避免客户端和具体产品代码的耦合。- 单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。- 开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><p>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</p></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>在许多设计工作的初期都会使用[[工厂方法模式]] （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[[抽象工厂模式]]、 [[原型模式]]或[[生成器模式]] （更灵活但更加复杂）。</p><p>[[生成器模式]]重点关注如何分步生成复杂对象。[[抽象工厂模式]]专门用于生产一系列相关对象。 [[抽象工厂模式]]会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。</p><p>[[抽象工厂模式]]通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</p><p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用[[抽象工厂模式]]来代替[[外观模式]]。</p><p>你可以将[[抽象工厂模式]]和[[桥接模式]]搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下，[[抽象工厂模式]]可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p><p>[[抽象工厂模式]]、[[生成器模式]]和[[原型模式]]都可以用[[单例模式]]来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/创建模式/抽象工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程方法模式</title>
      <link href="/design/chuang-jian-mo-shi/gong-han-fang-fa-mo-shi/"/>
      <url>/design/chuang-jian-mo-shi/gong-han-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="工程方法模式"><a href="#工程方法模式" class="headerlink" title="工程方法模式"></a>工程方法模式</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 工程方法模式date: 2022-12-14 15:15tags:  - 行动阶段/完成  - 主题场景/设计  - 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace  - 细化主题/设计模式/创建模式/工厂方法模式categories:  - 设计keywords:  - 设计模式/创建模式/工厂方法模式description: 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</code></pre><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p><img src="/attachment/74b84ee11861d2982d85d78e0bac6b30.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>意图：</strong><br>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>主要解决：</strong><br>主要解决接口选择的问题。</p><p><strong>何时使用：</strong><br>我们明确地计划不同条件下创建不同实例时。</p><p><strong>如何解决：</strong><br>让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p><strong>关键代码：</strong><br>创建过程在其子类执行。</p><p><strong>应用实例：</strong><br>1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。<br>2、Hibernate 换数据库只需换方言和驱动就可以。</p><p><strong>优点：</strong><br>1、一个调用者想创建一个对象，只要知道其名称就可以了。<br>2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。<br>3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点：</strong><br>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p><strong>使用场景：</strong><br>1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。<br>2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。<br>3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p><strong>注意事项：</strong><br>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="/attachment/5dc0264f94480a66a1085bd5dcb323bd.png"></p><ol><li><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</li><li><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</li><li><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。<br> 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。<br> 注意， 尽管它的名字是创建者， 但它最主要的职责并<strong>不是</strong>创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</li><li><strong>具体创建者</strong> （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。<br> 注意， 并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</li></ol><h2 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h2><pre><code class="line-numbers language-ad-bug">title:  当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。</code></pre><pre><code class="line-numbers language-ad-bug">title: 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。让我们思考复用现有对象的方法：首先， 你需要创建存储空间来存放所有已经创建的对象。当他人请求一个对象时， 程序将在对象池中搜索可用对象。… 然后将其返回给客户端代码。如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实例。因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。</code></pre><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</li><li>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</li><li>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。</li><li>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。</li><li>如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。</li><li>如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/attachment/cd4de4e719a94749d54b8ffcd4660f9b.png"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code class="line-numbers language-ad-success">title: 优点- 你可以避免创建者和具体产品之间的紧密耦合。- 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。- 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</code></pre><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition failure"><p class="admonition-title">缺点</p><p>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</p></div><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><p>在许多设计工作的初期都会使用[[工厂方法模式]] （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[[抽象工厂模式]]、 [[原型模式]]或[[生成器模式]] （更灵活但更加复杂）。</p><p>[[抽象工厂模式]]通常基于一组工厂方法， 但你也可以使用[[原型模式]]来生成这些类的方法。</p><p>你可以同时使用[[工厂方法模式]]和[[迭代器模式]]来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p><p>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 [[工厂方法模式]]基于继承， 但是它不需要初始化步骤。</p><p>[[工厂方法模式]]是[[模板方法模式]]的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/设计 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/ProjectSpace </tag>
            
            <tag> 细化主题/设计模式/创建模式/工厂方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 final</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-final"><a href="#【Java-多线程并发】-final" class="headerlink" title="【Java 多线程并发】 final"></a>【Java 多线程并发】 final</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 finaldate: 2022-12-14 15:02tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 final</code></pre><h2 id="final-基础使用"><a href="#final-基础使用" class="headerlink" title="final 基础使用"></a>final 基础使用</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><p>当某个类的整体定义为 final 时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p><p>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中给任何方法添加 final 关键字是没有任何意义的。</p><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><ul><li>private 方法是隐式的 final</li><li>final 方法是可以被重载的</li></ul><h4 id="private-final"><a href="#private-final" class="headerlink" title="private final"></a>private final</h4><p>类中所有 private 方法都隐式地指定为 final 的，由于无法取用 private 方法，所以也就不能覆盖它。可以对 private 方法增添 final 关键字，但这样做并没有什么好处。</p><h4 id="final-方法是可以被重载的"><a href="#final-方法是可以被重载的" class="headerlink" title="final 方法是可以被重载的"></a>final 方法是可以被重载的</h4><p>我们知道父类的 final 方法是不能够被子类重写的，那么 final 方法可以被重载吗? 答案是可以的，下面代码是正确的。</p><h3 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h3><p>Java 允许在参数列表中以声明的方式将参数指明为 final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p><h4 id="所有的final修饰的字段都是编译期常量吗"><a href="#所有的final修饰的字段都是编译期常量吗" class="headerlink" title="所有的final修饰的字段都是编译期常量吗?"></a>所有的final修饰的字段都是编译期常量吗?</h4><p>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</p><h4 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h4><p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p><h4 id="blank-final"><a href="#blank-final" class="headerlink" title="blank final"></a>blank final</h4><p>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p><ul><li>在定义处进行赋值(这不叫空白final)</li><li>在构造器中进行赋值，保证了该值在被使用前赋值。</li></ul><p>这增强了final的灵活性。</p><h2 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h2><h3 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h3><h4 id="写final域重排序规则"><a href="#写final域重排序规则" class="headerlink" title="写final域重排序规则"></a>写final域重排序规则</h4><p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外；</li><li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li></ul><h4 id="读final域重排序规则"><a href="#读final域重排序规则" class="headerlink" title="读final域重排序规则"></a>读final域重排序规则</h4><p>read()方法主要包含了三个操作：</p><ul><li>初次读引用变量finalDemo;</li><li>初次读引用变量finalDemo的普通域a;</li><li>初次读引用变量finalDemo的final域b;</li></ul><h3 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h3><h4 id="对final修饰的对象的成员域写操作"><a href="#对final修饰的对象的成员域写操作" class="headerlink" title="对final修饰的对象的成员域写操作"></a>对final修饰的对象的成员域写操作</h4><p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。</p><h4 id="对final修饰的对象的成员域读操作"><a href="#对final修饰的对象的成员域读操作" class="headerlink" title="对final修饰的对象的成员域读操作"></a>对final修饰的对象的成员域读操作</h4><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下<code>arrays[0] = 1</code>，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p><h3 id="关于final重排序的总结"><a href="#关于final重排序的总结" class="headerlink" title="关于final重排序的总结"></a>关于final重排序的总结</h3><ul><li>基本数据类型:<ul><li>final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li><li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li></ul></li><li>引用数据类型：</li><li>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li></ul><h2 id="final再深入理解"><a href="#final再深入理解" class="headerlink" title="final再深入理解"></a>final再深入理解</h2><h3 id="final的实现原理"><a href="#final的实现原理" class="headerlink" title="final的实现原理"></a>final的实现原理</h3><p>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p><h3 id="为什么final引用不能从构造函数中“溢出”"><a href="#为什么final引用不能从构造函数中“溢出”" class="headerlink" title="为什么final引用不能从构造函数中“溢出”"></a>为什么final引用不能从构造函数中“溢出”</h3><p>上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 volatile</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-volatile/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-volatile"><a href="#【Java-多线程并发】-volatile" class="headerlink" title="【Java 多线程并发】 volatile"></a>【Java 多线程并发】 volatile</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 volatiledate: 2022-12-14 15:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 volatile</code></pre><h2 id="volatile-的作用详解"><a href="#volatile-的作用详解" class="headerlink" title="volatile 的作用详解"></a>volatile 的作用详解</h2><h3 id="防重排序"><a href="#防重排序" class="headerlink" title="防重排序"></a>防重排序</h3><pre><code class="line-numbers language-java">public class Singleton {    public static volatile Singleton singleton;        private Singleton() {};    public static Singleton getInstance() {        if (singleton == null) {            synchronized (singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}</code></pre><p>现在我们分析一下为什么要在变量 singleton 之间加上 volatile 关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p><ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul><p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量。</p><h3 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p><h3 id="保证原子性-单次读-x2F-写"><a href="#保证原子性-单次读-x2F-写" class="headerlink" title="保证原子性: 单次读 / 写"></a>保证原子性: 单次读 / 写</h3><h4 id="问题-1：-i-为什么不能保证原子性"><a href="#问题-1：-i-为什么不能保证原子性" class="headerlink" title="问题 1： i++ 为什么不能保证原子性?"></a>问题 1： i++ 为什么不能保证原子性?</h4><p>对于原子性，需要强调一点，也是大家容易误解的一点：对 volatile 变量的单次读 / 写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++ 这种操作的原子性，因为本质上 i++ 是读、写两次操作。</p><h4 id="问题-2：-共享的-long-和-double-变量的为什么要用-volatile"><a href="#问题-2：-共享的-long-和-double-变量的为什么要用-volatile" class="headerlink" title="问题 2： 共享的 long 和 double 变量的为什么要用 volatile?"></a>问题 2： 共享的 long 和 double 变量的为什么要用 volatile?</h4><p>因为 long 和 double 两种数据类型的操作可分为高 32 位和低 32 位两部分，因此普通的 long 或 double 类型读 / 写可能不是原子的。因此，鼓励大家将共享的 long 和 double 变量设置为 volatile 类型，这样能保证任何情况下对 long 和 double 的单次读 / 写操作都具有原子性。</p><h2 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a>volatile 的实现原理</h2><h3 id="volatile-可见性实现"><a href="#volatile-可见性实现" class="headerlink" title="volatile 可见性实现"></a>volatile 可见性实现</h3><blockquote><p>volatile 变量的内存可见性是基于内存屏障 (Memory Barrier) 实现:</p></blockquote><ul><li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li><li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止 + 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</li></ul><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><h4 id="lock-指令"><a href="#lock-指令" class="headerlink" title="lock 指令"></a>lock 指令</h4><p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议 (MESI) 来保证。</p><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>缓存是分段 (line) 的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “嗅探(snooping)” 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p><h3 id="volatile-有序性实现"><a href="#volatile-有序性实现" class="headerlink" title="volatile 有序性实现"></a>volatile 有序性实现</h3><p>volatile 的 happens-before 关系</p><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-1.png"></p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读 / 写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-3.png"></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-4.png"></p><h2 id="volatile-的应用场景"><a href="#volatile-的应用场景" class="headerlink" title="volatile 的应用场景"></a>volatile 的应用场景</h2><p>使用 volatile 必须具备的条件</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><h3 id="模式-1：状态标志"><a href="#模式-1：状态标志" class="headerlink" title="模式 1：状态标志"></a>模式 1：状态标志</h3><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p><h3 id="模式-2：一次性安全发布-one-time-safe-publication"><a href="#模式-2：一次性安全发布-one-time-safe-publication" class="headerlink" title="模式 2：一次性安全发布 (one-time safe publication)"></a>模式 2：一次性安全发布 (one-time safe publication)</h3><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值 (由另一个线程写入) 和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定 (double-checked-locking) 问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p><h3 id="模式-3：独立观察-independent-observation"><a href="#模式-3：独立观察-independent-observation" class="headerlink" title="模式 3：独立观察 (independent observation)"></a>模式 3：独立观察 (independent observation)</h3><p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p><h3 id="模式-4：volatile-bean-模式"><a href="#模式-4：volatile-bean-模式" class="headerlink" title="模式 4：volatile bean 模式"></a>模式 4：volatile bean 模式</h3><p>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。</p><h3 id="模式-5：开销较低的读－写锁策略"><a href="#模式-5：开销较低的读－写锁策略" class="headerlink" title="模式 5：开销较低的读－写锁策略"></a>模式 5：开销较低的读－写锁策略</h3><p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作 (读、添加、存储) 的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p><h3 id="模式-6：双重检查-double-checked"><a href="#模式-6：双重检查-double-checked" class="headerlink" title="模式 6：双重检查 (double-checked)"></a>模式 6：双重检查 (double-checked)</h3><p>单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】synchronized</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-synchronized/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】synchronized"><a href="#【Java-多线程并发】synchronized" class="headerlink" title="【Java 多线程并发】synchronized"></a>【Java 多线程并发】synchronized</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】synchronizeddate: 2022-12-14 14:57tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 Synchronized</code></pre><h2 id="【Java-多线程并发】synchronized-1"><a href="#【Java-多线程并发】synchronized-1" class="headerlink" title="【Java 多线程并发】synchronized"></a>【Java 多线程并发】synchronized</h2><blockquote><p>在Java中除了提供Lock API外还在语法层面上提供了synchronized关键字来实现互斥同步原语</p></blockquote><p>在应用 Sychronized 关键字时需要把握如下注意点：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li><li>每个实例都对应有自己的一把锁 (this), 不同实例之间互不影响；例外：锁对象是 *.class 以及 synchronized 修饰的是 static 方法的时候，所有对象公用同一把锁</li><li>synchronized 修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li></ul><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)</p><h3 id="代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁"><a href="#代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁" class="headerlink" title="代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁"></a>代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁</h3><pre><code class="line-numbers language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence = new SynchronizedObjectLock();    @Override    public void run() {        // 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行        synchronized (this) {            System.out.println("我是线程" + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "结束");        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instence);        Thread t2 = new Thread(instence);        t1.start();        t2.start();    }}</code></pre><h3 id="方法锁形式：synchronized修饰普通方法，锁对象默认为this"><a href="#方法锁形式：synchronized修饰普通方法，锁对象默认为this" class="headerlink" title="方法锁形式：synchronized修饰普通方法，锁对象默认为this"></a>方法锁形式：synchronized修饰普通方法，锁对象默认为this</h3><pre><code class="line-numbers language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence = new SynchronizedObjectLock();    @Override    public void run() {        method();    }    public synchronized void method() {        System.out.println("我是线程" + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "结束");    }    public static void main(String[] args) {        Thread t1 = new Thread(instence);        Thread t2 = new Thread(instence);        t1.start();        t2.start();    }}</code></pre><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>指synchronize修饰静态的方法或指定锁对象为Class对象</p><h3 id="synchronize修饰静态方法"><a href="#synchronize修饰静态方法" class="headerlink" title="synchronize修饰静态方法"></a>synchronize修饰静态方法</h3><pre><code class="line-numbers language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();    @Override    public void run() {        method();    }    // synchronized用在普通方法上，默认的锁就是this，当前实例    public synchronized void method() {        System.out.println("我是线程" + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "结束");    }    public static void main(String[] args) {        // t1和t2对应的this是两个不同的实例，所以代码不会串行        Thread t1 = new Thread(instence1);        Thread t2 = new Thread(instence2);        t1.start();        t2.start();    }}</code></pre><h3 id="synchronized指定锁对象为Class对象"><a href="#synchronized指定锁对象为Class对象" class="headerlink" title="synchronized指定锁对象为Class对象"></a>synchronized指定锁对象为Class对象</h3><pre><code class="line-numbers language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();    @Override    public void run() {        // 所有线程需要的锁都是同一把        synchronized(SynchronizedObjectLock.class){            System.out.println("我是线程" + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "结束");        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instence1);        Thread t2 = new Thread(instence2);        t1.start();        t2.start();    }}</code></pre><h2 id="Synchronized原理分析"><a href="#Synchronized原理分析" class="headerlink" title="Synchronized原理分析"></a>Synchronized原理分析</h2><h3 id="加锁和释放锁的原理"><a href="#加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理"></a>加锁和释放锁的原理</h3><p><img src="/attachment%5C2bfd5508d9cb8a994c26149dac733340.png"></p><h3 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h3><ul><li>什么是可重入？可重入锁？</li></ul><p><strong>可重入：</strong>（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</p><p><strong>可重入锁：</strong> 又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><h3 id="保证可见性的原理：内存模型和happens-before规则"><a href="#保证可见性的原理：内存模型和happens-before规则" class="headerlink" title="保证可见性的原理：内存模型和happens-before规则"></a>保证可见性的原理：内存模型和happens-before规则</h3><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。</p><h2 id="JVM-中锁的优化"><a href="#JVM-中锁的优化" class="headerlink" title="JVM 中锁的优化"></a>JVM 中锁的优化</h2><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。</p><ul><li><strong>锁粗化(Lock Coarsening)：</strong> 也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</li><li><strong>锁消除(Lock Elimination)：</strong> 通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</li><li><strong>轻量级锁(Lightweight Locking)：</strong> 这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</li><li><strong>偏向锁(Biased Locking)：</strong> 是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</li><li><strong>适应性自旋(Adaptive Spinning)：</strong> 当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。</li></ul><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><blockquote><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p></blockquote><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><blockquote><p>为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</p></blockquote><p>如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。</p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么 JVM 会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到 100 此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM 对程序的锁的状态预测会越来越准确，JVM 也会越来越聪明。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。<br>JVM 会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那 JVM 就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>尽可能的将同步块的作用范围限制到尽量小的范围 (只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在对象头中 (<code>Object Header</code>) 存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为 32 位或者 64 位 (视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针 (<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p><h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><p>在线程执行同步块之前，JVM 会先在当前线程的栈帧中创建一个名为锁记录 (<code>Lock Record</code>) 的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝 (JVM 会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>) 这个时候线程堆栈与对象头的状态如图：</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-5.png"></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-6.png"></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-7.png"></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><blockquote><p>在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p></blockquote><p>只需要简单的测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-8.png"></p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点 (就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM 会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-9.png"></p><h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要 CAS 操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了响应速度</td><td>如线程成始终得不到锁竞争的线程，使用自旋会消耗 CPU 性能</td><td>追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不适用自旋，不会消耗 CPU</td><td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table><h2 id="Synchronized-与-Lock"><a href="#Synchronized-与-Lock" class="headerlink" title="Synchronized 与 Lock"></a>Synchronized 与 Lock</h2><p>synchronized 的缺陷</p><ul><li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock 可以中断和设置超时</li><li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件 (某个对象)，相对而言，读写锁更加灵活</li><li><code>无法知道是否成功获得锁</code>，相对而言，Lock 可以拿到状态，如果成功获取锁，….，如果获取失败，…..</li></ul><h3 id="Lock-解决相应问题"><a href="#Lock-解决相应问题" class="headerlink" title="Lock 解决相应问题"></a>Lock 解决相应问题</h3><p>Lock 类这里不做过多解释，主要看里面的 4 个方法:</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个 boolean 值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized 只有锁只与一个条件 (是否获取锁) 相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p><h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><p>synchronized 是通过软件 (JVM) 实现的，简单易用，即使在 JDK5 之后有了 Lock，仍然被广泛的使用。</p><p><strong>使用 Synchronized 有哪些要注意的？</strong></p><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用 Lock 也不要用 synchronized 关键字，用 java.util.concurrent 包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用 synchronized 关键，因为代码量少，避免出错</li></ul><p><strong>synchronized 是公平锁吗？</strong></p><p>synchronized 实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程并发</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-多线程并发"><a href="#Java-多线程并发" class="headerlink" title="Java 多线程并发"></a>Java 多线程并发</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java 多线程并发date: 2022-12-14 14:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题categories:  - Javakeywords:  - Java/多线程并发description: Java 多线程并发</code></pre><h2 id="Java-多线程并发-1"><a href="#Java-多线程并发-1" class="headerlink" title="Java 多线程并发"></a>Java 多线程并发</h2><p><img src="/attachment/3041eb7b6dfc4a8cc4eb38ad02234ac8.png"></p><h2 id="【Java-多线程并发】-基础"><a href="#【Java-多线程并发】-基础" class="headerlink" title="【Java 多线程并发】 基础"></a>【Java 多线程并发】 基础</h2><p>undefined</p><h2 id="【Java-多线程并发】-原理"><a href="#【Java-多线程并发】-原理" class="headerlink" title="【Java 多线程并发】 原理"></a>【Java 多线程并发】 原理</h2><p>undefined</p><h2 id="【Java-多线程并发】-locks"><a href="#【Java-多线程并发】-locks" class="headerlink" title="【Java 多线程并发】 locks"></a>【Java 多线程并发】 locks</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程并发</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-多线程并发"><a href="#Java-多线程并发" class="headerlink" title="Java 多线程并发"></a>Java 多线程并发</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java 多线程并发date: 2022-12-14 14:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题categories:  - Javakeywords:  - Java/多线程并发description: Java 多线程并发</code></pre><h2 id="Java-多线程并发-1"><a href="#Java-多线程并发-1" class="headerlink" title="Java 多线程并发"></a>Java 多线程并发</h2><p><img src="/attachment%5C3041eb7b6dfc4a8cc4eb38ad02234ac8.png"></p><h2 id="【Java-多线程并发】-理论基础"><a href="#【Java-多线程并发】-理论基础" class="headerlink" title="【Java 多线程并发】 理论基础"></a>【Java 多线程并发】 理论基础</h2><p>undefined</p><h2 id="【Java-多线程并发】-final"><a href="#【Java-多线程并发】-final" class="headerlink" title="【Java 多线程并发】 final"></a>【Java 多线程并发】 final</h2><p>undefined</p><h2 id="【Java-多线程并发】-volatile"><a href="#【Java-多线程并发】-volatile" class="headerlink" title="【Java 多线程并发】 volatile"></a>【Java 多线程并发】 volatile</h2><p>undefined</p><h2 id="【Java-多线程并发】synchronized"><a href="#【Java-多线程并发】synchronized" class="headerlink" title="【Java 多线程并发】synchronized"></a>【Java 多线程并发】synchronized</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 理论基础</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-li-lun-ji-chu/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-li-lun-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-多线程并发】-理论基础"><a href="#【Java-多线程并发】-理论基础" class="headerlink" title="【Java 多线程并发】 理论基础"></a>【Java 多线程并发】 理论基础</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 理论基础date: 2022-12-14 14:55tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 理论基础</code></pre><h2 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h2><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 <code>可见性</code>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 <code>原子性</code>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 <code>有序性</code>问题</li></ul><h2 id="并发出现问题的根源-并发三要素"><a href="#并发出现问题的根源-并发三要素" class="headerlink" title="并发出现问题的根源: 并发三要素"></a>并发出现问题的根源: 并发三要素</h2><h3 id="可见性-CPU-缓存引起"><a href="#可见性-CPU-缓存引起" class="headerlink" title="可见性: CPU 缓存引起"></a>可见性: CPU 缓存引起</h3><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>这就是可见性问题，线程 1 对变量 i 修改了之后，线程 2 没有立即看到线程 1 修改的值。</p><h3 id="原子性-分时复用引起"><a href="#原子性-分时复用引起" class="headerlink" title="原子性: 分时复用引起"></a>原子性: 分时复用引起</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>由于 CPU 分时复用（线程切换）的存在，线程 1 执行了第一条指令后，就切换到线程 2 执行，假如线程 2 执行了这三条指令后，再切换会线程 1 执行后续两条指令，将造成最后写到内存中的 i 值是 2 而不是 3。</p><h3 id="有序性-重排序引起"><a href="#有序性-重排序引起" class="headerlink" title="有序性: 重排序引起"></a>有序性: 重排序引起</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-3.png"></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><h2 id="JAVA-是怎么解决并发问题的-JMM-Java-内存模型）"><a href="#JAVA-是怎么解决并发问题的-JMM-Java-内存模型）" class="headerlink" title="JAVA 是怎么解决并发问题的: JMM(Java 内存模型）"></a>JAVA 是怎么解决并发问题的: JMM(Java 内存模型）</h2><p><strong>理解的第一个维度：核心知识点</strong></p><p>JMM 本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p><ul><li>原子性</li></ul><p>在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><blockquote><p>Java 内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></blockquote><ul><li>可见性</li></ul><p>Java 提供了 volatile 关键字来保证可见性。</p><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><ul><li>有序性</li></ul><p>在 Java 里面，可以通过 volatile 关键字来保证一定的 “有序性”（具体原理在下一节讲述）。另外可以通过 synchronized 和 Lock 来保证有序性，很显然，synchronized 和 Lock 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然 JMM 是通过 Happens-Before 规则来保证有序性的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】内存模型</title>
      <link href="/language/java/java-jvm/java-jvm-nei-cun-mo-xing/"/>
      <url>/language/java/java-jvm/java-jvm-nei-cun-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】内存模型"><a href="#【Java-JVM】内存模型" class="headerlink" title="【Java JVM】内存模型"></a>【Java JVM】内存模型</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】内存模型date: 2022-12-14 14:50tags:  - 行动阶段/未完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 内存模型</code></pre><h2 id="JMM-引入"><a href="#JMM-引入" class="headerlink" title="JMM 引入"></a>JMM 引入</h2><h3 id="从堆栈说起"><a href="#从堆栈说起" class="headerlink" title="从堆栈说起"></a>从堆栈说起</h3><p>JVM 内部使用的 Java 内存模型在线程栈和堆之间划分内存。 此图从逻辑角度说明了 Java 内存模型：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-1.png"></p><h3 id="堆栈里面放了什么"><a href="#堆栈里面放了什么" class="headerlink" title="堆栈里面放了什么?"></a>堆栈里面放了什么?</h3><p>线程堆栈还包含正在执行的每个方法的所有局部变量 (调用堆栈上的所有方法)。 线程只能访问它自己的线程堆栈。 由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。 因此，每个线程都有自己的每个局部变量的版本。</p><p>基本类型的所有局部变量 (boolean，byte，short，char，int，long，float，double) 完全存储在线程堆栈中，因此对其他线程不可见。 一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身。</p><p>堆包含了在 Java 应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类 (例如 Byte，Integer，Long 等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-2.png"></p><p>局部变量可以是基本类型，在这种情况下，它完全保留在线程堆栈上。</p><p>局部变量也可以是对象的引用。 在这种情况下，引用 (局部变量) 存储在线程堆栈中，但是对象本身存储在堆 (Heap) 上。</p><p>对象的成员变量与对象本身一起存储在堆上。 当成员变量是基本类型时，以及它是对象的引用时都是如此。</p><p>静态类变量也与类定义一起存储在堆上。</p><h3 id="线程栈如何访问堆上对象"><a href="#线程栈如何访问堆上对象" class="headerlink" title="线程栈如何访问堆上对象?"></a>线程栈如何访问堆上对象?</h3><p>所有具有对象引用的线程都可以访问堆上的对象。 当一个线程有权访问一个对象时，它也可以访问该对象的成员变量。 如果两个线程同时在同一个对象上调用一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本。</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-3.png"></p><p>两个线程有一组局部变量。 其中一个局部变量 (局部变量 2) 指向堆上的共享对象(对象 3)。 两个线程各自对同一对象具有不同的引用。 它们的引用是局部变量，因此存储在每个线程的线程堆栈中(在每个线程堆栈上)。 但是，这两个不同的引用指向堆上的同一个对象。</p><p>注意共享对象 (对象 3) 如何将对象 2 和对象 4 作为成员变量引用(由对象 3 到对象 2 和对象 4 的箭头所示)。 通过对象 3 中的这些成员变量引用，两个线程可以访问对象 2 和对象 4.</p><p>该图还显示了一个局部变量，该变量指向堆上的两个不同对象。 在这种情况下，引用指向两个不同的对象 (对象 1 和对象 5)，而不是同一个对象。 理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象 1 和对象 5。 但是在上图中，每个线程只引用了两个对象中的一个。</p><h2 id="JMM-与硬件内存结构关系"><a href="#JMM-与硬件内存结构关系" class="headerlink" title="JMM 与硬件内存结构关系"></a>JMM 与硬件内存结构关系</h2><h3 id="硬件内存结构简介"><a href="#硬件内存结构简介" class="headerlink" title="硬件内存结构简介"></a>硬件内存结构简介</h3><p>现代硬件内存架构与内部 Java 内存模型略有不同。 了解硬件内存架构也很重要，以了解 Java 内存模型如何与其一起工作。 本节介绍了常见的硬件内存架构，后面的部分将介绍 Java 内存模型如何与其配合使用。</p><p>这是现代计算机硬件架构的简化图：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-4.png"></p><p>现代计算机通常有 2 个或更多 CPU。 其中一些 CPU 也可能有多个内核。 关键是，在具有 2 个或更多 CPU 的现代计算机上，可以同时运行多个线程。 每个 CPU 都能够在任何给定时间运行一个线程。 这意味着如果您的 Java 应用程序是多线程的，线程真的在可能同时运行.</p><p>每个 CPU 基本上都包含一组在 CPU 内存中的寄存器。 CPU 可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为 CPU 可以比访问主存储器更快地访问这些寄存器。</p><p>每个 CPU 还可以具有 CPU 高速缓存存储器层。 事实上，大多数现代 CPU 都有一些大小的缓存存储层。 CPU 可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU 高速缓存存储器介于内部寄存器和主存储器的速度之间。 某些 CPU 可能有多个缓存层 (级别 1 和级别 2)，但要了解 Java 内存模型如何与内存交互，这一点并不重要。 重要的是要知道 CPU 可以有某种缓存存储层。</p><p>计算机还包含主存储区 (RAM)。 所有 CPU 都可以访问主内存。 主存储区通常比 CPU 的高速缓存存储器大得多。同时访问速度也就较慢.</p><p>通常，当 CPU 需要访问主存储器时，它会将部分主存储器读入其 CPU 缓存。 它甚至可以将部分缓存读入其内部寄存器，然后对其执行操作。 当 CPU 需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。</p><h3 id="JMM-与硬件内存连接-引入"><a href="#JMM-与硬件内存连接-引入" class="headerlink" title="JMM 与硬件内存连接 - 引入"></a>JMM 与硬件内存连接 - 引入</h3><p>如前所述，Java 内存模型和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于 CPU 高速缓存和内部 CPU 寄存器中。 这在图中说明：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-5.png"></p><h3 id="JMM-与硬件内存连接-对象共享后的可见性"><a href="#JMM-与硬件内存连接-对象共享后的可见性" class="headerlink" title="JMM 与硬件内存连接 - 对象共享后的可见性"></a>JMM 与硬件内存连接 - 对象共享后的可见性</h3><p>如果两个或多个线程共享一个对象，而没有正确使用 volatile 声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。</p><p>想象一下，共享对象最初存储在主存储器中。 然后，在 CPU 上运行的线程将共享对象读入其 CPU 缓存中。 它在那里对共享对象进行了更改。 只要 CPU 缓存尚未刷新回主内存，共享对象的更改版本对于在其他 CPU 上运行的线程是不可见的。 这样，每个线程最终都可能拥有自己的共享对象副本，每个副本都位于不同的 CPU 缓存中。</p><p>下图描绘了该情况。 在左 CPU 上运行的一个线程将共享对象复制到其 CPU 缓存中，并将其 count 变量更改为 2. 对于在右边的 CPU 上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-6.png"></p><p>要解决此问题，您可以使用 Java 的 volatile 关键字。 volatile 关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存。</p><p>要解决此问题，您可以使用 Java synchronized 块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为 volatile</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<mark style="background: #FF5582A6;">共享内存</mark>和<mark style="background: #FF5582A6;">消息传递</mark>。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><h3 id="Java-内存模型的抽象"><a href="#Java-内存模型的抽象" class="headerlink" title="Java 内存模型的抽象"></a>Java 内存模型的抽象</h3><p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用 “共享变量” 这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-1.png"></p><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ul><li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li><li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li></ul><p>下面通过示意图来说明这两个步骤：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-2.png"></p><p>如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。</p><p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-3.png"></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h3 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！</p><p>常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p><ul><li>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</li><li>※注 2：上表中的 x86 包括 x64 及 AMD64。</li><li>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</li><li>※注 4：数据依赖性后文会专门说明。</li></ul><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1; LoadLoad; Load2</td><td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td>Store1; StoreStore; Store2</td><td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td>Load1; LoadStore; Store2</td><td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td>Store1; StoreLoad; Load2</td><td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td></tr></tbody></table><p>StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p><p>StoreLoad Barriers 是一个 “全能型” 的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p><p>happens-before 与 JMM 的关系如下图所示：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-5.png"></p><p>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><h2 id="重排序-1"><a href="#重排序-1" class="headerlink" title="重排序"></a>重排序</h2><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 行动阶段/未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 内存结构</title>
      <link href="/language/java/java-jvm/java-jvm-nei-cun-jie-gou/"/>
      <url>/language/java/java-jvm/java-jvm-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】-内存结构"><a href="#【Java-JVM】-内存结构" class="headerlink" title="【Java JVM】 内存结构"></a>【Java JVM】 内存结构</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】 内存结构date: 2022-12-14 14:48tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 内存结构</code></pre><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6fz21n8kj30u00wpn5v.jpg"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法区</li><li><strong>线程共享</strong>：堆、方法区, 堆外内存（Java7 的永久代或 JDK8 的元空间、代码缓存）</li></ul><h2 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h2><p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。</p><p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或 PC 计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</p><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5kmznm1sj31m50u0wph.jpg"></p><p>（分析：进入 class 文件所在目录，执行 <code>javap -v xx.class</code> 反解析（或者通过 IDEA 插件 <code>Jclasslib</code> 直接查看，上图），可以看到当前类对应的 Code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。）</p><h3 id="1-2-概述"><a href="#1-2-概述" class="headerlink" title="1.2 概述"></a>1.2 概述</h3><ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li></ul><h2 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote><p>Java 虚拟机栈 (Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧 (Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p></blockquote><p><strong>作用</strong>：</p><ul><li>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li></ul><p><strong>特点</strong>：</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈 / 压栈），方法执行结束<strong>出栈</strong></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><p><strong>栈中可能出现的异常</strong>：</p><p>Java 虚拟机规范允许 <strong>Java 虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 <strong>OutOfMemoryError</strong> 异常</li></ul><p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><h3 id="2-2-栈的存储单位"><a href="#2-2-栈的存储单位" class="headerlink" title="2.2 栈的存储单位"></a>2.2 栈的存储单位</h3><p>栈中存储什么？</p><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li><li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h3 id="2-3-栈运行原理"><a href="#2-3-栈运行原理" class="headerlink" title="2.3 栈运行原理"></a>2.3 栈运行原理</h3><ul><li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循 “先进后出 / 后进先出” 原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li></ul><h3 id="2-4-栈帧的内部结构"><a href="#2-4-栈帧的内部结构" class="headerlink" title="2.4 栈帧的内部结构"></a>2.4 栈帧的内部结构</h3><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）(或称为表达式栈)</li><li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li><li>一些附加信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8tjehg8bj318m0lbtbu.jpg"></p><h4 id="2-4-1-局部变量表"><a href="#2-4-1-局部变量表" class="headerlink" title="2.4.1. 局部变量表"></a>2.4.1. 局部变量表</h4><ul><li>局部变量表也被称为局部变量数组或者本地变量表</li><li>是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li></ul><h5 id="槽-Slot"><a href="#槽-Slot" class="headerlink" title="槽 Slot"></a>槽 Slot</h5><ul><li>局部变量表最基本的存储单元是 Slot（变量槽）</li><li>在局部变量表中，32 位以内的类型只占用一个 Slot(包括 returnAddress 类型)，64 位的类型（long 和 double）占用两个连续的 Slot<ul><li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true</li><li>long 和 double 则占据两个 Slot</li></ul></li><li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot 上</li><li><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</li><li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为 this 变量不存在于当前方法的局部变量表中）</li><li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）</li><li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul><h4 id="2-4-2-操作数栈"><a href="#2-4-2-操作数栈" class="headerlink" title="2.4.2. 操作数栈"></a>2.4.2. 操作数栈</h4><ul><li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称为<strong>表达式栈</strong>（Expression Stack）</li><li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong></li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li></ul><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 数据项中</li><li>栈中的任何一个元素都可以是任意的 Java 数据类型<ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 PC 寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说 <strong>Java 虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li></ul><h5 id="栈顶缓存（Top-of-stack-Cashing）"><a href="#栈顶缓存（Top-of-stack-Cashing）" class="headerlink" title="栈顶缓存（Top-of-stack-Cashing）"></a>栈顶缓存（Top-of-stack-Cashing）</h5><p>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读 / 写速度非常迅速，甚至可以比内存的读 / 写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的 CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读 / 写次数。由于操作数是存储在内存中的，因此频繁的执行内存读 / 写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读 / 写次数，提升执行引擎的执行效率</strong></p><h4 id="2-4-3-动态链接（指向运行时常量池的方法引用）"><a href="#2-4-3-动态链接（指向运行时常量池的方法引用）" class="headerlink" title="2.4.3. 动态链接（指向运行时常量池的方法引用）"></a>2.4.3. 动态链接（指向运行时常量池的方法引用）</h4><ul><li><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 (Dynamic Linking)。</li><li>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gca4k4gndgj31d20o2td0.jpg"></p><h5 id="JVM-是如何执行方法调用的"><a href="#JVM-是如何执行方法调用的" class="headerlink" title="JVM 是如何执行方法调用的"></a>JVM 是如何执行方法调用的</h5><p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class 文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p><ul><li><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li><li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p><ul><li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li></ul><h5 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h5><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>其他方法称为虚方法</li></ul><h5 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h5><p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。<br>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。<br>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><h4 id="2-4-4-方法返回地址（return-address）"><a href="#2-4-4-方法返回地址（return-address）" class="headerlink" title="2.4.4. 方法返回地址（return address）"></a>2.4.4. 方法返回地址（return address）</h4><p>用来存放调用该方法的 PC 寄存器的值。</p><p>一个方法的结束，有两种方式</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。<br>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong><br>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定<br>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</li><li>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong><br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li></ol><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p><h4 id="2-4-5-附加信息"><a href="#2-4-5-附加信息" class="headerlink" title="2.4.5. 附加信息"></a>2.4.5. 附加信息</h4><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p><h2 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h2><h3 id="3-1-本地方法接口"><a href="#3-1-本地方法接口" class="headerlink" title="3.1 本地方法接口"></a>3.1 本地方法接口</h3><p>简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">为什么要使用本地方法（Native Method）?</p><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p><ul><li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li><li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li><li>Sun's Java：Sun 的解释器就是 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用 Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是 C 实现的，并被植入 JVM 内部。</li></ul></div><h3 id="3-2-本地方法栈（Native-Method-Stack）"><a href="#3-2-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.2 本地方法栈（Native Method Stack）"></a>3.2 本地方法栈（Native Method Stack）</h3><ul><li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈也是线程私有的</li><li>允许线程固定或者可动态扩展的内存大小<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li></ul></li><li>本地方法是使用 C 语言实现的</li><li>它的具体做法是 <code>Native Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li><li>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</li><li>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</li></ul><blockquote><p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote><h2 id="四、堆内存"><a href="#四、堆内存" class="headerlink" title="四、堆内存"></a>四、堆内存</h2><h3 id="4-1-内存划分"><a href="#4-1-内存划分" class="headerlink" title="4.1 内存划分"></a>4.1 内存划分</h3><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p><ul><li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li><li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li><li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg"></p><h4 id="年轻代-Young-Generation"><a href="#年轻代-Young-Generation" class="headerlink" title="年轻代 (Young Generation)"></a>年轻代 (Young Generation)</h4><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为 from/to 或 s0/s1），默认比例是<code>8:1:1</code></p><ul><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行 <strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ul><h4 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代 (Old Generation)"></a>老年代 (Old Generation)</h4><p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主 GC（Major GC），通常需要更长的时间。</p><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg"></p><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p><h3 id="4-2-设置堆内存大小和-OOM"><a href="#4-2-设置堆内存大小和-OOM" class="headerlink" title="4.2 设置堆内存大小和 OOM"></a>4.2 设置堆内存大小和 OOM</h3><p>Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 <code>-Xmx</code> 和 <code>-Xms</code> 来设定</p><ul><li><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></li></ul><p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p><p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p><ul><li>默认情况下，初始堆内存大小为：电脑内存大小 / 64</li><li>默认情况下，最大堆内存大小为：电脑内存大小 / 4</li></ul><h4 id="查看-JVM-堆内存分配"><a href="#查看-JVM-堆内存分配" class="headerlink" title="查看 JVM 堆内存分配"></a>查看 JVM 堆内存分配</h4><ol><li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li><li>默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置<ul><li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li></ul></li><li>若在 JDK 7 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄<br>此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code> 将会失效，而 JDK 8 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code><br>在 JDK 8 中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划</li></ol><p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小<br>计算依据是 <strong>GC 过程</strong>中统计的 <strong>GC 时间</strong>、<strong>吞吐量</strong>、<strong>内存占用量</strong></p><h3 id="4-3-对象在堆中的生命周期"><a href="#4-3-对象在堆中的生命周期" class="headerlink" title="4.3 对象在堆中的生命周期"></a>4.3 对象在堆中的生命周期</h3><ol><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代<ul><li>新生代又被进一步划分为 <strong>Eden 区</strong> 和 <strong>Survivor 区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul></li><li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区<ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul></li><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）<ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会 + 1</li></ul></li><li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li></ol><h3 id="4-4-对象的分配过程"><a href="#4-4-对象的分配过程" class="headerlink" title="4.4 对象的分配过程"></a>4.4 对象的分配过程</h3><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new 的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li><li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li></ol><h3 id="4-5-GC-垃圾回收简介"><a href="#4-5-GC-垃圾回收简介" class="headerlink" title="4.5 GC 垃圾回收简介"></a>4.5 GC 垃圾回收简介</h3><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li><li>目前只有 G1 GC 会有这种行为</li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><h3 id="4-6-TLAB"><a href="#4-6-TLAB" class="headerlink" title="4.6 TLAB"></a>4.6 TLAB</h3><h4 id="什么是-TLAB-（Thread-Local-Allocation-Buffer）"><a href="#什么是-TLAB-（Thread-Local-Allocation-Buffer）" class="headerlink" title="什么是 TLAB （Thread Local Allocation Buffer）?"></a>什么是 TLAB （Thread Local Allocation Buffer）?</h4><ul><li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li><li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li></ul><h4 id="为什么要有-TLAB"><a href="#为什么要有-TLAB" class="headerlink" title="为什么要有 TLAB ?"></a>为什么要有 TLAB ?</h4><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h3 id="4-7-堆是分配对象存储的唯一选择吗"><a href="#4-7-堆是分配对象存储的唯一选择吗" class="headerlink" title="4.7 堆是分配对象存储的唯一选择吗"></a>4.7 堆是分配对象存储的唯一选择吗</h3><blockquote><p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么 “绝对” 了。 ——《深入理解 Java 虚拟机》</p></blockquote><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p><strong>逃逸分析 (Escape Analysis) <strong>是目前 Java 虚拟机中比较前沿的优化技术</strong>。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li></ul><p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将 sb 返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，但是其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p><p><strong>参数设置：</strong></p><ul><li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li><li>如果使用较早版本，可以通过<code>-XX"+DoEscapeAnalysis</code>显式开启</li></ul><p>开发中使用局部变量，就不要在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做优化：</p><ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li></ul><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p><p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p><h5 id="代码优化之同步省略（消除）"><a href="#代码优化之同步省略（消除）" class="headerlink" title="代码优化之同步省略（消除）"></a>代码优化之同步省略（消除）</h5><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li><li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li></ul><h5 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h5><p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p><p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p><h5 id="代码优化之栈上分配"><a href="#代码优化之栈上分配" class="headerlink" title="代码优化之栈上分配"></a>代码优化之栈上分配</h5><p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><p><strong>总结：</strong></p><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</p><p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><h2 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h2><ul><li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li><li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本 / 字段 / 方法 / 接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</li><li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li><li>JVM 关闭后方法区即被释放</li></ul><h3 id="5-1-解惑"><a href="#5-1-解惑" class="headerlink" title="5.1 解惑"></a>5.1 解惑</h3><ul><li><strong>方法区（method area）</strong> 只是 <strong>JVM 规范</strong>中定义的一个<strong>概念</strong>，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（PermGen）</strong> 是  <strong>Hotspot</strong> 虚拟机特有的概念， Java8 的时候又被<strong>元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li><li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生 OOM（都会有溢出异常）</li><li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li><li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</li><li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code></li><li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）</li></ul><p>所以对于方法区，Java8 之后的变化：</p><ul><li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li><li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li><li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul><h3 id="5-2-设置方法区内存的大小"><a href="#5-2-设置方法区内存的大小" class="headerlink" title="5.2 设置方法区内存的大小"></a>5.2 设置方法区内存的大小</h3><p>JDK8 及以后：</p><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li><li>默认值依赖于平台。Windows 下，<code>-XX:MetaspaceSize</code> 是 21M，<code>-XX:MaxMetaspacaSize</code> 的值是 -1，即没有限制</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为 20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li></ul><h3 id="5-3-方法区内部结构"><a href="#5-3-方法区内部结构" class="headerlink" title="5.3 方法区内部结构"></a>5.3 方法区内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p><ul><li>这个类型的完整有效名称（全名 = 包名. 类名）</li><li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><ul><li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li></ul><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p><h5 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h5><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><p>如下，我们通过 jclasslib 查看一个只有 Main 方法的简单类，字节码中的 #2 指向的就是 Constant Pool</p><p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li><li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址<ul><li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li></ul></li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li></ul><h3 id="5-5-方法区在-JDK6、7、8-中的演进细节"><a href="#5-5-方法区在-JDK6、7、8-中的演进细节" class="headerlink" title="5.5 方法区在 JDK6、7、8 中的演进细节"></a>5.5 方法区在 JDK6、7、8 中的演进细节</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>jdk1.6 及之前</td><td>有永久代，静态变量存放在永久代上</td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池、静态变量移除，保存在堆中</td></tr><tr><td>jdk1.8 及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td></tr></tbody></table><h4 id="移除永久代原因"><a href="#移除永久代原因" class="headerlink" title="移除永久代原因"></a>移除永久代原因</h4><ul><li>为永久代设置空间大小是很难确定的。<br>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</li><li>对永久代进行调优较困难</li></ul><h3 id="5-6-方法区的垃圾回收"><a href="#5-6-方法区的垃圾回收" class="headerlink" title="5.6 方法区的垃圾回收"></a>5.6 方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>判定一个类型是否属于 “不再被使用的类”，需要同时满足三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】JAVA 类加载机制</title>
      <link href="/language/java/java-jvm/java-jvm-java-lei-jia-zai-ji-zhi/"/>
      <url>/language/java/java-jvm/java-jvm-java-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】JAVA-类加载机制"><a href="#【Java-JVM】JAVA-类加载机制" class="headerlink" title="【Java JVM】JAVA 类加载机制"></a>【Java JVM】JAVA 类加载机制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】JAVA 类加载机制date: 2022-12-14 14:47tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 类加载机制</code></pre><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>其中类加载的过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，_而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定 (也成为动态绑定或晚期绑定)_。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_2.png"></p><h3 id="类的加载-查找并加载类的二进制数据"><a href="#类的加载-查找并加载类的二进制数据" class="headerlink" title="类的加载: 查找并加载类的二进制数据"></a>类的加载: 查找并加载类的二进制数据</h3><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_1.png"></p><p>相对于类加载的其他阶段而言，_加载阶段 (准确地说，是加载阶段获取类的二进制字节流的动作) 是可控性最强的阶段_，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被 “首次主动使用” 时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了. class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误 (LinkageError 错误) 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">加载. class 文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载. class 文件</li><li>从 zip，jar 等归档文件中加载. class 文件</li><li>从专有数据库中提取. class 文件</li><li>将 Java 源文件动态编译为. class 文件</li></ul></div><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证-确保被加载的类的正确性"><a href="#验证-确保被加载的类的正确性" class="headerlink" title="验证: 确保被加载的类的正确性"></a>验证: 确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成 4 个阶段的检验动作:</p><ul><li><code>文件格式验证</code>: 验证字节流是否符合 Class 文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><code>元数据验证</code>: 对字节码描述的信息进行语义分析 (注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合 Java 语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><code>符号引用验证</code>: 确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p></blockquote><h4 id="准备-为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备-为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备: 为类的静态变量分配内存，并将其初始化为默认值"></a>准备: 为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意:</p><ul><li>这时候进行内存分配的仅包括类变量 (<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值 (如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在 Java 代码中被显式地赋予的值。<br>  假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量 value 在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">注意点</p><ul><li>对基本数据类型来说，对于类变量 (static) 和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li><li>如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。假设上面的类变量 value 被定义为: <code>public static final int value = 3；</code>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li></ul></div><h4 id="解析-把类中的符号引用转换为直接引用"><a href="#解析-把类中的符号引用转换为直接引用" class="headerlink" title="解析: 把类中的符号引用转换为直接引用"></a>解析: 把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符 7 类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p><strong>JVM 初始化步骤</strong></p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p><ul><li>创建类的实例，也就是 new 的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射 (如 Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java 虚拟机启动时被标明为启动类的类 (Java Test)，直接使用 java.exe 命令来运行某个主类</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类访问方法区内的数据结构的接口， 对象是 Heap 区的数据。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><strong>Java 虚拟机将结束生命周期的几种情况</strong></p><ul><li>执行了 System.exit() 方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li></ul><h2 id="类加载器，-JVM-类加载机制"><a href="#类加载器，-JVM-类加载机制" class="headerlink" title="类加载器， JVM 类加载机制"></a>类加载器， JVM 类加载机制</h2><h3 id="类加载器的层次"><a href="#类加载器的层次" class="headerlink" title="类加载器的层次"></a>类加载器的层次</h3><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_3.png"></p><blockquote><p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><blockquote><p>站在 Java 虚拟机的角度来讲，只存在两种不同的类加载器: 启动类加载器: 它使用 C++ 实现 (这里仅限于<code>Hotspot</code>，也就是 JDK1.5 之后默认的虚拟机，有很多其他的虚拟机是用 Java 语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p></blockquote><p><strong>站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类</strong> :</p><p><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在 JDK\jre\lib(JDK 代表 JDK 的安装目录，下同) 下，或被 - Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库 (如 rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载)。启动类加载器是无法被 Java 程序直接引用的。</p><p><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库 (如 javax.* 开头的类)，开发者可以直接使用扩展类加载器。</p><p><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径 (ClassPath) 所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为 JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassLoader，便可以做到如下几点:</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得 java class，例如数据库中和网络中。</li></ul><h3 id="寻找类加载器"><a href="#寻找类加载器" class="headerlink" title="寻找类加载器"></a>寻找类加载器</h3><pre><code class="line-numbers language-java">ClassLoader loader = Thread.currentThread().getContextClassLoader();</code></pre><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类加载有三种方式:</p><p>1、命令行启动应用时候由 JVM 初始化加载<br>2、通过 Class.forName() 方法动态加载<br>3、通过 ClassLoader.loadClass() 方法动态加载</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">Class.forName() 和 ClassLoader.loadClass() 区别</p><p>collapse: open</p><ul><li>Class.forName(): 将类的. class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；</li><li>ClassLoader.loadClass(): 只干一件事情，就是将. class 文件加载到 jvm 中，不会执行 static 中的内容, 只有在 newInstance 才会去执行 static 块。</li><li>Class.forName(name, initialize, loader) 带参函数也可控制是否加载 static 块。并且只有调用了 newInstance() 方法采用调用构造函数，创建类的对象 。</li></ul></div><h2 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h2><ul><li><code>全盘负责</code>，当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><code>缓存机制</code>，缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效</li><li><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">双亲委派机制过程</p><ol><li>当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。</li><li>当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。</li><li>如果 BootStrapClassLoader 加载失败 (例如在 $JAVA_HOME/jre/lib 里未查找到该 class)，会使用 ExtClassLoader 来尝试加载；</li><li>若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。</li></ol></div><p><strong>双亲委派优势</strong></p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证 Java 程序安全稳定运行</li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程:</p><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对 class 文件进行加密，因此没有解密的过程。</p><p><strong>这里有几点需要注意</strong> :</p><p>1、这里传递的文件名需要是类的全限定性名称，即<code>com.pdai.jvm.classloader.Test2</code>格式的，因为 defineClass 方法是按这种格式进行处理的。<br>2、最好不要重写 loadClass 方法，因为这样容易破坏双亲委托模式。<br>3、这类 Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM</title>
      <link href="/java/java-jvm/java-jvm/"/>
      <url>/java/java-jvm/java-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java JVM"></a>Java JVM</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java JVMdate: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java JVM</code></pre><h2 id="【Java-JVM】-内存管理"><a href="#【Java-JVM】-内存管理" class="headerlink" title="【Java JVM】 内存管理"></a>【Java JVM】 内存管理</h2><p>undefined</p><h2 id="【Java-JVM】-字节码与类加载"><a href="#【Java-JVM】-字节码与类加载" class="headerlink" title="【Java JVM】 字节码与类加载"></a>【Java JVM】 字节码与类加载</h2><p>undefined</p><h2 id="【Java-JVM】-性能监控与调优"><a href="#【Java-JVM】-性能监控与调优" class="headerlink" title="【Java JVM】 性能监控与调优"></a>【Java JVM】 性能监控与调优</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM</title>
      <link href="/language/java/java-jvm/java-jvm/"/>
      <url>/language/java/java-jvm/java-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java JVM"></a>Java JVM</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java JVMdate: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java JVM</code></pre><h2 id="【Java-JVM】字节码编码"><a href="#【Java-JVM】字节码编码" class="headerlink" title="【Java JVM】字节码编码"></a>【Java JVM】字节码编码</h2><p>undefined</p><h2 id="【Java-JVM】JAVA-类加载机制"><a href="#【Java-JVM】JAVA-类加载机制" class="headerlink" title="【Java JVM】JAVA 类加载机制"></a>【Java JVM】JAVA 类加载机制</h2><p>undefined</p><h2 id="【Java-JVM】-内存结构"><a href="#【Java-JVM】-内存结构" class="headerlink" title="【Java JVM】 内存结构"></a>【Java JVM】 内存结构</h2><p>undefined</p><h2 id="【Java-JVM】内存模型"><a href="#【Java-JVM】内存模型" class="headerlink" title="【Java JVM】内存模型"></a>【Java JVM】内存模型</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】字节码编码</title>
      <link href="/language/java/java-jvm/java-jvm-zi-jie-ma-bian-ma/"/>
      <url>/language/java/java-jvm/java-jvm-zi-jie-ma-bian-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-JVM】字节码编码"><a href="#【Java-JVM】字节码编码" class="headerlink" title="【Java JVM】字节码编码"></a>【Java JVM】字节码编码</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java JVM】字节码编码date: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 字节码编码</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计算机是不能直接运行 java 代码的，必须要先运行 java 虚拟机，再由 java 虚拟机运行编译后的 java 代码。这个编译后的 java 代码，就是本文要介绍的 java 字节码。</p><ul><li>Java 代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的 JVM 虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li><li>JVM 也不再只支持 Java，由此衍生出了许多基于 JVM 的编程语言，如 Groovy, Scala, Koltin 等等。</li></ul><p><img src="https://pdai.tech/_images/jvm/java-jvm-class-1.png"></p><h2 id="Java-字节码文件"><a href="#Java-字节码文件" class="headerlink" title="Java 字节码文件"></a>Java 字节码文件</h2><p>class 文件本质上是一个以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在 class 文件中。jvm 根据其特定的规则解析该二进制数据，从而得到相关信息。</p><p>Class 文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。</p><h3 id="Class-文件的结构属性"><a href="#Class-文件的结构属性" class="headerlink" title="Class 文件的结构属性"></a>Class 文件的结构属性</h3><p><img src="https://pdai.tech/_images/jvm/java-jvm-class-2.png"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p>collapse: closed</p><p>以文本的形式打开生成的 class 文件，内容如下:</p><pre><code class="language-class">cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0007 0008 0c00 0500 0601 0010 636f 6d2f7268 7974 686d 372f 4d61 696e 0100 106a6176 612f 6c61 6e67 2f4f 626a 6563 74002100 0300 0400 0000 0100 0200 0500 06000000 0200 0100 0700 0800 0100 0900 00001d00 0100 0100 0000 052a b700 01b1 00000001 000a 0000 0006 0001 0000 0003 0001000b 000c 0001 0009 0000 001f 0002 00010000 0007 2ab4 0002 0460 ac00 0000 01000a00 0000 0600 0100 0000 0800 0100 0d000000 0200 0e</code><p><code class="language-class"></code></p></pre><p></p></div><ul><li>文件开头的 4 个字节 (“cafe babe”) 称之为 <code>魔数</code>，唯有以 “cafe babe” 开头的 class 文件方可被虚拟机所接受，这 4 个字节就是字节码文件的身份识别。</li><li>0000 是编译器 jdk 版本的次版本号 0，0034 转化为十进制是 52, 是主版本号，java 的版本号从 45 开始，除 1.0 和 1.1 都是使用 45.x 外, 以后每升一个大版本，版本号加一。也就是说，编译生成该 class 文件的 jdk 版本为 1.8.0。</li></ul><h3 id="反编译字节码文件"><a href="#反编译字节码文件" class="headerlink" title="反编译字节码文件"></a>反编译字节码文件</h3><blockquote><p>使用到 java 内置的一个反编译工具 javap 可以反编译字节码文件, 用法: <code>javap &lt;options&gt; &lt;classes&gt;</code></p></blockquote><p>其中<code>&lt;options&gt;</code>选项包括:</p><pre><code class="line-numbers language-text">  -help  --help  -?        输出此用法消息  -version                 版本信息  -v  -verbose             输出附加信息  -l                       输出行号和本地变量表  -public                  仅显示公共类和成员  -protected               显示受保护的/公共类和成员  -package                 显示程序包/受保护的/公共类                           和成员 (默认)  -p  -private             显示所有类和成员  -c                       对代码进行反汇编  -s                       输出内部类型签名  -sysinfo                 显示正在处理的类的                           系统信息 (路径, 大小, 日期, MD5 散列)  -constants               显示最终常量  -classpath &lt;path&gt;        指定查找用户类文件的位置  -cp &lt;path&gt;               指定查找用户类文件的位置  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</code></pre><p>输入命令<code>javap -verbose -p Main.class</code>查看输出内容:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">collapse: closed</p><pre><code>Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class  Last modified 2018-4-7; size 362 bytes  MD5 checksum 4aed8540b098992663b7ba08c65312de  Compiled from "Main.java"public class com.rhythm7.Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #4.#18            #2 = Fieldref           #3.#19            #3 = Class              #20               #4 = Class              #21               #5 = Utf8               m   #6 = Utf8               I   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               LocalVariableTable  #12 = Utf8               this  #13 = Utf8               Lcom/rhythm7/Main;  #14 = Utf8               inc  #15 = Utf8               ()I  #16 = Utf8               SourceFile  #17 = Utf8               Main.java  #18 = NameAndType        #7:#8            #19 = NameAndType        #5:#6            #20 = Utf8               com/rhythm7/Main  #21 = Utf8               java/lang/Object{  private int m;    descriptor: I    flags: ACC_PRIVATE<p>  public com.rhythm7.Main();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial #1<br>         4: return<br>      LineNumberTable:<br>        line 3: 0<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       5     0  this   Lcom/rhythm7/Main;</p><p>  public int inc();<br>    descriptor: ()I<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=2, locals=1, args_size=1<br>         0: aload_0<br>         1: getfield      #2<br>         4: iconst_1<br>         5: iadd<br>         6: ireturn<br>      LineNumberTable:<br>        line 8: 0<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       7     0  this   Lcom/rhythm7/Main;<br>}<br>SourceFile: "Main.java"</p></code><p><code></code></p></pre><p></p></div><h3 id="字节码文件信息"><a href="#字节码文件信息" class="headerlink" title="字节码文件信息"></a>字节码文件信息</h3><p>开头的 7 行信息包括: Class 文件当前所在位置，最后修改时间，文件大小，MD5 值，编译自哪个文件，类的全限定名，jdk 次版本号，主版本号。</p><p>然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下:</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为 Public 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为 final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用 invokespecial 字节码指令的新语义．</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志这个类并非由用户代码产生</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><code>Constant pool</code>意为常量池。</p><p>常量池可以理解成 Class 文件中的资源仓库。主要存放的是两大类常量：字面量 (Literal) 和符号引用(Symbolic References)。字面量类似于 java 中的常量概念，如文本字符串，final 常量等，而符号引用则属于编译原理方面的概念，包括以下三种:</p><ul><li>类和接口的全限定名 (Fully Qualified Name)</li><li>字段的名称和描述符号 (Descriptor)</li><li>方法的名称和描述符</li></ul><p>不同于 C/C++, JVM 是在加载 Class 文件的时候才进行的动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。 直接通过反编译文件来查看字节码内容：</p><pre><code>#1 = Methodref          #4.#18         #4 = Class              #21            #7 = Utf8               &lt;init&gt;#8 = Utf8               ()V#18 = NameAndType        #7:#8          #21 = Utf8               java/lang/Object</code></pre><p><strong>第一个常量</strong>是一个方法定义，指向了第 4 和第 18 个常量。以此类推查看第 4 和第 18 个常量。最后可以拼接成第一个常量右侧的注释内容:</p><pre><code>java/lang/Object."&lt;init&gt;":()V</code></pre><p>这段可以理解为该类的实例构造器的声明，由于 Main 类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了 Main 类的直接父类是 Object。 该方法默认返回值是 V, 也就是 void，无返回值。</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型 byte</td></tr><tr><td>C</td><td>基本类型 char</td></tr><tr><td>D</td><td>基本类型 double</td></tr><tr><td>F</td><td>基本类型 float</td></tr><tr><td>I</td><td>基本类型 int</td></tr><tr><td>J</td><td>基本类型 long</td></tr><tr><td>S</td><td>基本类型 short</td></tr><tr><td>Z</td><td>基本类型 boolean</td></tr><tr><td>V</td><td>特殊类型 void</td></tr><tr><td>L</td><td>对象类型，以分号结尾，如 Ljava/lang/Object;</td></tr></tbody></table><p>对于数组类型，每一位使用一个前置的<code>[</code>字符来描述，如定义一个<code>java.lang.String[][]</code>类型的维数组，将被记录为<code>[[Ljava/lang/String;</code></p><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的 16 进制文件内容如何，我们直接看反编译后的内容。</p><p>code 内的主要属性为:</p><ul><li><p><strong>stack</strong>: 最大操作数栈，JVM 运行时会根据这个值来分配栈帧 (Frame) 中的操作栈深度, 此处为 1</p></li><li><p><strong>locals</strong>: 局部变量所需的存储空间，单位为 Slot, Slot 是虚拟机为局部变量分配内存时所使用的最小单位，为 4 个字节大小。方法参数 (包括实例方法中的隐藏参数 this)，显示异常处理器的参数 (try catch 中的 catch 块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals 的大小并不一定等于所有局部变量所占的 Slot 之和，因为局部变量中的 Slot 是可以重用的。</p></li><li><p><strong>args_size</strong>: 方法参数的个数，这里是 1，因为每个实例方法都会有一个隐藏参数 this</p></li><li><p><strong>attribute_info</strong>: 方法体内容，0,1,4 为字节码 “行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的<code>java/lang/Object."":()V</code>, 然后执行返回语句，结束方法。</p></li><li><p><strong>LineNumberTable</strong>: 该属性的作用是描述源码行号与字节码行号 (字节码偏移量) 之间的对应关系。可以使用 -g:none 或 - g:lines 选项来取消或要求生成这项信息，如果选择不生成 LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</p></li><li><p><strong>LocalVariableTable</strong>: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars 来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是 arg0, arg1 这样的占位符。 start 表示该局部变量在哪一行开始可见，length 表示可见行数，Slot 代表所在帧栈位置，Name 是变量名称，然后是类型签名。</p></li></ul><h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>最后很显然是源码文件：</p><pre><code>SourceFile: "Main.java"</code></pre><h2 id="字节码增强技术"><a href="#字节码增强技术" class="headerlink" title="字节码增强技术"></a>字节码增强技术</h2><p>从最直接操纵字节码的实现方式开始深入进行剖析</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-1.png"></p><h3 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h3><h4 id="ASM-简介"><a href="#ASM-简介" class="headerlink" title="ASM 简介"></a>ASM 简介</h4><p>ASM 是一个通用的 Java 字节码操作和分析框架。 它可以用于修改现有类或直接以二进制形式动态生成类。 ASM 提供了一些常见的字节码转换和分析算法，可以从中构建自定义复杂转换和代码分析工具。 ASM 提供与其他 Java 字节码框架类似的功能，但专注于性能。 因为它的设计和实现尽可能小而且快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中）。</p><p><mark style="background: #FF5582A6;">对于需要手动操纵字节码的需求，可以使用 ASM，它可以直接生产 .class 字节码文件，也可以在类被加载入 JVM 之前动态修改类行为。</mark></p><p>ASM 的应用场景有 AOP（Cglib 就是基于 ASM）、热部署、修改其他 jar 包中的类等。</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-2.png"></p><h4 id="ASM-API"><a href="#ASM-API" class="headerlink" title="ASM API"></a>ASM API</h4><h5 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h5><p>ASM Core API 可以类比解析 XML 文件中的 SAX 方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用 Core API。在 Core API 中有以下几个关键类：</p><ul><li>ClassReader：用于读取已经编译好的. class 文件。</li><li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li><li>各种 Visitor 类：如上所述，CoreAPI 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 Visitor，比如用于访问方法的 MethodVisitor、用于访问类变量的 FieldVisitor、用于访问注解的 AnnotationVisitor 等。为了实现 AOP，重点要使用的是 MethodVisitor。</li></ul><h5 id="树形-API"><a href="#树形-API" class="headerlink" title="树形 API"></a>树形 API</h5><p>ASM Tree API 可以类比解析 XML 文件中的 DOM 方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi 不同于 CoreAPI，TreeAPI 通过各种 Node 类来映射字节码的各个区域，类比 DOM 节点，就可以很好地理解这种编程方式。</p><h4 id="直接利用-ASM-实现-AOP"><a href="#直接利用-ASM-实现-AOP" class="headerlink" title="直接利用 ASM 实现 AOP"></a>直接利用 ASM 实现 AOP</h4><p>利用 ASM 的 CoreAPI 来增强类。这里不纠结于 AOP 的专业名词如切片、通知，只实现在方法调用前、后增加逻辑，通俗易懂且方便理解。首先定义需要被增强的 Base 类：其中只包含一个 process() 方法，方法内输出一行 “process”。增强后，我们期望的是，方法执行前输出 “start”，之后输出”end”。</p><p>为了利用 ASM 实现 AOP，需要定义两个类：一个是 MyClassVisitor 类，用于对字节码的 visit 以及修改；另一个是 Generator 类，在这个类中定义 ClassReader 和 ClassWriter，其中的逻辑是，classReader 读取字节码，然后交给 MyClassVisitor 类处理，处理完成后由 ClassWriter 写字节码并将旧的字节码替换掉。Generator 类较简单，我们先看一下它的实现，如下所示，然后重点解释 MyClassVisitor 类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import org.objectweb.asm.ClassReader;import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.ClassWriter;<p>public class Generator {<br>    public static void main(String[] args) throws Exception {</p><pre><code>    ClassReader classReader = new ClassReader(&amp;quot;meituan/bytecode/asm/Base&amp;quot;);    ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);        ClassVisitor classVisitor = new MyClassVisitor(classWriter);    classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);    byte[] data = classWriter.toByteArray();        File f = new File(&amp;quot;operation-server/target/classes/meituan/bytecode/asm/Base.class&amp;quot;);    FileOutputStream fout = new FileOutputStream(f);    fout.write(data);    fout.close();    System.out.println(&amp;quot;now generator cc success!!!!!&amp;quot;);}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><p>MyClassVisitor 继承自 ClassVisitor，用于对字节码的观察。它还包含一个内部类 MyMethodVisitor，继承自 MethodVisitor 用于对类内方法的观察，它的整体代码如下：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><p>利用这个类就可以实现对字节码的修改。详细解读其中的代码，对字节码做修改的步骤是：</p><ul><li>首先通过 MyClassVisitor 类中的 visitMethod 方法，判断当前字节码读到哪一个方法了。跳过构造方法 <code>&lt;init&gt;</code> 后，将需要被增强的方法交给内部类 MyMethodVisitor 来进行处理。</li><li>接下来，进入内部类 MyMethodVisitor 中的 visitCode 方法，它会在 ASM 开始访问某一个方法的 Code 区时被调用，重写 visitCode 方法，将 AOP 中的前置逻辑就放在这里。 MyMethodVisitor 继续读取字节码指令，每当 ASM 访问到无参数指令时，都会调用 MyMethodVisitor 中的 visitInsn 方法。我们判断了当前指令是否为无参数的 “return” 指令，如果是就在它的前面添加一些指令，也就是将 AOP 的后置逻辑放在该方法中。</li><li>综上，重写 MyMethodVisitor 中的两个方法，就可以实现 AOP 了，而重写方法时就需要用 ASM 的写法，手动写入或者修改字节码。通过调用 methodVisitor 的 visitXXXXInsn()方法就可以实现字节码的插入，XXXX 对应相应的操作码助记符类型，比如 mv.visitLdcInsn(“end”)对应的操作码就是 ldc “end”，即将字符串 “end” 压入栈。 完成这两个 visitor 类后，运行 Generator 中的 main 方法完成对 Base 类的字节码增强，增强后的结果可以在编译后的 target 文件夹中找到 Base.class 文件进行查看，可以看到反编译后的代码已经改变了。然后写一个测试类 MyTest，在其中 new Base()，并调用 base.process()方法，可以看到下图右侧所示的 AOP 实现效果：</li></ul><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-3.png" alt></p><pre><code class="language-java">import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.MethodVisitor;import org.objectweb.asm.Opcodes;<p>public class MyClassVisitor extends ClassVisitor implements Opcodes {<br>    public MyClassVisitor(ClassVisitor cv) {<br>        super(ASM5, cv);<br>    }<br>    @Override<br>    public void visit(int version, int access, String name, String signature,<br>                      String superName, String[] interfaces) {<br>        cv.visit(version, access, name, signature, superName, interfaces);<br>    }<br>    @Override<br>    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {<br>        MethodVisitor mv = cv.visitMethod(access, name, desc, signature,<br>                exceptions);</p><pre><code>    if (!name.equals(&amp;quot;&amp;lt;init&amp;gt;&amp;quot;) &amp;amp;&amp;amp; mv != null) {        mv = new MyMethodVisitor(mv);    }    return mv;}class MyMethodVisitor extends MethodVisitor implements Opcodes {    public MyMethodVisitor(MethodVisitor mv) {        super(Opcodes.ASM5, mv);    }    @Override    public void visitCode() {        super.visitCode();        mv.visitFieldInsn(GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);        mv.visitLdcInsn(&amp;quot;start&amp;quot;);        mv.visitMethodInsn(INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;, false);    }    @Override    public void visitInsn(int opcode) {        if ((opcode &amp;gt;= Opcodes.IRETURN &amp;amp;&amp;amp; opcode &amp;lt;= Opcodes.RETURN)                || opcode == Opcodes.ATHROW) {                        mv.visitFieldInsn(GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);            mv.visitLdcInsn(&amp;quot;end&amp;quot;);            mv.visitMethodInsn(INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;, false);        }        mv.visitInsn(opcode);    }}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="ASM-工具"><a href="#ASM-工具" class="headerlink" title="ASM 工具"></a>ASM 工具</h4><p>利用 ASM 手写字节码时，需要利用一系列 visitXXXXInsn() 方法来写对应的助记符，所以需要先将每一行源代码转化为一个个的助记符，然后通过 ASM 的语法转换为 visitXXXXInsn() 这种写法。第一步将源码转化为助记符就已经够麻烦了，不熟悉字节码操作集合的话，需要我们将代码编译后再反编译，才能得到源代码对应的助记符。第二步利用 ASM 写字节码时，如何传参也很令人头疼。ASM 社区也知道这两个问题，所以提供了工具 <a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline">ASM ByteCode Outline (opens new window)</a>。</p><p>安装后，右键选择 “Show Bytecode Outline”，在新标签页中选择“ASMified” 这个 tab，如图 19 所示，就可以看到这个类中的代码对应的 ASM 写法了。图中上下两个红框分别对应 AOP 中的前置逻辑于后置逻辑，将这两块直接复制到 visitor 中的 visitMethod()以及 visitInsn()方法中，就可以了。</p><h3 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h3><p>ASM 是在指令层次上操作字节码的，阅读上文后，我们的直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，我们再简单介绍另外一类框架：强调源代码层次操作字节码的框架 Javassist。</p><p>利用 Javassist 实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是 ClassPool、CtClass、CtMethod、CtField 这四个类：</p><ul><li>CtClass（compile-time class）：编译时类信息，它是一个 class 文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个 CtClass 对象，用来表示这个类文件。</li><li>ClassPool：从开发视角来看，ClassPool 是一张保存 CtClass 信息的 HashTable，key 为类名，value 为类名对应的 CtClass 对象。当我们需要对某个类进行修改时，就是通过 pool.getCtClass(“className”) 方法从 pool 中获取到相应的 CtClass。</li><li>CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。</li></ul><p>了解这四个类后，我们可以写一个小 Demo 来展示 Javassist 简单、快速的特点。我们依然是对 Base 中的 process() 方法做增强，在方法调用前后分别输出”start” 和”end”，实现代码如下。我们需要做的就是从 pool 中获取到相应的 CtClass 对象和其中的方法，然后执行 method.insertBefore 和 insertAfter 方法，参数为要插入的 Java 代码，再以字符串的形式传入即可，实现起来也极为简单。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import com.meituan.mtrace.agent.javassist.*;</code><p><code class="language-java">public class JavassistTest {<br>    public static void main(String[] args) throws NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException, IOException {<br>        ClassPool cp = ClassPool.getDefault();<br>        CtClass cc = cp.get("meituan.bytecode.javassist.Base");<br>        CtMethod m = cc.getDeclaredMethod("process");<br>        m.insertBefore("{ System.out.println(&amp;quot;start&amp;quot;); }");<br>        m.insertAfter("{ System.out.println(&amp;quot;end&amp;quot;); }");<br>        Class c = cc.toClass();<br>        cc.writeFile("/Users/zen/projects");<br>        Base h = (Base)c.newInstance();<br>        h.process();<br>    }<br>}</code></p></pre><p></p></div><h2 id="运行时类的重载"><a href="#运行时类的重载" class="headerlink" title="运行时类的重载"></a>运行时类的重载</h2><h3 id="Instrument"><a href="#Instrument" class="headerlink" title="Instrument"></a>Instrument</h3><p>instrument 是 JVM 提供的一个可以修改已加载类的类库，专门为 Java 语言编写的插桩服务提供支持。它需要依赖 JVMTI 的 Attach API 机制实现，JVMTI 这一部分，我们将在下一小节进行介绍。在 JDK 1.6 以前，instrument 只能在 JVM 刚启动开始加载类时生效，而在 JDK 1.6 之后，instrument 支持了在运行时对类定义的修改。要使用 instrument 的类修改功能，我们需要实现它提供的 ClassFileTransformer 接口，定义一个类文件转换器。接口中的 transform() 方法会在类文件被加载时调用，而在 transform 方法里，我们可以利用上文中的 ASM 或 Javassist 对传入的字节码进行改写或替换，生成新的字节码数组后返回。</p><p>我们定义一个实现了 ClassFileTransformer 接口的类 TestTransformer，依然在其中利用 Javassist 对 Base 类中的 process()方法进行增强，在前后分别打印 “start” 和“end”，代码如下：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import java.lang.instrument.ClassFileTransformer;<p>public class TestTransformer implements ClassFileTransformer {<br>    @Override<br>    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {<br>        System.out.println("Transforming " + className);<br>        try {<br>            ClassPool cp = ClassPool.getDefault();<br>            CtClass cc = cp.get("meituan.bytecode.jvmti.Base");<br>            CtMethod m = cc.getDeclaredMethod("process");<br>            m.insertBefore("{ System.out.println(&amp;quot;start&amp;quot;); }");<br>            m.insertAfter("{ System.out.println(&amp;quot;end&amp;quot;); }");<br>            return cc.toBytecode();<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>        return null;<br>    }<br>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><p>现在有了 Transformer，那么它要如何注入到正在运行的 JVM 呢？还需要定义一个 Agent，借助 Agent 的能力将 Instrument 注入到 JVM 中。我们将在下一小节介绍 Agent，现在要介绍的是 Agent 中用到的另一个类 Instrumentation。在 JDK 1.6 之后，Instrumentation 可以做启动后的 Instrument、本地代码（Native Code）的 Instrument，以及动态改变 Classpath 等等。我们可以向 Instrumentation 中添加上文中定义的 Transformer，并指定要被重加载的类，代码如下所示。这样，当 Agent 被 Attach 到一个 JVM 中时，就会执行类字节码替换并重载入 JVM 的操作。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import java.lang.instrument.Instrumentation;<p>public class TestAgent {<br>    public static void agentmain(String args, Instrumentation inst) {</p><pre><code>    inst.addTransformer(new TestTransformer(), true);    try {                inst.retransformClasses(Base.class);        System.out.println(&amp;quot;Agent Load Done.&amp;quot;);    } catch (Exception e) {        System.out.println(&amp;quot;agent load failed!&amp;quot;);    }}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="JVMTI-amp-Agent-amp-Attach-API"><a href="#JVMTI-amp-Agent-amp-Attach-API" class="headerlink" title="JVMTI &amp; Agent &amp; Attach API"></a>JVMTI &amp; Agent &amp; Attach API</h3><p>追根溯源需要先介绍 JPDA（Java Platform Debugger Architecture）。如果 JVM 启动时开启了 JPDA，那么类是允许被重新加载的。在这种情况下，已被加载的旧版本类信息可以被卸载，然后重新加载新版本的类。正如 JDPA 名称中的 Debugger，JDPA 其实是一套用于调试 Java 程序的标准，任何 JDK 都必须实现该标准。</p><p>JPDA 定义了一整套完整的体系，它将调试体系分为三部分，并规定了三者之间的通信接口。三部分由低到高分别是 Java 虚拟机工具接口（JVMTI），Java 调试协议（JDWP）以及 Java 调试接口（JDI），三者之间的关系如下图所示：</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-6.png"></p><p>现在回到正题，我们可以借助 JVMTI 的一部分能力，帮助动态重载类信息。JVM TI（JVM TOOL INTERFACE，JVM 工具接口）是 JVM 提供的一套对 JVM 进行操作的工具接口。通过 JVMTI，可以实现对 JVM 的多种操作，它通过接口注册各种事件勾子，在 JVM 事件触发时，同时触发预定义的勾子，以实现对各个 JVM 事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC 开始和结束、方法调用进入和退出、临界区竞争与等待、VM 启动与退出等等。</p><p>而 Agent 就是 JVMTI 的一种实现，Agent 有两种启动方式，一是随 Java 进程启动而启动，经常见到的 java -agentlib 就是这种方式；二是运行时载入，通过 attach API，将模块（jar 包）动态地 Attach 到指定进程 id 的 Java 进程内。</p><p>Attach API 的作用是提供 JVM 进程间通信的能力，比如说我们为了让另外一个 JVM 进程把线上服务的线程 Dump 出来，会运行 jstack 或 jmap 的进程，并传递 pid 的参数，告诉它要对哪个进程进行线程 Dump，这就是 Attach API 做的事情。在下面，我们将通过 Attach API 的 loadAgent() 方法，将打包好的 Agent jar 包动态 Attach 到目标 JVM 上。具体实现起来的步骤如下：</p><ul><li>定义 Agent，并在其中实现 AgentMain 方法，如上一小节中定义的代码块 7 中的 TestAgent 类；</li><li>然后将 TestAgent 类打成一个包含 MANIFEST.MF 的 jar 包，其中 MANIFEST.MF 文件中将 Agent-Class 属性指定为 TestAgent 的全限定名</li><li>最后利用 Attach API，将我们打包好的 jar 包 Attach 到指定的 JVM pid 上</li><li>由于在 MANIFEST.MF 中指定了 Agent-Class，所以在 Attach 后，目标 JVM 在运行时会走到 TestAgent 类中定义的 agentmain()方法，而在这个方法中，我们利用 Instrumentation，将指定类的字节码通过定义的类转化器 TestTransformer 做了 Base 类的字节码替换（通过 javassist），并完成了类的重新加载。由此，我们达成了 “在 JVM 运行时，改变类的字节码并重新载入类信息” 的目的。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。</li><li>Mock：测试时候对某些服务做 Mock。</li><li>性能诊断工具：比如 bTrace 就是利用 Instrument，实现无侵入地跟踪一个正在运行的 JVM，监控到类和方法级别的状态信息。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字节码增强技术相当于是一把打开运行时 JVM 的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪 JVM 运行中程序的状态。此外，我们平时使用的动态代理、AOP 也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。综上所述，掌握字节码增强后可以高效地定位并快速修复一些棘手的问题（如线上性能问题、方法出现不可控的出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 WeakHashMap</title>
      <link href="/java/java-ji-he/java-ji-he-weakhashmap/"/>
      <url>/java/java-ji-he/java-ji-he-weakhashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-WeakHashMap"><a href="#【Java-集合】-WeakHashMap" class="headerlink" title="【Java 集合】 WeakHashMap"></a>【Java 集合】 WeakHashMap</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 WeakHashMapdate: 2022-12-14 14:29tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: WeakHashMap</code></pre><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。<br>更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况:</p><ul><li>调用两次<code>size()</code>方法返回不同的值；</li><li>两次调用<code>isEmpty()</code>方法，第一次返回false，第二次返回true；</li><li>两次调用<code>containsKey()</code>方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；</li><li>两次调用<code>get()</code>方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。<br>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，WeakHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。<br>要明白 WeakHashMap 的工作原理，还需要引入一个概念 : 弱引用(WeakReference)。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的有效引用 并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。<br>WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。<br>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>WeakHashMap的存储结构类似于Map - HashSet &amp; HashMap 源码解析，这里不再赘述。<br>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p><h2 id="Weak-HashSet"><a href="#Weak-HashSet" class="headerlink" title="Weak HashSet?"></a>Weak HashSet?</h2><p>如果你看过前几篇关于 Map 和 Set 的讲解，一定会问: 既然有 WeakHashMap，是否有 WeekHashSet 呢? 答案是没有:( 。不过Java Collections工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 Map包装成一个Set。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 WeakHashMap</title>
      <link href="/language/java/java-ji-he/java-ji-he-weakhashmap/"/>
      <url>/language/java/java-ji-he/java-ji-he-weakhashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-WeakHashMap"><a href="#【Java-集合】-WeakHashMap" class="headerlink" title="【Java 集合】 WeakHashMap"></a>【Java 集合】 WeakHashMap</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 WeakHashMapdate: 2022-12-14 14:29tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: WeakHashMap</code></pre><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。<br>更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况:</p><ul><li>调用两次<code>size()</code>方法返回不同的值；</li><li>两次调用<code>isEmpty()</code>方法，第一次返回false，第二次返回true；</li><li>两次调用<code>containsKey()</code>方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；</li><li>两次调用<code>get()</code>方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。<br>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，WeakHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。<br>要明白 WeakHashMap 的工作原理，还需要引入一个概念 : 弱引用(WeakReference)。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的有效引用 并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。<br>WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。<br>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>WeakHashMap的存储结构类似于Map - HashSet &amp; HashMap 源码解析，这里不再赘述。<br>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p><h2 id="Weak-HashSet"><a href="#Weak-HashSet" class="headerlink" title="Weak HashSet?"></a>Weak HashSet?</h2><p>如果你看过前几篇关于 Map 和 Set 的讲解，一定会问: 既然有 WeakHashMap，是否有 WeekHashSet 呢? 答案是没有:( 。不过Java Collections工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 Map包装成一个Set。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 TreeSet &amp; TreeMap</title>
      <link href="/java/java-ji-he/java-ji-he-treeset-treemap/"/>
      <url>/java/java-ji-he/java-ji-he-treeset-treemap/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-TreeSet-amp-TreeMap"><a href="#【Java-集合】-TreeSet-amp-TreeMap" class="headerlink" title="【Java 集合】 TreeSet &amp; TreeMap"></a>【Java 集合】 TreeSet &amp; TreeMap</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 TreeSet &amp; TreeMapdate: 2022-12-14 14:28tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: TreeSet &amp; TreeMap</code></pre><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)**。因此本文将重点分析TreeMap。</p><p>Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p><p>TreeMap底层通过红黑树(Red-Black tree)实现，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="/attachment/7a7166f88bbf82409e0ea2dfef3fb432.png"></p><p>出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成(wrapped)同步的:</p><pre><code class="line-numbers language-java">SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></pre><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(Rotate Left)，右旋(RotateRight)**。</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment/5032edc39f7b7fc0d8b1bb352641b5c9.png"></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment/4a47735be3f67803d2bb86f0b523126e.png"></p><h3 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h3><p>对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="/attachment/5a8f8447940c459fdcfa2e59ccd2376a.png"></p><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据key的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的entry。</p><p><img src="/attachment/eb8661b88f7261fb41c2730481d104d0.png"></p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。</p><p>上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的entry并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。<br><img src="/attachment/92a9af8db273d3091dea45a5cb592716.png"><br>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到key值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p><p>getEntry()函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p><p>由于<strong>红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。</p><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/attachment/92a9af8db273d3091dea45a5cb592716.png"></p><p>上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。</p><p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 TreeSet &amp; TreeMap</title>
      <link href="/language/java/java-ji-he/java-ji-he-treeset-treemap/"/>
      <url>/language/java/java-ji-he/java-ji-he-treeset-treemap/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-TreeSet-amp-TreeMap"><a href="#【Java-集合】-TreeSet-amp-TreeMap" class="headerlink" title="【Java 集合】 TreeSet &amp; TreeMap"></a>【Java 集合】 TreeSet &amp; TreeMap</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 TreeSet &amp; TreeMapdate: 2022-12-14 14:28tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: TreeSet &amp; TreeMap</code></pre><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)**。因此本文将重点分析TreeMap。</p><p>Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p><p>TreeMap底层通过红黑树(Red-Black tree)实现，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="/attachment%5C7a7166f88bbf82409e0ea2dfef3fb432.png"></p><p>出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成(wrapped)同步的:</p><pre><code class="line-numbers language-java">SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></pre><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(Rotate Left)，右旋(RotateRight)**。</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment%5C5032edc39f7b7fc0d8b1bb352641b5c9.png"></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment%5C4a47735be3f67803d2bb86f0b523126e.png"></p><h3 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h3><p>对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="/attachment%5C5a8f8447940c459fdcfa2e59ccd2376a.png"></p><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据key的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的entry。</p><p><img src="/attachment%5Ceb8661b88f7261fb41c2730481d104d0.png"></p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。</p><p>上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的entry并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。<br><img src="/attachment%5C92a9af8db273d3091dea45a5cb592716.png"><br>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到key值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p><p>getEntry()函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p><p>由于<strong>红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。</p><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/attachment%5C92a9af8db273d3091dea45a5cb592716.png"></p><p>上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。</p><p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedHashSet&amp;Map</title>
      <link href="/java/java-ji-he/java-ji-he-linkedhashset-map/"/>
      <url>/java/java-ji-he/java-ji-he-linkedhashset-map/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-LinkedHashSet-amp-Map"><a href="#【Java-集合】-LinkedHashSet-amp-Map" class="headerlink" title="【Java 集合】 LinkedHashSet&amp;Map"></a>【Java 集合】 LinkedHashSet&amp;Map</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 LinkedHashSet&amp;Mapdate: 2022-12-14 14:27tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedHashSet&amp;Map</code></pre><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>如果你已看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文将要讲解的LinkedHashSet和LinkedHashMap其实也是一回事。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap(适配器模式)。因此本文将重点分析LinkedHashMap。</p><p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。</p><p><img src="/attachment/a2a0572e540cb3667a33ff02a9506ba3.png"></p><p>事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。</p><p>除了可以保迭代历顺序，这种结构还有一个好处 : 迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。</p><p>有两个参数可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要<code>@Override hashCode()</code>和<code>equals()</code>方法。</p><p>出于性能原因，LinkedHashMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成(wrapped)同步的:</p><pre><code class="line-numbers language-java">Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></pre><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行参考前文，这里不再赘述。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p><code>put(K key, V value)</code>方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的entry。</p><p>注意，这里的插入有<strong>两重含义</strong>:</p><ol><li>从table的角度看，新的<code>entry</code>需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol><p><img src="/attachment/b3a124c667ece2d44b38023cf6b28415.png"></p><p>上述代码中用到了<code>addBefore()</code>方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。</p><p>上述代码只是简单修改相关entry的引用而已。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到key值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的删除也有两重含义:</p><blockquote><ol><li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="/attachment/b2057acdb4b57a0381c29f3da5e18e07.png"></p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。</p><h2 id="LinkedHashMap经典用法"><a href="#LinkedHashMap经典用法" class="headerlink" title="LinkedHashMap经典用法"></a>LinkedHashMap经典用法</h2><p>LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问<code>removeEldestEntry()</code>是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让<code>removeEldestEntry()</code>返回true，就能够实现一个固定大小的FIFO策略的缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedHashSet&amp;Map</title>
      <link href="/language/java/java-ji-he/java-ji-he-linkedhashset-map/"/>
      <url>/language/java/java-ji-he/java-ji-he-linkedhashset-map/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-LinkedHashSet-amp-Map"><a href="#【Java-集合】-LinkedHashSet-amp-Map" class="headerlink" title="【Java 集合】 LinkedHashSet&amp;Map"></a>【Java 集合】 LinkedHashSet&amp;Map</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 LinkedHashSet&amp;Mapdate: 2022-12-14 14:27tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedHashSet&amp;Map</code></pre><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>如果你已看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文将要讲解的LinkedHashSet和LinkedHashMap其实也是一回事。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap(适配器模式)。因此本文将重点分析LinkedHashMap。</p><p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。</p><p><img src="/attachment%5Ca2a0572e540cb3667a33ff02a9506ba3.png"></p><p>事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。</p><p>除了可以保迭代历顺序，这种结构还有一个好处 : 迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。</p><p>有两个参数可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要<code>@Override hashCode()</code>和<code>equals()</code>方法。</p><p>出于性能原因，LinkedHashMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成(wrapped)同步的:</p><pre><code class="line-numbers language-java">Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></pre><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行参考前文，这里不再赘述。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p><code>put(K key, V value)</code>方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的entry。</p><p>注意，这里的插入有<strong>两重含义</strong>:</p><ol><li>从table的角度看，新的<code>entry</code>需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol><p><img src="/attachment%5Cb3a124c667ece2d44b38023cf6b28415.png"></p><p>上述代码中用到了<code>addBefore()</code>方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。</p><p>上述代码只是简单修改相关entry的引用而已。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到key值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的删除也有两重含义:</p><blockquote><ol><li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="/attachment%5Cb2057acdb4b57a0381c29f3da5e18e07.png"></p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。</p><h2 id="LinkedHashMap经典用法"><a href="#LinkedHashMap经典用法" class="headerlink" title="LinkedHashMap经典用法"></a>LinkedHashMap经典用法</h2><p>LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问<code>removeEldestEntry()</code>是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让<code>removeEldestEntry()</code>返回true，就能够实现一个固定大小的FIFO策略的缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】HashSet &amp; HashMap</title>
      <link href="/java/java-ji-he/java-ji-he-hashset-hashmap/"/>
      <url>/java/java-ji-he/java-ji-he-hashset-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】HashSet-amp-HashMap"><a href="#【Java-集合】HashSet-amp-HashMap" class="headerlink" title="【Java 集合】HashSet &amp; HashMap"></a>【Java 集合】HashSet &amp; HashMap</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】HashSet &amp; HashMapdate: 2022-12-14 14:26tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: HashSet &amp; HashMap</code></pre><h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>之所以把HashSet和HashMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap(适配器模式)。因此本文将重点分析HashMap。</p><p>HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式。</strong></p><p><img src="/attachment/0e757c0ad4f83dc5a4d23e3766a40b5b.png"></p><p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。</p><p>有两个参数可以影响HashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到HashMap或HashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要<code>@Override</code> hashCode()和equals()方法。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个entry。</p><p><img src="/attachment/657342a08666fd428fa01da97955e06a.png"></p><p>上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为头插法。</p><p><img src="/attachment/8352c0cd711fff93e7177ecf74436844.png"></p><h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>来一张图简单示意一下吧：</p><p><img src="/attachment/46d8f27734298c8228231f63d3948780.png"></p><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ul><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等( = = 或equals)的 key</li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】HashSet &amp; HashMap</title>
      <link href="/language/java/java-ji-he/java-ji-he-hashset-hashmap/"/>
      <url>/language/java/java-ji-he/java-ji-he-hashset-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】HashSet-amp-HashMap"><a href="#【Java-集合】HashSet-amp-HashMap" class="headerlink" title="【Java 集合】HashSet &amp; HashMap"></a>【Java 集合】HashSet &amp; HashMap</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】HashSet &amp; HashMapdate: 2022-12-14 14:26tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: HashSet &amp; HashMap</code></pre><h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>之所以把HashSet和HashMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap(适配器模式)。因此本文将重点分析HashMap。</p><p>HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式。</strong></p><p><img src="/attachment%5C0e757c0ad4f83dc5a4d23e3766a40b5b.png"></p><p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。</p><p>有两个参数可以影响HashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到HashMap或HashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要<code>@Override</code> hashCode()和equals()方法。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个entry。</p><p><img src="/attachment%5C657342a08666fd428fa01da97955e06a.png"></p><p>上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为头插法。</p><p><img src="/attachment%5C8352c0cd711fff93e7177ecf74436844.png"></p><h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>来一张图简单示意一下吧：</p><p><img src="/attachment%5C46d8f27734298c8228231f63d3948780.png"></p><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ul><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等( = = 或equals)的 key</li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】PriorityQueue</title>
      <link href="/java/java-ji-he/java-ji-he-priorityqueue/"/>
      <url>/java/java-ji-he/java-ji-he-priorityqueue/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】PriorityQueue"><a href="#【Java-集合】PriorityQueue" class="headerlink" title="【Java 集合】PriorityQueue"></a>【Java 集合】PriorityQueue</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】PriorityQueuedate: 2022-12-14 14:25tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: PriorityQueue</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><p>Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为PriorityQueue的底层实现。</p><p><img src="/attachment/312394fa06a43080329f9f1fafa64962.png"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:</p><ul><li><code>leftNo = parentNo*2+1</code></li><li><code>rightNo = parentNo*2+2</code></li><li><code>parentNo = (nodeNo-1)/2</code></li></ul><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p>PriorityQueue的<code>peek()</code>和<code>element</code>操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。</p><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h3><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。</p><p><img src="/attachment/4d6d38c41256871b2dc7aaff20f458c9.png"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素x并维持堆的特性。</p><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为 : <strong>从k指定的位置开始，将<code>x</code>逐层与当前点的parent进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong> 。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h3 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p><p><img src="/attachment/659365dc4d6a29fc83e2ca41681c0958.png"></p><h3 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/attachment/824b6d4b5dd97fa012eb0331473a4b30.png"></p><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p><code>remove(Object o)</code>方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况: </p><ol><li>删除的是最后一个元素。直接删除即可，不需要调整。</li><li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</li></ol><p><img src="/attachment/59bbb3fa3b3e9145fb9ad09faa16a7dc.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】PriorityQueue</title>
      <link href="/language/java/java-ji-he/java-ji-he-priorityqueue/"/>
      <url>/language/java/java-ji-he/java-ji-he-priorityqueue/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】PriorityQueue"><a href="#【Java-集合】PriorityQueue" class="headerlink" title="【Java 集合】PriorityQueue"></a>【Java 集合】PriorityQueue</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】PriorityQueuedate: 2022-12-14 14:25tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: PriorityQueue</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><p>Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为PriorityQueue的底层实现。</p><p><img src="/attachment%5C312394fa06a43080329f9f1fafa64962.png"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:</p><ul><li><code>leftNo = parentNo*2+1</code></li><li><code>rightNo = parentNo*2+2</code></li><li><code>parentNo = (nodeNo-1)/2</code></li></ul><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p>PriorityQueue的<code>peek()</code>和<code>element</code>操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。</p><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h3><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。</p><p><img src="/attachment%5C4d6d38c41256871b2dc7aaff20f458c9.png"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素x并维持堆的特性。</p><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为 : <strong>从k指定的位置开始，将<code>x</code>逐层与当前点的parent进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong> 。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h3 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p><p><img src="/attachment%5C659365dc4d6a29fc83e2ca41681c0958.png"></p><h3 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/attachment%5C824b6d4b5dd97fa012eb0331473a4b30.png"></p><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p><code>remove(Object o)</code>方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况: </p><ol><li>删除的是最后一个元素。直接删除即可，不需要调整。</li><li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</li></ol><p><img src="/attachment%5C59bbb3fa3b3e9145fb9ad09faa16a7dc.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 Stack&amp;Queue</title>
      <link href="/java/java-ji-he/java-ji-he-stack-queue/"/>
      <url>/java/java-ji-he/java-ji-he-stack-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-Stack-amp-Queue"><a href="#【Java-集合】-Stack-amp-Queue" class="headerlink" title="【Java 集合】 Stack&amp;Queue"></a>【Java 集合】 Stack&amp;Queue</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 Stack&amp;Queuedate: 2022-12-14 14:24tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: Stack&amp;Queue</code></pre><h2 id="Stack-amp-Queue概述"><a href="#Stack-amp-Queue概述" class="headerlink" title="Stack &amp; Queue概述"></a>Stack &amp; Queue概述</h2><p>Java里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue接口继承自Collection接口，除了最基本的<code>Collection</code>的方法之外，它还支持额外的<code>insertion</code>, <code>extraction</code>和<code>inspection</code>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td></tr><tr><td>Remove</td><td>remove()</td></tr><tr><td>Examine</td><td>element()</td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>是”<code>double ended queue</code>“, 表示双向的队列，英文读作”deck”. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p><table><thead><tr><th>First Element - Head</th><th>Last Element - Tail</th></tr></thead><tbody><tr><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td></tr><tr><td>Examine</td><td>getFirst()</td></tr></tbody></table><p>当把<code>Deque</code>当做<code>FIFO</code>的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下:</p><p>Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td><td>向队尾插入元素，失败则返回false</td></tr><tr><td>remove()</td><td>removeFirst()</td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td>poll()</td><td>pollFirst()</td><td>获取并删除队首元素，失败则返回null</td></tr><tr><td>element()</td><td>getFirst()</td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除队首元素，失败则返回null</td></tr></tbody></table><p>下表列出了Deque与Stack对应的接口:</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td>offerFirst(e)</td><td>向栈顶插入元素，失败则返回false</td></tr><tr><td>pop()</td><td>removeFirst()</td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>pollFirst()</td><td>获取并删除栈顶元素，失败则返回null</td></tr><tr><td>peek()</td><td>getFirst()</td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则返回null</td></tr></tbody></table><p>上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。</p><p>ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。</p><p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p><img src="/attachment/08d0890337e4677367a3599ba968166b.png"></p><p>上图中我们看到，<code>head</code> <strong>指向首端第一个有效元素</strong>，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h3><p><code>addFirst(E e)</code> 的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[–head] = e即可。</p><p><img src="/attachment/978a80c9de15f7d5c8f028867fb3ee9f.png"></p><p>实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。</p><pre><code class="line-numbers language-java">//addFirst(E e)public void addFirst(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界    if (head == tail)//1.空间是否够用        doubleCapacity();//扩容}</code></pre><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。</p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p><p><img src="/attachment/06c965f8d110aa684fc6e289c3b0ff97.png"></p><p>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><pre><code class="line-numbers language-java">//doubleCapacity()private void doubleCapacity() {    assert head == tail;    int p = head;    int n = elements.length;    int r = n - p; // head右边元素的个数    int newCapacity = n &lt;&lt; 1;//原空间的2倍    if (newCapacity &lt; 0)        throw new IllegalStateException("Sorry, deque too big");    Object[] a = new Object[newCapacity];    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分    elements = (E[])a;    head = 0;    tail = n;}</code></pre><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。</p><p><img src="/attachment/b46ab44c8c54c0ab4dcaf88edb518eb7.png"></p><pre><code class="line-numbers language-java">public void addLast(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[tail] = e;//赋值    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理        doubleCapacity();//扩容}</code></pre><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h3><p><code>pollFirst()</code>的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当<code>elements[head] == null</code>时，意味着容器为空。</p><pre><code class="line-numbers language-java">public E pollFirst() {    E result = elements[head];    if (result == null)//null值意味着deque为空        return null;    elements[h] = null;//let GC work    head = (head + 1) &amp; (elements.length - 1);//下标越界处理    return result;}</code></pre><h3 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h3><p>pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="line-numbers language-java">public E pollLast() {    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素    E result = elements[t];    if (result == null)//null值意味着deque为空        return null;    elements[t] = null;//let GC work    tail = t;    return result;}</code></pre><h3 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h3><p><code>peekFirst()</code>的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回<code>elements[head]</code>即可。</p><h3 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h3><p><code>peekLast()</code>的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="line-numbers language-java">public E peekLast() {    return elements[(tail - 1) &amp; (elements.length - 1)];} </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 Stack&amp;Queue</title>
      <link href="/language/java/java-ji-he/java-ji-he-stack-queue/"/>
      <url>/language/java/java-ji-he/java-ji-he-stack-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-Stack-amp-Queue"><a href="#【Java-集合】-Stack-amp-Queue" class="headerlink" title="【Java 集合】 Stack&amp;Queue"></a>【Java 集合】 Stack&amp;Queue</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 Stack&amp;Queuedate: 2022-12-14 14:24tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: Stack&amp;Queue</code></pre><h2 id="Stack-amp-Queue概述"><a href="#Stack-amp-Queue概述" class="headerlink" title="Stack &amp; Queue概述"></a>Stack &amp; Queue概述</h2><p>Java里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue接口继承自Collection接口，除了最基本的<code>Collection</code>的方法之外，它还支持额外的<code>insertion</code>, <code>extraction</code>和<code>inspection</code>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td></tr><tr><td>Remove</td><td>remove()</td></tr><tr><td>Examine</td><td>element()</td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>是”<code>double ended queue</code>“, 表示双向的队列，英文读作”deck”. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p><table><thead><tr><th>First Element - Head</th><th>Last Element - Tail</th></tr></thead><tbody><tr><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td></tr><tr><td>Examine</td><td>getFirst()</td></tr></tbody></table><p>当把<code>Deque</code>当做<code>FIFO</code>的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下:</p><p>Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td><td>向队尾插入元素，失败则返回false</td></tr><tr><td>remove()</td><td>removeFirst()</td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td>poll()</td><td>pollFirst()</td><td>获取并删除队首元素，失败则返回null</td></tr><tr><td>element()</td><td>getFirst()</td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除队首元素，失败则返回null</td></tr></tbody></table><p>下表列出了Deque与Stack对应的接口:</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td>offerFirst(e)</td><td>向栈顶插入元素，失败则返回false</td></tr><tr><td>pop()</td><td>removeFirst()</td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>pollFirst()</td><td>获取并删除栈顶元素，失败则返回null</td></tr><tr><td>peek()</td><td>getFirst()</td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则返回null</td></tr></tbody></table><p>上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。</p><p>ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。</p><p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p><img src="/attachment%5C08d0890337e4677367a3599ba968166b.png"></p><p>上图中我们看到，<code>head</code> <strong>指向首端第一个有效元素</strong>，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h3><p><code>addFirst(E e)</code> 的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[–head] = e即可。</p><p><img src="/attachment%5C978a80c9de15f7d5c8f028867fb3ee9f.png"></p><p>实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。</p><pre><code class="line-numbers language-java">//addFirst(E e)public void addFirst(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界    if (head == tail)//1.空间是否够用        doubleCapacity();//扩容}</code></pre><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。</p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p><p><img src="/attachment%5C06c965f8d110aa684fc6e289c3b0ff97.png"></p><p>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><pre><code class="line-numbers language-java">//doubleCapacity()private void doubleCapacity() {    assert head == tail;    int p = head;    int n = elements.length;    int r = n - p; // head右边元素的个数    int newCapacity = n &lt;&lt; 1;//原空间的2倍    if (newCapacity &lt; 0)        throw new IllegalStateException("Sorry, deque too big");    Object[] a = new Object[newCapacity];    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分    elements = (E[])a;    head = 0;    tail = n;}</code></pre><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。</p><p><img src="/attachment%5Cb46ab44c8c54c0ab4dcaf88edb518eb7.png"></p><pre><code class="line-numbers language-java">public void addLast(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[tail] = e;//赋值    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理        doubleCapacity();//扩容}</code></pre><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h3><p><code>pollFirst()</code>的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当<code>elements[head] == null</code>时，意味着容器为空。</p><pre><code class="line-numbers language-java">public E pollFirst() {    E result = elements[head];    if (result == null)//null值意味着deque为空        return null;    elements[h] = null;//let GC work    head = (head + 1) &amp; (elements.length - 1);//下标越界处理    return result;}</code></pre><h3 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h3><p>pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="line-numbers language-java">public E pollLast() {    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素    E result = elements[t];    if (result == null)//null值意味着deque为空        return null;    elements[t] = null;//let GC work    tail = t;    return result;}</code></pre><h3 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h3><p><code>peekFirst()</code>的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回<code>elements[head]</code>即可。</p><h3 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h3><p><code>peekLast()</code>的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="line-numbers language-java">public E peekLast() {    return elements[(tail - 1) &amp; (elements.length - 1)];} </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedList</title>
      <link href="/java/java-ji-he/java-ji-he-linkedlist/"/>
      <url>/java/java-ji-he/java-ji-he-linkedlist/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-LinkedList"><a href="#【Java-集合】-LinkedList" class="headerlink" title="【Java 集合】 LinkedList"></a>【Java 集合】 LinkedList</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 LinkedListdate: 2022-12-14 14:23tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedList</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类(它是个接口名字)。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。</p><p><img src="/attachment/68cde8f6127c75943241f2fec6f1fb9b.png"></p><p>LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。</p><h2 id="LinkedLists实现"><a href="#LinkedLists实现" class="headerlink" title="LinkedLists实现"></a>LinkedLists实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>LinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，而将Queue和Stack以及Deque相关的知识放在下一节讲。双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。</p><pre><code class="line-numbers language-java">    transient int size = 0;    /**     * Pointer to first node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (first.prev == null &amp;&amp; first.item != null)     */    transient Node&lt;E&gt; first;    /**     * Pointer to last node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     */    transient Node&lt;E&gt; last;</code></pre><p>其中Node是私有的内部类:</p><pre><code class="line-numbers language-java">    private static class Node&lt;E&gt; {        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {            this.item = element;            this.next = next;            this.prev = prev;        }    }</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="line-numbers language-java">    /**     * Constructs an empty list.     */    public LinkedList() {    }    /**     * Constructs a list containing the elements of the specified     * collection, in the order they are returned by the collection's     * iterator.     *     * @param  c the collection whose elements are to be placed into this list     * @throws NullPointerException if the specified collection is null     */    public LinkedList(Collection&lt;? extends E&gt; c) {        this();        addAll(c);    }</code></pre><h3 id="getFirst-getLast"><a href="#getFirst-getLast" class="headerlink" title="getFirst(), getLast()"></a>getFirst(), getLast()</h3><p>获取第一个元素， 和获取最后一个元素:</p><pre><code class="line-numbers language-java">    /**     * Returns the first element in this list.     *     * @return the first element in this list     * @throws NoSuchElementException if this list is empty     */    public E getFirst() {        final Node&lt;E&gt; f = first;        if (f == null)            throw new NoSuchElementException();        return f.item;    }    /**     * Returns the last element in this list.     *     * @return the last element in this list     * @throws NoSuchElementException if this list is empty     */    public E getLast() {        final Node&lt;E&gt; l = last;        if (l == null)            throw new NoSuchElementException();        return l.item;    }</code></pre><h3 id="removeFirst-removeLast-remove-e-remove-index"><a href="#removeFirst-removeLast-remove-e-remove-index" class="headerlink" title="removeFirst(), removeLast(), remove(e), remove(index)"></a>removeFirst(), removeLast(), remove(e), remove(index)</h3><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><img src="/attachment/b190f02840a986ee73942dda0f3e37b8.png"></p><p>删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p><p><code>remove(int index)</code>使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。</p><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p><code>add()</code>方法有两个版本，一个是<code>add(E e)</code>，该方法在<code>LinkedList</code>的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><p><img src="/attachment/dfc813989f550f643c970e9dcfd90051.png"></p><p><code>add(int index, E element)</code>, 当<code>index==size</code>时，等同于<code>add(E e)</code>; 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p><p>上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</p><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。</p><h3 id="Positional-Access-方法"><a href="#Positional-Access-方法" class="headerlink" title="Positional Access 方法"></a>Positional Access 方法</h3><p>通过index获取元素</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedList</title>
      <link href="/language/java/java-ji-he/java-ji-he-linkedlist/"/>
      <url>/language/java/java-ji-he/java-ji-he-linkedlist/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-LinkedList"><a href="#【Java-集合】-LinkedList" class="headerlink" title="【Java 集合】 LinkedList"></a>【Java 集合】 LinkedList</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 LinkedListdate: 2022-12-14 14:23tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedList</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类(它是个接口名字)。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。</p><p><img src="/attachment%5C68cde8f6127c75943241f2fec6f1fb9b.png"></p><p>LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。</p><h2 id="LinkedLists实现"><a href="#LinkedLists实现" class="headerlink" title="LinkedLists实现"></a>LinkedLists实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>LinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，而将Queue和Stack以及Deque相关的知识放在下一节讲。双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。</p><pre><code class="line-numbers language-java">    transient int size = 0;    /**     * Pointer to first node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (first.prev == null &amp;&amp; first.item != null)     */    transient Node&lt;E&gt; first;    /**     * Pointer to last node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     */    transient Node&lt;E&gt; last;</code></pre><p>其中Node是私有的内部类:</p><pre><code class="line-numbers language-java">    private static class Node&lt;E&gt; {        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {            this.item = element;            this.next = next;            this.prev = prev;        }    }</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="line-numbers language-java">    /**     * Constructs an empty list.     */    public LinkedList() {    }    /**     * Constructs a list containing the elements of the specified     * collection, in the order they are returned by the collection's     * iterator.     *     * @param  c the collection whose elements are to be placed into this list     * @throws NullPointerException if the specified collection is null     */    public LinkedList(Collection&lt;? extends E&gt; c) {        this();        addAll(c);    }</code></pre><h3 id="getFirst-getLast"><a href="#getFirst-getLast" class="headerlink" title="getFirst(), getLast()"></a>getFirst(), getLast()</h3><p>获取第一个元素， 和获取最后一个元素:</p><pre><code class="line-numbers language-java">    /**     * Returns the first element in this list.     *     * @return the first element in this list     * @throws NoSuchElementException if this list is empty     */    public E getFirst() {        final Node&lt;E&gt; f = first;        if (f == null)            throw new NoSuchElementException();        return f.item;    }    /**     * Returns the last element in this list.     *     * @return the last element in this list     * @throws NoSuchElementException if this list is empty     */    public E getLast() {        final Node&lt;E&gt; l = last;        if (l == null)            throw new NoSuchElementException();        return l.item;    }</code></pre><h3 id="removeFirst-removeLast-remove-e-remove-index"><a href="#removeFirst-removeLast-remove-e-remove-index" class="headerlink" title="removeFirst(), removeLast(), remove(e), remove(index)"></a>removeFirst(), removeLast(), remove(e), remove(index)</h3><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><img src="/attachment%5Cb190f02840a986ee73942dda0f3e37b8.png"></p><p>删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p><p><code>remove(int index)</code>使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。</p><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p><code>add()</code>方法有两个版本，一个是<code>add(E e)</code>，该方法在<code>LinkedList</code>的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><p><img src="/attachment%5Cdfc813989f550f643c970e9dcfd90051.png"></p><p><code>add(int index, E element)</code>, 当<code>index==size</code>时，等同于<code>add(E e)</code>; 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p><p>上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</p><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。</p><h3 id="Positional-Access-方法"><a href="#Positional-Access-方法" class="headerlink" title="Positional Access 方法"></a>Positional Access 方法</h3><p>通过index获取元素</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/java/java-ji-he/java-ji-he/"/>
      <url>/java/java-ji-he/java-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java 集合date: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 集合</code></pre><h2 id="Java-集合-1"><a href="#Java-集合-1" class="headerlink" title="Java 集合"></a>Java 集合</h2><p><img src="/attachment/7727cae2e6a5956678ac0bbedc6748d6.png"></p><h2 id="【Java-集合】-ArrayList"><a href="#【Java-集合】-ArrayList" class="headerlink" title="【Java 集合】 ArrayList"></a>【Java 集合】 ArrayList</h2><p>undefined</p><h2 id="【Java-集合】-LinkedList"><a href="#【Java-集合】-LinkedList" class="headerlink" title="【Java 集合】 LinkedList"></a>【Java 集合】 LinkedList</h2><p>undefined</p><h2 id="【Java-集合】-LinkedHashSet-amp-Map"><a href="#【Java-集合】-LinkedHashSet-amp-Map" class="headerlink" title="【Java 集合】 LinkedHashSet&amp;Map"></a>【Java 集合】 LinkedHashSet&amp;Map</h2><p>undefined</p><h2 id="【Java-集合】-Stack-amp-Queue"><a href="#【Java-集合】-Stack-amp-Queue" class="headerlink" title="【Java 集合】 Stack&amp;Queue"></a>【Java 集合】 Stack&amp;Queue</h2><p>undefined</p><h2 id="【Java-集合】-TreeSet-amp-TreeMap"><a href="#【Java-集合】-TreeSet-amp-TreeMap" class="headerlink" title="【Java 集合】 TreeSet &amp; TreeMap"></a>【Java 集合】 TreeSet &amp; TreeMap</h2><p>undefined</p><h2 id="【Java-集合】-WeakHashMap"><a href="#【Java-集合】-WeakHashMap" class="headerlink" title="【Java 集合】 WeakHashMap"></a>【Java 集合】 WeakHashMap</h2><p>undefined</p><h2 id="【Java-集合】PriorityQueue"><a href="#【Java-集合】PriorityQueue" class="headerlink" title="【Java 集合】PriorityQueue"></a>【Java 集合】PriorityQueue</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 ArrayList</title>
      <link href="/java/java-ji-he/java-ji-he-arraylist/"/>
      <url>/java/java-ji-he/java-ji-he-arraylist/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-ArrayList"><a href="#【Java-集合】-ArrayList" class="headerlink" title="【Java 集合】 ArrayList"></a>【Java 集合】 ArrayList</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 ArrayListdate: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: 集合</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><p><img src="/attachment/8bcaee4d397913b246c1598cac55fea4.png"></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><h2 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><pre><code class="line-numbers language-java">    /**     * The array buffer into which the elements of the ArrayList are stored.     * The capacity of the ArrayList is the length of this array buffer. Any     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA     * will be expanded to DEFAULT_CAPACITY when the first element is added.     */    transient Object[] elementData; // non-private to simplify nested class access    /**     * The size of the ArrayList (the number of elements it contains).     *     * @serial     */    private int size;</code></pre><h3 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h3><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><pre><code class="line-numbers language-ad-tip">当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。</code></pre><p><img src="/attachment/63ae74eaa7189b56a8ac2d7407e60a57.png"></p><h3 id="add-addAll"><a href="#add-addAll" class="headerlink" title="add(), addAll()"></a>add(), addAll()</h3><p>跟C++ 的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。</p><p><img src="/attachment/e68ac4bef1a5e34817cbd016daef64c8.png"></p><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。</p><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。</p><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(), lastIndexOf()"></a>indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index<br>获取元素的最后一次出现的index</p><h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/language/java/java-ji-he/java-ji-he/"/>
      <url>/language/java/java-ji-he/java-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java 集合date: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 集合</code></pre><h2 id="Java-集合-1"><a href="#Java-集合-1" class="headerlink" title="Java 集合"></a>Java 集合</h2><p><img src="/attachment%5C7727cae2e6a5956678ac0bbedc6748d6.png"></p><h2 id="【Java-集合】-ArrayList"><a href="#【Java-集合】-ArrayList" class="headerlink" title="【Java 集合】 ArrayList"></a>【Java 集合】 ArrayList</h2><p>undefined</p><h2 id="【Java-集合】-LinkedList"><a href="#【Java-集合】-LinkedList" class="headerlink" title="【Java 集合】 LinkedList"></a>【Java 集合】 LinkedList</h2><p>undefined</p><h2 id="【Java-集合】-LinkedHashSet-amp-Map"><a href="#【Java-集合】-LinkedHashSet-amp-Map" class="headerlink" title="【Java 集合】 LinkedHashSet&amp;Map"></a>【Java 集合】 LinkedHashSet&amp;Map</h2><p>undefined</p><h2 id="【Java-集合】-Stack-amp-Queue"><a href="#【Java-集合】-Stack-amp-Queue" class="headerlink" title="【Java 集合】 Stack&amp;Queue"></a>【Java 集合】 Stack&amp;Queue</h2><p>undefined</p><h2 id="【Java-集合】-TreeSet-amp-TreeMap"><a href="#【Java-集合】-TreeSet-amp-TreeMap" class="headerlink" title="【Java 集合】 TreeSet &amp; TreeMap"></a>【Java 集合】 TreeSet &amp; TreeMap</h2><p>undefined</p><h2 id="【Java-集合】-WeakHashMap"><a href="#【Java-集合】-WeakHashMap" class="headerlink" title="【Java 集合】 WeakHashMap"></a>【Java 集合】 WeakHashMap</h2><p>undefined</p><h2 id="【Java-集合】PriorityQueue"><a href="#【Java-集合】PriorityQueue" class="headerlink" title="【Java 集合】PriorityQueue"></a>【Java 集合】PriorityQueue</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 ArrayList</title>
      <link href="/language/java/java-ji-he/java-ji-he-arraylist/"/>
      <url>/language/java/java-ji-he/java-ji-he-arraylist/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-集合】-ArrayList"><a href="#【Java-集合】-ArrayList" class="headerlink" title="【Java 集合】 ArrayList"></a>【Java 集合】 ArrayList</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 集合】 ArrayListdate: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: 集合</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><p><img src="/attachment%5C8bcaee4d397913b246c1598cac55fea4.png"></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><h2 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><pre><code class="line-numbers language-java">    /**     * The array buffer into which the elements of the ArrayList are stored.     * The capacity of the ArrayList is the length of this array buffer. Any     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA     * will be expanded to DEFAULT_CAPACITY when the first element is added.     */    transient Object[] elementData; // non-private to simplify nested class access    /**     * The size of the ArrayList (the number of elements it contains).     *     * @serial     */    private int size;</code></pre><h3 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h3><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><pre><code class="line-numbers language-ad-tip">当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。</code></pre><p><img src="/attachment%5C63ae74eaa7189b56a8ac2d7407e60a57.png"></p><h3 id="add-addAll"><a href="#add-addAll" class="headerlink" title="add(), addAll()"></a>add(), addAll()</h3><p>跟C++ 的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。</p><p><img src="/attachment%5Ce68ac4bef1a5e34817cbd016daef64c8.png"></p><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。</p><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。</p><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(), lastIndexOf()"></a>indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index<br>获取元素的最后一次出现的index</p><h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 注解</title>
      <link href="/java/java-ji-chu/java-ji-chu-zhu-jie/"/>
      <url>/java/java-ji-chu/java-ji-chu-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-注解"><a href="#【Java-基础】-注解" class="headerlink" title="【Java 基础】 注解"></a>【Java 基础】 注解</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 注解date: 2022-12-14 14:13tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/注解categories:  - Javakeywords:  - Java/基础  - 注解description: 注解</code></pre><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><strong>Java自带的标准注解</strong>，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li><li><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li><li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li></ul><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li></ul><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li><strong>用来修饰方法</strong></li><li><strong>编译时有效</strong></li><li><strong>重写的父类的中的相同签名的方法</strong></li></ul><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {}</code></pre></div><ul><li>被文档化</li><li>保留到运行时</li><li>修饰构造方法、属性、局部变量、方法、包、参数、类型</li></ul><p>告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings {    String[] value();}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li>修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量</li><li>只能存活在源码时</li><li>取值为<code>String[]</code></li></ul><p>告诉编译器忽略指定的警告信息</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing/unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table></div><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><strong>作用</strong></p><p>描述注解的使用范围（即：被修饰的注解可以用在什么地方）</p><p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了<code>@Target</code> 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在<code>ElementType</code> 枚举中。</p><p><strong>ElementType</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum ElementType { <pre><code>TYPE, // 类、接口、枚举类FIELD, // 成员变量（包括：枚举常量）METHOD, // 成员方法PARAMETER, // 方法参数CONSTRUCTOR, // 构造方法LOCAL_VARIABLE, // 局部变量ANNOTATION_TYPE, // 注解类PACKAGE, // 可用于修饰：包TYPE_PARAMETER, // 类型参数，JDK 1.8 新增TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Retention-amp-RetentionTarget"><a href="#Retention-amp-RetentionTarget" class="headerlink" title="@Retention &amp; @RetentionTarget"></a>@Retention &amp; @RetentionTarget</h4><p><strong>作用</strong></p><p>描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。<br>用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在<code>RetentionPolicy</code>枚举中。</p><p><strong>RetentionPolicy</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum RetentionPolicy { <pre><code>SOURCE,    // 源文件保留CLASS,       // 编译期保留，默认值RUNTIME   // 运行期保留，可通过反射去获取注解信息</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p><strong>作用</strong></p><p>描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p><strong>作用</strong></p><p>被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p><strong>作用</strong></p><p>重复注解 <code>ElementType.TYPE_USE</code></p><h4 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h4><p><strong>作用</strong></p><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p><h3 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h3><p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。</p><ul><li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li></ul><p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p><p><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></p><p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p><ul><li><code>Annotation[] getAnnotations()</code></li></ul><p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p><ul><li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p><ul><li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p><ul><li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code></li></ul><p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>- </p><h2 id="注解实现的原理"><a href="#注解实现的原理" class="headerlink" title="注解实现的原理"></a>注解实现的原理</h2><h3 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h3><p>注解是一个接口，一个继承自Annotation的接口。<br>里面每一个属性，其实就是接口的一个抽象方法。</p><p>这里推荐你两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li><li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li></ul><h2 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h2><h3 id="配置化到注解化-框架的演进"><a href="#配置化到注解化-框架的演进" class="headerlink" title="配置化到注解化 - 框架的演进"></a>配置化到注解化 - 框架的演进</h3><p>Spring 框架 配置化到注解化的转变。</p><h3 id="继承实现到注解实现-Junit3到Junit4"><a href="#继承实现到注解实现-Junit3到Junit4" class="headerlink" title="继承实现到注解实现 - Junit3到Junit4"></a>继承实现到注解实现 - Junit3到Junit4</h3><blockquote><p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p></blockquote><h3 id="自定义注解和AOP-通过切面实现解耦"><a href="#自定义注解和AOP-通过切面实现解耦" class="headerlink" title="自定义注解和AOP - 通过切面实现解耦"></a>自定义注解和AOP - 通过切面实现解耦</h3><ul><li>自定义Log注解</li><li>实现日志的切面, 对自定义注解Log作切点进行拦截</li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 注解</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-zhu-jie/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-注解"><a href="#【Java-基础】-注解" class="headerlink" title="【Java 基础】 注解"></a>【Java 基础】 注解</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 注解date: 2022-12-14 14:13tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/注解categories:  - Javakeywords:  - Java/基础  - 注解description: 注解</code></pre><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><strong>Java自带的标准注解</strong>，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li><li><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li><li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li></ul><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li></ul><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li><strong>用来修饰方法</strong></li><li><strong>编译时有效</strong></li><li><strong>重写的父类的中的相同签名的方法</strong></li></ul><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {}</code></pre></div><ul><li>被文档化</li><li>保留到运行时</li><li>修饰构造方法、属性、局部变量、方法、包、参数、类型</li></ul><p>告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings {    String[] value();}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li>修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量</li><li>只能存活在源码时</li><li>取值为<code>String[]</code></li></ul><p>告诉编译器忽略指定的警告信息</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing/unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table></div><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><strong>作用</strong></p><p>描述注解的使用范围（即：被修饰的注解可以用在什么地方）</p><p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了<code>@Target</code> 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在<code>ElementType</code> 枚举中。</p><p><strong>ElementType</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum ElementType { <pre><code>TYPE, // 类、接口、枚举类FIELD, // 成员变量（包括：枚举常量）METHOD, // 成员方法PARAMETER, // 方法参数CONSTRUCTOR, // 构造方法LOCAL_VARIABLE, // 局部变量ANNOTATION_TYPE, // 注解类PACKAGE, // 可用于修饰：包TYPE_PARAMETER, // 类型参数，JDK 1.8 新增TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Retention-amp-RetentionTarget"><a href="#Retention-amp-RetentionTarget" class="headerlink" title="@Retention &amp; @RetentionTarget"></a>@Retention &amp; @RetentionTarget</h4><p><strong>作用</strong></p><p>描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。<br>用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在<code>RetentionPolicy</code>枚举中。</p><p><strong>RetentionPolicy</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum RetentionPolicy { <pre><code>SOURCE,    // 源文件保留CLASS,       // 编译期保留，默认值RUNTIME   // 运行期保留，可通过反射去获取注解信息</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p><strong>作用</strong></p><p>描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p><strong>作用</strong></p><p>被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p><strong>作用</strong></p><p>重复注解 <code>ElementType.TYPE_USE</code></p><h4 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h4><p><strong>作用</strong></p><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p><h3 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h3><p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。</p><ul><li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li></ul><p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p><p><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></p><p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p><ul><li><code>Annotation[] getAnnotations()</code></li></ul><p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p><ul><li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p><ul><li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p><ul><li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code></li></ul><p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>- </p><h2 id="注解实现的原理"><a href="#注解实现的原理" class="headerlink" title="注解实现的原理"></a>注解实现的原理</h2><h3 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h3><p>注解是一个接口，一个继承自Annotation的接口。<br>里面每一个属性，其实就是接口的一个抽象方法。</p><p>这里推荐你两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li><li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li></ul><h2 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h2><h3 id="配置化到注解化-框架的演进"><a href="#配置化到注解化-框架的演进" class="headerlink" title="配置化到注解化 - 框架的演进"></a>配置化到注解化 - 框架的演进</h3><p>Spring 框架 配置化到注解化的转变。</p><h3 id="继承实现到注解实现-Junit3到Junit4"><a href="#继承实现到注解实现-Junit3到Junit4" class="headerlink" title="继承实现到注解实现 - Junit3到Junit4"></a>继承实现到注解实现 - Junit3到Junit4</h3><blockquote><p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p></blockquote><h3 id="自定义注解和AOP-通过切面实现解耦"><a href="#自定义注解和AOP-通过切面实现解耦" class="headerlink" title="自定义注解和AOP - 通过切面实现解耦"></a>自定义注解和AOP - 通过切面实现解耦</h3><ul><li>自定义Log注解</li><li>实现日志的切面, 对自定义注解Log作切点进行拦截</li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 泛型</title>
      <link href="/java/java-ji-chu/java-ji-chu-fan-xing/"/>
      <url>/java/java-ji-chu/java-ji-chu-fan-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-泛型"><a href="#【Java-基础】-泛型" class="headerlink" title="【Java 基础】 泛型"></a>【Java 基础】 泛型</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 泛型date: 2022-12-14 14:12tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/泛型categories:  - Javakeywords:  - Java/基础  - 泛型description: 泛型</code></pre><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>泛型的本质是为了参数化类型。</p><ul><li>适用于多种数据类型执行相同的代码（代码复用）</li><li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li></ul><h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p><p>定义泛型方法语法格式</p><p><img src="/attachment/ddcdc6a539768f8dc7017062098af3bb.png"></p><ul><li>调用泛型方法语法格式</li></ul><p><img src="/attachment/ef4e9cc951e4f6e085f5e62fd0156c58.png"></p><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>- </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code class="line-numbers language-java">&lt;?&gt; 无限制通配符&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类// 使用原则《Effictive Java》// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限1. 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;2. 如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 泛型</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-fan-xing/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-fan-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-泛型"><a href="#【Java-基础】-泛型" class="headerlink" title="【Java 基础】 泛型"></a>【Java 基础】 泛型</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 泛型date: 2022-12-14 14:12tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/泛型categories:  - Javakeywords:  - Java/基础  - 泛型description: 泛型</code></pre><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>泛型的本质是为了参数化类型。</p><ul><li>适用于多种数据类型执行相同的代码（代码复用）</li><li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li></ul><h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p><p>定义泛型方法语法格式</p><p><img src="/attachment%5Cddcdc6a539768f8dc7017062098af3bb.png"></p><ul><li>调用泛型方法语法格式</li></ul><p><img src="/attachment%5Cef4e9cc951e4f6e085f5e62fd0156c58.png"></p><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>- </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code class="line-numbers language-java">&lt;?&gt; 无限制通配符&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类// 使用原则《Effictive Java》// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限1. 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;2. 如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 异常</title>
      <link href="/java/java-ji-chu/java-ji-chu-yi-chang/"/>
      <url>/java/java-ji-chu/java-ji-chu-yi-chang/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-异常"><a href="#【Java-基础】-异常" class="headerlink" title="【Java 基础】 异常"></a>【Java 基础】 异常</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 异常date: 2022-12-14 14:11tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/异常categories:  - Javakeywords:  - Java/基础  - 异常description: 异常</code></pre><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:</p><ul><li>受检异常 : 需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li>非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h2><h3 id="异常关键字"><a href="#异常关键字" class="headerlink" title="异常关键字"></a>异常关键字</h3><ul><li><code>try</code> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><code>catch</code> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><code>finally</code> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><code>throw</code> – 用于抛出异常。</li><li><code>throws</code> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h3 id="异常的申明-throws"><a href="#异常的申明-throws" class="headerlink" title="异常的申明(throws)"></a>异常的申明(throws)</h3><p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><h3 id="Throws抛出异常的规则"><a href="#Throws抛出异常的规则" class="headerlink" title="Throws抛出异常的规则"></a>Throws抛出异常的规则</h3><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="异常的自定义"><a href="#异常的自定义" class="headerlink" title="异常的自定义"></a>异常的自定义</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public class MyException extends Exception {    public MyException(){ }    public MyException(String msg){        super(msg);    }    // ...}</code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h4><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private static void readFile(String filePath) {    try {        // code    } catch (FileNotFoundException | UnknownHostException e) {        // handle FileNotFoundException or UnknownHostException    } catch (IOException e){        // handle IOException    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">try {                            //执行程序代码，可能会出现异常                 } catch(Exception e) {       //捕获异常并处理   } finally {    //必执行的代码}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h4><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h4 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h4><p>JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 <code>AutoCloseable</code> 接口的类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private  static void tryWithResourceTest(){    try (Scanner scanner = new Scanner(new FileInputStream("c:/abc"),"UTF-8")){        // code    } catch (IOException e){        // handle exception    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h2 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h2><p>Java异常类层次结构图：</p><p><img src="/attachment/33441534b3f04acef0aca20b2b192abb.png"></p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>此类错误一般表示代码运行时 JVM 出现问题。通常有 <code>Virtual MachineError</code>（虚拟机运行错误）、<code>NoClassDefFoundError</code>（类定义错误）等。比如 <code>OutOfMemoryError</code>：内存不足错误；<code>StackOverflowError</code>：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><h3 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception (异常)"></a>Exception (异常)</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h4 id="非运行时异常-（编译异常）"><a href="#非运行时异常-（编译异常）" class="headerlink" title="非运行时异常 （编译异常）"></a>非运行时异常 （编译异常）</h4><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）"><a href="#可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）" class="headerlink" title="可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）"></a>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</h3><h4 id="可查异常（编译器要求必须处置的异常）："><a href="#可查异常（编译器要求必须处置的异常）：" class="headerlink" title="可查异常（编译器要求必须处置的异常）："></a>可查异常（编译器要求必须处置的异常）：</h4><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h4 id="不可查异常-编译器不要求强制处置的异常"><a href="#不可查异常-编译器不要求强制处置的异常" class="headerlink" title="不可查异常(编译器不要求强制处置的异常)"></a>不可查异常(编译器不要求强制处置的异常)</h4><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="尽量使用标准的异常"><a href="#尽量使用标准的异常" class="headerlink" title="尽量使用标准的异常"></a>尽量使用标准的异常</h3><p>重用现有的异常有几个好处：</p><ul><li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li><li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li><li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li></ul><p>Java标准异常中有几个是经常被使用的异常。如下表格：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table></div><h3 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h3><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p><p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><h3 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h3><h3 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h3><h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><h3 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h3><h3 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="包装异常时不要抛弃原始的异常"></a>包装异常时不要抛弃原始的异常</h3><h3 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h3><h3 id="不要在finally块中使用return"><a href="#不要在finally块中使用return" class="headerlink" title="不要在finally块中使用return"></a>不要在finally块中使用return</h3><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li><li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li><li>finally语句块中的代码一定会被执行，常用于回收资源 。</li><li>throws：声明一个异常，告知方法调用者。</li><li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li></ul><p>Java编程思想一书中，对异常的总结。</p><ul><li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li><li>让类库和程序更安全。</li></ul><h2 id="常用的异常"><a href="#常用的异常" class="headerlink" title="常用的异常"></a>常用的异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ul><li>RuntimeException<ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li>IOException<ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li>其他<ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 异常</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-yi-chang/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-yi-chang/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-异常"><a href="#【Java-基础】-异常" class="headerlink" title="【Java 基础】 异常"></a>【Java 基础】 异常</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 异常date: 2022-12-14 14:11tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/异常categories:  - Javakeywords:  - Java/基础  - 异常description: 异常</code></pre><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:</p><ul><li>受检异常 : 需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li>非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h2><h3 id="异常关键字"><a href="#异常关键字" class="headerlink" title="异常关键字"></a>异常关键字</h3><ul><li><code>try</code> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><code>catch</code> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><code>finally</code> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><code>throw</code> – 用于抛出异常。</li><li><code>throws</code> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h3 id="异常的申明-throws"><a href="#异常的申明-throws" class="headerlink" title="异常的申明(throws)"></a>异常的申明(throws)</h3><p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><h3 id="Throws抛出异常的规则"><a href="#Throws抛出异常的规则" class="headerlink" title="Throws抛出异常的规则"></a>Throws抛出异常的规则</h3><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="异常的自定义"><a href="#异常的自定义" class="headerlink" title="异常的自定义"></a>异常的自定义</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public class MyException extends Exception {    public MyException(){ }    public MyException(String msg){        super(msg);    }    // ...}</code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h4><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private static void readFile(String filePath) {    try {        // code    } catch (FileNotFoundException | UnknownHostException e) {        // handle FileNotFoundException or UnknownHostException    } catch (IOException e){        // handle IOException    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">try {                            //执行程序代码，可能会出现异常                 } catch(Exception e) {       //捕获异常并处理   } finally {    //必执行的代码}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h4><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h4 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h4><p>JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 <code>AutoCloseable</code> 接口的类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private  static void tryWithResourceTest(){    try (Scanner scanner = new Scanner(new FileInputStream("c:/abc"),"UTF-8")){        // code    } catch (IOException e){        // handle exception    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h2 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h2><p>Java异常类层次结构图：</p><p><img src="/attachment%5C33441534b3f04acef0aca20b2b192abb.png"></p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>此类错误一般表示代码运行时 JVM 出现问题。通常有 <code>Virtual MachineError</code>（虚拟机运行错误）、<code>NoClassDefFoundError</code>（类定义错误）等。比如 <code>OutOfMemoryError</code>：内存不足错误；<code>StackOverflowError</code>：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><h3 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception (异常)"></a>Exception (异常)</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h4 id="非运行时异常-（编译异常）"><a href="#非运行时异常-（编译异常）" class="headerlink" title="非运行时异常 （编译异常）"></a>非运行时异常 （编译异常）</h4><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）"><a href="#可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）" class="headerlink" title="可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）"></a>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</h3><h4 id="可查异常（编译器要求必须处置的异常）："><a href="#可查异常（编译器要求必须处置的异常）：" class="headerlink" title="可查异常（编译器要求必须处置的异常）："></a>可查异常（编译器要求必须处置的异常）：</h4><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h4 id="不可查异常-编译器不要求强制处置的异常"><a href="#不可查异常-编译器不要求强制处置的异常" class="headerlink" title="不可查异常(编译器不要求强制处置的异常)"></a>不可查异常(编译器不要求强制处置的异常)</h4><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="尽量使用标准的异常"><a href="#尽量使用标准的异常" class="headerlink" title="尽量使用标准的异常"></a>尽量使用标准的异常</h3><p>重用现有的异常有几个好处：</p><ul><li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li><li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li><li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li></ul><p>Java标准异常中有几个是经常被使用的异常。如下表格：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table></div><h3 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h3><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p><p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><h3 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h3><h3 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h3><h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><h3 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h3><h3 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="包装异常时不要抛弃原始的异常"></a>包装异常时不要抛弃原始的异常</h3><h3 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h3><h3 id="不要在finally块中使用return"><a href="#不要在finally块中使用return" class="headerlink" title="不要在finally块中使用return"></a>不要在finally块中使用return</h3><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li><li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li><li>finally语句块中的代码一定会被执行，常用于回收资源 。</li><li>throws：声明一个异常，告知方法调用者。</li><li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li></ul><p>Java编程思想一书中，对异常的总结。</p><ul><li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li><li>让类库和程序更安全。</li></ul><h2 id="常用的异常"><a href="#常用的异常" class="headerlink" title="常用的异常"></a>常用的异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ul><li>RuntimeException<ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li>IOException<ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li>其他<ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 反射</title>
      <link href="/java/java-ji-chu/java-ji-chu-fan-she/"/>
      <url>/java/java-ji-chu/java-ji-chu-fan-she/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-反射"><a href="#【Java-基础】-反射" class="headerlink" title="【Java 基础】 反射"></a>【Java 基础】 反射</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 反射date: 2022-12-14 14:09tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/反射categories:  - Javakeywords:  - Java/基础  - 反射description: 反射</code></pre><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:</p><ul><li>Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor : 可以用 Constructor 创建新的对象。</li></ul><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p><ul><li>Class类也是类的一种，与class关键字是不一样的。</li><li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li><li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 反射</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-fan-she/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-fan-she/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-反射"><a href="#【Java-基础】-反射" class="headerlink" title="【Java 基础】 反射"></a>【Java 基础】 反射</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 反射date: 2022-12-14 14:09tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/反射categories:  - Javakeywords:  - Java/基础  - 反射description: 反射</code></pre><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:</p><ul><li>Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor : 可以用 Constructor 创建新的对象。</li></ul><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p><ul><li>Class类也是类的一种，与class关键字是不一样的。</li><li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li><li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 面向对象</title>
      <link href="/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/"/>
      <url>/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-面向对象"><a href="#【Java-基础】-面向对象" class="headerlink" title="【Java 基础】 面向对象"></a>【Java 基础】 面向对象</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 面向对象date: 2022-12-14 14:07tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/面向对象categories:  - Javakeywords:  - Java/基础  - 面向对象description: 面向对象</code></pre><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型<mark style="background: #FF5582A6;">将数据和基于数据的操作封装在一起</mark>，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p><strong>优点:</strong></p><ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <mark style="background: #FF5582A6;">IS-A 关系</mark>，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循<strong>里氏替换原则</strong>，<mark style="background: #FF5582A6;">子类对象必须能够替换掉所有父类对象</mark>。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态:</p><ul><li><strong>编译时多态</strong>主要指<mark style="background: #ABF7F7A6;">方法的重载</mark></li><li><strong>运行时多态</strong>指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h3><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE3NXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNzUgMjA3IiB3aWR0aD0iMTc1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE0IiB4PSIyMy41IiB5PSIyMi45OTUxIj5HZW5lcmFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgVmVoaWNhbC0tPjxnIGlkPSJlbGVtX1ZlaGljYWwiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iVmVoaWNhbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODEiIHg9IjQzIiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjU4IiBjeT0iNjAuMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik02MC45Njg4LDY1LjkzNzUgUTYwLjM5MDYsNjYuMjM0NCA1OS43NSw2Ni4zNzUgUTU5LjEwOTQsNjYuNTMxMyA1OC40MDYzLDY2LjUzMTMgUTU1LjkwNjMsNjYuNTMxMyA1NC41NzgxLDY0Ljg5MDYgUTUzLjI2NTYsNjMuMjM0NCA1My4yNjU2LDYwLjEwOTQgUTUzLjI2NTYsNTYuOTg0NCA1NC41NzgxLDU1LjMyODEgUTU1LjkwNjMsNTMuNjcxOSA1OC40MDYzLDUzLjY3MTkgUTU5LjEwOTQsNTMuNjcxOSA1OS43NSw1My44MjgxIFE2MC40MDYzLDUzLjk4NDQgNjAuOTY4OCw1NC4yODEzIEw2MC45Njg4LDU3IFE2MC4zNDM4LDU2LjQyMTkgNTkuNzUsNTYuMTU2MyBRNTkuMTU2Myw1NS44NzUgNTguNTMxMyw1NS44NzUgUTU3LjE4NzUsNTUuODc1IDU2LjUsNTYuOTUzMSBRNTUuODEyNSw1OC4wMTU2IDU1LjgxMjUsNjAuMTA5NCBRNTUuODEyNSw2Mi4yMDMxIDU2LjUsNjMuMjgxMyBRNTcuMTg3NSw2NC4zNDM4IDU4LjUzMTMsNjQuMzQzOCBRNTkuMTU2Myw2NC4zNDM4IDU5Ljc1LDY0LjA3ODEgUTYwLjM0MzgsNjMuNzk2OSA2MC45Njg4LDYzLjIxODggTDYwLjk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSI3MiIgeT0iNjUuMTQzNiI+VmVoaWNhbDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI0NCIgeDI9IjEyMyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iNDQiIHgyPSIxMjMiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgQ2FyLS0+PGcgaWQ9ImVsZW1fQ2FyIj48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IkNhciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNTUiIHg9IjciIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuOTY4OCwxNzMuOTM3NSBRMjQuMzkwNiwxNzQuMjM0NCAyMy43NSwxNzQuMzc1IFEyMy4xMDk0LDE3NC41MzEzIDIyLjQwNjMsMTc0LjUzMTMgUTE5LjkwNjMsMTc0LjUzMTMgMTguNTc4MSwxNzIuODkwNiBRMTcuMjY1NiwxNzEuMjM0NCAxNy4yNjU2LDE2OC4xMDk0IFExNy4yNjU2LDE2NC45ODQ0IDE4LjU3ODEsMTYzLjMyODEgUTE5LjkwNjMsMTYxLjY3MTkgMjIuNDA2MywxNjEuNjcxOSBRMjMuMTA5NCwxNjEuNjcxOSAyMy43NSwxNjEuODI4MSBRMjQuNDA2MywxNjEuOTg0NCAyNC45Njg4LDE2Mi4yODEzIEwyNC45Njg4LDE2NSBRMjQuMzQzOCwxNjQuNDIxOSAyMy43NSwxNjQuMTU2MyBRMjMuMTU2MywxNjMuODc1IDIyLjUzMTMsMTYzLjg3NSBRMjEuMTg3NSwxNjMuODc1IDIwLjUsMTY0Ljk1MzEgUTE5LjgxMjUsMTY2LjAxNTYgMTkuODEyNSwxNjguMTA5NCBRMTkuODEyNSwxNzAuMjAzMSAyMC41LDE3MS4yODEzIFEyMS4xODc1LDE3Mi4zNDM4IDIyLjUzMTMsMTcyLjM0MzggUTIzLjE1NjMsMTcyLjM0MzggMjMuNzUsMTcyLjA3ODEgUTI0LjM0MzgsMTcxLjc5NjkgMjQuOTY4OCwxNzEuMjE4OCBMMjQuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIzIiB4PSIzNiIgeT0iMTczLjE0MzYiPkNhcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNjEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjYxIiB5MT0iMTkyLjI5NjkiIHkyPSIxOTIuMjk2OSIvPjwvZz48IS0tY2xhc3MgVHJ1Y2stLT48ZyBpZD0iZWxlbV9UcnVjayI+PHJlY3QgY29kZUxpbmU9IjYiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJUcnVjayIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzEiIHg9Ijk3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMTIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTQuOTY4OCwxNzMuOTM3NSBRMTE0LjM5MDYsMTc0LjIzNDQgMTEzLjc1LDE3NC4zNzUgUTExMy4xMDk0LDE3NC41MzEzIDExMi40MDYzLDE3NC41MzEzIFExMDkuOTA2MywxNzQuNTMxMyAxMDguNTc4MSwxNzIuODkwNiBRMTA3LjI2NTYsMTcxLjIzNDQgMTA3LjI2NTYsMTY4LjEwOTQgUTEwNy4yNjU2LDE2NC45ODQ0IDEwOC41NzgxLDE2My4zMjgxIFExMDkuOTA2MywxNjEuNjcxOSAxMTIuNDA2MywxNjEuNjcxOSBRMTEzLjEwOTQsMTYxLjY3MTkgMTEzLjc1LDE2MS44MjgxIFExMTQuNDA2MywxNjEuOTg0NCAxMTQuOTY4OCwxNjIuMjgxMyBMMTE0Ljk2ODgsMTY1IFExMTQuMzQzOCwxNjQuNDIxOSAxMTMuNzUsMTY0LjE1NjMgUTExMy4xNTYzLDE2My44NzUgMTEyLjUzMTMsMTYzLjg3NSBRMTExLjE4NzUsMTYzLjg3NSAxMTAuNSwxNjQuOTUzMSBRMTA5LjgxMjUsMTY2LjAxNTYgMTA5LjgxMjUsMTY4LjEwOTQgUTEwOS44MTI1LDE3MC4yMDMxIDExMC41LDE3MS4yODEzIFExMTEuMTg3NSwxNzIuMzQzOCAxMTIuNTMxMywxNzIuMzQzOCBRMTEzLjE1NjMsMTcyLjM0MzggMTEzLjc1LDE3Mi4wNzgxIFExMTQuMzQzOCwxNzEuNzk2OSAxMTQuOTY4OCwxNzEuMjE4OCBMMTE0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzOSIgeD0iMTI2IiB5PSIxNzMuMTQzNiI+VHJ1Y2s8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgVmVoaWNhbCB0byBDYXItLT48ZyBpZD0ibGlua19WZWhpY2FsX0NhciI+PHBhdGggY29kZUxpbmU9IjgiIGQ9Ik02My45NCwxMTEuNTk2OSBDNTcuNTYsMTI1LjQwNjkgNTAuNzEsMTQwLjIyNjkgNDUuMjMsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iVmVoaWNhbC1iYWNrdG8tQ2FyIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9IjU4LDEwOC43NzY5LDcyLjc1LDkzLjU1NjksNzAuNzEsMTE0LjY0NjksNTgsMTA4Ljc3NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tcmV2ZXJzZSBsaW5rIFZlaGljYWwgdG8gVHJ1Y2stLT48ZyBpZD0ibGlua19WZWhpY2FsX1RydWNrIj48cGF0aCBjb2RlTGluZT0iOSIgZD0iTTEwMy4wNiwxMTEuNTk2OSBDMTA5LjQ0LDEyNS40MDY5IDExNi4yOSwxNDAuMjI2OSAxMjEuNzcsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iVmVoaWNhbC1iYWNrdG8tVHJ1Y2siIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iOTYuMjksMTE0LjY0NjksOTQuMjUsOTMuNTU2OSwxMDksMTA4Ljc3NjksOTYuMjksMTE0LjY0NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tU1JDPVtBeWFpb0tiTFM0X0RJb3JBcENjaUlZcDlwQ19adWFoRUlJbWtMV1hCcFNYQ0ppbzF5Zm1KWXcyaWFBQkl2Nm1rQmdZcVdhc0RoWXZPNWFLMGVXVzBdLS0+PC9nPjwvc3ZnPg=="><h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE1OXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNTkgMjA3IiB3aWR0aD0iMTU5cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODUiIHg9IjMwIiB5PSIyMi45OTUxIj5SZWFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgTW92ZUJlaGF2aW9yLS0+PGcgaWQ9ImVsZW1fTW92ZUJlaGF2aW9yIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTI5IiB4PSIxMi41IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI3LjUiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIzLjQyMTksNTYuMDYyNSBMMjMuNDIxOSw1My45MDYzIEwzMC44MTI1LDUzLjkwNjMgTDMwLjgxMjUsNTYuMDYyNSBMMjguMzQzOCw1Ni4wNjI1IEwyOC4zNDM4LDY0LjE0MDYgTDMwLjgxMjUsNjQuMTQwNiBMMzAuODEyNSw2Ni4yOTY5IEwyMy40MjE5LDY2LjI5NjkgTDIzLjQyMTksNjQuMTQwNiBMMjUuODkwNiw2NC4xNDA2IEwyNS44OTA2LDU2LjA2MjUgTDIzLjQyMTksNTYuMDYyNSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBmb250LXN0eWxlPSJpdGFsaWMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTciIHg9IjQxLjUiIHk9IjY1LjE0MzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMy41IiB4Mj0iMTQwLjUiIHkxPSI3Ni4yOTY5IiB5Mj0iNzYuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEzLjUiIHgyPSIxNDAuNSIgeTE9Ijg0LjI5NjkiIHkyPSI4NC4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBGbHktLT48ZyBpZD0iZWxlbV9GbHkiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRmx5IiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI1MCIgeD0iNyIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNC45Njg4LDE3My45Mzc1IFEyNC4zOTA2LDE3NC4yMzQ0IDIzLjc1LDE3NC4zNzUgUTIzLjEwOTQsMTc0LjUzMTMgMjIuNDA2MywxNzQuNTMxMyBRMTkuOTA2MywxNzQuNTMxMyAxOC41NzgxLDE3Mi44OTA2IFExNy4yNjU2LDE3MS4yMzQ0IDE3LjI2NTYsMTY4LjEwOTQgUTE3LjI2NTYsMTY0Ljk4NDQgMTguNTc4MSwxNjMuMzI4MSBRMTkuOTA2MywxNjEuNjcxOSAyMi40MDYzLDE2MS42NzE5IFEyMy4xMDk0LDE2MS42NzE5IDIzLjc1LDE2MS44MjgxIFEyNC40MDYzLDE2MS45ODQ0IDI0Ljk2ODgsMTYyLjI4MTMgTDI0Ljk2ODgsMTY1IFEyNC4zNDM4LDE2NC40MjE5IDIzLjc1LDE2NC4xNTYzIFEyMy4xNTYzLDE2My44NzUgMjIuNTMxMywxNjMuODc1IFEyMS4xODc1LDE2My44NzUgMjAuNSwxNjQuOTUzMSBRMTkuODEyNSwxNjYuMDE1NiAxOS44MTI1LDE2OC4xMDk0IFExOS44MTI1LDE3MC4yMDMxIDIwLjUsMTcxLjI4MTMgUTIxLjE4NzUsMTcyLjM0MzggMjIuNTMxMywxNzIuMzQzOCBRMjMuMTU2MywxNzIuMzQzOCAyMy43NSwxNzIuMDc4MSBRMjQuMzQzOCwxNzEuNzk2OSAyNC45Njg4LDE3MS4yMTg4IEwyNC45Njg4LDE3My45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTgiIHg9IjM2IiB5PSIxNzMuMTQzNiI+Rmx5PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSI1NiIgeTE9IjE4NC4yOTY5IiB5Mj0iMTg0LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNTYiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBSdW4tLT48ZyBpZD0iZWxlbV9SdW4iPjxyZWN0IGNvZGVMaW5lPSI2IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iUnVuIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI2MCIgeD0iOTIiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEwNyIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEwOS45Njg4LDE3My45Mzc1IFExMDkuMzkwNiwxNzQuMjM0NCAxMDguNzUsMTc0LjM3NSBRMTA4LjEwOTQsMTc0LjUzMTMgMTA3LjQwNjMsMTc0LjUzMTMgUTEwNC45MDYzLDE3NC41MzEzIDEwMy41NzgxLDE3Mi44OTA2IFExMDIuMjY1NiwxNzEuMjM0NCAxMDIuMjY1NiwxNjguMTA5NCBRMTAyLjI2NTYsMTY0Ljk4NDQgMTAzLjU3ODEsMTYzLjMyODEgUTEwNC45MDYzLDE2MS42NzE5IDEwNy40MDYzLDE2MS42NzE5IFExMDguMTA5NCwxNjEuNjcxOSAxMDguNzUsMTYxLjgyODEgUTEwOS40MDYzLDE2MS45ODQ0IDEwOS45Njg4LDE2Mi4yODEzIEwxMDkuOTY4OCwxNjUgUTEwOS4zNDM4LDE2NC40MjE5IDEwOC43NSwxNjQuMTU2MyBRMTA4LjE1NjMsMTYzLjg3NSAxMDcuNTMxMywxNjMuODc1IFExMDYuMTg3NSwxNjMuODc1IDEwNS41LDE2NC45NTMxIFExMDQuODEyNSwxNjYuMDE1NiAxMDQuODEyNSwxNjguMTA5NCBRMTA0LjgxMjUsMTcwLjIwMzEgMTA1LjUsMTcxLjI4MTMgUTEwNi4xODc1LDE3Mi4zNDM4IDEwNy41MzEzLDE3Mi4zNDM4IFExMDguMTU2MywxNzIuMzQzOCAxMDguNzUsMTcyLjA3ODEgUTEwOS4zNDM4LDE3MS43OTY5IDEwOS45Njg4LDE3MS4yMTg4IEwxMDkuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSIxMjEiIHk9IjE3My4xNDM2Ij5SdW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgTW92ZUJlaGF2aW9yIHRvIEZseS0tPjxnIGlkPSJsaW5rX01vdmVCZWhhdmlvcl9GbHkiPjxwYXRoIGNvZGVMaW5lPSI4IiBkPSJNNTkuMDQsMTExLjU5NjkgQzUzLjE4LDEyNS40MDY5IDQ2Ljg5LDE0MC4yMjY5IDQxLjg1LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9Ik1vdmVCZWhhdmlvci1iYWNrdG8tRmx5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSI1Mi44NywxMDkuMjM2OSw2Ny4xMiw5My41NTY5LDY1Ljc1LDExNC43MDY5LDUyLjg3LDEwOS4yMzY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBNb3ZlQmVoYXZpb3IgdG8gUnVuLS0+PGcgaWQ9ImxpbmtfTW92ZUJlaGF2aW9yX1J1biI+PHBhdGggY29kZUxpbmU9IjkiIGQ9Ik05NC45NiwxMTEuNTk2OSBDMTAwLjgyLDEyNS40MDY5IDEwNy4xMSwxNDAuMjI2OSAxMTIuMTUsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iTW92ZUJlaGF2aW9yLWJhY2t0by1SdW4iIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijg4LjI1LDExNC43MDY5LDg2Ljg4LDkzLjU1NjksMTAxLjEzLDEwOS4yMzY5LDg4LjI1LDExNC43MDY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkwyNGZEcENjaUlZcDlwQ19adWloQ0FxYWpJYWpDSmJObXBJekJUS2hESTJwQnAyX1lJaXY5QjJ2TVNDa2ZYQkEySWU1Z2FMS2VzREpld080TE84ZzI1MEMwXS0tPjwvZz48L3N2Zz4="><h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM0MXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNDEgMjA3IiB3aWR0aD0iMzQxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTciIHg9IjExNSIgeT0iMjIuOTk1MSI+QWdncmVnYXRpb248L3RleHQ+PCEtLWNsYXNzIENvbXB1dGVyLS0+PGcgaWQ9ImVsZW1fQ29tcHV0ZXIiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcHV0ZXIiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEwMSIgeD0iMTI4IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjE0MyIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTQ1Ljk2ODgsNjUuOTM3NSBRMTQ1LjM5MDYsNjYuMjM0NCAxNDQuNzUsNjYuMzc1IFExNDQuMTA5NCw2Ni41MzEzIDE0My40MDYzLDY2LjUzMTMgUTE0MC45MDYzLDY2LjUzMTMgMTM5LjU3ODEsNjQuODkwNiBRMTM4LjI2NTYsNjMuMjM0NCAxMzguMjY1Niw2MC4xMDk0IFExMzguMjY1Niw1Ni45ODQ0IDEzOS41NzgxLDU1LjMyODEgUTE0MC45MDYzLDUzLjY3MTkgMTQzLjQwNjMsNTMuNjcxOSBRMTQ0LjEwOTQsNTMuNjcxOSAxNDQuNzUsNTMuODI4MSBRMTQ1LjQwNjMsNTMuOTg0NCAxNDUuOTY4OCw1NC4yODEzIEwxNDUuOTY4OCw1NyBRMTQ1LjM0MzgsNTYuNDIxOSAxNDQuNzUsNTYuMTU2MyBRMTQ0LjE1NjMsNTUuODc1IDE0My41MzEzLDU1Ljg3NSBRMTQyLjE4NzUsNTUuODc1IDE0MS41LDU2Ljk1MzEgUTE0MC44MTI1LDU4LjAxNTYgMTQwLjgxMjUsNjAuMTA5NCBRMTQwLjgxMjUsNjIuMjAzMSAxNDEuNSw2My4yODEzIFExNDIuMTg3NSw2NC4zNDM4IDE0My41MzEzLDY0LjM0MzggUTE0NC4xNTYzLDY0LjM0MzggMTQ0Ljc1LDY0LjA3ODEgUTE0NS4zNDM4LDYzLjc5NjkgMTQ1Ljk2ODgsNjMuMjE4OCBMMTQ1Ljk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSIxNTciIHk9IjY1LjE0MzYiPkNvbXB1dGVyPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyOSIgeDI9IjIyOCIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTI5IiB4Mj0iMjI4IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWNsYXNzIEtleWJvYXJkLS0+PGcgaWQ9ImVsZW1fS2V5Ym9hcmQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iS2V5Ym9hcmQiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijk3IiB4PSI3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsMTczLjkzNzUgUTI0LjM5MDYsMTc0LjIzNDQgMjMuNzUsMTc0LjM3NSBRMjMuMTA5NCwxNzQuNTMxMyAyMi40MDYzLDE3NC41MzEzIFExOS45MDYzLDE3NC41MzEzIDE4LjU3ODEsMTcyLjg5MDYgUTE3LjI2NTYsMTcxLjIzNDQgMTcuMjY1NiwxNjguMTA5NCBRMTcuMjY1NiwxNjQuOTg0NCAxOC41NzgxLDE2My4zMjgxIFExOS45MDYzLDE2MS42NzE5IDIyLjQwNjMsMTYxLjY3MTkgUTIzLjEwOTQsMTYxLjY3MTkgMjMuNzUsMTYxLjgyODEgUTI0LjQwNjMsMTYxLjk4NDQgMjQuOTY4OCwxNjIuMjgxMyBMMjQuOTY4OCwxNjUgUTI0LjM0MzgsMTY0LjQyMTkgMjMuNzUsMTY0LjE1NjMgUTIzLjE1NjMsMTYzLjg3NSAyMi41MzEzLDE2My44NzUgUTIxLjE4NzUsMTYzLjg3NSAyMC41LDE2NC45NTMxIFExOS44MTI1LDE2Ni4wMTU2IDE5LjgxMjUsMTY4LjEwOTQgUTE5LjgxMjUsMTcwLjIwMzEgMjAuNSwxNzEuMjgxMyBRMjEuMTg3NSwxNzIuMzQzOCAyMi41MzEzLDE3Mi4zNDM4IFEyMy4xNTYzLDE3Mi4zNDM4IDIzLjc1LDE3Mi4wNzgxIFEyNC4zNDM4LDE3MS43OTY5IDI0Ljk2ODgsMTcxLjIxODggTDI0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NSIgeD0iMzYiIHk9IjE3My4xNDM2Ij5LZXlib2FyZDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTAzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMDMiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBNb3VzZS0tPjxnIGlkPSJlbGVtX01vdXNlIj48cmVjdCBjb2RlTGluZT0iNiIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdXNlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI3OSIgeD0iMTM5IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxNTQiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xNTYuOTY4OCwxNzMuOTM3NSBRMTU2LjM5MDYsMTc0LjIzNDQgMTU1Ljc1LDE3NC4zNzUgUTE1NS4xMDk0LDE3NC41MzEzIDE1NC40MDYzLDE3NC41MzEzIFExNTEuOTA2MywxNzQuNTMxMyAxNTAuNTc4MSwxNzIuODkwNiBRMTQ5LjI2NTYsMTcxLjIzNDQgMTQ5LjI2NTYsMTY4LjEwOTQgUTE0OS4yNjU2LDE2NC45ODQ0IDE1MC41NzgxLDE2My4zMjgxIFExNTEuOTA2MywxNjEuNjcxOSAxNTQuNDA2MywxNjEuNjcxOSBRMTU1LjEwOTQsMTYxLjY3MTkgMTU1Ljc1LDE2MS44MjgxIFExNTYuNDA2MywxNjEuOTg0NCAxNTYuOTY4OCwxNjIuMjgxMyBMMTU2Ljk2ODgsMTY1IFExNTYuMzQzOCwxNjQuNDIxOSAxNTUuNzUsMTY0LjE1NjMgUTE1NS4xNTYzLDE2My44NzUgMTU0LjUzMTMsMTYzLjg3NSBRMTUzLjE4NzUsMTYzLjg3NSAxNTIuNSwxNjQuOTUzMSBRMTUxLjgxMjUsMTY2LjAxNTYgMTUxLjgxMjUsMTY4LjEwOTQgUTE1MS44MTI1LDE3MC4yMDMxIDE1Mi41LDE3MS4yODEzIFExNTMuMTg3NSwxNzIuMzQzOCAxNTQuNTMxMywxNzIuMzQzOCBRMTU1LjE1NjMsMTcyLjM0MzggMTU1Ljc1LDE3Mi4wNzgxIFExNTYuMzQzOCwxNzEuNzk2OSAxNTYuOTY4OCwxNzEuMjE4OCBMMTU2Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0NyIgeD0iMTY4IiB5PSIxNzMuMTQzNiI+TW91c2U8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTQwIiB4Mj0iMjE3IiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE0MCIgeDI9IjIxNyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLWNsYXNzIFNjcmVlbi0tPjxnIGlkPSJlbGVtX1NjcmVlbiI+PHJlY3QgY29kZUxpbmU9IjciIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJTY3JlZW4iIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjgxIiB4PSIyNTMiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI2OCIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI3MC45Njg4LDE3My45Mzc1IFEyNzAuMzkwNiwxNzQuMjM0NCAyNjkuNzUsMTc0LjM3NSBRMjY5LjEwOTQsMTc0LjUzMTMgMjY4LjQwNjMsMTc0LjUzMTMgUTI2NS45MDYzLDE3NC41MzEzIDI2NC41NzgxLDE3Mi44OTA2IFEyNjMuMjY1NiwxNzEuMjM0NCAyNjMuMjY1NiwxNjguMTA5NCBRMjYzLjI2NTYsMTY0Ljk4NDQgMjY0LjU3ODEsMTYzLjMyODEgUTI2NS45MDYzLDE2MS42NzE5IDI2OC40MDYzLDE2MS42NzE5IFEyNjkuMTA5NCwxNjEuNjcxOSAyNjkuNzUsMTYxLjgyODEgUTI3MC40MDYzLDE2MS45ODQ0IDI3MC45Njg4LDE2Mi4yODEzIEwyNzAuOTY4OCwxNjUgUTI3MC4zNDM4LDE2NC40MjE5IDI2OS43NSwxNjQuMTU2MyBRMjY5LjE1NjMsMTYzLjg3NSAyNjguNTMxMywxNjMuODc1IFEyNjcuMTg3NSwxNjMuODc1IDI2Ni41LDE2NC45NTMxIFEyNjUuODEyNSwxNjYuMDE1NiAyNjUuODEyNSwxNjguMTA5NCBRMjY1LjgxMjUsMTcwLjIwMzEgMjY2LjUsMTcxLjI4MTMgUTI2Ny4xODc1LDE3Mi4zNDM4IDI2OC41MzEzLDE3Mi4zNDM4IFEyNjkuMTU2MywxNzIuMzQzOCAyNjkuNzUsMTcyLjA3ODEgUTI3MC4zNDM4LDE3MS43OTY5IDI3MC45Njg4LDE3MS4yMTg4IEwyNzAuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSIyODIiIHk9IjE3My4xNDM2Ij5TY3JlZW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMjU0IiB4Mj0iMzMzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjI1NCIgeDI9IjMzMyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBLZXlib2FyZC0tPjxnIGlkPSJsaW5rX0NvbXB1dGVyX0tleWJvYXJkIj48cGF0aCBjb2RlTGluZT0iOSIgZD0iTTE0MS4xMywxMDEuNDk2OSBDMTIyLjIsMTE3LjgxNjkgOTkuNjQsMTM3LjI1NjkgODIuNDMsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLUtleWJvYXJkIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9IjE1MC41MSw5Mi41NTY5LDE0My4zNTMyLDkzLjQzOTksMTQxLjQxNTcsMTAwLjM4NTksMTQ4LjU3MjUsOTkuNTAyOCwxNTAuNTEsOTIuNTU2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcHV0ZXIgdG8gTW91c2UtLT48ZyBpZD0ibGlua19Db21wdXRlcl9Nb3VzZSI+PHBhdGggY29kZUxpbmU9IjEwIiBkPSJNMTc4LjUsMTA2LjM2NjkgQzE3OC41LDEyMS41NjY5IDE3OC41LDEzOC43MDY5IDE3OC41LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9IkNvbXB1dGVyLWJhY2t0by1Nb3VzZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIxNzguNSw5My41NTY5LDE3NC41LDk5LjU1NjksMTc4LjUsMTA1LjU1NjksMTgyLjUsOTkuNTU2OSwxNzguNSw5My41NTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBTY3JlZW4tLT48ZyBpZD0ibGlua19Db21wdXRlcl9TY3JlZW4iPjxwYXRoIGNvZGVMaW5lPSIxMSIgZD0iTTIxMy42OCwxMDEuNzI2OSBDMjMxLjMzLDExNy45OTY5IDI1Mi4zMSwxMzcuMzI2OSAyNjguMzIsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLVNjcmVlbiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIyMDQuNzQsOTMuNTU2OSwyMDYuNDM4NywxMDAuNTY1LDIxMy41NjEyLDEwMS42OTI0LDIxMS44NjI0LDk0LjY4NDIsMjA0Ljc0LDkzLjU1NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tU1JDPVtBeWFpb0tiTFM0bkZCcWZESm9wOXBDX1p1YWhFSUlta0xkM0Vwb3FlQkthaldkQXpLb2tKeVhFQktnMVN0X3BJdWJHZUVwWXZBM0tMZzAtY0dvNVZMblVYN2FLS2VXcjUyQWVSMDAwMF0tLT48L2c+PC9zdmc+"><h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjI5N3B4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyOTcgMjA3IiB3aWR0aD0iMjk3cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTgiIHg9IjkyLjc1IiB5PSIyMi45OTUxIj5Db21wb3NpdGlvbjwvdGV4dD48IS0tY2xhc3MgQ29tcGFueS0tPjxnIGlkPSJlbGVtX0NvbXBhbnkiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcGFueSIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iOTciIHg9Ijk5LjUiIHk9IjQ0LjI5NjkiLz48ZWxsaXBzZSBjeD0iMTE0LjUiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTExNy40Njg4LDY1LjkzNzUgUTExNi44OTA2LDY2LjIzNDQgMTE2LjI1LDY2LjM3NSBRMTE1LjYwOTQsNjYuNTMxMyAxMTQuOTA2Myw2Ni41MzEzIFExMTIuNDA2Myw2Ni41MzEzIDExMS4wNzgxLDY0Ljg5MDYgUTEwOS43NjU2LDYzLjIzNDQgMTA5Ljc2NTYsNjAuMTA5NCBRMTA5Ljc2NTYsNTYuOTg0NCAxMTEuMDc4MSw1NS4zMjgxIFExMTIuNDA2Myw1My42NzE5IDExNC45MDYzLDUzLjY3MTkgUTExNS42MDk0LDUzLjY3MTkgMTE2LjI1LDUzLjgyODEgUTExNi45MDYzLDUzLjk4NDQgMTE3LjQ2ODgsNTQuMjgxMyBMMTE3LjQ2ODgsNTcgUTExNi44NDM4LDU2LjQyMTkgMTE2LjI1LDU2LjE1NjMgUTExNS42NTYzLDU1Ljg3NSAxMTUuMDMxMyw1NS44NzUgUTExMy42ODc1LDU1Ljg3NSAxMTMsNTYuOTUzMSBRMTEyLjMxMjUsNTguMDE1NiAxMTIuMzEyNSw2MC4xMDk0IFExMTIuMzEyNSw2Mi4yMDMxIDExMyw2My4yODEzIFExMTMuNjg3NSw2NC4zNDM4IDExNS4wMzEzLDY0LjM0MzggUTExNS42NTYzLDY0LjM0MzggMTE2LjI1LDY0LjA3ODEgUTExNi44NDM4LDYzLjc5NjkgMTE3LjQ2ODgsNjMuMjE4OCBMMTE3LjQ2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY1IiB4PSIxMjguNSIgeT0iNjUuMTQzNiI+Q29tcGFueTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMDAuNSIgeDI9IjE5NS41IiB5MT0iNzYuMjk2OSIgeTI9Ijc2LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMDAuNSIgeDI9IjE5NS41IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWNsYXNzIERlcGFydG1lbnRBLS0+PGcgaWQ9ImVsZW1fRGVwYXJ0bWVudEEiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRGVwYXJ0bWVudEEiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEyNCIgeD0iNyIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNC45Njg4LDE3My45Mzc1IFEyNC4zOTA2LDE3NC4yMzQ0IDIzLjc1LDE3NC4zNzUgUTIzLjEwOTQsMTc0LjUzMTMgMjIuNDA2MywxNzQuNTMxMyBRMTkuOTA2MywxNzQuNTMxMyAxOC41NzgxLDE3Mi44OTA2IFExNy4yNjU2LDE3MS4yMzQ0IDE3LjI2NTYsMTY4LjEwOTQgUTE3LjI2NTYsMTY0Ljk4NDQgMTguNTc4MSwxNjMuMzI4MSBRMTkuOTA2MywxNjEuNjcxOSAyMi40MDYzLDE2MS42NzE5IFEyMy4xMDk0LDE2MS42NzE5IDIzLjc1LDE2MS44MjgxIFEyNC40MDYzLDE2MS45ODQ0IDI0Ljk2ODgsMTYyLjI4MTMgTDI0Ljk2ODgsMTY1IFEyNC4zNDM4LDE2NC40MjE5IDIzLjc1LDE2NC4xNTYzIFEyMy4xNTYzLDE2My44NzUgMjIuNTMxMywxNjMuODc1IFEyMS4xODc1LDE2My44NzUgMjAuNSwxNjQuOTUzMSBRMTkuODEyNSwxNjYuMDE1NiAxOS44MTI1LDE2OC4xMDk0IFExOS44MTI1LDE3MC4yMDMxIDIwLjUsMTcxLjI4MTMgUTIxLjE4NzUsMTcyLjM0MzggMjIuNTMxMywxNzIuMzQzOCBRMjMuMTU2MywxNzIuMzQzOCAyMy43NSwxNzIuMDc4MSBRMjQuMzQzOCwxNzEuNzk2OSAyNC45Njg4LDE3MS4yMTg4IEwyNC45Njg4LDE3My45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTIiIHg9IjM2IiB5PSIxNzMuMTQzNiI+RGVwYXJ0bWVudEE8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjEzMCIgeTE9IjE4NC4yOTY5IiB5Mj0iMTg0LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTMwIiB5MT0iMTkyLjI5NjkiIHkyPSIxOTIuMjk2OSIvPjwvZz48IS0tY2xhc3MgRGVwYXJ0bWVudEItLT48ZyBpZD0iZWxlbV9EZXBhcnRtZW50QiI+PHJlY3QgY29kZUxpbmU9IjYiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJEZXBhcnRtZW50QiIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTI1IiB4PSIxNjUuNSIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMTgwLjUiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xODMuNDY4OCwxNzMuOTM3NSBRMTgyLjg5MDYsMTc0LjIzNDQgMTgyLjI1LDE3NC4zNzUgUTE4MS42MDk0LDE3NC41MzEzIDE4MC45MDYzLDE3NC41MzEzIFExNzguNDA2MywxNzQuNTMxMyAxNzcuMDc4MSwxNzIuODkwNiBRMTc1Ljc2NTYsMTcxLjIzNDQgMTc1Ljc2NTYsMTY4LjEwOTQgUTE3NS43NjU2LDE2NC45ODQ0IDE3Ny4wNzgxLDE2My4zMjgxIFExNzguNDA2MywxNjEuNjcxOSAxODAuOTA2MywxNjEuNjcxOSBRMTgxLjYwOTQsMTYxLjY3MTkgMTgyLjI1LDE2MS44MjgxIFExODIuOTA2MywxNjEuOTg0NCAxODMuNDY4OCwxNjIuMjgxMyBMMTgzLjQ2ODgsMTY1IFExODIuODQzOCwxNjQuNDIxOSAxODIuMjUsMTY0LjE1NjMgUTE4MS42NTYzLDE2My44NzUgMTgxLjAzMTMsMTYzLjg3NSBRMTc5LjY4NzUsMTYzLjg3NSAxNzksMTY0Ljk1MzEgUTE3OC4zMTI1LDE2Ni4wMTU2IDE3OC4zMTI1LDE2OC4xMDk0IFExNzguMzEyNSwxNzAuMjAzMSAxNzksMTcxLjI4MTMgUTE3OS42ODc1LDE3Mi4zNDM4IDE4MS4wMzEzLDE3Mi4zNDM4IFExODEuNjU2MywxNzIuMzQzOCAxODIuMjUsMTcyLjA3ODEgUTE4Mi44NDM4LDE3MS43OTY5IDE4My40Njg4LDE3MS4yMTg4IEwxODMuNDY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkzIiB4PSIxOTQuNSIgeT0iMTczLjE0MzYiPkRlcGFydG1lbnRCPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE2Ni41IiB4Mj0iMjg5LjUiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTY2LjUiIHgyPSIyODkuNSIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wYW55IHRvIERlcGFydG1lbnRBLS0+PGcgaWQ9ImxpbmtfQ29tcGFueV9EZXBhcnRtZW50QSI+PHBhdGggY29kZUxpbmU9IjgiIGQ9Ik0xMjIuNDYsMTAzLjU2NjkgQzExMC42MywxMTkuNDM2OSA5Ni44OSwxMzcuODc2OSA4Ni4zLDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9IkNvbXBhbnktYmFja3RvLURlcGFydG1lbnRBIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjEzMC42Niw5My41NTY5LDEyMy44NjgsOTUuOTc5MywxMjMuNDkxNywxMDMuMTgwNiwxMzAuMjgzOCwxMDAuNzU4MiwxMzAuNjYsOTMuNTU2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcGFueSB0byBEZXBhcnRtZW50Qi0tPjxnIGlkPSJsaW5rX0NvbXBhbnlfRGVwYXJ0bWVudEIiPjxwYXRoIGNvZGVMaW5lPSI5IiBkPSJNMTczLjg2LDEwMy41NjY5IEMxODUuODQsMTE5LjQzNjkgMTk5Ljc2LDEzNy44NzY5IDIxMC40OCwxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJDb21wYW55LWJhY2t0by1EZXBhcnRtZW50QiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxNjUuNTYsOTMuNTU2OSwxNjUuOTgyMiwxMDAuNzU1NiwxNzIuNzg5NSwxMDMuMTM0NywxNzIuMzY3NCw5NS45MzU5LDE2NS41Niw5My41NTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTQ3hGQlNXbHBZcDlwQ19adWFoRUlJbWsxV2lidmJMMlVJd2YxT2I1OVJjZlVJTUU2MjlFTjVuR25HZlFraGVlSWg2QkV0NDEwMDAwXS0tPjwvZz48L3N2Zz4="><h3 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSI5OXB4IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiBzdHlsZT0id2lkdGg6MjE1cHg7aGVpZ2h0Ojk5cHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjE1IDk5IiB3aWR0aD0iMjE1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTEiIHg9IjU1IiB5PSIyMi45OTUxIj5Bc3NvY2lhdGlvbjwvdGV4dD48IS0tY2xhc3MgU2Nob29sLS0+PGcgaWQ9ImVsZW1fU2Nob29sIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IlNjaG9vbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzkiIHg9IjciIHk9IjQ0LjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsNjUuOTM3NSBRMjQuMzkwNiw2Ni4yMzQ0IDIzLjc1LDY2LjM3NSBRMjMuMTA5NCw2Ni41MzEzIDIyLjQwNjMsNjYuNTMxMyBRMTkuOTA2Myw2Ni41MzEzIDE4LjU3ODEsNjQuODkwNiBRMTcuMjY1Niw2My4yMzQ0IDE3LjI2NTYsNjAuMTA5NCBRMTcuMjY1Niw1Ni45ODQ0IDE4LjU3ODEsNTUuMzI4MSBRMTkuOTA2Myw1My42NzE5IDIyLjQwNjMsNTMuNjcxOSBRMjMuMTA5NCw1My42NzE5IDIzLjc1LDUzLjgyODEgUTI0LjQwNjMsNTMuOTg0NCAyNC45Njg4LDU0LjI4MTMgTDI0Ljk2ODgsNTcgUTI0LjM0MzgsNTYuNDIxOSAyMy43NSw1Ni4xNTYzIFEyMy4xNTYzLDU1Ljg3NSAyMi41MzEzLDU1Ljg3NSBRMjEuMTg3NSw1NS44NzUgMjAuNSw1Ni45NTMxIFExOS44MTI1LDU4LjAxNTYgMTkuODEyNSw2MC4xMDk0IFExOS44MTI1LDYyLjIwMzEgMjAuNSw2My4yODEzIFEyMS4xODc1LDY0LjM0MzggMjIuNTMxMyw2NC4zNDM4IFEyMy4xNTYzLDY0LjM0MzggMjMuNzUsNjQuMDc4MSBRMjQuMzQzOCw2My43OTY5IDI0Ljk2ODgsNjMuMjE4OCBMMjQuOTY4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDciIHg9IjM2IiB5PSI2NS4xNDM2Ij5TY2hvb2w8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9Ijg1IiB5MT0iNzYuMjk2OSIgeTI9Ijc2LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iODUiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgU3R1ZGVudC0tPjxnIGlkPSJlbGVtX1N0dWRlbnQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iU3R1ZGVudCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODciIHg9IjEyMSIgeT0iNDQuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMzYiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEzOC45Njg4LDY1LjkzNzUgUTEzOC4zOTA2LDY2LjIzNDQgMTM3Ljc1LDY2LjM3NSBRMTM3LjEwOTQsNjYuNTMxMyAxMzYuNDA2Myw2Ni41MzEzIFExMzMuOTA2Myw2Ni41MzEzIDEzMi41NzgxLDY0Ljg5MDYgUTEzMS4yNjU2LDYzLjIzNDQgMTMxLjI2NTYsNjAuMTA5NCBRMTMxLjI2NTYsNTYuOTg0NCAxMzIuNTc4MSw1NS4zMjgxIFExMzMuOTA2Myw1My42NzE5IDEzNi40MDYzLDUzLjY3MTkgUTEzNy4xMDk0LDUzLjY3MTkgMTM3Ljc1LDUzLjgyODEgUTEzOC40MDYzLDUzLjk4NDQgMTM4Ljk2ODgsNTQuMjgxMyBMMTM4Ljk2ODgsNTcgUTEzOC4zNDM4LDU2LjQyMTkgMTM3Ljc1LDU2LjE1NjMgUTEzNy4xNTYzLDU1Ljg3NSAxMzYuNTMxMyw1NS44NzUgUTEzNS4xODc1LDU1Ljg3NSAxMzQuNSw1Ni45NTMxIFExMzMuODEyNSw1OC4wMTU2IDEzMy44MTI1LDYwLjEwOTQgUTEzMy44MTI1LDYyLjIwMzEgMTM0LjUsNjMuMjgxMyBRMTM1LjE4NzUsNjQuMzQzOCAxMzYuNTMxMyw2NC4zNDM4IFExMzcuMTU2Myw2NC4zNDM4IDEzNy43NSw2NC4wNzgxIFExMzguMzQzOCw2My43OTY5IDEzOC45Njg4LDYzLjIxODggTDEzOC45Njg4LDY1LjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NSIgeD0iMTUwIiB5PSI2NS4xNDM2Ij5TdHVkZW50PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyMiIgeDI9IjIwNyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTIyIiB4Mj0iMjA3IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWxpbmsgU2Nob29sIHRvIFN0dWRlbnQtLT48ZyBpZD0ibGlua19TY2hvb2xfU3R1ZGVudCI+PHBhdGggY29kZUxpbmU9IjciIGQ9Ik04Ni4xNCw2OC4yOTY5IEM5Ny42Nyw2OC4yOTY5IDEwOS4yLDY4LjI5NjkgMTIwLjczLDY4LjI5NjkgIiBmaWxsPSJub25lIiBpZD0iU2Nob29sLVN0dWRlbnQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgiIHg9IjkzLjkxMzQiIHk9IjY0LjAzOTciPjE8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOCIgeD0iMTA1LjExNjciIHk9IjY0LjE3OSI+bjwvdGV4dD48L2c+PCEtLVNSQz1bQXlhaW9LYkxTMm1rcGFfRUoycDlwQ19adWFoRUlJbWtMV1hFcGlaRnB1NW5JYWZKS2xEQWtCV1dlV2ZBWGFlQWtXZkFVS2ZtNkcwMF0tLT48L2c+PC9zdmc+"><h3 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:</p><ul><li>A 类是 B 类中的(某中方法的)局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMzlweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjMzOXB4O2hlaWdodDoyMzlweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzMzkgMjM5IiB3aWR0aD0iMzM5cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9IjExMyIgeT0iMjIuOTk1MSI+RGVwZW5kZW5jeTwvdGV4dD48IS0tY2xhc3MgVmVoaWNsZS0tPjxnIGlkPSJlbGVtX1ZlaGljbGUiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjY0LjI5NjkiIGlkPSJWZWhpY2xlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxNTciIHg9IjgzIiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEzMi4yNSIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTM1LjIxODgsNjUuOTM3NSBRMTM0LjY0MDYsNjYuMjM0NCAxMzQsNjYuMzc1IFExMzMuMzU5NCw2Ni41MzEzIDEzMi42NTYzLDY2LjUzMTMgUTEzMC4xNTYzLDY2LjUzMTMgMTI4LjgyODEsNjQuODkwNiBRMTI3LjUxNTYsNjMuMjM0NCAxMjcuNTE1Niw2MC4xMDk0IFExMjcuNTE1Niw1Ni45ODQ0IDEyOC44MjgxLDU1LjMyODEgUTEzMC4xNTYzLDUzLjY3MTkgMTMyLjY1NjMsNTMuNjcxOSBRMTMzLjM1OTQsNTMuNjcxOSAxMzQsNTMuODI4MSBRMTM0LjY1NjMsNTMuOTg0NCAxMzUuMjE4OCw1NC4yODEzIEwxMzUuMjE4OCw1NyBRMTM0LjU5MzgsNTYuNDIxOSAxMzQsNTYuMTU2MyBRMTMzLjQwNjMsNTUuODc1IDEzMi43ODEzLDU1Ljg3NSBRMTMxLjQzNzUsNTUuODc1IDEzMC43NSw1Ni45NTMxIFExMzAuMDYyNSw1OC4wMTU2IDEzMC4wNjI1LDYwLjEwOTQgUTEzMC4wNjI1LDYyLjIwMzEgMTMwLjc1LDYzLjI4MTMgUTEzMS40Mzc1LDY0LjM0MzggMTMyLjc4MTMsNjQuMzQzOCBRMTMzLjQwNjMsNjQuMzQzOCAxMzQsNjQuMDc4MSBRMTM0LjU5MzgsNjMuNzk2OSAxMzUuMjE4OCw2My4yMTg4IEwxMzUuMjE4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTAiIHg9IjE1Mi43NSIgeT0iNjUuMTQzNiI+VmVoaWNsZTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4NCIgeDI9IjIzOSIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iODQiIHgyPSIyMzkiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0NSIgeD0iODkiIHk9IjEwMS4yOTIiPm1vdmUoTW92ZUJlaGF2aW9yKTwvdGV4dD48L2c+PCEtLWNsYXNzIE1vdmVCZWhhdmlvci0tPjxnIGlkPSJlbGVtX01vdmVCZWhhdmlvciI+PHJlY3QgY29kZUxpbmU9IjgiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNjQuMjk2OSIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTI5IiB4PSI3IiB5PSIxNjguNTg2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE4NC41ODY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTE3LjkyMTksMTgwLjM1MjUgTDE3LjkyMTksMTc4LjE5NjMgTDI1LjMxMjUsMTc4LjE5NjMgTDI1LjMxMjUsMTgwLjM1MjUgTDIyLjg0MzgsMTgwLjM1MjUgTDIyLjg0MzgsMTg4LjQzMDYgTDI1LjMxMjUsMTg4LjQzMDYgTDI1LjMxMjUsMTkwLjU4NjkgTDE3LjkyMTksMTkwLjU4NjkgTDE3LjkyMTksMTg4LjQzMDYgTDIwLjM5MDYsMTg4LjQzMDYgTDIwLjM5MDYsMTgwLjM1MjUgTDE3LjkyMTksMTgwLjM1MjUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC1zdHlsZT0iaXRhbGljIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3IiB4PSIzNiIgeT0iMTg5LjQzMzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTM1IiB5MT0iMjAwLjU4NjkiIHkyPSIyMDAuNTg2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMzUiIHkxPSIyMDguNTg2OSIgeTI9IjIwOC41ODY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDgiIHg9IjEzIiB5PSIyMjUuNTgyIj5tb3ZlKCk8L3RleHQ+PC9nPjxnIGlkPSJlbGVtX04iPjxwYXRoIGQ9Ik0xNzEsMTg4LjE3NjkgTDE3MSwyMTMuMzA5NyBBMCwwIDAgMCAwIDE3MSwyMTMuMzA5NyBMMzMyLDIxMy4zMDk3IEEwLDAgMCAwIDAgMzMyLDIxMy4zMDk3IEwzMzIsMTk4LjE3NjkgTDMyMiwxODguMTc2OSBMMjQ2LjczLDE4OC4xNzY5IEwxODQuNjgsMTA4LjkzNjkgTDIzOC43MywxODguMTc2OSBMMTcxLDE4OC4xNzY5IEEwLDAgMCAwIDAgMTcxLDE4OC4xNzY5ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTMyMiwxODguMTc2OSBMMzIyLDE5OC4xNzY5IEwzMzIsMTk4LjE3NjkgTDMyMiwxODguMTc2OSAiIGZpbGw9IiNGRUZGREQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0MCIgeD0iMTc3IiB5PSIyMDUuMjQzOCI+TW92ZUJlaGF2aW9yLm1vdmUoKTwvdGV4dD48L2c+PCEtLWxpbmsgVmVoaWNsZSB0byBNb3ZlQmVoYXZpb3ItLT48ZyBpZD0ibGlua19WZWhpY2xlX01vdmVCZWhhdmlvciI+PHBhdGggY29kZUxpbmU9IjE0IiBkPSJNMTM4LjMyLDEwOC45MzY5IEMxMjYuMDQsMTI1LjYyNjkgMTEwLjksMTQ2LjIwNjkgOTguMTMsMTYzLjU0NjkgIiBmaWxsPSJub25lIiBpZD0iVmVoaWNsZS10by1Nb3ZlQmVoYXZpb3IiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9Ijk0LjYsMTY3LjM0NjksMTAzLjE1MDEsMTYyLjQ1ODYsOTcuNTU4NywxNjMuMzE2Miw5Ni43MDExLDE1Ny43MjQ3LDk0LjYsMTY3LjM0NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tU1JDPVtBeWFpb0tiTFM0YWpJQ3JCSVNyQmhrSllJaXY5QjJ2TTI0bERvNG02b2JIcEFHMTFSZHZQZ2VPbGE3MUFwS1dpb3ltbHFrSWd2VUJBcDJqOUJLZkJKNHZMRzlQMnJXOU1iZlRWYWdnV1hBbjQzb0FmZjkxT2hFMzduR01wSXFfRjNpS2FQMWNXRVcwMF0tLT48L2c+PC9zdmc+"><h2 id="面向对象设计的-SOLID-原则"><a href="#面向对象设计的-SOLID-原则" class="headerlink" title="面向对象设计的 SOLID 原则"></a>面向对象设计的 SOLID 原则</h2><table><thead><tr><th>缩写</th><th>全名</th><th>中文</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr></tbody></table><h3 id="SRP-单一责任原则"><a href="#SRP-单一责任原则" class="headerlink" title="SRP 单一责任原则"></a>SRP 单一责任原则</h3><p>当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是<mark style="background: #FF5582A6;">让一个类只做一种类型责任</mark>，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</p><h3 id="OCP-开放封闭原则"><a href="#OCP-开放封闭原则" class="headerlink" title="OCP 开放封闭原则"></a>OCP 开放封闭原则</h3><p>软件实体应该是<mark style="background: #FF5582A6;">可扩展，而不可修改的</mark>。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。</p><h3 id="LSP-里氏替换原则"><a href="#LSP-里氏替换原则" class="headerlink" title="LSP 里氏替换原则"></a>LSP 里氏替换原则</h3><p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有 is-A 关系</p><h3 id="DIP-依赖倒置原则"><a href="#DIP-依赖倒置原则" class="headerlink" title="DIP 依赖倒置原则"></a>DIP 依赖倒置原则</h3><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ol><h3 id="ISP-接口分离原则"><a href="#ISP-接口分离原则" class="headerlink" title="ISP 接口分离原则"></a>ISP 接口分离原则</h3><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用<mark style="background: #FF5582A6;">多个专门的接口比使用单一的总接口总要好</mark>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 面向对象</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】-面向对象"><a href="#【Java-基础】-面向对象" class="headerlink" title="【Java 基础】 面向对象"></a>【Java 基础】 面向对象</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】 面向对象date: 2022-12-14 14:07tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/面向对象categories:  - Javakeywords:  - Java/基础  - 面向对象description: 面向对象</code></pre><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型<mark style="background: #FF5582A6;">将数据和基于数据的操作封装在一起</mark>，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p><strong>优点:</strong></p><ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <mark style="background: #FF5582A6;">IS-A 关系</mark>，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循<strong>里氏替换原则</strong>，<mark style="background: #FF5582A6;">子类对象必须能够替换掉所有父类对象</mark>。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态:</p><ul><li><strong>编译时多态</strong>主要指<mark style="background: #ABF7F7A6;">方法的重载</mark></li><li><strong>运行时多态</strong>指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h3><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE3NXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNzUgMjA3IiB3aWR0aD0iMTc1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE0IiB4PSIyMy41IiB5PSIyMi45OTUxIj5HZW5lcmFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgVmVoaWNhbC0tPjxnIGlkPSJlbGVtX1ZlaGljYWwiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iVmVoaWNhbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODEiIHg9IjQzIiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjU4IiBjeT0iNjAuMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik02MC45Njg4LDY1LjkzNzUgUTYwLjM5MDYsNjYuMjM0NCA1OS43NSw2Ni4zNzUgUTU5LjEwOTQsNjYuNTMxMyA1OC40MDYzLDY2LjUzMTMgUTU1LjkwNjMsNjYuNTMxMyA1NC41NzgxLDY0Ljg5MDYgUTUzLjI2NTYsNjMuMjM0NCA1My4yNjU2LDYwLjEwOTQgUTUzLjI2NTYsNTYuOTg0NCA1NC41NzgxLDU1LjMyODEgUTU1LjkwNjMsNTMuNjcxOSA1OC40MDYzLDUzLjY3MTkgUTU5LjEwOTQsNTMuNjcxOSA1OS43NSw1My44MjgxIFE2MC40MDYzLDUzLjk4NDQgNjAuOTY4OCw1NC4yODEzIEw2MC45Njg4LDU3IFE2MC4zNDM4LDU2LjQyMTkgNTkuNzUsNTYuMTU2MyBRNTkuMTU2Myw1NS44NzUgNTguNTMxMyw1NS44NzUgUTU3LjE4NzUsNTUuODc1IDU2LjUsNTYuOTUzMSBRNTUuODEyNSw1OC4wMTU2IDU1LjgxMjUsNjAuMTA5NCBRNTUuODEyNSw2Mi4yMDMxIDU2LjUsNjMuMjgxMyBRNTcuMTg3NSw2NC4zNDM4IDU4LjUzMTMsNjQuMzQzOCBRNTkuMTU2Myw2NC4zNDM4IDU5Ljc1LDY0LjA3ODEgUTYwLjM0MzgsNjMuNzk2OSA2MC45Njg4LDYzLjIxODggTDYwLjk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSI3MiIgeT0iNjUuMTQzNiI+VmVoaWNhbDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI0NCIgeDI9IjEyMyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iNDQiIHgyPSIxMjMiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgQ2FyLS0+PGcgaWQ9ImVsZW1fQ2FyIj48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IkNhciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNTUiIHg9IjciIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuOTY4OCwxNzMuOTM3NSBRMjQuMzkwNiwxNzQuMjM0NCAyMy43NSwxNzQuMzc1IFEyMy4xMDk0LDE3NC41MzEzIDIyLjQwNjMsMTc0LjUzMTMgUTE5LjkwNjMsMTc0LjUzMTMgMTguNTc4MSwxNzIuODkwNiBRMTcuMjY1NiwxNzEuMjM0NCAxNy4yNjU2LDE2OC4xMDk0IFExNy4yNjU2LDE2NC45ODQ0IDE4LjU3ODEsMTYzLjMyODEgUTE5LjkwNjMsMTYxLjY3MTkgMjIuNDA2MywxNjEuNjcxOSBRMjMuMTA5NCwxNjEuNjcxOSAyMy43NSwxNjEuODI4MSBRMjQuNDA2MywxNjEuOTg0NCAyNC45Njg4LDE2Mi4yODEzIEwyNC45Njg4LDE2NSBRMjQuMzQzOCwxNjQuNDIxOSAyMy43NSwxNjQuMTU2MyBRMjMuMTU2MywxNjMuODc1IDIyLjUzMTMsMTYzLjg3NSBRMjEuMTg3NSwxNjMuODc1IDIwLjUsMTY0Ljk1MzEgUTE5LjgxMjUsMTY2LjAxNTYgMTkuODEyNSwxNjguMTA5NCBRMTkuODEyNSwxNzAuMjAzMSAyMC41LDE3MS4yODEzIFEyMS4xODc1LDE3Mi4zNDM4IDIyLjUzMTMsMTcyLjM0MzggUTIzLjE1NjMsMTcyLjM0MzggMjMuNzUsMTcyLjA3ODEgUTI0LjM0MzgsMTcxLjc5NjkgMjQuOTY4OCwxNzEuMjE4OCBMMjQuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIzIiB4PSIzNiIgeT0iMTczLjE0MzYiPkNhcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNjEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjYxIiB5MT0iMTkyLjI5NjkiIHkyPSIxOTIuMjk2OSIvPjwvZz48IS0tY2xhc3MgVHJ1Y2stLT48ZyBpZD0iZWxlbV9UcnVjayI+PHJlY3QgY29kZUxpbmU9IjYiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJUcnVjayIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzEiIHg9Ijk3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMTIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTQuOTY4OCwxNzMuOTM3NSBRMTE0LjM5MDYsMTc0LjIzNDQgMTEzLjc1LDE3NC4zNzUgUTExMy4xMDk0LDE3NC41MzEzIDExMi40MDYzLDE3NC41MzEzIFExMDkuOTA2MywxNzQuNTMxMyAxMDguNTc4MSwxNzIuODkwNiBRMTA3LjI2NTYsMTcxLjIzNDQgMTA3LjI2NTYsMTY4LjEwOTQgUTEwNy4yNjU2LDE2NC45ODQ0IDEwOC41NzgxLDE2My4zMjgxIFExMDkuOTA2MywxNjEuNjcxOSAxMTIuNDA2MywxNjEuNjcxOSBRMTEzLjEwOTQsMTYxLjY3MTkgMTEzLjc1LDE2MS44MjgxIFExMTQuNDA2MywxNjEuOTg0NCAxMTQuOTY4OCwxNjIuMjgxMyBMMTE0Ljk2ODgsMTY1IFExMTQuMzQzOCwxNjQuNDIxOSAxMTMuNzUsMTY0LjE1NjMgUTExMy4xNTYzLDE2My44NzUgMTEyLjUzMTMsMTYzLjg3NSBRMTExLjE4NzUsMTYzLjg3NSAxMTAuNSwxNjQuOTUzMSBRMTA5LjgxMjUsMTY2LjAxNTYgMTA5LjgxMjUsMTY4LjEwOTQgUTEwOS44MTI1LDE3MC4yMDMxIDExMC41LDE3MS4yODEzIFExMTEuMTg3NSwxNzIuMzQzOCAxMTIuNTMxMywxNzIuMzQzOCBRMTEzLjE1NjMsMTcyLjM0MzggMTEzLjc1LDE3Mi4wNzgxIFExMTQuMzQzOCwxNzEuNzk2OSAxMTQuOTY4OCwxNzEuMjE4OCBMMTE0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzOSIgeD0iMTI2IiB5PSIxNzMuMTQzNiI+VHJ1Y2s8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgVmVoaWNhbCB0byBDYXItLT48ZyBpZD0ibGlua19WZWhpY2FsX0NhciI+PHBhdGggY29kZUxpbmU9IjgiIGQ9Ik02My45NCwxMTEuNTk2OSBDNTcuNTYsMTI1LjQwNjkgNTAuNzEsMTQwLjIyNjkgNDUuMjMsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iVmVoaWNhbC1iYWNrdG8tQ2FyIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9IjU4LDEwOC43NzY5LDcyLjc1LDkzLjU1NjksNzAuNzEsMTE0LjY0NjksNTgsMTA4Ljc3NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tcmV2ZXJzZSBsaW5rIFZlaGljYWwgdG8gVHJ1Y2stLT48ZyBpZD0ibGlua19WZWhpY2FsX1RydWNrIj48cGF0aCBjb2RlTGluZT0iOSIgZD0iTTEwMy4wNiwxMTEuNTk2OSBDMTA5LjQ0LDEyNS40MDY5IDExNi4yOSwxNDAuMjI2OSAxMjEuNzcsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iVmVoaWNhbC1iYWNrdG8tVHJ1Y2siIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iOTYuMjksMTE0LjY0NjksOTQuMjUsOTMuNTU2OSwxMDksMTA4Ljc3NjksOTYuMjksMTE0LjY0NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tU1JDPVtBeWFpb0tiTFM0X0RJb3JBcENjaUlZcDlwQ19adWFoRUlJbWtMV1hCcFNYQ0ppbzF5Zm1KWXcyaWFBQkl2Nm1rQmdZcVdhc0RoWXZPNWFLMGVXVzBdLS0+PC9nPjwvc3ZnPg=="><h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE1OXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNTkgMjA3IiB3aWR0aD0iMTU5cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODUiIHg9IjMwIiB5PSIyMi45OTUxIj5SZWFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgTW92ZUJlaGF2aW9yLS0+PGcgaWQ9ImVsZW1fTW92ZUJlaGF2aW9yIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTI5IiB4PSIxMi41IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI3LjUiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIzLjQyMTksNTYuMDYyNSBMMjMuNDIxOSw1My45MDYzIEwzMC44MTI1LDUzLjkwNjMgTDMwLjgxMjUsNTYuMDYyNSBMMjguMzQzOCw1Ni4wNjI1IEwyOC4zNDM4LDY0LjE0MDYgTDMwLjgxMjUsNjQuMTQwNiBMMzAuODEyNSw2Ni4yOTY5IEwyMy40MjE5LDY2LjI5NjkgTDIzLjQyMTksNjQuMTQwNiBMMjUuODkwNiw2NC4xNDA2IEwyNS44OTA2LDU2LjA2MjUgTDIzLjQyMTksNTYuMDYyNSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBmb250LXN0eWxlPSJpdGFsaWMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTciIHg9IjQxLjUiIHk9IjY1LjE0MzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMy41IiB4Mj0iMTQwLjUiIHkxPSI3Ni4yOTY5IiB5Mj0iNzYuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEzLjUiIHgyPSIxNDAuNSIgeTE9Ijg0LjI5NjkiIHkyPSI4NC4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBGbHktLT48ZyBpZD0iZWxlbV9GbHkiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRmx5IiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI1MCIgeD0iNyIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNC45Njg4LDE3My45Mzc1IFEyNC4zOTA2LDE3NC4yMzQ0IDIzLjc1LDE3NC4zNzUgUTIzLjEwOTQsMTc0LjUzMTMgMjIuNDA2MywxNzQuNTMxMyBRMTkuOTA2MywxNzQuNTMxMyAxOC41NzgxLDE3Mi44OTA2IFExNy4yNjU2LDE3MS4yMzQ0IDE3LjI2NTYsMTY4LjEwOTQgUTE3LjI2NTYsMTY0Ljk4NDQgMTguNTc4MSwxNjMuMzI4MSBRMTkuOTA2MywxNjEuNjcxOSAyMi40MDYzLDE2MS42NzE5IFEyMy4xMDk0LDE2MS42NzE5IDIzLjc1LDE2MS44MjgxIFEyNC40MDYzLDE2MS45ODQ0IDI0Ljk2ODgsMTYyLjI4MTMgTDI0Ljk2ODgsMTY1IFEyNC4zNDM4LDE2NC40MjE5IDIzLjc1LDE2NC4xNTYzIFEyMy4xNTYzLDE2My44NzUgMjIuNTMxMywxNjMuODc1IFEyMS4xODc1LDE2My44NzUgMjAuNSwxNjQuOTUzMSBRMTkuODEyNSwxNjYuMDE1NiAxOS44MTI1LDE2OC4xMDk0IFExOS44MTI1LDE3MC4yMDMxIDIwLjUsMTcxLjI4MTMgUTIxLjE4NzUsMTcyLjM0MzggMjIuNTMxMywxNzIuMzQzOCBRMjMuMTU2MywxNzIuMzQzOCAyMy43NSwxNzIuMDc4MSBRMjQuMzQzOCwxNzEuNzk2OSAyNC45Njg4LDE3MS4yMTg4IEwyNC45Njg4LDE3My45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTgiIHg9IjM2IiB5PSIxNzMuMTQzNiI+Rmx5PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSI1NiIgeTE9IjE4NC4yOTY5IiB5Mj0iMTg0LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNTYiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBSdW4tLT48ZyBpZD0iZWxlbV9SdW4iPjxyZWN0IGNvZGVMaW5lPSI2IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iUnVuIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI2MCIgeD0iOTIiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEwNyIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEwOS45Njg4LDE3My45Mzc1IFExMDkuMzkwNiwxNzQuMjM0NCAxMDguNzUsMTc0LjM3NSBRMTA4LjEwOTQsMTc0LjUzMTMgMTA3LjQwNjMsMTc0LjUzMTMgUTEwNC45MDYzLDE3NC41MzEzIDEwMy41NzgxLDE3Mi44OTA2IFExMDIuMjY1NiwxNzEuMjM0NCAxMDIuMjY1NiwxNjguMTA5NCBRMTAyLjI2NTYsMTY0Ljk4NDQgMTAzLjU3ODEsMTYzLjMyODEgUTEwNC45MDYzLDE2MS42NzE5IDEwNy40MDYzLDE2MS42NzE5IFExMDguMTA5NCwxNjEuNjcxOSAxMDguNzUsMTYxLjgyODEgUTEwOS40MDYzLDE2MS45ODQ0IDEwOS45Njg4LDE2Mi4yODEzIEwxMDkuOTY4OCwxNjUgUTEwOS4zNDM4LDE2NC40MjE5IDEwOC43NSwxNjQuMTU2MyBRMTA4LjE1NjMsMTYzLjg3NSAxMDcuNTMxMywxNjMuODc1IFExMDYuMTg3NSwxNjMuODc1IDEwNS41LDE2NC45NTMxIFExMDQuODEyNSwxNjYuMDE1NiAxMDQuODEyNSwxNjguMTA5NCBRMTA0LjgxMjUsMTcwLjIwMzEgMTA1LjUsMTcxLjI4MTMgUTEwNi4xODc1LDE3Mi4zNDM4IDEwNy41MzEzLDE3Mi4zNDM4IFExMDguMTU2MywxNzIuMzQzOCAxMDguNzUsMTcyLjA3ODEgUTEwOS4zNDM4LDE3MS43OTY5IDEwOS45Njg4LDE3MS4yMTg4IEwxMDkuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSIxMjEiIHk9IjE3My4xNDM2Ij5SdW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgTW92ZUJlaGF2aW9yIHRvIEZseS0tPjxnIGlkPSJsaW5rX01vdmVCZWhhdmlvcl9GbHkiPjxwYXRoIGNvZGVMaW5lPSI4IiBkPSJNNTkuMDQsMTExLjU5NjkgQzUzLjE4LDEyNS40MDY5IDQ2Ljg5LDE0MC4yMjY5IDQxLjg1LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9Ik1vdmVCZWhhdmlvci1iYWNrdG8tRmx5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSI1Mi44NywxMDkuMjM2OSw2Ny4xMiw5My41NTY5LDY1Ljc1LDExNC43MDY5LDUyLjg3LDEwOS4yMzY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBNb3ZlQmVoYXZpb3IgdG8gUnVuLS0+PGcgaWQ9ImxpbmtfTW92ZUJlaGF2aW9yX1J1biI+PHBhdGggY29kZUxpbmU9IjkiIGQ9Ik05NC45NiwxMTEuNTk2OSBDMTAwLjgyLDEyNS40MDY5IDEwNy4xMSwxNDAuMjI2OSAxMTIuMTUsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iTW92ZUJlaGF2aW9yLWJhY2t0by1SdW4iIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijg4LjI1LDExNC43MDY5LDg2Ljg4LDkzLjU1NjksMTAxLjEzLDEwOS4yMzY5LDg4LjI1LDExNC43MDY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkwyNGZEcENjaUlZcDlwQ19adWloQ0FxYWpJYWpDSmJObXBJekJUS2hESTJwQnAyX1lJaXY5QjJ2TVNDa2ZYQkEySWU1Z2FMS2VzREpld080TE84ZzI1MEMwXS0tPjwvZz48L3N2Zz4="><h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM0MXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNDEgMjA3IiB3aWR0aD0iMzQxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTciIHg9IjExNSIgeT0iMjIuOTk1MSI+QWdncmVnYXRpb248L3RleHQ+PCEtLWNsYXNzIENvbXB1dGVyLS0+PGcgaWQ9ImVsZW1fQ29tcHV0ZXIiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcHV0ZXIiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEwMSIgeD0iMTI4IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjE0MyIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTQ1Ljk2ODgsNjUuOTM3NSBRMTQ1LjM5MDYsNjYuMjM0NCAxNDQuNzUsNjYuMzc1IFExNDQuMTA5NCw2Ni41MzEzIDE0My40MDYzLDY2LjUzMTMgUTE0MC45MDYzLDY2LjUzMTMgMTM5LjU3ODEsNjQuODkwNiBRMTM4LjI2NTYsNjMuMjM0NCAxMzguMjY1Niw2MC4xMDk0IFExMzguMjY1Niw1Ni45ODQ0IDEzOS41NzgxLDU1LjMyODEgUTE0MC45MDYzLDUzLjY3MTkgMTQzLjQwNjMsNTMuNjcxOSBRMTQ0LjEwOTQsNTMuNjcxOSAxNDQuNzUsNTMuODI4MSBRMTQ1LjQwNjMsNTMuOTg0NCAxNDUuOTY4OCw1NC4yODEzIEwxNDUuOTY4OCw1NyBRMTQ1LjM0MzgsNTYuNDIxOSAxNDQuNzUsNTYuMTU2MyBRMTQ0LjE1NjMsNTUuODc1IDE0My41MzEzLDU1Ljg3NSBRMTQyLjE4NzUsNTUuODc1IDE0MS41LDU2Ljk1MzEgUTE0MC44MTI1LDU4LjAxNTYgMTQwLjgxMjUsNjAuMTA5NCBRMTQwLjgxMjUsNjIuMjAzMSAxNDEuNSw2My4yODEzIFExNDIuMTg3NSw2NC4zNDM4IDE0My41MzEzLDY0LjM0MzggUTE0NC4xNTYzLDY0LjM0MzggMTQ0Ljc1LDY0LjA3ODEgUTE0NS4zNDM4LDYzLjc5NjkgMTQ1Ljk2ODgsNjMuMjE4OCBMMTQ1Ljk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSIxNTciIHk9IjY1LjE0MzYiPkNvbXB1dGVyPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyOSIgeDI9IjIyOCIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTI5IiB4Mj0iMjI4IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWNsYXNzIEtleWJvYXJkLS0+PGcgaWQ9ImVsZW1fS2V5Ym9hcmQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iS2V5Ym9hcmQiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijk3IiB4PSI3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsMTczLjkzNzUgUTI0LjM5MDYsMTc0LjIzNDQgMjMuNzUsMTc0LjM3NSBRMjMuMTA5NCwxNzQuNTMxMyAyMi40MDYzLDE3NC41MzEzIFExOS45MDYzLDE3NC41MzEzIDE4LjU3ODEsMTcyLjg5MDYgUTE3LjI2NTYsMTcxLjIzNDQgMTcuMjY1NiwxNjguMTA5NCBRMTcuMjY1NiwxNjQuOTg0NCAxOC41NzgxLDE2My4zMjgxIFExOS45MDYzLDE2MS42NzE5IDIyLjQwNjMsMTYxLjY3MTkgUTIzLjEwOTQsMTYxLjY3MTkgMjMuNzUsMTYxLjgyODEgUTI0LjQwNjMsMTYxLjk4NDQgMjQuOTY4OCwxNjIuMjgxMyBMMjQuOTY4OCwxNjUgUTI0LjM0MzgsMTY0LjQyMTkgMjMuNzUsMTY0LjE1NjMgUTIzLjE1NjMsMTYzLjg3NSAyMi41MzEzLDE2My44NzUgUTIxLjE4NzUsMTYzLjg3NSAyMC41LDE2NC45NTMxIFExOS44MTI1LDE2Ni4wMTU2IDE5LjgxMjUsMTY4LjEwOTQgUTE5LjgxMjUsMTcwLjIwMzEgMjAuNSwxNzEuMjgxMyBRMjEuMTg3NSwxNzIuMzQzOCAyMi41MzEzLDE3Mi4zNDM4IFEyMy4xNTYzLDE3Mi4zNDM4IDIzLjc1LDE3Mi4wNzgxIFEyNC4zNDM4LDE3MS43OTY5IDI0Ljk2ODgsMTcxLjIxODggTDI0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NSIgeD0iMzYiIHk9IjE3My4xNDM2Ij5LZXlib2FyZDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTAzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMDMiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBNb3VzZS0tPjxnIGlkPSJlbGVtX01vdXNlIj48cmVjdCBjb2RlTGluZT0iNiIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdXNlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI3OSIgeD0iMTM5IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxNTQiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xNTYuOTY4OCwxNzMuOTM3NSBRMTU2LjM5MDYsMTc0LjIzNDQgMTU1Ljc1LDE3NC4zNzUgUTE1NS4xMDk0LDE3NC41MzEzIDE1NC40MDYzLDE3NC41MzEzIFExNTEuOTA2MywxNzQuNTMxMyAxNTAuNTc4MSwxNzIuODkwNiBRMTQ5LjI2NTYsMTcxLjIzNDQgMTQ5LjI2NTYsMTY4LjEwOTQgUTE0OS4yNjU2LDE2NC45ODQ0IDE1MC41NzgxLDE2My4zMjgxIFExNTEuOTA2MywxNjEuNjcxOSAxNTQuNDA2MywxNjEuNjcxOSBRMTU1LjEwOTQsMTYxLjY3MTkgMTU1Ljc1LDE2MS44MjgxIFExNTYuNDA2MywxNjEuOTg0NCAxNTYuOTY4OCwxNjIuMjgxMyBMMTU2Ljk2ODgsMTY1IFExNTYuMzQzOCwxNjQuNDIxOSAxNTUuNzUsMTY0LjE1NjMgUTE1NS4xNTYzLDE2My44NzUgMTU0LjUzMTMsMTYzLjg3NSBRMTUzLjE4NzUsMTYzLjg3NSAxNTIuNSwxNjQuOTUzMSBRMTUxLjgxMjUsMTY2LjAxNTYgMTUxLjgxMjUsMTY4LjEwOTQgUTE1MS44MTI1LDE3MC4yMDMxIDE1Mi41LDE3MS4yODEzIFExNTMuMTg3NSwxNzIuMzQzOCAxNTQuNTMxMywxNzIuMzQzOCBRMTU1LjE1NjMsMTcyLjM0MzggMTU1Ljc1LDE3Mi4wNzgxIFExNTYuMzQzOCwxNzEuNzk2OSAxNTYuOTY4OCwxNzEuMjE4OCBMMTU2Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0NyIgeD0iMTY4IiB5PSIxNzMuMTQzNiI+TW91c2U8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTQwIiB4Mj0iMjE3IiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE0MCIgeDI9IjIxNyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLWNsYXNzIFNjcmVlbi0tPjxnIGlkPSJlbGVtX1NjcmVlbiI+PHJlY3QgY29kZUxpbmU9IjciIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJTY3JlZW4iIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjgxIiB4PSIyNTMiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI2OCIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI3MC45Njg4LDE3My45Mzc1IFEyNzAuMzkwNiwxNzQuMjM0NCAyNjkuNzUsMTc0LjM3NSBRMjY5LjEwOTQsMTc0LjUzMTMgMjY4LjQwNjMsMTc0LjUzMTMgUTI2NS45MDYzLDE3NC41MzEzIDI2NC41NzgxLDE3Mi44OTA2IFEyNjMuMjY1NiwxNzEuMjM0NCAyNjMuMjY1NiwxNjguMTA5NCBRMjYzLjI2NTYsMTY0Ljk4NDQgMjY0LjU3ODEsMTYzLjMyODEgUTI2NS45MDYzLDE2MS42NzE5IDI2OC40MDYzLDE2MS42NzE5IFEyNjkuMTA5NCwxNjEuNjcxOSAyNjkuNzUsMTYxLjgyODEgUTI3MC40MDYzLDE2MS45ODQ0IDI3MC45Njg4LDE2Mi4yODEzIEwyNzAuOTY4OCwxNjUgUTI3MC4zNDM4LDE2NC40MjE5IDI2OS43NSwxNjQuMTU2MyBRMjY5LjE1NjMsMTYzLjg3NSAyNjguNTMxMywxNjMuODc1IFEyNjcuMTg3NSwxNjMuODc1IDI2Ni41LDE2NC45NTMxIFEyNjUuODEyNSwxNjYuMDE1NiAyNjUuODEyNSwxNjguMTA5NCBRMjY1LjgxMjUsMTcwLjIwMzEgMjY2LjUsMTcxLjI4MTMgUTI2Ny4xODc1LDE3Mi4zNDM4IDI2OC41MzEzLDE3Mi4zNDM4IFEyNjkuMTU2MywxNzIuMzQzOCAyNjkuNzUsMTcyLjA3ODEgUTI3MC4zNDM4LDE3MS43OTY5IDI3MC45Njg4LDE3MS4yMTg4IEwyNzAuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSIyODIiIHk9IjE3My4xNDM2Ij5TY3JlZW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMjU0IiB4Mj0iMzMzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjI1NCIgeDI9IjMzMyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBLZXlib2FyZC0tPjxnIGlkPSJsaW5rX0NvbXB1dGVyX0tleWJvYXJkIj48cGF0aCBjb2RlTGluZT0iOSIgZD0iTTE0MS4xMywxMDEuNDk2OSBDMTIyLjIsMTE3LjgxNjkgOTkuNjQsMTM3LjI1NjkgODIuNDMsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLUtleWJvYXJkIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9IjE1MC41MSw5Mi41NTY5LDE0My4zNTMyLDkzLjQzOTksMTQxLjQxNTcsMTAwLjM4NTksMTQ4LjU3MjUsOTkuNTAyOCwxNTAuNTEsOTIuNTU2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcHV0ZXIgdG8gTW91c2UtLT48ZyBpZD0ibGlua19Db21wdXRlcl9Nb3VzZSI+PHBhdGggY29kZUxpbmU9IjEwIiBkPSJNMTc4LjUsMTA2LjM2NjkgQzE3OC41LDEyMS41NjY5IDE3OC41LDEzOC43MDY5IDE3OC41LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9IkNvbXB1dGVyLWJhY2t0by1Nb3VzZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIxNzguNSw5My41NTY5LDE3NC41LDk5LjU1NjksMTc4LjUsMTA1LjU1NjksMTgyLjUsOTkuNTU2OSwxNzguNSw5My41NTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBTY3JlZW4tLT48ZyBpZD0ibGlua19Db21wdXRlcl9TY3JlZW4iPjxwYXRoIGNvZGVMaW5lPSIxMSIgZD0iTTIxMy42OCwxMDEuNzI2OSBDMjMxLjMzLDExNy45OTY5IDI1Mi4zMSwxMzcuMzI2OSAyNjguMzIsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLVNjcmVlbiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIyMDQuNzQsOTMuNTU2OSwyMDYuNDM4NywxMDAuNTY1LDIxMy41NjEyLDEwMS42OTI0LDIxMS44NjI0LDk0LjY4NDIsMjA0Ljc0LDkzLjU1NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tU1JDPVtBeWFpb0tiTFM0bkZCcWZESm9wOXBDX1p1YWhFSUlta0xkM0Vwb3FlQkthaldkQXpLb2tKeVhFQktnMVN0X3BJdWJHZUVwWXZBM0tMZzAtY0dvNVZMblVYN2FLS2VXcjUyQWVSMDAwMF0tLT48L2c+PC9zdmc+"><h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjI5N3B4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyOTcgMjA3IiB3aWR0aD0iMjk3cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTgiIHg9IjkyLjc1IiB5PSIyMi45OTUxIj5Db21wb3NpdGlvbjwvdGV4dD48IS0tY2xhc3MgQ29tcGFueS0tPjxnIGlkPSJlbGVtX0NvbXBhbnkiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcGFueSIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iOTciIHg9Ijk5LjUiIHk9IjQ0LjI5NjkiLz48ZWxsaXBzZSBjeD0iMTE0LjUiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTExNy40Njg4LDY1LjkzNzUgUTExNi44OTA2LDY2LjIzNDQgMTE2LjI1LDY2LjM3NSBRMTE1LjYwOTQsNjYuNTMxMyAxMTQuOTA2Myw2Ni41MzEzIFExMTIuNDA2Myw2Ni41MzEzIDExMS4wNzgxLDY0Ljg5MDYgUTEwOS43NjU2LDYzLjIzNDQgMTA5Ljc2NTYsNjAuMTA5NCBRMTA5Ljc2NTYsNTYuOTg0NCAxMTEuMDc4MSw1NS4zMjgxIFExMTIuNDA2Myw1My42NzE5IDExNC45MDYzLDUzLjY3MTkgUTExNS42MDk0LDUzLjY3MTkgMTE2LjI1LDUzLjgyODEgUTExNi45MDYzLDUzLjk4NDQgMTE3LjQ2ODgsNTQuMjgxMyBMMTE3LjQ2ODgsNTcgUTExNi44NDM4LDU2LjQyMTkgMTE2LjI1LDU2LjE1NjMgUTExNS42NTYzLDU1Ljg3NSAxMTUuMDMxMyw1NS44NzUgUTExMy42ODc1LDU1Ljg3NSAxMTMsNTYuOTUzMSBRMTEyLjMxMjUsNTguMDE1NiAxMTIuMzEyNSw2MC4xMDk0IFExMTIuMzEyNSw2Mi4yMDMxIDExMyw2My4yODEzIFExMTMuNjg3NSw2NC4zNDM4IDExNS4wMzEzLDY0LjM0MzggUTExNS42NTYzLDY0LjM0MzggMTE2LjI1LDY0LjA3ODEgUTExNi44NDM4LDYzLjc5NjkgMTE3LjQ2ODgsNjMuMjE4OCBMMTE3LjQ2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY1IiB4PSIxMjguNSIgeT0iNjUuMTQzNiI+Q29tcGFueTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMDAuNSIgeDI9IjE5NS41IiB5MT0iNzYuMjk2OSIgeTI9Ijc2LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMDAuNSIgeDI9IjE5NS41IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWNsYXNzIERlcGFydG1lbnRBLS0+PGcgaWQ9ImVsZW1fRGVwYXJ0bWVudEEiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRGVwYXJ0bWVudEEiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEyNCIgeD0iNyIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNC45Njg4LDE3My45Mzc1IFEyNC4zOTA2LDE3NC4yMzQ0IDIzLjc1LDE3NC4zNzUgUTIzLjEwOTQsMTc0LjUzMTMgMjIuNDA2MywxNzQuNTMxMyBRMTkuOTA2MywxNzQuNTMxMyAxOC41NzgxLDE3Mi44OTA2IFExNy4yNjU2LDE3MS4yMzQ0IDE3LjI2NTYsMTY4LjEwOTQgUTE3LjI2NTYsMTY0Ljk4NDQgMTguNTc4MSwxNjMuMzI4MSBRMTkuOTA2MywxNjEuNjcxOSAyMi40MDYzLDE2MS42NzE5IFEyMy4xMDk0LDE2MS42NzE5IDIzLjc1LDE2MS44MjgxIFEyNC40MDYzLDE2MS45ODQ0IDI0Ljk2ODgsMTYyLjI4MTMgTDI0Ljk2ODgsMTY1IFEyNC4zNDM4LDE2NC40MjE5IDIzLjc1LDE2NC4xNTYzIFEyMy4xNTYzLDE2My44NzUgMjIuNTMxMywxNjMuODc1IFEyMS4xODc1LDE2My44NzUgMjAuNSwxNjQuOTUzMSBRMTkuODEyNSwxNjYuMDE1NiAxOS44MTI1LDE2OC4xMDk0IFExOS44MTI1LDE3MC4yMDMxIDIwLjUsMTcxLjI4MTMgUTIxLjE4NzUsMTcyLjM0MzggMjIuNTMxMywxNzIuMzQzOCBRMjMuMTU2MywxNzIuMzQzOCAyMy43NSwxNzIuMDc4MSBRMjQuMzQzOCwxNzEuNzk2OSAyNC45Njg4LDE3MS4yMTg4IEwyNC45Njg4LDE3My45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTIiIHg9IjM2IiB5PSIxNzMuMTQzNiI+RGVwYXJ0bWVudEE8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjEzMCIgeTE9IjE4NC4yOTY5IiB5Mj0iMTg0LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTMwIiB5MT0iMTkyLjI5NjkiIHkyPSIxOTIuMjk2OSIvPjwvZz48IS0tY2xhc3MgRGVwYXJ0bWVudEItLT48ZyBpZD0iZWxlbV9EZXBhcnRtZW50QiI+PHJlY3QgY29kZUxpbmU9IjYiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJEZXBhcnRtZW50QiIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTI1IiB4PSIxNjUuNSIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMTgwLjUiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xODMuNDY4OCwxNzMuOTM3NSBRMTgyLjg5MDYsMTc0LjIzNDQgMTgyLjI1LDE3NC4zNzUgUTE4MS42MDk0LDE3NC41MzEzIDE4MC45MDYzLDE3NC41MzEzIFExNzguNDA2MywxNzQuNTMxMyAxNzcuMDc4MSwxNzIuODkwNiBRMTc1Ljc2NTYsMTcxLjIzNDQgMTc1Ljc2NTYsMTY4LjEwOTQgUTE3NS43NjU2LDE2NC45ODQ0IDE3Ny4wNzgxLDE2My4zMjgxIFExNzguNDA2MywxNjEuNjcxOSAxODAuOTA2MywxNjEuNjcxOSBRMTgxLjYwOTQsMTYxLjY3MTkgMTgyLjI1LDE2MS44MjgxIFExODIuOTA2MywxNjEuOTg0NCAxODMuNDY4OCwxNjIuMjgxMyBMMTgzLjQ2ODgsMTY1IFExODIuODQzOCwxNjQuNDIxOSAxODIuMjUsMTY0LjE1NjMgUTE4MS42NTYzLDE2My44NzUgMTgxLjAzMTMsMTYzLjg3NSBRMTc5LjY4NzUsMTYzLjg3NSAxNzksMTY0Ljk1MzEgUTE3OC4zMTI1LDE2Ni4wMTU2IDE3OC4zMTI1LDE2OC4xMDk0IFExNzguMzEyNSwxNzAuMjAzMSAxNzksMTcxLjI4MTMgUTE3OS42ODc1LDE3Mi4zNDM4IDE4MS4wMzEzLDE3Mi4zNDM4IFExODEuNjU2MywxNzIuMzQzOCAxODIuMjUsMTcyLjA3ODEgUTE4Mi44NDM4LDE3MS43OTY5IDE4My40Njg4LDE3MS4yMTg4IEwxODMuNDY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkzIiB4PSIxOTQuNSIgeT0iMTczLjE0MzYiPkRlcGFydG1lbnRCPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE2Ni41IiB4Mj0iMjg5LjUiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTY2LjUiIHgyPSIyODkuNSIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wYW55IHRvIERlcGFydG1lbnRBLS0+PGcgaWQ9ImxpbmtfQ29tcGFueV9EZXBhcnRtZW50QSI+PHBhdGggY29kZUxpbmU9IjgiIGQ9Ik0xMjIuNDYsMTAzLjU2NjkgQzExMC42MywxMTkuNDM2OSA5Ni44OSwxMzcuODc2OSA4Ni4zLDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9IkNvbXBhbnktYmFja3RvLURlcGFydG1lbnRBIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjEzMC42Niw5My41NTY5LDEyMy44NjgsOTUuOTc5MywxMjMuNDkxNywxMDMuMTgwNiwxMzAuMjgzOCwxMDAuNzU4MiwxMzAuNjYsOTMuNTU2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcGFueSB0byBEZXBhcnRtZW50Qi0tPjxnIGlkPSJsaW5rX0NvbXBhbnlfRGVwYXJ0bWVudEIiPjxwYXRoIGNvZGVMaW5lPSI5IiBkPSJNMTczLjg2LDEwMy41NjY5IEMxODUuODQsMTE5LjQzNjkgMTk5Ljc2LDEzNy44NzY5IDIxMC40OCwxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJDb21wYW55LWJhY2t0by1EZXBhcnRtZW50QiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxNjUuNTYsOTMuNTU2OSwxNjUuOTgyMiwxMDAuNzU1NiwxNzIuNzg5NSwxMDMuMTM0NywxNzIuMzY3NCw5NS45MzU5LDE2NS41Niw5My41NTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTQ3hGQlNXbHBZcDlwQ19adWFoRUlJbWsxV2lidmJMMlVJd2YxT2I1OVJjZlVJTUU2MjlFTjVuR25HZlFraGVlSWg2QkV0NDEwMDAwXS0tPjwvZz48L3N2Zz4="><h3 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSI5OXB4IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiBzdHlsZT0id2lkdGg6MjE1cHg7aGVpZ2h0Ojk5cHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjE1IDk5IiB3aWR0aD0iMjE1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTEiIHg9IjU1IiB5PSIyMi45OTUxIj5Bc3NvY2lhdGlvbjwvdGV4dD48IS0tY2xhc3MgU2Nob29sLS0+PGcgaWQ9ImVsZW1fU2Nob29sIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IlNjaG9vbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzkiIHg9IjciIHk9IjQ0LjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsNjUuOTM3NSBRMjQuMzkwNiw2Ni4yMzQ0IDIzLjc1LDY2LjM3NSBRMjMuMTA5NCw2Ni41MzEzIDIyLjQwNjMsNjYuNTMxMyBRMTkuOTA2Myw2Ni41MzEzIDE4LjU3ODEsNjQuODkwNiBRMTcuMjY1Niw2My4yMzQ0IDE3LjI2NTYsNjAuMTA5NCBRMTcuMjY1Niw1Ni45ODQ0IDE4LjU3ODEsNTUuMzI4MSBRMTkuOTA2Myw1My42NzE5IDIyLjQwNjMsNTMuNjcxOSBRMjMuMTA5NCw1My42NzE5IDIzLjc1LDUzLjgyODEgUTI0LjQwNjMsNTMuOTg0NCAyNC45Njg4LDU0LjI4MTMgTDI0Ljk2ODgsNTcgUTI0LjM0MzgsNTYuNDIxOSAyMy43NSw1Ni4xNTYzIFEyMy4xNTYzLDU1Ljg3NSAyMi41MzEzLDU1Ljg3NSBRMjEuMTg3NSw1NS44NzUgMjAuNSw1Ni45NTMxIFExOS44MTI1LDU4LjAxNTYgMTkuODEyNSw2MC4xMDk0IFExOS44MTI1LDYyLjIwMzEgMjAuNSw2My4yODEzIFEyMS4xODc1LDY0LjM0MzggMjIuNTMxMyw2NC4zNDM4IFEyMy4xNTYzLDY0LjM0MzggMjMuNzUsNjQuMDc4MSBRMjQuMzQzOCw2My43OTY5IDI0Ljk2ODgsNjMuMjE4OCBMMjQuOTY4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDciIHg9IjM2IiB5PSI2NS4xNDM2Ij5TY2hvb2w8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9Ijg1IiB5MT0iNzYuMjk2OSIgeTI9Ijc2LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iODUiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgU3R1ZGVudC0tPjxnIGlkPSJlbGVtX1N0dWRlbnQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iU3R1ZGVudCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODciIHg9IjEyMSIgeT0iNDQuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMzYiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEzOC45Njg4LDY1LjkzNzUgUTEzOC4zOTA2LDY2LjIzNDQgMTM3Ljc1LDY2LjM3NSBRMTM3LjEwOTQsNjYuNTMxMyAxMzYuNDA2Myw2Ni41MzEzIFExMzMuOTA2Myw2Ni41MzEzIDEzMi41NzgxLDY0Ljg5MDYgUTEzMS4yNjU2LDYzLjIzNDQgMTMxLjI2NTYsNjAuMTA5NCBRMTMxLjI2NTYsNTYuOTg0NCAxMzIuNTc4MSw1NS4zMjgxIFExMzMuOTA2Myw1My42NzE5IDEzNi40MDYzLDUzLjY3MTkgUTEzNy4xMDk0LDUzLjY3MTkgMTM3Ljc1LDUzLjgyODEgUTEzOC40MDYzLDUzLjk4NDQgMTM4Ljk2ODgsNTQuMjgxMyBMMTM4Ljk2ODgsNTcgUTEzOC4zNDM4LDU2LjQyMTkgMTM3Ljc1LDU2LjE1NjMgUTEzNy4xNTYzLDU1Ljg3NSAxMzYuNTMxMyw1NS44NzUgUTEzNS4xODc1LDU1Ljg3NSAxMzQuNSw1Ni45NTMxIFExMzMuODEyNSw1OC4wMTU2IDEzMy44MTI1LDYwLjEwOTQgUTEzMy44MTI1LDYyLjIwMzEgMTM0LjUsNjMuMjgxMyBRMTM1LjE4NzUsNjQuMzQzOCAxMzYuNTMxMyw2NC4zNDM4IFExMzcuMTU2Myw2NC4zNDM4IDEzNy43NSw2NC4wNzgxIFExMzguMzQzOCw2My43OTY5IDEzOC45Njg4LDYzLjIxODggTDEzOC45Njg4LDY1LjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NSIgeD0iMTUwIiB5PSI2NS4xNDM2Ij5TdHVkZW50PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyMiIgeDI9IjIwNyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTIyIiB4Mj0iMjA3IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWxpbmsgU2Nob29sIHRvIFN0dWRlbnQtLT48ZyBpZD0ibGlua19TY2hvb2xfU3R1ZGVudCI+PHBhdGggY29kZUxpbmU9IjciIGQ9Ik04Ni4xNCw2OC4yOTY5IEM5Ny42Nyw2OC4yOTY5IDEwOS4yLDY4LjI5NjkgMTIwLjczLDY4LjI5NjkgIiBmaWxsPSJub25lIiBpZD0iU2Nob29sLVN0dWRlbnQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgiIHg9IjkzLjkxMzQiIHk9IjY0LjAzOTciPjE8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOCIgeD0iMTA1LjExNjciIHk9IjY0LjE3OSI+bjwvdGV4dD48L2c+PCEtLVNSQz1bQXlhaW9LYkxTMm1rcGFfRUoycDlwQ19adWFoRUlJbWtMV1hFcGlaRnB1NW5JYWZKS2xEQWtCV1dlV2ZBWGFlQWtXZkFVS2ZtNkcwMF0tLT48L2c+PC9zdmc+"><h3 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:</p><ul><li>A 类是 B 类中的(某中方法的)局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMzlweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjMzOXB4O2hlaWdodDoyMzlweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzMzkgMjM5IiB3aWR0aD0iMzM5cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9IjExMyIgeT0iMjIuOTk1MSI+RGVwZW5kZW5jeTwvdGV4dD48IS0tY2xhc3MgVmVoaWNsZS0tPjxnIGlkPSJlbGVtX1ZlaGljbGUiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjY0LjI5NjkiIGlkPSJWZWhpY2xlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxNTciIHg9IjgzIiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEzMi4yNSIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTM1LjIxODgsNjUuOTM3NSBRMTM0LjY0MDYsNjYuMjM0NCAxMzQsNjYuMzc1IFExMzMuMzU5NCw2Ni41MzEzIDEzMi42NTYzLDY2LjUzMTMgUTEzMC4xNTYzLDY2LjUzMTMgMTI4LjgyODEsNjQuODkwNiBRMTI3LjUxNTYsNjMuMjM0NCAxMjcuNTE1Niw2MC4xMDk0IFExMjcuNTE1Niw1Ni45ODQ0IDEyOC44MjgxLDU1LjMyODEgUTEzMC4xNTYzLDUzLjY3MTkgMTMyLjY1NjMsNTMuNjcxOSBRMTMzLjM1OTQsNTMuNjcxOSAxMzQsNTMuODI4MSBRMTM0LjY1NjMsNTMuOTg0NCAxMzUuMjE4OCw1NC4yODEzIEwxMzUuMjE4OCw1NyBRMTM0LjU5MzgsNTYuNDIxOSAxMzQsNTYuMTU2MyBRMTMzLjQwNjMsNTUuODc1IDEzMi43ODEzLDU1Ljg3NSBRMTMxLjQzNzUsNTUuODc1IDEzMC43NSw1Ni45NTMxIFExMzAuMDYyNSw1OC4wMTU2IDEzMC4wNjI1LDYwLjEwOTQgUTEzMC4wNjI1LDYyLjIwMzEgMTMwLjc1LDYzLjI4MTMgUTEzMS40Mzc1LDY0LjM0MzggMTMyLjc4MTMsNjQuMzQzOCBRMTMzLjQwNjMsNjQuMzQzOCAxMzQsNjQuMDc4MSBRMTM0LjU5MzgsNjMuNzk2OSAxMzUuMjE4OCw2My4yMTg4IEwxMzUuMjE4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTAiIHg9IjE1Mi43NSIgeT0iNjUuMTQzNiI+VmVoaWNsZTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4NCIgeDI9IjIzOSIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iODQiIHgyPSIyMzkiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0NSIgeD0iODkiIHk9IjEwMS4yOTIiPm1vdmUoTW92ZUJlaGF2aW9yKTwvdGV4dD48L2c+PCEtLWNsYXNzIE1vdmVCZWhhdmlvci0tPjxnIGlkPSJlbGVtX01vdmVCZWhhdmlvciI+PHJlY3QgY29kZUxpbmU9IjgiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNjQuMjk2OSIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTI5IiB4PSI3IiB5PSIxNjguNTg2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE4NC41ODY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTE3LjkyMTksMTgwLjM1MjUgTDE3LjkyMTksMTc4LjE5NjMgTDI1LjMxMjUsMTc4LjE5NjMgTDI1LjMxMjUsMTgwLjM1MjUgTDIyLjg0MzgsMTgwLjM1MjUgTDIyLjg0MzgsMTg4LjQzMDYgTDI1LjMxMjUsMTg4LjQzMDYgTDI1LjMxMjUsMTkwLjU4NjkgTDE3LjkyMTksMTkwLjU4NjkgTDE3LjkyMTksMTg4LjQzMDYgTDIwLjM5MDYsMTg4LjQzMDYgTDIwLjM5MDYsMTgwLjM1MjUgTDE3LjkyMTksMTgwLjM1MjUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC1zdHlsZT0iaXRhbGljIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3IiB4PSIzNiIgeT0iMTg5LjQzMzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTM1IiB5MT0iMjAwLjU4NjkiIHkyPSIyMDAuNTg2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMzUiIHkxPSIyMDguNTg2OSIgeTI9IjIwOC41ODY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDgiIHg9IjEzIiB5PSIyMjUuNTgyIj5tb3ZlKCk8L3RleHQ+PC9nPjxnIGlkPSJlbGVtX04iPjxwYXRoIGQ9Ik0xNzEsMTg4LjE3NjkgTDE3MSwyMTMuMzA5NyBBMCwwIDAgMCAwIDE3MSwyMTMuMzA5NyBMMzMyLDIxMy4zMDk3IEEwLDAgMCAwIDAgMzMyLDIxMy4zMDk3IEwzMzIsMTk4LjE3NjkgTDMyMiwxODguMTc2OSBMMjQ2LjczLDE4OC4xNzY5IEwxODQuNjgsMTA4LjkzNjkgTDIzOC43MywxODguMTc2OSBMMTcxLDE4OC4xNzY5IEEwLDAgMCAwIDAgMTcxLDE4OC4xNzY5ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTMyMiwxODguMTc2OSBMMzIyLDE5OC4xNzY5IEwzMzIsMTk4LjE3NjkgTDMyMiwxODguMTc2OSAiIGZpbGw9IiNGRUZGREQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0MCIgeD0iMTc3IiB5PSIyMDUuMjQzOCI+TW92ZUJlaGF2aW9yLm1vdmUoKTwvdGV4dD48L2c+PCEtLWxpbmsgVmVoaWNsZSB0byBNb3ZlQmVoYXZpb3ItLT48ZyBpZD0ibGlua19WZWhpY2xlX01vdmVCZWhhdmlvciI+PHBhdGggY29kZUxpbmU9IjE0IiBkPSJNMTM4LjMyLDEwOC45MzY5IEMxMjYuMDQsMTI1LjYyNjkgMTEwLjksMTQ2LjIwNjkgOTguMTMsMTYzLjU0NjkgIiBmaWxsPSJub25lIiBpZD0iVmVoaWNsZS10by1Nb3ZlQmVoYXZpb3IiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9Ijk0LjYsMTY3LjM0NjksMTAzLjE1MDEsMTYyLjQ1ODYsOTcuNTU4NywxNjMuMzE2Miw5Ni43MDExLDE1Ny43MjQ3LDk0LjYsMTY3LjM0NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tU1JDPVtBeWFpb0tiTFM0YWpJQ3JCSVNyQmhrSllJaXY5QjJ2TTI0bERvNG02b2JIcEFHMTFSZHZQZ2VPbGE3MUFwS1dpb3ltbHFrSWd2VUJBcDJqOUJLZkJKNHZMRzlQMnJXOU1iZlRWYWdnV1hBbjQzb0FmZjkxT2hFMzduR01wSXFfRjNpS2FQMWNXRVcwMF0tLT48L2c+PC9zdmc+"><h2 id="面向对象设计的-SOLID-原则"><a href="#面向对象设计的-SOLID-原则" class="headerlink" title="面向对象设计的 SOLID 原则"></a>面向对象设计的 SOLID 原则</h2><table><thead><tr><th>缩写</th><th>全名</th><th>中文</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr></tbody></table><h3 id="SRP-单一责任原则"><a href="#SRP-单一责任原则" class="headerlink" title="SRP 单一责任原则"></a>SRP 单一责任原则</h3><p>当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是<mark style="background: #FF5582A6;">让一个类只做一种类型责任</mark>，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</p><h3 id="OCP-开放封闭原则"><a href="#OCP-开放封闭原则" class="headerlink" title="OCP 开放封闭原则"></a>OCP 开放封闭原则</h3><p>软件实体应该是<mark style="background: #FF5582A6;">可扩展，而不可修改的</mark>。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。</p><h3 id="LSP-里氏替换原则"><a href="#LSP-里氏替换原则" class="headerlink" title="LSP 里氏替换原则"></a>LSP 里氏替换原则</h3><p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有 is-A 关系</p><h3 id="DIP-依赖倒置原则"><a href="#DIP-依赖倒置原则" class="headerlink" title="DIP 依赖倒置原则"></a>DIP 依赖倒置原则</h3><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ol><h3 id="ISP-接口分离原则"><a href="#ISP-接口分离原则" class="headerlink" title="ISP 接口分离原则"></a>ISP 接口分离原则</h3><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用<mark style="background: #FF5582A6;">多个专门的接口比使用单一的总接口总要好</mark>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/java/java-ji-chu/java-ji-chu/"/>
      <url>/java/java-ji-chu/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java 基础date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 基础</code></pre><h2 id="Java技术体系所包括的内容"><a href="#Java技术体系所包括的内容" class="headerlink" title="Java技术体系所包括的内容"></a>Java技术体系所包括的内容</h2><p><img src="/attachment/503cfa9d59fc3cd8b415fd8f6a5b41c4.png"></p><h2 id="【Java-基础】-面向对象"><a href="#【Java-基础】-面向对象" class="headerlink" title="【Java 基础】 面向对象"></a>【Java 基础】 面向对象</h2><p>undefined</p><h2 id="【Java-基础】数据类型"><a href="#【Java-基础】数据类型" class="headerlink" title="【Java 基础】数据类型"></a>【Java 基础】数据类型</h2><p>undefined</p><h2 id="【Java-基础】-泛型"><a href="#【Java-基础】-泛型" class="headerlink" title="【Java 基础】 泛型"></a>【Java 基础】 泛型</h2><p>undefined</p><h2 id="【Java-基础】-注解"><a href="#【Java-基础】-注解" class="headerlink" title="【Java 基础】 注解"></a>【Java 基础】 注解</h2><p>undefined</p><h2 id="【Java-基础】-反射"><a href="#【Java-基础】-反射" class="headerlink" title="【Java 基础】 反射"></a>【Java 基础】 反射</h2><p>undefined</p><h2 id="【Java-基础】-异常"><a href="#【Java-基础】-异常" class="headerlink" title="【Java 基础】 异常"></a>【Java 基础】 异常</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】数据类型</title>
      <link href="/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/"/>
      <url>/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】数据类型"><a href="#【Java-基础】数据类型" class="headerlink" title="【Java 基础】数据类型"></a>【Java 基础】数据类型</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】数据类型date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/数据类型categories:  - Javakeywords:  - Java/基础  - 数据类型description: 数据类型</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h4 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h4><ol><li>可以缓存 hash 值</li><li>String Pool 的需要</li><li>安全性</li><li>线程安全</li></ol><h4 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h4><ol><li>可变性</li></ol><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><ol start="2"><li>线程安全</li></ol><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><pre><code class="line-numbers language-java">public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable {}</code></pre><h3 id="Equals"><a href="#Equals" class="headerlink" title="Equals()"></a>Equals()</h3><h4 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h4><p><strong>自反性</strong><br><strong>对称性</strong><br><strong>传递性</strong><br><strong>一致性</strong><br><strong>与 null 的比较</strong></p><h4 id="equals-与-x3D-x3D"><a href="#equals-与-x3D-x3D" class="headerlink" title="equals() 与 =="></a>equals() 与 ==</h4><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 <code>@</code> 后面的数值为散列码的无符号十六进制表示。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><h4 id="cloneable"><a href="#cloneable" class="headerlink" title="cloneable"></a>cloneable</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>拷贝对象和原始对象的引用类型引用不同对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/language/java/java-ji-chu/java-ji-chu/"/>
      <url>/language/java/java-ji-chu/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Java 基础date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 基础</code></pre><h2 id="【Java-基础】-面向对象"><a href="#【Java-基础】-面向对象" class="headerlink" title="【Java 基础】 面向对象"></a>【Java 基础】 面向对象</h2><p>undefined</p><h2 id="【Java-基础】数据类型"><a href="#【Java-基础】数据类型" class="headerlink" title="【Java 基础】数据类型"></a>【Java 基础】数据类型</h2><p>undefined</p><h2 id="【Java-基础】-泛型"><a href="#【Java-基础】-泛型" class="headerlink" title="【Java 基础】 泛型"></a>【Java 基础】 泛型</h2><p>undefined</p><h2 id="【Java-基础】-注解"><a href="#【Java-基础】-注解" class="headerlink" title="【Java 基础】 注解"></a>【Java 基础】 注解</h2><p>undefined</p><h2 id="【Java-基础】-反射"><a href="#【Java-基础】-反射" class="headerlink" title="【Java 基础】 反射"></a>【Java 基础】 反射</h2><p>undefined</p><h2 id="【Java-基础】-异常"><a href="#【Java-基础】-异常" class="headerlink" title="【Java 基础】 异常"></a>【Java 基础】 异常</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】数据类型</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="【Java-基础】数据类型"><a href="#【Java-基础】数据类型" class="headerlink" title="【Java 基础】数据类型"></a>【Java 基础】数据类型</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 基础】数据类型date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/数据类型categories:  - Javakeywords:  - Java/基础  - 数据类型description: 数据类型</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h4 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h4><ol><li>可以缓存 hash 值</li><li>String Pool 的需要</li><li>安全性</li><li>线程安全</li></ol><h4 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h4><ol><li>可变性</li></ol><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><ol start="2"><li>线程安全</li></ol><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><pre><code class="line-numbers language-java">public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable {}</code></pre><h3 id="Equals"><a href="#Equals" class="headerlink" title="Equals()"></a>Equals()</h3><h4 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h4><p><strong>自反性</strong><br><strong>对称性</strong><br><strong>传递性</strong><br><strong>一致性</strong><br><strong>与 null 的比较</strong></p><h4 id="equals-与-x3D-x3D"><a href="#equals-与-x3D-x3D" class="headerlink" title="equals() 与 =="></a>equals() 与 ==</h4><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 <code>@</code> 后面的数值为散列码的无符号十六进制表示。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><h4 id="cloneable"><a href="#cloneable" class="headerlink" title="cloneable"></a>cloneable</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>拷贝对象和原始对象的引用类型引用不同对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/java/java/"/>
      <url>/java/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Javadate: 2022-12-14 14:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</code></pre><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><p>undefined</p><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><p>undefined</p><h2 id="Java-多线程并发"><a href="#Java-多线程并发" class="headerlink" title="Java 多线程并发"></a>Java 多线程并发</h2><p>undefined</p><h2 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java JVM"></a>Java JVM</h2><p>undefined</p><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/language/java/java/"/>
      <url>/language/java/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Javadate: 2022-12-14 14:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</code></pre><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><p>undefined</p><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><p>undefined</p><h2 id="Java-多线程并发"><a href="#Java-多线程并发" class="headerlink" title="Java 多线程并发"></a>Java 多线程并发</h2><p>undefined</p><h2 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java JVM"></a>Java JVM</h2><p>undefined</p><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解 -Assertions 断言</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-assertions-duan-yan/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-assertions-duan-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter-组件详解-Assertions-断言"><a href="#JMeter-组件详解-Assertions-断言" class="headerlink" title="JMeter 组件详解 -Assertions 断言"></a>JMeter 组件详解 -Assertions 断言</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeter 组件详解 -Assertions 断言date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/断言categories:  - JMeterkeywords:  - JMeter  - 组件  - 断言description: 断言用于对采样器执行额外的检查，并在相同范围内的每个采样器之后进行处理。要确保Assertion只应用于特定的采样器，请将其添加为该采样器的子元素。</code></pre><h2 id="Assertions-断言"><a href="#Assertions-断言" class="headerlink" title="Assertions | 断言"></a>Assertions | 断言</h2><p>断言用于对采样器执行额外的检查，并在相同范围内的每个采样器之后进行处理。要确保Assertion只应用于特定的采样器，请将其添加为该采样器的子元素。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:除非另有说明，断言不应用于子样本(子样本)—只应用于父样本。对于JSR223和BeanShell断言，脚本可以使用prev.getSubResults()方法检索子示例，该方法返回一个samplerresults数组。如果没有，则数组为空。</p></div><p>断言可以应用于主样例、子样例，也可以同时应用于两者。默认情况是只对主示例应用断言。如果Assertion支持此选项，那么GUI上会出现如下条目:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C43dcd57acadeb98ecb2d1d0e5096a5e3.png" alt></p></div><p>如果子采样器失败而主样本成功，则主样本将被设置为失败状态，并将添加断言结果。如果使用了JMeter变量选项，则假定它与主示例有关，任何失败都将只应用于主示例。</p><h3 id="Response-Assertion-响应断言"><a href="#Response-Assertion-响应断言" class="headerlink" title="Response Assertion | 响应断言"></a>Response Assertion | 响应断言</h3><p>响应断言控制面板允许您添加模式字符串，以便与请求或响应的各种字段进行比较。模式字符串是:</p><ul><li><code>Contains, Matches</code>: Perl5-style正则表达式</li><li><code>Equals, Substring</code>: 纯文本,区分大小写</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cd48cec173c79631705b5dc72f79918af.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Apply to:</td><td>这是用于可以生成子样本的采样器，例如带有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。</td><td>Yes</td></tr><tr><td>Field to Test</td><td>指示JMeter测试请求或响应的哪个字段。</td><td>Yes</td></tr><tr><td>Ignore status</td><td>指示JMeter将初始状态设置为成功。</td><td>Yes</td></tr><tr><td>Pattern Matching Rules</td><td>指示如何根据模式检查被测试的文本。</td><td>Yes</td></tr><tr><td>Patterns to Test</td><td>要测试的模式列表。每个模式都是单独测试的。如果一个模式失败，则不会检查其他模式。使用多个模式设置一个断言与使用每个模式设置多个断言之间没有区别(假设其他选项相同)。</td><td>Yes</td></tr><tr><td>Custom failure message</td><td>允许您定义将替换生成的失败消息的失败消息</td><td>No</td></tr></tbody></table></div><h3 id="Duration-Assertion-断言持续时间"><a href="#Duration-Assertion-断言持续时间" class="headerlink" title="Duration Assertion | 断言持续时间"></a>Duration Assertion | 断言持续时间</h3><p>持续时间断言测试是否在给定的时间内收到每个响应。任何超过给定毫秒数(由用户指定)的响应都被标记为失败的响应。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6848b3fb438834313ee585358d5ea3d7.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Duration in Milliseconds</td><td>在被标记为失败之前，允许每个响应的最大毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Size-Assertion-大小断言"><a href="#Size-Assertion-大小断言" class="headerlink" title="Size Assertion | 大小断言"></a>Size Assertion | 大小断言</h3><p>大小断言测试每个响应中包含正确的字节数。可以指定大小等于、大于、小于或不等于给定字节数。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C16813019eccbc6c7461bd5122168683f.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Size in bytes</td><td>用于测试响应大小(或JMeter变量的值)的字节数。</td><td>Yes</td></tr><tr><td>Type of Comparison</td><td>是否测试响应是否等于、大于、小于或不等于指定的字节数。</td><td>Yes</td></tr></tbody></table></div><h3 id="XML-Assertion-XML-断言"><a href="#XML-Assertion-XML-断言" class="headerlink" title="XML Assertion | XML 断言"></a>XML Assertion | XML 断言</h3><p>XML断言测试响应数据由形式上正确的XML文档组成。它不基于DTD或模式验证XML，也不做任何进一步的验证。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C813fb287b364bfa545c3d3a8ec1c060a.png" alt></p></div><h3 id="BeanShell-Assertion-BeanShell-断言"><a href="#BeanShell-Assertion-BeanShell-断言" class="headerlink" title="BeanShell Assertion | BeanShell 断言"></a>BeanShell Assertion | BeanShell 断言</h3><p>BeanShell断言允许用户使用BeanShell脚本执行断言检查。</p><p>请注意，在测试脚本的每个线程中，断言的每个独立出现都使用不同的解释器，但后续调用使用相同的解释器。这意味着变量将在对断言的调用之间持久化。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C39526932dc308f283bd5884807864725.png" alt></p></div><h3 id="MD5Hex-Assertion-MD5Hex-断言"><a href="#MD5Hex-Assertion-MD5Hex-断言" class="headerlink" title="MD5Hex Assertion | MD5Hex 断言"></a>MD5Hex Assertion | MD5Hex 断言</h3><p>MD5Hex断言允许用户检查响应数据的MD5哈希值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca12d5ee2fc45124ba60f1b43f18685fc.png" alt></p></div><h3 id="HTML-Assertion-HTML-断言"><a href="#HTML-Assertion-HTML-断言" class="headerlink" title="HTML Assertion | HTML 断言"></a>HTML Assertion | HTML 断言</h3><p>HTML断言允许用户使用JTidy检查响应数据的HTML语法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C2526877b0515200861c2c2950455cca9.png" alt></p></div><h3 id="XPath-Assertion-XPath-断言"><a href="#XPath-Assertion-XPath-断言" class="headerlink" title="XPath Assertion | XPath 断言"></a>XPath Assertion | XPath 断言</h3><p>XPath断言测试文档的格式是否良好，可以根据DTD进行验证，也可以通过JTidy对文档进行XPath测试。如果XPath存在，断言为真。使用“<code>/</code>”将匹配任何格式良好的文档，并且是默认的XPath表达式。该断言还支持布尔表达式，如“<code>count(//*error)=2</code>”。有关XPath的更多信息，请参见<a href="http://www.w3.org/TR/xpath%E3%80%82">http://www.w3.org/TR/xpath。</a></p><h3 id="Compare-Assertion-比较断言"><a href="#Compare-Assertion-比较断言" class="headerlink" title="Compare Assertion | 比较断言"></a>Compare Assertion | 比较断言</h3><p>比较断言可用于在其范围内比较样本结果。可以比较内容或运行时间，并且可以在比较之前过滤内容。可以在比较断言可视化工具中看到断言比较。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C837dc552d4a8b425c36abd68d45351ac.png" alt></p></div><h3 id="JSON-Assertion-JSON-断言"><a href="#JSON-Assertion-JSON-断言" class="headerlink" title="JSON Assertion | JSON 断言"></a>JSON Assertion | JSON 断言</h3><p>该组件允许您执行JSON文档的验证。首先，它将解析JSON，如果数据不是JSON，则会失败。其次，它将搜索指定的路径，使用来自Jayway JsonPath 1.2.0的语法。如果没有找到路径，它将失败。第三，如果在文档中找到了JSON路径，并且请求对预期值进行验证，它将执行验证。对于空值，GUI中有一个特殊的复选框。注意，如果路径将返回数组对象，则将对其进行迭代，如果找到预期值，则断言将成功。要验证空数组，请使用<code>[]</code>string。此外，如果patch将返回字典对象，它将在比较之前被转换为字符串。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ccbc9c846557f6aa5e44884c749538fd3.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/断言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Listeners 监听器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter-组件详解-Listeners-监听器"><a href="#JMeter-组件详解-Listeners-监听器" class="headerlink" title="JMeter 组件详解-Listeners 监听器"></a>JMeter 组件详解-Listeners 监听器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeter 组件详解-Listeners 监听器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/监听器categories:  - JMeterkeywords:  - JMeter  - 组件  - 监听器description: 监听结果，还提供了查看、保存和读取保存的测试结果的方法。</code></pre><h2 id="Listeners-监听器"><a href="#Listeners-监听器" class="headerlink" title="Listeners | 监听器"></a>Listeners | 监听器</h2><p>除了”听”测试结果之外，大多数监听器还扮演着几个角色。它们还提供了查看、保存和读取保存的测试结果的方法。</p><p>注意，侦听器在找到它们的范围的末尾处理。</p><p>测试结果的保存和读取是通用的。各种侦听器都有一个面板，可以通过该面板指定将结果写入(或读取)的文件。默认情况下，结果存储为XML文件，通常带有 <code>.jtl</code> 扩展。将其存储为CSV是最有效的选项，但没有XML(另一种可用选项)详细。</p><p><strong>侦听器不会在CLI模式下处理示例数据，但是如果配置了输出文件，则会保存原始数据。</strong>为了分析CLI运行生成的数据，您需要将文件加载到适当的Listener中。</p><blockquote><p>要读取现有结果并显示它们，请使用文件面板Browse按钮打开文件。</p></blockquote><p>如果您想在加载一个新文件之前清除任何当前数据，请在加载文件之前使用菜单项<code>Run→clear (Ctrl + Shift + E)</code>或<code>Run→clear All (Ctrl + E)</code>。</p><p>结果可以从XML或CSV格式文件中读取。当读取CSV结果文件时，使用头(如果存在)来确定存在哪些字段。为了正确地解释<code>无头CSV</code>文件，必须在<code>jmeter.properties</code>中设置适当的属性。</p><p><strong>如果样本很多，监听器会占用大量内存</strong>。为尽量减少所需的内存，请使用<code>Simple Data Writer</code>，并使用<code>CSV</code>格式。</p><h3 id="Simple-Data-Writer-简单数据写入器"><a href="#Simple-Data-Writer-简单数据写入器" class="headerlink" title="Simple Data Writer | 简单数据写入器"></a>Simple Data Writer | 简单数据写入器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3d0ba23ab6cc18a90fd6043e33bda676.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Filename</td><td>包含示例结果的文件的名称。可以使用相对路径名或绝对路径名指定文件名。相对路径是相对于当前工作目录解析的(默认为bin/目录)。JMeter还支持相对于包含当前测试计划(JMX文件)的目录的路径。如果路径名以”~/“(或jmeter.save.saveservice。base_prefix JMeter属性)，则假定路径相对于JMX文件位置。</td><td>No</td></tr><tr><td>Browse</td><td>文件浏览按钮</td><td>No</td></tr><tr><td>Errors</td><td>选择此选项将导致只写/读的结果带有错误</td><td>No</td></tr><tr><td>Success</td><td>选择这个选项，只写/读结果，不出错。如果既没有选择Errors也没有选择successful，那么将处理所有结果。</td><td>No</td></tr><tr><td>Configure</td><td>配置按钮，参见下面</td><td>No</td></tr></tbody></table><h3 id="Graph-Results-图结果"><a href="#Graph-Results-图结果" class="headerlink" title="Graph Results  | 图结果"></a>Graph Results  | 图结果</h3><blockquote><p>图结果绝对不能在负载测试期间使用，因为它会消耗大量资源(内存和CPU)。只在功能测试或测试计划调试和验证期间使用它。</p></blockquote><p>Graph Results侦听器生成一个简单的图来绘制所有样本时间。在图的底部，以毫秒为单位显示当前样本(黑色)、所有样本的当前平均值(蓝色)、当前标准差(红色)和当前吞吐量率(绿色)。</p><p>吞吐量数字表示服务器每分钟处理的实际请求数。这个计算包括您添加到测试中的任何延迟和JMeter自己的内部处理时间。这样计算的好处是，这个数字代表真实的东西—您的服务器所在的东西</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C70bba1717e63c269deee6df4487e92de.png" alt></p></div><p>下表简要描述了图表中的项目。关于统计术语的精确含义的进一步细节可以在网上找到，如维基百科，或通过查阅统计书籍。</p><p>Data - 绘制实际数据值<br>Average - 绘制平均值<br>Median - 绘制中位数(中间值)<br>Deviation - 绘制标准差(一种变化的度量)<br>Throughput - 绘制出单位时间内的样本数量</p><h3 id="Assertion-Results-断言结果"><a href="#Assertion-Results-断言结果" class="headerlink" title="Assertion Results | 断言结果"></a>Assertion Results | 断言结果</h3><blockquote><p>在负载测试期间绝对不能使用断言结果，因为它会消耗大量资源(内存和CPU)。只在功能测试或测试计划调试和验证期间使用它。</p></blockquote><p>Assertion Results可视化工具显示每个样本的Label。它还报告测试计划中任何断言的失败。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C65fc9b6fb51159cbd447672860b3b5f3.png" alt></p></div><h3 id="View-Results-Tree-查看结果树"><a href="#View-Results-Tree-查看结果树" class="headerlink" title="View Results Tree | 查看结果树"></a>View Results Tree | 查看结果树</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C331167fcf04e16b77e624fa176f61cb5.png" alt></p></div><p>视图结果树显示所有示例响应的树，允许您查看任何示例的响应。除了显示响应之外，您还可以看到获取此响应所需的时间和一些响应代码。请注意，请求面板只显示JMeter添加的标题。它不显示HTTP协议实现可能添加的任何报头(如Host)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Renderer</th><th>Description</th></tr></thead><tbody><tr><td>CSS/JQuery Tester</td><td>CSS/JQuery测试器只适用于文本响应。它在上面的面板中显示纯文本。"测试"按钮允许用户将CSS/JQuery应用到上面的面板，结果将显示在下面的面板。CSS/JQuery表达式引擎可以是JSoup或Jodd，这两种实现的语法略有不同。&lt;/br&gt; 例如，将href属性应用到当前JMeter函数页面的Selector a[class=sectionlink]会给出如下输出: &lt;/br&gt; Match count: 74 &lt;/br&gt; Match[1]=<code>#functions</code> &lt;/br&gt; Match[2]=<code>#what_can_do</code> &lt;/br&gt; Match[3]=<code>#where</code> &lt;/br&gt; Match[4]=<code>#how</code> &lt;/br&gt; Match[5]=<code>#function_helper</code> &lt;/br&gt; Match[6]=<code>#functions</code> &lt;/br&gt; Match[7]=<code>#__regexFunction</code> Match[8]=<code>#__regexFunction_parms</code> &lt;/br&gt; Match[9]=<code>#__counter</code> &lt;/br&gt; … and so on …</td></tr><tr><td>Document</td><td>文档视图将显示从各种类型的文档中提取的文本，如Microsoft Office(Word, Excel, PowerPoint 97-2003, 2007-2010 (openxml)， Apache OpenOffice (writer, calc, impress)， HTML, gzip, jar/zip文件(内容列表)，以及一些"多媒体"文件的元数据，如mp3, mp4, flv等。完整的支持格式列表可以在Apache Tika格式页面上找到。&lt;/br&gt; &gt; Document视图的一个要求是下载Apache Tika二进制包(Tika -app-x.x.jar)，并将其放在JMETER_HOME/lib目录中。&lt;/br&gt;如果文档大于10mb，则不显示。要更改此限制，请设置JMeter属性文档。Max_size(单位为字节)或设置为0以删除限制。</td></tr><tr><td>HTML</td><td>HTML视图试图将响应呈现为HTML。渲染的HTML很可能比较差，一个人会在任何web浏览器获得的视图;然而，它确实提供了一个快速的近似值，有助于初步结果的评估。不下载图像、样式表等。</td></tr><tr><td>HTML (download resources)</td><td>如果选择了 HTML（下载资源）视图选项，则渲染器可以下载 HTML 代码引用的图像、样式表等。</td></tr><tr><td>HTML Source formatted</td><td>如果选择了 HTML Source formatted view 选项，渲染器将显示由 Jsoup 格式化和清理的 HTML 源代码。</td></tr><tr><td>JSON</td><td>JSON 视图将以树形样式显示响应（也处理嵌入在 JavaScript 中的 JSON）。</td></tr><tr><td>JSON Path Tester</td><td>JSON Path Tester 视图将让您测试您的 JSON-PATH 表达式并查看从特定响应中提取的数据。</td></tr><tr><td>JSON JMESPath Tester</td><td>JSON JMESPath Tester 视图将让您测试 JMESPath 表达式并查看从特定响应中提取的数据。</td></tr><tr><td>Regexp Tester</td><td>Regexp Tester 视图仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将正则表达式应用到上面板，结果将显示在下面板中。 正则表达式引擎与正则表达式提取器中使用的引擎相同。 例如，应用于当前 JMeter 主页的 <code>RE (JMeter\w*).*</code> 会给出以下输出： &lt;/br&gt; <code>Match count: 26</code> &lt;/br&gt; <code>Match[1][0]=JMeter - Apache JMeter &lt;/title&gt;</code> &lt;/br&gt; <code>Match[1][1]=JMeter</code> &lt;/br&gt; <code>Match[2][0]=JMeter" title="JMeter" border="0"&gt;&lt;/a&gt;</code> &lt;/br&gt; <code>Match[2][1]=JMeter</code> &lt;/br&gt; <code>Match[3][0]=JMeterCommitters"&gt;Contributors&lt;/a&gt;</code> &lt;/br&gt; <code>Match[3][1]=JMeterCommitters</code> &lt;/br&gt;… and so on … &lt;/br&gt; []中的第一个数字是匹配号； 第二个数字是组。 组 [0] 是与整个 RE 匹配的任何内容。 组 [1] 是与第一组匹配的任何内容，即在这种情况下为 <code>(JMeter\w*)</code>。</td></tr><tr><td>Text</td><td>默认文本视图显示响应中包含的所有文本。 请注意，这仅在响应内容类型被视为文本时才有效。 如果 content-type 以下列任何一种开头，则认为是二进制，否则认为是文本。 &lt;/br&gt; image/ &lt;/br&gt; audio/ &lt;/br&gt; video/</td></tr><tr><td>XML</td><td>XML 视图将以树形样式显示响应。 任何 DTD 节点或 Prolog 节点都不会出现在树中； 但是，响应可能包含这些节点。 您可以右键单击任何节点并展开或折叠其下方的所有节点。</td></tr><tr><td>XPath Tester</td><td>XPath 测试器仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将 XPath 查询应用到上面板，结果将显示在下面板中。</td></tr><tr><td>Boundary Extractor Tester</td><td>边界提取器测试器仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将边界提取器查询应用到上面板，结果将显示在下面板中。</td></tr></tbody></table></div><p>使用Search选项，大多数视图还允许搜索显示的数据;搜索结果将在上面的显示中高亮显示。例如下面的控制面板截图显示了搜索”Java”的结果。注意，搜索对可见文本进行操作，因此在搜索text和HTML视图时，您可能会得到不同的结果。</p><p>注意:正则表达式使用Java引擎(而不是像正则表达式提取器或Regexp Tester视图那样的ORO引擎)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_xml.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_regex.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_document.png" alt></p></div><h3 id="Aggregate-Report-汇总报告"><a href="#Aggregate-Report-汇总报告" class="headerlink" title="Aggregate Report | 汇总报告"></a>Aggregate Report | 汇总报告</h3><p>聚合报告为测试中的每个不同名称的请求创建一个表行。对于每个请求，它汇总响应信息，并提供请求计数、最小、最大、平均、错误率、大致吞吐量(请求/秒)和每秒千字节吞吐量。一旦测试完成，吞吐量就是整个测试期间的实际吞吐量。</p><p>吞吐量是从采样器目标的角度计算的(例如，在HTTP采样的情况下，远程服务器)。JMeter会考虑生成请求的总时间。如果其他采样器和计时器在同一个线程中，这将增加总时间，从而降低吞吐量值。所以两个名称不同的相同采样器的吞吐量是两个名称相同的采样器的一半。正确选择采样器名称以从聚合报告中获得最佳结果是很重要的。</p><p>计算中位数和90 % Line(第90百分位)值需要额外的内存。JMeter现在结合了具有相同运行时间的示例，因此使用的内存更少。然而，对于花费超过几秒的样本，概率是更少的样本将有相同的时间，在这种情况下，将需要更多的内存。注意，您可以在之后使用这个侦听器重新加载CSV或XML结果文件，这是避免性能影响的推荐方法。参见摘要报告了解类似的监听器，该监听器不存储单个示例，因此需要固定的内存。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca64d56f2914c2724d59c566b94769543.png" alt></p></div><ul><li><code>Label</code> - 样品的标签。如果选择<code>Include group name in label?</code>，则将线程组的名称作为前缀添加。这允许在需要时分别对来自不同线程组的相同标签进行排序。</li><li><code># Samples</code> - 相同标签的样品数量</li><li><code>Average</code> - 一组结果的平均时间</li><li><code>Median</code> - 中位数是一组结果中间的时间。50 %的样本不超过这次;剩下的至少花了同样长的时间。</li><li><code>90% Line</code> - 90 %的样本不超过这次。剩下的样本至少花了这么长时间。(90)</li><li><code>95% Line</code> - 95 %的样本不超过这次。剩下的样本至少花了这么长时间。(95)</li><li><code>99% Line</code> - 99% %的样本不超过这次。剩下的样本至少花了这么长时间。(99)</li><li><code>Min</code> - 相同标签的样品时间最短</li><li><code>Max</code> - 相同标签的样品时间最长</li><li><code>Error %</code> - 请求错误的百分比</li><li><code>Throughput</code> - 吞吐量以每秒/分钟/小时的请求数来衡量。选择时间单位使显示的速率至少为1.0。当吞吐量被保存到一个CSV文件时，它被表示为请求/秒，即30.0请求/分钟被保存为0.5。</li><li><code>Received KB/sec</code> - 以每秒接收千字节为单位的吞吐量</li><li><code>Sent KB/sec</code> - 以每秒发送千字节为单位的吞吐量</li></ul><p>Times are in milliseconds.</p><h3 id="View-Results-in-Table-用表格查看结果"><a href="#View-Results-in-Table-用表格查看结果" class="headerlink" title="View Results in Table | 用表格查看结果"></a>View Results in Table | 用表格查看结果</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cdc2cf9f66bfeb7ce18f87d258912228a.png" alt></p></div><p>这个可视化工具为每个示例结果创建一行。与View Results Tree一样，这个可视化工具也使用大量内存。</p><p>默认情况下，它只显示主(父)样例;它不显示子样本(子样本)。JMeter有一个”Child Samples?”复选框。如果选中此选项，则显示子样本而不是主样本。</p><h3 id="Simple-Data-Writer-简单数据写入器-1"><a href="#Simple-Data-Writer-简单数据写入器-1" class="headerlink" title="Simple Data Writer | 简单数据写入器"></a>Simple Data Writer | 简单数据写入器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfd590e5f3b82b4b58e0765ca686ad7bd.png" alt></p></div><p>这个侦听器可以将结果记录到文件中，但不能记录到UI中。它旨在通过消除GUI开销来提供记录数据的有效方法。在CLI模式下运行时，可以使用<code>-l</code>标志创建数据文件。要保存的字段是由JMeter属性定义的。看到 <code>jmeter.properties</code> 查看详细信息。</p><h3 id="Aggregate-Graph-汇总图"><a href="#Aggregate-Graph-汇总图" class="headerlink" title="Aggregate Graph | 汇总图"></a>Aggregate Graph | 汇总图</h3><p>聚合图类似于聚合报告。主要的区别是聚合图提供了一种简单的方法来生成条形图并将图保存为PNG文件。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7f01d0b57ce976023f98bd370d6c84c4.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Column settings</td><td>- <code>Columns to display:</code> 选择要在图形中显示的列。 &lt;/br&gt; - <code>Rectangles color:</code> 点击右边的颜色矩形打开一个弹出对话框，为列选择一个自定义的颜色。 &lt;/br&gt; - <code>Foreground color</code> 允许改变值文本颜色。 &lt;/br&gt; - <code>Value font:</code> 允许定义文本的字体设置。 &lt;/br&gt; - <code>Draw outlines bar?</code> 在柱状图上画或不画边线 &lt;/br&gt; - <code>Show number grouping?</code> 是否显示Y轴标签中的数字分组。 &lt;/br&gt;  - <code>Value labels vertical?</code> 更改值标签的方向。(默认是水平) &lt;/br&gt; - <code>Column label selection:</code> 根据结果标签进行筛选。可以使用正则表达式，例如: <code>.*Transaction.*</code> 在显示图形之前，单击<code>Apply filter</code>按钮以刷新内部数据。</td><td>Yes</td></tr><tr><td>Title</td><td>在图表的头部定义图表的标题。空值为默认值:"聚合图"。Synchronize with name按钮用监听器的标签定义标题。并定义图形标题的字体设置</td><td>No</td></tr><tr><td>Graph size</td><td>根据当前JMeter窗口大小的宽度和高度计算图形大小。使用宽度和高度字段定义自定义大小。单位为像素。</td><td>No</td></tr><tr><td>X Axis settings</td><td>定义X轴标签的最大长度(像素)。</td><td>No</td></tr><tr><td>Y Axis settings</td><td>为Y轴定义一个自定义最大值。</td><td>No</td></tr><tr><td>Legend</td><td>定义图表图例的位置和字体设置</td><td>Yes</td></tr></tbody></table></div><h3 id="Response-Time-Graph-响应时间图"><a href="#Response-Time-Graph-响应时间图" class="headerlink" title="Response Time Graph | 响应时间图"></a>Response Time Graph | 响应时间图</h3><p>响应时间图绘制了一个折线图，显示了测试期间每个标记的请求响应时间的演变。如果同一时间戳存在多个样本，则显示平均值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cad233a5e67ca717331f26c4c3033e4d6.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Interval (ms)</td><td>X轴间隔的时间，以毫秒为单位。样本根据这个值分组。在显示图形之前，单击应用间隔按钮来刷新内部数据。</td><td>Yes</td></tr><tr><td>Sampler label selection</td><td>根据结果标签进行筛选。可以使用正则表达式，例如:<code>*Transaction.*</code>。在显示图形之前，单击Apply filter按钮以刷新内部数据。</td><td>No</td></tr><tr><td>Title</td><td>在图表的头部定义图表的标题。空值为默认值:"响应时间图"。Synchronize with name按钮用监听器的标签定义标题。并定义图形标题的字体设置</td><td>No</td></tr><tr><td>Line settings</td><td>定义线的宽度。定义每个值点的类型。选择none将有一条没有标记的线</td><td>Yes</td></tr><tr><td>Graph size</td><td>根据当前JMeter窗口大小的宽度和高度计算图形大小。使用宽度和高度字段定义自定义大小。单位为像素。</td><td>No</td></tr><tr><td>X Axis settings</td><td>定制X轴标签的日期格式。语法是Java SimpleDateFormat API。</td><td>No</td></tr><tr><td>Y Axis settings</td><td>以毫秒为单位定义Y轴的自定义最大值。显示或不显示Y轴标签中的数字分组。</td><td>No</td></tr><tr><td>Legend</td><td>定义图表图例的位置和字体设置</td><td>Yes</td></tr></tbody></table></div><h3 id="Summary-Report-汇总报告"><a href="#Summary-Report-汇总报告" class="headerlink" title="Summary Report | 汇总报告"></a>Summary Report | 汇总报告</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb55b93e85bb21e37fd31f53c9422e9fb.png" alt></p></div><p>摘要报告为测试中的每个不同名称的请求创建一个表行。这类似于聚合报告，只是它使用更少的内存。</p><p>吞吐量是从采样器目标的角度计算的(例如，在HTTP采样的情况下，远程服务器)。JMeter会考虑生成请求的总时间。如果其他采样器和计时器在同一个线程中，这将增加总时间，从而降低吞吐量值。所以两个名称不同的相同采样器的吞吐量是两个名称相同的采样器的一半。正确选择取样器标签是很重要的，以便从报告中得到最好的结果。</p><ul><li><code>Label</code> - 样品的标签。如果选择<code>Include group name in label?</code>，则将线程组的名称作为前缀添加。这允许在需要时分别对来自不同线程组的相同标签进行排序。</li><li><code># Samples</code> - 相同标签的样品数量</li><li><code>Average</code> - 一组结果的平均时间</li><li><code>Min</code> - 相同标签的样品时间最短</li><li><code>Max</code> - 相同标签的样品时间最长</li><li><code>Std. Dev.</code> - 样本运行时间的标准偏差</li><li><code>Error %</code> - 请求错误的百分比</li><li><code>Throughput</code> - 吞吐量以每秒/分钟/小时的请求数来衡量。选择时间单位使显示的速率至少为1.0。当吞吐量被保存到一个CSV文件时，它被表示为请求/秒，即30.0请求/分钟被保存为0.5。</li><li><code>Received KB/sec</code> - 以每秒接收千字节为单位的吞吐量</li><li><code>Sent KB/sec</code> - 以每秒发送千字节为单位的吞吐量</li><li><code>Avg. Bytes</code> - 样本响应的平均大小(以字节为单位)。</li></ul><h3 id="Save-Responses-to-a-file-保存响应到文件"><a href="#Save-Responses-to-a-file-保存响应到文件" class="headerlink" title="Save Responses to a file | 保存响应到文件"></a>Save Responses to a file | 保存响应到文件</h3><p>这个测试元素可以放置在测试计划中的任何地方。对于其范围内的每个示例，它将创建一个响应Data文件。它的主要用途是创建功能测试，但当响应太大而无法在”视图结果树侦听器”中显示时，它也很有用。文件名是从指定的前缀加上一个数字创建的(除非禁用了这个前缀，请参阅下面的内容)。文件扩展名根据文档类型创建(如果已知的话)。如果不知道，文件扩展名设置为’unknown’。如果禁用了编号，并且禁用了添加后缀，那么文件前缀将被用作整个文件名。这允许在需要时生成一个固定的文件名。生成的文件名存储在示例响应中，如果需要，可以保存在测试日志输出文件中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb01b3cb405edec2c42945587bbc5a86a.png" alt></p></div><h3 id="Generate-Summary-Results-生成概要结果"><a href="#Generate-Summary-Results-生成概要结果" class="headerlink" title="Generate Summary Results | 生成概要结果"></a>Generate Summary Results | 生成概要结果</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7f24cca56183626429571f7c033363ca.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/监听器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Post-Processors 后置处理器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter-组件详解-Post-Processors-后置处理器"><a href="#JMeter-组件详解-Post-Processors-后置处理器" class="headerlink" title="JMeter 组件详解-Post-Processors 后置处理器"></a>JMeter 组件详解-Post-Processors 后置处理器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeter 组件详解-Post-Processors 后置处理器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/处理器categories:  - JMeterkeywords:  - JMeter  - 组件  - 处理器description: 后处理器应用于采样器之后。请注意，它们应用于相同范围内的所有采样器，因此要确保后处理器只应用于特定的采样器，请将其添加为该采样器的子级。</code></pre><h2 id="Post-Processors-后置处理器"><a href="#Post-Processors-后置处理器" class="headerlink" title="Post Processors | 后置处理器"></a>Post Processors | 后置处理器</h2><p>顾名思义，后处理器应用于采样器之后。请注意，它们应用于相同范围内的所有采样器，因此要确保后处理器只应用于特定的采样器，请将其添加为该采样器的子级。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:除非另有说明，否则后处理程序不会应用于子样本(子样本)-只适用于父样本。对于JSR223和BeanShell后处理器，脚本可以使用prev.getSubResults()方法检索子示例，该方法返回一个samplerresults数组。如果没有，则数组为空。</p></div><p>后处理器在断言之前运行，因此它们不能访问任何断言结果，示例状态也不能反映任何断言的结果。如果您需要访问断言结果，请尝试使用侦听器。还要注意变量JMeterThread。在运行所有断言之后，last_sample_ok设置为“true”或“false”。</p><h3 id="Regular-Expression-Extractor-正则表达式提取器"><a href="#Regular-Expression-Extractor-正则表达式提取器" class="headerlink" title="Regular Expression Extractor | 正则表达式提取器"></a>Regular Expression Extractor | 正则表达式提取器</h3><p>允许用户使用perl类型的正则表达式从服务器响应中提取值。作为一个后处理器，该元素将在其范围内的每个Sample请求之后执行，应用正则表达式，提取请求的值，生成模板字符串，并将结果存储到给定的变量名中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C63a8726b7e5b75834e0dcefadfce8b6a.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称</td><td>No</td></tr><tr><td>Apply to:</td><td>这是用于可以生成子样本的采样器，例如带有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。</td><td>Yes</td></tr><tr><td>Field to check</td><td><code>Body</code>  <code>Body (unescaped)</code> <code>Body as a Document</code>   <code>Request Headers</code>        <code>Response Headers</code>   <code>URL</code>   <code>Response Code</code>  <code>Response Message</code></td><td>Yes</td></tr><tr><td>Name of created variable</td><td>要在其中存储结果的JMeter变量的名称。还要注意，每个组都存储为<code>[refname]_g#</code>，其中<code>[refname]</code>是作为引用名输入的字符串，<code>#</code>是组号，其中<code>组0</code>是整个匹配，<code>组1</code>是来自第一组圆括号的匹配，等等。</td><td>Yes</td></tr><tr><td>Regular Expression</td><td>用于解析响应数据的正则表达式。这必须包含至少一组圆括号“()”来捕获字符串的一部分，除非使用组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。不要将表达式包含在/ /中——当然，除非您也想匹配这些字符。</td><td>Yes</td></tr><tr><td>Template</td><td>用于根据找到的匹配项创建字符串的模板。这是一个任意字符串，其中包含用于引用正则表达式中的组的特殊元素。表示组的语法是:'<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>'表示组1，'<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>'表示组2，等等。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>表示整个表达式匹配的任何内容。</td><td>Yes</td></tr><tr><td>Match No. (0 for Random)</td><td>指示要使用哪个匹配。正则表达式可以匹配多次。 -1表示全部</td><td>Yes</td></tr><tr><td>Default Value</td><td>如果正则表达式不匹配，那么引用变量将被设置为默认值。这对于调试测试特别有用。如果没有提供缺省值，那么很难判断是正则表达式不匹配，还是没有处理RE元素，或者可能使用了错误的变量。</td><td>No, but recommended</td></tr><tr><td>Use empty default value</td><td>如果复选框被选中并且默认值为空，那么JMeter将把变量设置为空字符串，而不是不设置它。因此，当你在你的测试计划中使用<code>${var}</code>(如果引用名称是var)时，如果没有找到提取的值，那么<code>${var}</code>将等于空字符串，而不是包含<code>${var}</code>，如果提取的值是可选的，它可能是有用的。</td><td>No</td></tr></tbody></table></div><h3 id="CSS-x2F-JQuery-Extractor-CSS-x2F-JQuery-提取器"><a href="#CSS-x2F-JQuery-Extractor-CSS-x2F-JQuery-提取器" class="headerlink" title="CSS/JQuery Extractor  | CSS/JQuery 提取器"></a>CSS/JQuery Extractor  | CSS/JQuery 提取器</h3><p>允许用户使用CSS选择器语法从服务器HTML响应中提取值。作为一个后处理器，该元素将在其范围内的每个Sample请求之后执行，应用CSS/JQuery表达式，提取被请求的节点，提取节点作为文本或属性值，并将结果存储到给定的变量名中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C11a88c2a90612ebd0679902ccc96a469.png" alt></p></div><h3 id="Result-Status-Action-Handler-结果状态处理器"><a href="#Result-Status-Action-Handler-结果状态处理器" class="headerlink" title="Result Status Action Handler | 结果状态处理器"></a>Result Status Action Handler | 结果状态处理器</h3><p>如果相关的采样器失败，这个test元素允许用户停止线程或整个测试。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5eb30e766f2119f8ff0da88fd90c4cbd.png" alt></p></div><h3 id="JSON-Extractor-JSON-提取器"><a href="#JSON-Extractor-JSON-提取器" class="headerlink" title="JSON Extractor | JSON 提取器"></a>JSON Extractor | JSON 提取器</h3><p>JSON PostProcessor允许您使用JSON- path语法从JSON响应中提取数据。这个后处理器非常类似于正则表达式提取器。它必须被放置为HTTP采样器或任何其他有响应的采样器的子级。它将允许您以非常简单的方式提取文本内容，请参阅JSON路径语法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cae263477a4ba574f58c7dbea086aa0f6.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Configuration 配置元件</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter-组件详解-Configuration-配置元件"><a href="#JMeter-组件详解-Configuration-配置元件" class="headerlink" title="JMeter 组件详解-Configuration 配置元件"></a>JMeter 组件详解-Configuration 配置元件</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeter 组件详解-Configuration 配置元件date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/配置categories:  - JMeterkeywords:  - JMeter  - 组件  - 配置description: 配置元素可用于设置默认值和变量，供采样器稍后使用。注意，这些元素在找到它们的范围的开始处处理，即在同一范围内的任何采样器之前处理。</code></pre><h2 id="Configuration-配置元件"><a href="#Configuration-配置元件" class="headerlink" title="Configuration | 配置元件"></a>Configuration | 配置元件</h2><p>配置元素可用于设置默认值和变量，供采样器稍后使用。注意，这些元素在找到它们的范围的开始处处理，即在同一范围内的任何采样器之前处理。</p><h3 id="CSV-Data-Set-Config-CSV-数据集配置"><a href="#CSV-Data-Set-Config-CSV-数据集配置" class="headerlink" title="CSV Data Set Config | CSV 数据集配置"></a>CSV Data Set Config | CSV 数据集配置</h3><p>CSV数据集配置用于从文件中读取行，并将它们分割为变量。它比<code>__CSVRead()</code>和<code>__StringFromFile()</code>函数更容易使用。它非常适合处理大量变量，并且对于使用”随机”和惟一值进行测试也很有用。</p><p>就CPU和内存而言，在运行时生成唯一的随机值非常昂贵，所以只需在测试之前创建数据。如果有必要，文件中的”随机”数据可以与运行时参数结合使用，从而在每次运行中创建不同的值集——例如使用串联——这比在运行时生成所有值要便宜得多。</p><p>JMeter允许值被引用;这允许值包含分隔符。如果启用了 “<code>allow quoted data</code>“(“允许引用数据”)，值可以用双引号括起来。这些都是删除。要在带引号的字段中包含双引号，请使用两个双引号。</p><p>JMeter支持用标题行定义列名的CSV文件。要启用此功能，请将 “<code>Variable Names</code>“ “变量名称”字段保留为空。必须提供正确的分隔符。</p><p>默认情况下，文件只打开一次，每个线程将使用文件中的不同行。但是，将行传递给线程的顺序取决于它们的执行顺序，这在迭代之间可能会有所不同。在每个测试迭代的开始读取行。在第一次迭代中解析文件名和模式。</p><p>有关其他选项，请参阅下面对共享模式的描述。如果希望每个线程都有自己的一组值，那么需要创建一组文件，每个线程一个文件。例如test1.csv, test2.csv，…，testn.csv。使用文件名<code>test${__threadNum}.csv</code>，将”<code>Sharing mode</code>“(“共享模式”)设置为 “<code>Current thread</code>“(“当前线程”)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cce47f39f5ccee667dcd4f0ef5d3b0baf.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。<br> 要读取的文件的名称。相对文件名根据活动测试计划的路径进行解析。对于分布式测试，CSV文件必须存储在服务器主机系统中启动JMeter服务器的正确相对目录中。也支持绝对文件名，但是请注意，它们不太可能在远程模式下工作，除非远程服务器具有相同的目录结构。如果以两种不同的方式引用同一个物理文件——例如csvdata.txt和./csvdata.txt——那么这些文件将被视为不同的文件。如果操作系统不区分大小写，也会单独打开csvData.TXT。</td><td>Yes</td></tr><tr><td>File Encoding</td><td>用于读取文件的编码，如果不是平台默认值的话。</td><td>No</td></tr><tr><td>Variable Names</td><td>变量名列表。名称必须由分隔符分隔。它们可以用双引号引用。JMeter支持CSV标题行:如果变量名字段为空，那么文件的第一行将被读取并解释为列名列表。</td><td>No</td></tr><tr><td>Use first line as Variable Names</td><td>忽略CSV文件的第一行，它只会在变量名不为空时使用，如果变量名为空，第一行必须包含标题。</td><td>No</td></tr><tr><td>Delimiter</td><td>分隔符，用于分割文件中的记录。如果行上的值比变量的值少，那么剩余的变量将不会更新——因此它们将保留以前的值(如果有的话)。</td><td>Yes</td></tr><tr><td>Allow quoted data?</td><td>CSV文件是否允许值被引用?如果启用，值可以括在 <code>"</code>-双引号-允许值包含分隔符。</td><td>Yes</td></tr><tr><td>Recycle on EOF?</td><td>文件是否应该在到达EOF时从头重新读取?(默认是<code>true</code>的)</td><td>Yes</td></tr><tr><td>Stop thread on EOF?</td><td>如果循环是假的，线程应该停止在EOF ?(默认是假的)</td><td>Yes</td></tr><tr><td>Sharing mode</td><td>- All threads - (the default) 该文件在所有线程之间共享。<br> - Current thread group - 对于出现该元素的每个线程组，每个文件都会打开一次 <br> - Current thread - 每个文件为每个线程分别打开 <br> - Identifier - 共享相同标识符的所有线程共享相同的文件。例如，如果您有4个线程组，您可以为两个或多个组使用一个公共id来在它们之间共享文件。或者可以使用线程号在不同线程组中的相同线程号之间共享文件。</td><td>Yes</td></tr></tbody></table><h3 id="DNS-Cache-Manager-DNS缓存管理器"><a href="#DNS-Cache-Manager-DNS缓存管理器" class="headerlink" title="DNS Cache Manager | DNS缓存管理器"></a>DNS Cache Manager | DNS缓存管理器</h3><p>DNS缓存管理器元素允许测试应用程序，当用户从不同的IP接收内容时，负载均衡器(CDN等)后面有多个服务器。JMeter默认使用JVM DNS缓存。这就是为什么集群中只有一个服务器接收负载的原因。DNS缓存管理器在每次迭代时分别为每个线程解析名称，并将解析结果保存到其内部DNS缓存中，该缓存独立于JVM和OS的DNS缓存。</p><p>静态主机的映射可以用来模拟类似于<code>/etc/hosts</code>文件的内容。这些条目将优先于自定义解析器。如果要使用此映射，必须启用自定义DNS解析器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6a3ba849bb5754e150f44e07fc37eeed.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>DNS缓存管理器设计用于在线程组或测试计划的根目录中使用。不把它作为子元素的特定HTTP采样</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>DNS缓存管理器只适用于使用HTTPClient4实现的HTTP请求。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear cache each Iteration</td><td>如果选中，每次新的迭代开始时，每个线程的DNS缓存都会被清除。</td><td>No</td></tr><tr><td>Use system DNS resolver</td><td>系统DNS解析器将被使用。对于正确的工作编辑 <code>$JAVA_HOME/jre/lib/security/java.security</code> 并且添加 <code>networkaddress.cache.ttl=0</code></td><td>N/A</td></tr><tr><td>Use custom DNS resolver</td><td>将使用自定义DNS解析器(来自dnsjava库)。</td><td>N/A</td></tr><tr><td>Hostname or IP address</td><td>使用的DNS服务器列表。如果为空，则使用网络配置DNS。</td><td>No</td></tr><tr><td>Add Button</td><td>在DNS服务器表中添加一条表项。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Host and Hostname or IP address</td><td>将主机名映射到静态主机条目，该条目将使用自定义DNS解析器进行解析。</td><td>No</td></tr><tr><td>Add static host Button</td><td>在静态主机表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete static host Button</td><td>删除表中当前选择的静态主机。</td><td>N/A</td></tr></tbody></table></div><h3 id="HTTP-Authorization-Manager-HTTP授权管理器"><a href="#HTTP-Authorization-Manager-HTTP授权管理器" class="headerlink" title="HTTP Authorization Manager | HTTP授权管理器"></a>HTTP Authorization Manager | HTTP授权管理器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cbc7857565fd9ff73dbe5e04ea209b160.png" alt></p></div><p>授权管理器允许您为使用服务器身份验证限制的网页指定一个或多个用户登录。当您使用浏览器访问受限制的页面，并且浏览器显示登录对话框时，您会看到这种类型的身份验证。JMeter在遇到这种类型的页面时传输登录信息。</p><p>授权标头可能不会显示在树视图侦听器的”请求”选项卡中。Java实现执行了先发制人的身份验证，但是当JMeter获取授权报头时，它不返回授权报头。HttpComponents (HC 4.5.X)实现自3.2开始默认为先发制人，头部将显示。要禁用此功能，请设置以下值，在这种情况下，身份验证将只在响应质询时执行。</p><p>在 <code>jmeter.properties</code> 文件中 设置 <code>httpclient4.auth.preemptive=false</code></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:上述设置仅适用于HttpClient采样器。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>当针对URL查找匹配项时，JMeter依次检查每个条目，并在找到第一个匹配项时停止。因此，最特定的url应该出现在列表的最前面，其次是不那么特定的url。重复的url将被忽略。如果你想为不同的线程使用不同的用户名/密码，你可以使用变量。这些可以使用CSV数据集配置元素(例如)来设置。</p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear auth on each iteration?</td><td>用于Kerberos认证。如果勾选此项，将对每一次主线程组循环的迭代进行身份验证，即使它已经在前一次循环中完成了。如果每个主线程组迭代代表一个虚拟用户的行为，这通常是有用的。</td><td>Yes</td></tr><tr><td>Base URL</td><td>匹配一个或多个HTTP请求URL的部分或完整URL。例如，您指定一个Base URL为 “<code>http://localhost/restricted/</code>“，用户名为”<code>jmeter</code>“，密码为”<code>jmeter</code>“。如果您向URL”<code>http://localhost/restricted/ant/myPage.html</code>“发送HTTP请求，授权管理器将发送名为”jmeter”的用户的登录信息。</td><td>yES</td></tr><tr><td>Username</td><td>需要授权的用户名。</td><td>Yes</td></tr><tr><td>Password</td><td>用户的密码。(注意，此数据未加密存储在测试计划中)</td><td>Yes</td></tr><tr><td>Domain</td><td>用于NTLM的域。</td><td>No</td></tr><tr><td>Realm</td><td>用于NTLM的领域。</td><td>No</td></tr><tr><td>Mechanism</td><td>执行的认证类型。JMeter可以基于使用的Http采样器执行不同类型的认证:</td><td>No</td></tr></tbody></table><h3 id="HTTP-Cache-Manager-HTTP-缓存控制器"><a href="#HTTP-Cache-Manager-HTTP-缓存控制器" class="headerlink" title="HTTP Cache Manager | HTTP 缓存控制器"></a>HTTP Cache Manager | HTTP 缓存控制器</h3><p>HTTP缓存管理器用于在其作用域内向HTTP请求添加缓存功能，以模拟浏览器缓存特性。每个虚拟用户线程都有自己的缓存。默认情况下，缓存管理器将使用LRU算法在每个虚拟用户线程的缓存中存储最多5000个条目。使用属性”maxSize”来修改这个值。请注意，这个值增加越多，HTTP缓存管理器消耗的内存就越多，因此一定要相应地调整-Xmx JVM选项。</p><p>如果一个样本是成功的(即有响应代码2xx)，然后最后修改和Etag(和过期，如果相关)的值为URL保存。在执行下一个示例之前，采样器检查缓存中是否有条目，如果有，则为请求设置if - last - modified和if - none - match条件报头。</p><p>此外，如果”使用Cache-Control/Expires头”选项被选中，那么Cache-Control/Expires值将根据当前时间进行检查。如果请求是一个GET请求，并且时间戳在将来，那么采样器将立即返回，而不需要从远程服务器请求URL。这是为了模拟浏览器的行为。注意，如果cache - control报头为”no-cache”，响应将被存储在缓存中，因此将生成一个有条件的GET请求。如果Cache-Control有其他值，则处理”max-age”过期选项来计算条目的生存期，如果缺少则使用过期头，如果也缺少条目将使用RFC 2616章节13.2.4中指定的Last-Modified time和response Date进行缓存。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果所请求的文档自缓存以来没有更改，那么响应体将为空。同样，如果过期日期在未来。这可能会给断言带来问题。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C431a1b16f59e2a2a78ff45601e41b2fa.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear cache each iteration</td><td>如果选择该选项，则在线程开始时清除缓存。</td><td>Yes</td></tr><tr><td>Use Cache Control/Expires header when processing GET requests</td><td>参见上面的描述。</td><td>Yes</td></tr><tr><td>Max缓存中的元素个数</td><td>参见上面的描述。</td><td>Yes</td></tr></tbody></table></div><h3 id="HTTP-Cookie-Manager-HTTP-Cookie-管理器"><a href="#HTTP-Cookie-Manager-HTTP-Cookie-管理器" class="headerlink" title="HTTP Cookie Manager | HTTP Cookie 管理器"></a>HTTP Cookie Manager | HTTP Cookie 管理器</h3><p>Cookie Manager元素有两个功能:</p><p>首先，它像网络浏览器一样存储和发送cookie。如果您有一个HTTP请求和响应包含一个cookie, cookie管理器自动存储该cookie，并将使用它为所有未来的请求，以特定的网站。每个JMeter线程都有自己的“cookie存储区域”。因此，如果您正在测试一个使用cookie存储会话信息的网站，那么每个JMeter线程将拥有自己的会话。注意，这样的Cookie不会出现在Cookie Manager的显示中，但是可以使用View Results Tree Listener查看它们。</p><p>JMeter检查接收到的cookie对URL是否有效。这意味着不存储跨域cookie。如果您有错误行为或希望使用跨域cookie，定义JMeter属性 “<code>CookieManager.check.cookies=false</code>“</p><p>接收到的cookie可以存储为JMeter线程变量。要将cookie保存为变量，需要定义属性”<code>CookieManager.save.cookies=true</code>“。此外，cookie名称在存储之前会以“COOKIE_”作为前缀(这可以避免局部变量的意外损坏)。要恢复到原来的行为，需要定义属性”<code>CookieManager.name.prefix=</code>“(一个或多个空格)。如果启用，一个名为TEST的cookie的值可以被引用为<code>${COOKIE_TEST}</code>。</p><p>其次，您可以手动添加cookie到cookie管理器。但是，如果您这样做，cookie将被所有JMeter线程共享。</p><p>注意，这样的cookie创建时的过期时间较远</p><p>默认情况下，具有<strong>空值</strong>的cookie将被忽略。这可以通过设置JMeter属性来改变:<code>CookieManager.delete_null_cookies=false</code>。注意，这也适用于手动定义的cookie -任何这样的cookie在更新时将从显示中删除。还要注意cookie名称必须是唯一的——如果第二个cookie定义为相同的名称，它将替换第一个cookie。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C230dad077b303fe9551fe423dc86b965.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果在一个采样器的范围内有多个Cookie Manager，目前没有办法指定要使用哪个。另外，存储在一个cookie管理器中的cookie对任何其他管理器都不可用，所以要小心使用多个cookie管理器。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear Cookies each Iteration</td><td>如果选中该选项，则在每次执行主线程组循环时清除所有服务器定义的cookie。在GUI中定义的cookie不会被清除。</td><td>Yes</td></tr><tr><td>Cookie Policy</td><td>用于管理cookie的cookie策略。"standard"是3.0之后的默认设置，应该在大多数情况下都可以使用。参见Cookie规范和CookieSpec实现<code>[注:"ignoreCookies"等价于省略CookieManager。]</code></td><td>Yes</td></tr><tr><td>Implementation</td><td>HC4CookieHandler (HttpClient 4.5。X的API)。从3.0开始默认为HC4CookieHandler。 <code>[注:如果你有一个网站来测试IPv6地址，选择HC4CookieHandler (IPv6兼容)]</code></td><td>Yes</td></tr><tr><td>User-Defined Cookies</td><td>这使您有机会使用将在测试执行期间被所有线程使用的硬编码cookie。 <code>域</code>是服务器的主机名(没有http://);端口当前被忽略。</td><td>N/A</td></tr><tr><td>Add Button</td><td>向cookie表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Load Button</td><td>加载之前保存的cookie表，并将条目添加到现有的cookie表条目中。</td><td>N/A</td></tr><tr><td>Save As Button</td><td>将当前cookie表保存到一个文件中(不保存从HTTP响应中提取的任何cookie)。</td><td>N/A</td></tr></tbody></table></div><h3 id="HTTP-Request-Defaults-HTTP-请求默认值"><a href="#HTTP-Request-Defaults-HTTP-请求默认值" class="headerlink" title="HTTP Request Defaults | HTTP 请求默认值"></a>HTTP Request Defaults | HTTP 请求默认值</h3><p>这个元素允许你设置HTTP请求控制器使用的默认值。例如，如果您正在使用25个HTTP请求控制器创建一个Test Plan，并且所有的请求都被发送到相同的服务器，您可以添加一个单独的HTTP Request Defaults元素，填充“服务器名称或IP”字段。然后，当您添加25个HTTP请求控制器时，<mark style="background: #ABF7F7A6;">将“服务器名称或IP”字段保留为空</mark> 。控制器将从HTTP Request Defaults元素继承这个字段值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C4b94edb137f5ce1ac2fc7f273c5b352c.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>所有端口值都被同等对待;一个没有指定端口的采样器将使用HTTP请求默认端口(如果提供了)。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attibute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Server</td><td>web服务器的域名或IP地址。例如,www.example.com。<code>[不包含http://前缀。</code></td><td>No</td></tr><tr><td>Port</td><td>web服务器正在监听的端口。</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时。等待连接打开的毫秒数。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时。等待响应的毫秒数。</td><td>No</td></tr><tr><td>Implementation</td><td>Java, HttpClient4。如果没有指定，默认值取决于JMeter属性JMeter的值。httpsampler，如果失败，则使用Java实现。</td><td>No</td></tr><tr><td>Protocol</td><td>HTTP or HTTPS.</td><td>No</td></tr><tr><td>Content encoding</td><td>用于请求的编码。</td><td>No</td></tr><tr><td>Path</td><td>资源的路径(例如/servlets/myServlet)。如果资源需要查询字符串参数，在下面的“发送请求参数”部分添加它们。注意，该路径是完整路径的默认值，而不是应用于HTTP请求屏幕上指定的路径的前缀。</td><td>No</td></tr><tr><td>Send Parameters With the Request</td><td>查询字符串将从您提供的参数列表中生成。每个参数都有一个名称和值。查询字符串将以正确的方式生成，取决于你所做的“方法”的选择(即，如果你选择了GET，查询字符串将被附加到URL，如果是POST，那么它将被单独发送)。此外，如果您正在使用多部分表单发送文件，那么查询字符串将使用多部分表单规范创建。</td><td>No</td></tr><tr><td>Server (proxy)</td><td>执行请求的代理服务器的主机名或IP地址。<code>[不包含http://前缀。]</code></td><td>No</td></tr><tr><td>Port</td><td>代理服务器正在监听的端口。不能，除非指定了代理主机名</td><td>No</td></tr><tr><td>Username</td><td>代理服务器的用户名(可选)。</td><td>No</td></tr><tr><td>Password</td><td>代理服务器密码(可选)。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Retrieve All Embedded Resources from HTML Files</td><td>告诉JMeter解析HTML文件，并对文件中引用的所有图像、Java小程序、JavaScript文件、css等发送HTTP/HTTPS请求。</td><td>No</td></tr><tr><td>Use concurrent pool</td><td>使用并发连接池来获得嵌入式资源。</td><td>No</td></tr><tr><td>Size</td><td>用于获取嵌入式资源的并发连接的池大小。</td><td>No</td></tr><tr><td>URLs must match:</td><td>如果存在，则必须是一个正则表达式，用于匹配找到的任何嵌入式url。因此，如果您只想从<code>http://example.invalid/</code>下载嵌入式资源，请使用表达式:<code>http://example\.invalid/.*</code></td><td>No</td></tr><tr><td>URLs must not match:</td><td>如果存在，则必须是一个正则表达式，用于过滤掉找到的任何嵌入的url。所以，如果你不想从任何来源下载PNG或SVG文件，使用表达式:<code>.*\.(?i: SVG | PNG)</code></td><td>No</td></tr></tbody></table></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注:单选按钮只有两种状态-开或关。这使得不可能始终如一地覆盖设置——关闭意味着关闭，还是意味着使用当前的默认值?JMeter使用后者(否则默认值根本不起作用)。因此，如果按钮是关闭的，那么后面的元素可以将其设置为开启，但如果按钮是开启的，后面的元素就不能将其设置为关闭。</p></div><h3 id="HTTP-Header-Manager-HTTP-头信息管理器"><a href="#HTTP-Header-Manager-HTTP-头信息管理器" class="headerlink" title="HTTP Header Manager | HTTP 头信息管理器"></a>HTTP Header Manager | HTTP 头信息管理器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C0333bdcf912b8486049febc4d746f591.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Name (Header)</td><td>请求头的名称。您可能想要试验的两个常见请求头是"<code>User-Agent</code>"和"<code>Referer</code>"。</td><td>No (You should have at least one, however)</td></tr><tr><td>Value</td><td>请求头的值</td><td>No (You should have at least one, however)</td></tr><tr><td>Add Button</td><td>向标题表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Load Button</td><td>加载先前保存的头表，并将条目添加到现有的头表条目中。</td><td>N/A</td></tr><tr><td>Save As Button</td><td>将当前头表保存到一个文件中。</td><td>N/A</td></tr></tbody></table></div><h3 id="Java-Request-Defaults-java-请求默认值"><a href="#Java-Request-Defaults-java-请求默认值" class="headerlink" title="Java Request Defaults | java 请求默认值"></a>Java Request Defaults | java 请求默认值</h3><p>Java Request Defaults组件允许您为Java测试设置默认值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C18f4c033bd431c9dd7b76f52ce282a52.png" alt></p></div><h3 id="JDBC-Connection-Configuration-JDBC-连接-配置"><a href="#JDBC-Connection-Configuration-JDBC-连接-配置" class="headerlink" title="JDBC Connection Configuration | JDBC 连接 配置"></a>JDBC Connection Configuration | JDBC 连接 配置</h3><p>从提供的JDBC connection设置创建一个数据库连接(由JDBC RequestSampler使用)。连接可以在线程之间选择性地池化。否则，每个线程将获得自己的连接。JDBC Sampler使用连接配置名称来选择适当的连接。已用池为DBCP，请参见BasicDataSource配置参数</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C1833bb3bf3831447c387e587824ac09a.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的连接配置的描述性名称。</td><td>No</td></tr><tr><td>Variable Name for created pool</td><td>连接绑定到的变量的名称。可以使用多个连接，每个连接绑定到不同的变量，从而允许JDBC sampler选择适当的连接。</td><td>Yes</td></tr><tr><td>Max Number of Connections</td><td>池中允许的最大连接数。在大多数情况下，设置为0(0)。这意味着每个线程将得到它自己的池，其中有一个连接，即连接不是线程之间共享的。</td><td>Yes</td></tr><tr><td>Max Wait (ms)</td><td>如果在尝试检索连接的过程中超过了超时时间，池将抛出一个错误</td><td>Yes</td></tr><tr><td>Time Between Eviction Runs (ms)</td><td>空闲对象回收器线程运行之间休眠的毫秒数。当非正值时，不会运行空闲的对象驱逐符线程。(默认为60000,1分钟)。看到</td><td>Yes</td></tr><tr><td>Auto Commit</td><td>打开或关闭连接的自动提交。</td><td>Yes</td></tr><tr><td>Transaction isolation</td><td>事务隔离</td><td>Yes</td></tr><tr><td>Pool Prepared Statements</td><td>每个连接池中准备语句的最大数量。“-1”禁用池，“0”表示不限制准备语句池的数量。(默认为“1”)</td><td>Yes</td></tr><tr><td>Preinit Pool</td><td>可以立即初始化连接池。如果设置为False(默认值)，使用该池的JDBC请求采样器可能会为第一次查询度量更高的响应时间—因为包括了整个池的连接建立时间。</td><td>No</td></tr><tr><td>Init SQL statements separated by new line</td><td>一组SQL语句，在第一次创建物理连接时，这些SQL语句将用于初始化它们。这些语句只执行一次—当配置的连接工厂创建连接时。</td><td>No</td></tr><tr><td>Test While Idle</td><td>测试池的空闲连接</td><td>Yes</td></tr><tr><td>Soft Min Evictable Idle Time(ms)</td><td>在空闲对象回收器有资格回收连接之前，连接在池中空闲的最短时间，附加条件是至少有minIdle连接保留在池中。 默认值为5000(5秒)</td><td>Yes</td></tr><tr><td>Validation Query</td><td>一个简单的查询，用于确定数据库是否仍在响应。这默认是jdbc驱动程序的’isValid()’方法，它适用于许多数据库。然而，有些可能需要不同的查询;例如，Oracle类似于“SELECT 1 FROM DUAL”可以使用。</td><td>No</td></tr><tr><td>Database URL</td><td>JDBC数据库连接字符串。</td><td>Yes</td></tr><tr><td>JDBC Driver class</td><td>驱动程序类的完全限定名称。(必须在JMeter的类路径-最容易复制.jar文件到JMeter的/lib目录)。</td><td>Yes</td></tr><tr><td>Username</td><td>要连接的用户名。</td><td>No</td></tr><tr><td>Password</td><td>连接的密码。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Connection Properties</td><td>建立连接时设置的连接属性(例如Oracle的internal_logon=sysdba)</td><td>No</td></tr></tbody></table><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">Some examples for databases and their parameters are given below.</p><p>MySQLDriver classcom.mysql.jdbc.DriverDatabase URLjdbc:mysql://host[:port]/dbnamePostgreSQLDriver classorg.postgresql.DriverDatabase URLjdbc:postgresql:{dbname}OracleDriver classoracle.jdbc.OracleDriverDatabase URLjdbc:oracle:thin:@//host:port/service OR jdbc:oracle:thin:@(description=(address=(host={mc-name})(protocol=tcp)(port={port-no}))(connect_data=(sid={sid})))Ingress (2006)Driver classingres.jdbc.IngresDriverDatabase URLjdbc:ingres://host:port/db[;attr=value]Microsoft SQL Server (MS JDBC driver)Driver classcom.microsoft.sqlserver.jdbc.SQLServerDriverDatabase URLjdbc:sqlserver://host:port;DatabaseName=dbnameApache DerbyDriver classorg.apache.derby.jdbc.ClientDriverDatabase URLjdbc:derby://server[:port]/databaseName[;URLAttributes=value[;…]]MariaDBDriver classorg.mariadb.jdbc.DriverDatabase URLjdbc:mariadb://host[:port]/dbname[;URLAttributes=value[;…]]Exasol (see also JDBC driver documentation)Driver classcom.exasol.jdbc.EXADriverDatabase URLjdbc:exa:host[:port][;schema=SCHEMA_NAME][;prop_x=value_x]</p></div><h3 id="Keystore-Configuration-密钥库配置"><a href="#Keystore-Configuration-密钥库配置" class="headerlink" title="Keystore Configuration | 密钥库配置"></a>Keystore Configuration | 密钥库配置</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfc1e3f1718138d5076fed611399657fd.png" alt></p></div><h3 id="Login-Config-Element-登录配置"><a href="#Login-Config-Element-登录配置" class="headerlink" title="Login Config Element | 登录配置"></a>Login Config Element | 登录配置</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C2b3e839344fae2210caac4697f84f470.png" alt></p></div><h3 id="TCP-Sampler-Config-TCP-采样器-配置"><a href="#TCP-Sampler-Config-TCP-采样器-配置" class="headerlink" title="TCP Sampler Config | TCP 采样器 配置"></a>TCP Sampler Config | TCP 采样器 配置</h3><p>TCP采样器配置为TCP采样器提供缺省数据</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3149a737279a4e4563260c1d0fac8e54.png" alt></p></div><h3 id="User-Defined-Variables-用户定义变量"><a href="#User-Defined-Variables-用户定义变量" class="headerlink" title="User Defined Variables | 用户定义变量"></a>User Defined Variables | 用户定义变量</h3><p>User Defined Variables元素允许您定义一组初始变量，就像在Test Plan中一样。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfe2292d00bd006cbb0a5b6d2fa7b0d5e.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意，测试计划中的所有UDV元素—无论它们在哪里—都在开始时处理。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td></td></tr><tr><td>User Defined Variables</td><td>变量名称/值对。"<code>Name</code>"列下的字符串是您需要放在<code>${…}</code>构造中方括号内的内容，以便稍后使用变量。整个<code>${…}</code>将被"Value"列中的字符串替换。</td><td></td></tr></tbody></table></div><h3 id="Random-Variable-随机变量"><a href="#Random-Variable-随机变量" class="headerlink" title="Random Variable | 随机变量"></a>Random Variable | 随机变量</h3><p>随机变量配置元素用于生成随机数字字符串，并将它们存储在变量中以备以后使用。它比使用用户定义变量和<code>__Random()</code>函数更简单。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca323effcee9ceb4d9e663ed1674deb4c.png" alt></p></div><table><thead><tr><th>Attibute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>Yes</td></tr><tr><td>Variable Name</td><td>存储随机字符串的变量的名称。</td><td>Yes</td></tr><tr><td>Format String</td><td>要使用的<code>java.text.DecimalFormat</code>格式字符串。例如，”000”将生成至少3位的数字，或”<code>USER_000</code>“将生成形式为<code>USER_nnn</code>的输出。如果未指定，则默认使用<code>Long.toString()</code>生成数字。</td><td>No</td></tr><tr><td>Minimum Value</td><td>生成的随机数的最小值(长)。</td><td>Yes</td></tr><tr><td>Maximum Value</td><td>生成的随机数的最大值(长)。</td><td>Yes</td></tr><tr><td>Random Seed</td><td>随机数生成器的种子。如果您使用相同的种子值，将Per Thread设置为true，您将为每个Thread获得与每个Random类相同的值。如果没有设置种子，将使用Random的默认构造函数。</td><td>No</td></tr><tr><td>Per Thread(User)?</td><td>如果为False，则线程组中的所有线程共享生成器。如果为True，则每个线程都有自己的随机生成器。</td><td>Yes</td></tr></tbody></table><h3 id="Counter-计数器"><a href="#Counter-计数器" class="headerlink" title="Counter | 计数器"></a>Counter | 计数器</h3><p>允许用户创建一个计数器，该计数器可以在线程组的任何位置引用。计数器配置允许用户配置起始点、最大值和增量。计数器将从开始循环到最大，然后重新开始，像这样继续下去，直到测试结束。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C1b0a8607c0781b426f35bd5043f77014.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Starting value</td><td>计数器的起始值。计数器将在第一次迭代期间等于这个值(默认为0)。</td><td>Yes</td></tr><tr><td>Increment</td><td>在每次迭代之后计数器增加多少(默认为0，表示没有增加)。</td><td>No</td></tr><tr><td>Maximum value</td><td>如果计数器超过最大值，则将其重置为起始值。默认是长。MAX_VALUE</td><td>No</td></tr><tr><td>Format</td><td>可选的格式，例如000将格式为001、002等。它被传递给DecimalFormat，因此可以使用任何有效的格式。如果解释格式有问题，就会忽略它。<code>[默认格式是使用Long.toString()生成的]</code></td><td>No</td></tr><tr><td>Exported Variable Name</td><td>这将是计数器值可用的变量名。如果你把它命名为counterA，你可以使用用户定义值中的<code>${counterA}</code>来访问它(默认情况下，它会创建一个空的字符串变量，可以使用<code>${}</code>来访问，但这是非常不鼓励的)</td><td>No</td></tr><tr><td>Track Counter Independently for each User</td><td>换句话说，这是一个全局计数器，还是每个用户都有自己的计数器?如果未选中，计数器是全局的(即，用户#1将在第一次迭代中获得值“1”，用户#2将获得值“2”)。如果勾选此项，每个用户都有一个独立的计数器。</td><td>No</td></tr><tr><td>Reset counter on each Thread Group Iteration</td><td>此选项仅在每个用户跟踪计数器时可用，如果选中，计数器将在每次线程组迭代时重置为Start值。当计数器在循环控制器中时，这是很有用的。</td><td>No</td></tr></tbody></table><h3 id="Simple-Config-Element-简单配置元件"><a href="#Simple-Config-Element-简单配置元件" class="headerlink" title="Simple Config Element | 简单配置元件"></a>Simple Config Element | 简单配置元件</h3><p>简单配置元素允许您在采样器中添加或重写任意值。您可以选择值的名称和值本身。尽管一些喜欢冒险的用户可能会找到这个元素的用途，但它主要是供开发人员在开发新的JMeter组件时作为基本GUI使用的。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C57794dfe00c7db8952e1c7cef2f3d50a.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Name</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>Yes</td></tr><tr><td>Parameter Name</td><td>每个参数的名称。这些值是JMeter工作的内部值，通常没有文档记录。只有熟悉代码的人才知道这些值。</td><td>Yes</td></tr><tr><td>Parameter Value</td><td>应用于该参数的值。</td><td>Yes</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Logic Controllers 逻辑控制器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter-组件详解-Logic-Controllers-逻辑控制器"><a href="#JMeter-组件详解-Logic-Controllers-逻辑控制器" class="headerlink" title="JMeter 组件详解-Logic Controllers 逻辑控制器"></a>JMeter 组件详解-Logic Controllers 逻辑控制器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeter 组件详解-Logic Controllers 逻辑控制器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/控制器categories:  - JMeterkeywords:  - JMeter  - 组件  - 控制器description: 逻辑控制器决定了采样器被处理的顺序。</code></pre><h2 id="Logic-Controllers-逻辑控制器"><a href="#Logic-Controllers-逻辑控制器" class="headerlink" title="Logic Controllers | 逻辑控制器"></a>Logic Controllers | 逻辑控制器</h2><p>逻辑控制器决定了采样器被处理的顺序。</p><h3 id="Simple-Controller-简单逻辑控制器"><a href="#Simple-Controller-简单逻辑控制器" class="headerlink" title="Simple Controller | 简单逻辑控制器"></a>Simple Controller | 简单逻辑控制器</h3><p>简单逻辑控制器让你组织你的采样器和其他逻辑控制器。与其他逻辑控制器不同，此控制器除了存储设备之外不提供任何功能。</p><p>简单控制器可以将在其之下的所有组件，作为一个整体。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5b75893a30784a65622306cdd5eee7e5.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Loop-Controller-循环控制器"><a href="#Loop-Controller-循环控制器" class="headerlink" title="Loop Controller | 循环控制器"></a>Loop Controller | 循环控制器</h3><p>如果你将生成或逻辑控制器添加到一个循环控制器，JMeter将通过它们循环一定的次数，除了你为线程组指定的循环值。例如，如果您添加一个循环次数为2的HTTP请求到一个循环控制器，并配置Thread Group循环次数为3,JMeter将总共发送2 * 3 = 6个HTTP请求。</p><p>JMeter将把循环索引作为一个名为<code>__jm__&lt;元素名&gt;__idx</code>的变量公开。例如，如果你的循环控制器名为LC，那么你可以通过<code>${__jm__LC__idx}</code>访问循环索引。索引从0开始</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cf2f9ef537a2838592a6a22213705163f.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Loop Count</td><td>这个控制器的子元素在每次测试运行中迭代的次数。&lt;/br&gt; 值-1相当于检查永远切换。</td><td>Yes, unless "Forever" is checked</td></tr></tbody></table></div><h3 id="Once-Only-Controller-仅一次控制器"><a href="#Once-Only-Controller-仅一次控制器" class="headerlink" title="Once Only Controller | 仅一次控制器"></a>Once Only Controller | 仅一次控制器</h3><p>Once Only逻辑控制器告诉JMeter每个线程只处理它内部的控制器一次，并在测试计划的进一步迭代期间传递它下面的任何请求。</p><p>Once Only控制器现在将始终在任何循环父控制器的第一次迭代期间执行。因此，如果Once Only控制器被放置在一个指定循环5次的环路控制器下，那么Once Only控制器将只在通过环路控制器的第一次迭代时执行(即每5次)。</p><p>注意，这意味着Once Only控制器的行为仍将与之前预期的一样</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca518627998462bc10d3a24c5274f70d5.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Interleave-Controller-交替控制器"><a href="#Interleave-Controller-交替控制器" class="headerlink" title="Interleave Controller | 交替控制器"></a>Interleave Controller | 交替控制器</h3><p>如果你将生成或逻辑控制器添加到交错控制器中，JMeter将在每个循环迭代中交替使用其他控制器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">交替控制器</p><p><img src="/attachment%5C5c85cc68f4017a652e96d46c4efc05ef.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>ignore sub-controller blocks</td><td>如果选中此项，交错控制器将把子控制器当作单个请求元素来处理，并且每次只允许每个控制器一个请求。</td><td>No</td></tr><tr><td>交错跨线程</td><td>如果勾选，交错控制器将在每个循环迭代中交替使用其子控制器，但在所有线程中，例如，在4个线程和3个子控制器的配置中，在第一次迭代中，线程1将运行第一个子控制器，线程2第二子控制器，线程3第三子控制器，线程4第一个子控制器，在下一次迭代中，每个线程将运行下面的子控制器</td><td>No</td></tr></tbody></table></div><blockquote><p>注： 外部交错控制器在两个内部交错控制器之间交替。然后，每个内部交错控制器在每个HTTP请求之间交替。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p><img src="https://jmeter.apache.org/images/screenshots/logic-controller/interleave2.png" alt></p><p>如果交错控制器下 是两个交错控制器</p><p>Home Page, Interleaved, Bug Page, Interleaved, CVS Page, Interleaved, and FAQ Page, Interleaved.</p><p>如果交错主控制器下的两个交错控制器是简单控制器，那么顺序就是: Home Page, CVS Page, Interleaved, Bug Page, FAQ Page, Interleaved.</p></div><h3 id="Random-Controller-随机控制器"><a href="#Random-Controller-随机控制器" class="headerlink" title="Random Controller | 随机控制器"></a>Random Controller | 随机控制器</h3><p>随机逻辑控制器的行为类似于交错控制器，不同的是，它不是按顺序通过其子控制器和采样器，而是在每次经过时随机选择一个。</p><blockquote><p>多个控制器之间的交互可以产生复杂的行为。随机控制器尤其如此。在你假设任何给定的相互作用会带来什么结果之前，先进行实验</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C267d5a22a02335f1421605825fb15764.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>ignore sub-controller blocks</td><td>如果选中此项，交错控制器将把子控制器当作单个请求元素来处理，并且每次只允许每个控制器一个请求。</td><td>No</td></tr></tbody></table></div><h3 id="Random-Order-Controller-随机顺序控制器"><a href="#Random-Order-Controller-随机顺序控制器" class="headerlink" title="Random Order Controller | 随机顺序控制器"></a>Random Order Controller | 随机顺序控制器</h3><p>Random Order Controller很像Simple Controller，因为它最多只执行每个子元素一次，但节点的执行顺序是随机的。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6330929ffafcc3c4a18de57586014b18.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Throughput-Controller-吞吐量控制器"><a href="#Throughput-Controller-吞吐量控制器" class="headerlink" title="Throughput Controller | 吞吐量控制器"></a>Throughput Controller | 吞吐量控制器</h3><p>吞吐量控制器允许用户控制它的执行频率。有两种模式:</p><ul><li>百分比执行<ul><li>使控制器通过测试计划执行一定百分比的迭代。</li></ul></li><li>总数执行<ul><li>使控制器在执行了一定的次数后停止执行。</li></ul></li></ul><p>与Once Only控制器一样，当父回路控制器重启时，此设置将被重置。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C9f431050da107da7416d467b37b34adb.png" alt></p></div><blockquote><p>当与其他控制器组合时，吞吐量控制器可以产生非常复杂的行为——特别是与交错或随机控制器作为父控制器(也非常有用)。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Execution Style</td><td>控制器将以百分比执行模式还是总执行模式运行。</td><td>Yes</td></tr><tr><td>Throughput</td><td>一个数字。对于百分比执行模式，一个0-100的数字，表示控制器执行时间的百分比。"50"表示控制器将在测试计划的一半迭代中执行。对于总执行模式，number表示控制器将执行的总次数。</td><td>Yes</td></tr><tr><td>Per User</td><td>如果选中此选项，则per user将导致控制器计算是否应该以每个用户(每个线程)为基础执行。如果未选中，则计算将对所有用户是全局的。例如，如果使用总执行模式，而不选中"per user"，则给出的吞吐量数将是执行的总次数。如果检查了"每个用户"，那么执行的总数量将是用户数量乘以给定的吞吐量。</td><td>No</td></tr></tbody></table></div><h3 id="Runtime-Controller-运行时间控制器"><a href="#Runtime-Controller-运行时间控制器" class="headerlink" title="Runtime Controller | 运行时间控制器"></a>Runtime Controller | 运行时间控制器</h3><p>运行时控制器控制其子程序的运行时间。控制器将运行其子控制器，直到超过配置的运行时为止。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3762bea8a2a37cdebb442a2309981c85.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>Yes</td></tr><tr><td>Runtime (seconds)</td><td>所需的运行时间(以秒为单位)。0表示不运行。</td><td>Yes</td></tr></tbody></table></div><h3 id="If-Controller-If-控制器"><a href="#If-Controller-If-控制器" class="headerlink" title="If Controller | If 控制器"></a>If Controller | If 控制器</h3><p>If控制器允许用户控制是否运行它(其子元素)下面的test元素。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C64b180d15fefb537f4d7776e828003f8.png" alt></p></div><p>默认情况下，条件只在初始条目上计算一次，但是您可以选择对控制器中包含的每个可运行元素进行计算。</p><p>最好的选项(默认选项)是检查 <code>Interpret Condition as Variable Expression?</code>，然后在条件字段中有两个选项:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">选项1:使用包含true或false的变量</p><p>如果你想测试最后一个样本是否成功，你可以使用 <code>${JMeterThread.last_sample_ok}</code></p><p><img src="https://jmeter.apache.org/images/screenshots/if_controller_variable.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">选项2:使用函数(建议使用`${__jexl3()}`)来计算必须返回true或false的表达式</p><p><img src="https://jmeter.apache.org/images/screenshots/if_controller_expression.png" alt></p></div><p>例如，以前可以使用条件:<code>${__jexl3(${VAR} == 23)}</code>，这将被评估为true/false，然后将结果传递给JavaScript，然后返回true/false。如果选择了变量表达式，那么表达式将被计算并与”true”进行比较，而不需要使用JavaScript。</p><p>如果取消选择<code>Interpret Condition as Variable Expression?</code>， If Controller将在内部使用javascript来评估条件，这可能会造成非常大的性能损失，并使您的测试不太可伸缩。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Condition (default JavaScript)</td><td>默认情况下，该条件被解释为返回"true"或"false"的JavaScript代码，但这可以被重写(见下文)</td><td>Yes</td></tr><tr><td>Interpret Condition as Variable Expression?</td><td>如果选中此选项，那么条件必须是一个计算结果为"<code>true</code>"的表达式(忽略大小写)。例如，<code>${FOUND}</code>或<code>${__jexl3(${VAR} &amp;gt;100)}</code>。与JavaScript的大小写不同，只检查条件是否匹配"true"(大小写被忽略)。</td><td>Yes</td></tr><tr><td>Evaluate for all children</td><td>是否应该对所有 Children 进行状况评估?如果没有选中，则只在进入时对条件进行计算。</td><td>Yes</td></tr></tbody></table></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><ul><li><code>${__groovy(vars.get("myVar") != "Invalid" )}</code> (Groovy check myVar is not equal to Invalid)</li><li><code>${__groovy(vars.get("myInt").toInteger() &lt;=4 )}</code> (Groovy check myInt is less then or equal to 4)</li><li><code>${__groovy(vars.get("myMissing") != null )}</code> (Groovy check if the myMissing variable is not set)</li><li><code>${__jexl3(${COUNT} &lt; 10)}</code></li><li><code>${RESULT}</code></li><li><code>${JMeterThread.last_sample_ok}</code> (check if the last sample succeeded)</li></ul></div><h3 id="While-Controller-While-控制器"><a href="#While-Controller-While-控制器" class="headerlink" title="While Controller | While 控制器"></a>While Controller | While 控制器</h3><p>While控制器运行它的子控制器，直到条件为”false”。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb6ab801f14714f9176c2af3babdfb1d2.png" alt></p></div><p>JMeter将把循环索引作为一个名为<code>__jm__&lt;元素名&gt;__idx</code>的变量公开。例如，如果你的While控制器名为WC，那么你可以通过<code>${__jm__WC__idx}</code>访问循环索引。索引从0开始</p><p>可能的条件值:</p><ul><li>blank - 当循环中的最后一个样本失败时退出循环</li><li>LAST - 当循环中的最后一个样本失败时退出循环。如果循环之前的最后一个样本失败了，就不要进入循环。</li><li>Otherwise - 当条件等于字符串”false”时退出(或不进入)循环</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p>举例</p><ul><li><code>${VAR}</code> - VAR被其他测试元素设置为false</li><li><code>$ {__jexl3 ($ {C} = = 10)}</code></li><li><code>$ {__jexl3 (" $ {VAR2} " = = " abcd ")}</code></li><li><code>${_P(property)}</code> - property在其他地方设置为"false"</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>No</td></tr><tr><td>Condition</td><td>blank, LAST, or variable/function</td><td>No</td></tr></tbody></table></div><h3 id="Switch-Controller-选择控制器"><a href="#Switch-Controller-选择控制器" class="headerlink" title="Switch Controller | 选择控制器"></a>Switch Controller | 选择控制器</h3><p>Switch Controller的行为类似于Interleave Controller，它在每次迭代中运行一个从属元素，但不是按顺序运行它们，而是运行由Switch值定义的元素。</p><blockquote><p>switch的值也可以是名称。</p></blockquote><p>如果开关值超出范围，它将运行第0个元素，因此充当数值情况的默认值。如果值是空字符串，它还运行第0个元素。<br>如果该值是非数字(且非空)，则Switch Controller查找同名元素(大小写重要)。如果名称都不匹配，则选择名为”<code>default</code>“的元素(大小写不重要)。如果没有默认值，则没有选择任何元素，控制器将不运行任何东西。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb8db55fa62d65dcfd7db3650b5ff12bd.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Switch Value</td><td>要调用的从属元素的编号(或名称)。元素从0开始编号。默认值为0</td><td>No</td></tr></tbody></table></div><h3 id="ForEach-Controller-ForEach控制器"><a href="#ForEach-Controller-ForEach控制器" class="headerlink" title="ForEach Controller | ForEach控制器"></a>ForEach Controller | ForEach控制器</h3><p>ForEach控制器循环遍历一组相关变量的值。当您向ForEach控制器添加采样器(或控制器)时，每个采样器(或控制器)将执行一次或多次，在每次循环期间，变量都有一个新值。输入应该由几个变量组成，每个变量都有一个下划线和一个数字。每个这样的变量都必须有一个值。例如，当输入变量名为<code>inputVar</code>时，应该定义以下变量:</p><ul><li>inputVar_1 = wendy</li><li>inputVar_2 = charles</li><li>inputVar_3 = peter</li><li>inputVar_4 = john</li></ul><p>当返回变量给定为”<code>returnVar</code>“时，ForEach控制器下的采样器和控制器的集合将连续执行4次，返回变量分别具有上述值，然后可以在采样器中使用。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cadd5994075ef8e32743f10bb4a63e643.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Input variable prefix</td><td>用作输入的变量名的前缀。默认为一个空字符串作为前缀。</td><td>No</td></tr><tr><td>Start index for loop</td><td>循环遍历变量的起始索引(独占)(第一个元素在起始索引+ 1处)</td><td>No</td></tr><tr><td>End index for loop</td><td>结束变量循环索引(包括)</td><td>No</td></tr><tr><td>Output variable</td><td>变量的名称，该变量可以在循环中用于在采样器中替换。默认为空变量名，这很可能是不需要的。</td><td>No</td></tr><tr><td>Use Separator</td><td>如果不勾选，则省略"<code>_</code>"分隔符。</td><td>Yes</td></tr></tbody></table></div><h3 id="Module-Controller-模块控制器"><a href="#Module-Controller-模块控制器" class="headerlink" title="Module Controller | 模块控制器"></a>Module Controller | 模块控制器</h3><p>模块控制器提供了一种在运行时将测试计划片段替换为当前测试计划的机制。</p><p>一个测试计划片段由一个控制器和它包含的所有测试元素(采样器等)组成。片段可以位于任何线程组中。如果片段位于一个线程组中，那么它的控制器可以被禁用，以防止除了模块控制器之外的片段运行。或者您可以将片段存储在一个虚拟线程组中，并禁用整个线程组。</p><p>可以有多个碎片，每个碎片下都有不同系列的采样器。通过在下拉框中选择适当的控制器，模块控制器就可以轻松地在这些多个测试用例之间切换。这为快速轻松地运行许多备用测试计划提供了便利。</p><p><strong>模块控制器使用的任何片段都必须有一个唯一的名称</strong>，因为该名称用于在重新加载测试计划时找到目标控制器。由于这个原因，最好确保Controller名称从默认更改为Controller名称，否则在向测试计划添加新元素时可能会意外创建副本。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5923e6dbb68b425da6d5685f2918c08a.png" alt></p></div><h3 id="Transaction-Controller-事务控制器"><a href="#Transaction-Controller-事务控制器" class="headerlink" title="Transaction Controller | 事务控制器"></a>Transaction Controller | 事务控制器</h3><p>事务控制器生成一个额外的示例，用于度量执行嵌套测试元素所花费的总时间。</p><blockquote><p>注意:当勾选”包含生成样本中定时器和前后处理器的持续时间”复选框时，该时间包括控制器范围内的所有处理，而不仅仅是样本。</p></blockquote><p>有两种操作模式:</p><ul><li>在嵌套样例之后添加附加样例</li><li>附加样例作为嵌套样例的父类添加</li></ul><p>生成的采样时间包括所有嵌套采样的时间，不包括默认的(自2.11起)计时器和前后处理器的处理时间，除非选中了 <code>Include duration of timer and pre-post processors in generated sample</code> (包括生成样本中的计时器和前后处理器的持续时间)复选框。根据时钟分辨率的不同，它可能比单个采样器加计时器的总和稍长。时钟可能在控制器记录开始时间后滴答作响，但在第一个样本开始之前。最后也是一样。</p><p>只有在所有子样本都成功的情况下，生成的样本才被认为是成功的。</p><blockquote><p>在父模式中，断言(等等)可以添加到事务控制器。但是默认情况下，它们将同时应用于单个示例和整个事务示例。为了限制断言的范围，可以使用一个简单控制器来包含示例，并将断言添加到简单控制器。父模式控制器目前不支持任何类型的嵌套事务控制器。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cad75c9a98968eb36d939f9c9a7996ebb.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>Yes</td></tr><tr><td>Generate Parent Sample</td><td>生成父样本</td><td>Yes</td></tr><tr><td>Include duration of timer and pre-post processors in generated sample</td><td>是否在生成的样本中包括定时器、预处理和后处理延迟。默认的是假的</td><td>Yes</td></tr></tbody></table><h3 id="Recording-Controller-记录控制器"><a href="#Recording-Controller-记录控制器" class="headerlink" title="Recording Controller | 记录控制器"></a>Recording Controller | 记录控制器</h3><p>记录控制器是一个占位符，指示代理服务器应该将样本记录到何处。在测试运行期间，它没有效果，类似于简单控制器。但是在使用HTTP(S)测试脚本记录器进行记录的过程中，所有记录的样本将默认保存在记录控制器下。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C949ce70f7f1c76f11507f448576da701.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Critical-Section-Controller-临界区控制器"><a href="#Critical-Section-Controller-临界区控制器" class="headerlink" title="Critical Section Controller | 临界区控制器"></a>Critical Section Controller | 临界区控制器</h3><p>临界区控制器确保它的子元素(采样/控制器等)将只被一个线程执行，因为在执行控制器的子元素之前会获取一个命名锁。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C4a78d82bcdd498f4c60ceae7fd93685c.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Pre-Processors 前置处理器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter-组件详解-Pre-Processors-前置处理器"><a href="#JMeter-组件详解-Pre-Processors-前置处理器" class="headerlink" title="JMeter 组件详解-Pre-Processors 前置处理器"></a>JMeter 组件详解-Pre-Processors 前置处理器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeter 组件详解-Pre-Processors 前置处理器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/处理器categories:  - JMeterkeywords:  - JMeter  - 组件  - 处理器description: 预处理器用于在其范围内修改采样器。</code></pre><h2 id="Pre-Processors-前置处理器"><a href="#Pre-Processors-前置处理器" class="headerlink" title="Pre Processors | 前置处理器"></a>Pre Processors | 前置处理器</h2><p>预处理器用于在其范围内修改采样器。</p><h3 id="HTML-Link-Parser-HTML-链接解析器"><a href="#HTML-Link-Parser-HTML-链接解析器" class="headerlink" title="HTML Link Parser | HTML 链接解析器"></a>HTML Link Parser | HTML 链接解析器</h3><p>这个修饰符解析来自服务器的HTML响应并提取链接和表单。通过此修饰符的URL测试示例将被检查，以确定它是否“匹配”从上一个立即响应中提取的任何链接或表单。然后，它将用匹配链接或表单中的适当值替换URL测试示例中的值。perl类型的正则表达式用于查找匹配。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ceaa6a9fdad32bfe0dd77ac9b87804da4.png" alt></p></div><p>使用协议、主机、路径和参数名称进行匹配。目标采样器不能包含响应链接中没有的参数。</p><h3 id="HTTP-URL-Re-writing-Modifier-HTTP-重写修饰符"><a href="#HTTP-URL-Re-writing-Modifier-HTTP-重写修饰符" class="headerlink" title="HTTP URL Re-writing Modifier | HTTP 重写修饰符"></a>HTTP URL Re-writing Modifier | HTTP 重写修饰符</h3><p>这个修饰符的工作原理与HTML Link Parser类似，只是它有一个特定的用途，它比HTML Link Parser更容易使用，而且更高效。对于使用URL重写来存储会话id而不是Cookie的web应用程序，这个元素可以附加在ThreadGroup级别，就像HTTP Cookie Manager一样。只需给它指定会话id参数的名称，它就会在页面上找到它，并将该参数添加到该ThreadGroup的每个请求中。</p><p>或者，这个修饰符可以附加到选择请求，它将只修改它们。聪明的用户甚至会确定这个修饰符可以用来获取避开HTML链接解析器的值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7deb56f9f97a3e9528764e2af1912256.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>测试树中这个元素的描述性名称。</td><td>No</td></tr><tr><td>Session Argument Name</td><td>要从以前的响应中获取的参数的名称。该修饰符将在页面上任何存在参数的地方找到参数，并获取分配给它的值，无论它是在HREF或表单中。</td><td>Yes</td></tr><tr><td>Path Extension</td><td>一些web应用程序通过添加分号和会话id参数来重写url。如果是这样，请勾选此框。</td><td>No</td></tr><tr><td>Do not use equals in path extension</td><td>一些web应用程序重写url时不需要在参数名和值之间使用"="符号(如Intershop Enfinity)。</td><td>No</td></tr><tr><td>Do not use questionmark in path extension</td><td>防止查询字符串结束在路径扩展(如Intershop Enfinity)。</td><td>No</td></tr><tr><td>Cache Session Id?</td><td>当会话Id不存在时，是否应该保存会话Id的值以备以后使用?</td><td>Yes</td></tr><tr><td>URL Encode</td><td>URL写入参数时的编码值</td><td>No</td></tr></tbody></table></div><h3 id="User-Parameters-用户参数"><a href="#User-Parameters-用户参数" class="headerlink" title="User Parameters | 用户参数"></a>User Parameters | 用户参数</h3><p>允许用户指定特定于单个线程的用户变量值。</p><p>用户变量也可以在Test Plan中指定，但不是特定于单个线程。此面板允许您为任意用户变量指定一系列值。对于每个线程，将按顺序为变量分配序列中的一个值。如果线程比值多，则重用值。例如，这可以用来为每个线程分配一个不同的用户id。用户变量可以在任何JMeter组件的任何字段中引用。</p><p>通过单击面板底部的“添加变量”按钮，并在“name:”列中填写变量名称，可以指定变量。要向系列添加新值，请单击“添加用户”按钮，并在新添加的列中填写所需的值。</p><p>可以使用函数语法:<code>${variable}</code>在同一线程组中的任何测试组件中访问值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">参数</p><p><img src="/attachment%5Ca3098c8fa35a478a9efda43f7869bfa4.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Samplers 采样器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter-组件详解-Samplers-采样器"><a href="#JMeter-组件详解-Samplers-采样器" class="headerlink" title="JMeter 组件详解-Samplers 采样器"></a>JMeter 组件详解-Samplers 采样器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeter 组件详解-Samplers 采样器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/采样器categories:  - JMeterkeywords:  - JMeter  - 组件  - 采样器description: 采样器执行JMeter的实际工作。每个采样器(流量控制动作除外)产生一个或多个采样结果。示例结果具有各种属性(成功/失败、运行时间、数据大小等)，可以在各种侦听器中查看。</code></pre><h2 id="Samplers-采样器"><a href="#Samplers-采样器" class="headerlink" title="Samplers 采样器"></a>Samplers 采样器</h2><p>采样器执行JMeter的实际工作。每个采样器(流量控制动作除外)产生一个或多个采样结果。示例结果具有各种属性(成功/失败、运行时间、数据大小等)，可以在各种侦听器中查看。</p><h3 id="FTP-Request-FTP请求"><a href="#FTP-Request-FTP请求" class="headerlink" title="FTP Request | FTP请求"></a>FTP Request | FTP请求</h3><p>这个控制器允许你向FTP服务器发送一个FTP”检索文件”或”上传文件”请求。如果你打算向同一个FTP服务器发送多个请求，考虑使用FTP请求默认配置元素，这样你就不必为每个FTP请求生成控制器输入相同的信息。当下载一个文件时，它可以存储在磁盘(本地文件)或响应数据中，或两者都有。</p><p>延迟时间设置为登录所需的时间。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C119383d6ef62fda8d58e5c22b8881e21.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Server Name or IP</td><td>FTP服务器的域名或IP地址。</td><td>Yes</td></tr><tr><td>Port</td><td>端口使用。如果是&gt;0，则使用这个特定的端口，否则JMeter使用默认的FTP端口。</td><td>No</td></tr><tr><td>Remote File:</td><td>要检索的文件或要上传的目标文件的名称。</td><td>Yes</td></tr><tr><td>Local File:</td><td>要上传的文件或下载的目标文件(默认为远程文件名)。</td><td>"Yes, if uploading (*)"</td></tr><tr><td>Local File Contents:</td><td>提供上传的内容，重写"本地文件"属性。</td><td>"Yes, if uploading (*)"</td></tr><tr><td>get(RETR) / put(STOR)</td><td>是否检索或上传文件。</td><td>Yes</td></tr><tr><td>Use Binary mode?</td><td>检查此选项以使用二进制模式(默认ASCII)</td><td>Yes</td></tr><tr><td>Save File in Response?</td><td>是否在响应数据中存储检索到的文件的内容。如果模式是ASCII，则内容将在视图结果树中可见。</td><td>"Yes, if downloading"</td></tr><tr><td>Username</td><td>FTP帐户的用户名。</td><td>Usually</td></tr><tr><td>Password</td><td>FTP帐户密码。注意:这将在测试计划中可见。</td><td>Usually</td></tr></tbody></table></div><h3 id="HTTP-Request-HTTP请求"><a href="#HTTP-Request-HTTP请求" class="headerlink" title="HTTP Request | HTTP请求"></a>HTTP Request | HTTP请求</h3><p>这个示例程序允许您向web服务器发送HTTP/HTTPS请求。它还允许您控制JMeter是否解析图像和其他嵌入资源的HTML文件，并发送HTTP请求来检索它们。可以检索以下类型的嵌入式资源:</p><ul><li>图片</li><li>小应用程序</li><li>样式表(CSS)和从这些文件引用的资源</li><li>外部脚本</li><li>框架,iframes</li><li>背景图片(主体，表，TD, TR)</li><li>背景声音</li></ul><p>默认的解析器是 <code>org.apache.jmeter.protocol.http.parser.LagartoBasedHtmlParser</code>。这可以通过使用 <code>htmlparser.className</code> 属性来改变。-参见jmeter.properties 的细节。</p><p>如果你打算向同一个web服务器发送多个请求，考虑使用HTTP请求默认配置元素，这样你就不必为每个HTTP请求输入相同的信息。</p><p>或者，代替手动添加HTTP请求，您可能想使用JMeter的HTTP(S)测试脚本记录器来创建它们。如果您有很多HTTP请求或带有许多参数的请求，这可以节省您的时间。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C10fa23d3cd01ba4376173c9450dfa1ab.png" alt></p><p>Screenshot of Control-Panel of HTTP Request</p><p><img src="/attachment%5C8614d4e8dba9153e66454d0393117cbb.png" alt>HTTP Request Advanced config fields</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Server</td><td>web服务器的域名或IP地址，如 <code>www.example.com</code> 。不包含<code>http://</code>前缀。注意:如果"Host"头是在header Manager中定义的，那么它将被用作虚拟主机名。</td><td>No</td></tr><tr><td>Port</td><td>web服务器正在监听的端口。默认值:80</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时。等待连接打开的毫秒数。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时。等待响应的毫秒数。注意，这适用于每次等待响应。如果服务器响应是在几个块中发送的，那么总的运行时间可能会比超时时间长。&lt;/br&gt; 持续时间断言可用于检测需要太长时间才能完成的响应。</td><td>No</td></tr><tr><td>Server (proxy)</td><td>执行请求的代理服务器的主机名或IP地址。不包含http://前缀。</td><td>No</td></tr><tr><td>Port (proxy)</td><td>代理服务器正在监听的端口。</td><td>No, unless proxy hostname is specified</td></tr><tr><td>Username</td><td>代理服务器的用户名(可选)。</td><td>No</td></tr><tr><td>Password</td><td>代理服务器密码(可选)。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Implementation</td><td>Java, HttpClient4。如果没有指定(也没有由HTTP请求默认值定义)，默认值取决于JMeter属性JMeter的值。httpsampler，如果失败，就使用HttpClient4实现。</td><td>No</td></tr><tr><td>Protocol</td><td>HTTP, HTTPS或文件。默认值:HTTP</td><td>No</td></tr><tr><td>Method</td><td>GET, POST, HEAD, TRACE, OPTIONS, PUT, DELETE, PATCH (JAVA实现不支持)。使用HttpClient4，以下与WebDav相关的方法也被允许:COPY, LOCK, MKCOL, MOVE, PROPFIND, PROPPATCH, UNLOCK, REPORT, MKCALENDAR, SEARCH。 &lt;/br&gt; 通过使用JMeter属性httpsampler.user_defined_methods，可以为HttpClient4预定义更多方法。</td><td>Yes</td></tr><tr><td>Content Encoding</td><td>要使用的内容编码(用于POST、PUT、PATCH和FILE)。这是要使用的字符编码，与内容编码HTTP报头无关。</td><td>No</td></tr><tr><td>Redirect Automatically</td><td>将底层http协议处理程序设置为自动遵循重定向，因此它们不会被JMeter看到，因此不会显示为示例。应该只用于GET和HEAD请求。HttpClient采样器将拒绝将其用于POST或PUT的尝试。</td><td>No</td></tr><tr><td>Follow Redirects</td><td>这只有在"自动重定向"未启用的情况下才有效。如果设置了，JMeter采样器将检查响应是否是重定向，如果是，则跟踪它。初始重定向和进一步的响应将作为额外的样本显示。父样例的URL和数据字段将取自最终样例(未重定向)，但父样例的字节计数和运行时间包括所有样例。延迟是从初始响应中提取的。注意HttpClient采样器可能会记录以下消息: &lt;/br&gt; <code>"Redirect requested but followRedirects is disabled"</code></td><td>No</td></tr><tr><td>Use KeepAlive</td><td>JMeter设置Connection: keep-alive头。这在默认HTTP实现中不能正常工作，因为连接重用不在用户控制之下。它与Apache HttpComponents HttpClient实现一起工作。</td><td>No</td></tr><tr><td>Use multipart/form-data for HTTP POST</td><td>使用multipart/form-data或application/x-www-form-urlencoded post请求</td><td>No</td></tr><tr><td>Browser-compatible headers</td><td>当使用multipart/form-data时，这会抑制Content-Type和Content-Transfer-Encoding头;只发送Content-Disposition头部。</td><td>No</td></tr><tr><td>Path</td><td>资源的路径(例如/servlets/myServlet)。如果资源需要查询字符串参数，在下面的"发送请求参数"部分添加它们。 &lt;/br&gt; 在这种情况下，服务器、端口和协议字段被忽略;参数对于GET和DELETE方法也会被忽略。另外请注意，该路径没有被编码——除了用%20替换空格之外——因此可能需要对不安全字符进行编码，以避免出现URISyntaxException等错误。</td><td>No</td></tr><tr><td>Send Parameters With the Request</td><td>查询字符串将从您提供的参数列表中生成。每个参数都有一个名称和值，编码参数的选项，以及包含或排除等号的选项(一些应用程序在值为空字符串时不希望有等号)。查询字符串将以正确的方式生成，取决于你所做的"方法"的选择(即，如果你选择了GET或DELETE，查询字符串将被附加到URL，如果POST或PUT，那么它将被单独发送)。此外，如果您正在使用多部分表单发送文件，那么查询字符串将使用多部分表单规范创建。</td><td>No</td></tr><tr><td>File Path</td><td>要发送的文件的名称。如果留空，JMeter不发送文件，如果填写，JMeter自动发送请求作为一个多部分表单请求。</td><td>No</td></tr><tr><td>Parameter name</td><td>"name"web请求参数的值。</td><td>No</td></tr><tr><td>MIME Type</td><td>MIME类型(例如，文本/普通)。如果是一个POST、PUT或PATCH请求，并且省略了"name"属性(下面)或者请求正文仅由参数值构造，那么该字段的值将被用作内容类型请求头的值。</td><td>No</td></tr><tr><td>从HTML文件中检索所有嵌入式资源</td><td>告诉JMeter解析HTML文件，并对文件中引用的所有图像、Java小程序、JavaScript文件、css等发送HTTP/HTTPS请求。详见下文。</td><td>No</td></tr><tr><td>Save response as MD5 hash?</td><td>如果选择此选项，则响应不会存储在示例结果中。相反，计算并存储数据的32个字符的MD5哈希值。这是为了测试大量数据。</td><td>No</td></tr><tr><td>URLs must match</td><td>如果存在，则必须是一个正则表达式，用于匹配找到的任何嵌入式url。因此，如果您只想从<code>http://example.invalid/</code>下载嵌入式资源，请使用表达式:<code>http://example\.invalid/.*</code></td><td>No</td></tr><tr><td>URLs must not match</td><td>如果存在，则必须是一个正则表达式，用于过滤掉找到的任何嵌入的url。所以，如果你不想从任何来源下载PNG或SVG文件，使用表达式:<code>.*\.(?i: SVG | PNG)</code></td><td>No</td></tr><tr><td>Use concurrent pool</td><td>使用并发连接池来获得嵌入式资源。</td><td>No</td></tr><tr><td>Size</td><td>用于获取嵌入式资源的并发连接的池大小。</td><td>No</td></tr><tr><td>Source address type</td><td>只适用于HTTPClient实现的HTTP请求 &lt;/br&gt;要区分源地址值</td><td>No</td></tr><tr><td>Source address field</td><td>只适用于HTTPClient实现的HTTP请求&lt;/br&gt;此属性用于启用IP欺骗。它覆盖了这个示例的默认本地IP地址。JMeter主机必须有多个IP地址(即IP别名、网络接口、设备)。取值为主机名、IP地址或网口设备，如"eth0"、"lo"、"wlan0"。&lt;/br&gt;如果属性httpclient。定义了localaddress，用于所有HttpClient请求。</td><td>No</td></tr></tbody></table></div><h3 id="JDBC-Request-JDBC-请求"><a href="#JDBC-Request-JDBC-请求" class="headerlink" title="JDBC Request | JDBC 请求"></a>JDBC Request | JDBC 请求</h3><p>这个示例程序允许向数据库发送JDBC请求(一个SQL查询)。</p><p>在使用它之前，您需要设置一个[JDBC Connection Configuration] Configuration元素</p><p>如果提供了Variable Names列表，那么对于Select语句返回的每一行，将使用相应列的值设置变量(如果提供了变量名)，并设置行数。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C9c9ae2a4f9139da9cf540c698bfaf715.png" alt>Screenshot of Control-Panel of JDBC Request</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Variable Name of Pool declared in JDBC Connection Configuration</td><td>连接池绑定到的JMeter变量的名称。这必须与 [JDBC Connection Configuration] 中的 <code>Variable Name</code> 字段一致。</td><td>No</td></tr><tr><td>Query Type</td><td>根据语句类型设置 &lt;/br&gt; - Select Statement&lt;/br&gt; - Update Statement - use this for Inserts and Deletes as well&lt;/br&gt; - Callable Statement&lt;/br&gt;Prepared Select Statement&lt;/br&gt; - Prepared Update Statement - use this for Inserts and Deletes as well&lt;/br&gt; - Commit&lt;/br&gt; - Rollback&lt;/br&gt; - Autocommit(false)&lt;/br&gt; - Autocommit(true)&lt;/br&gt; - Edit - this should be a variable reference that evaluates to one of the above &lt;/br&gt; &lt;/br&gt; <strong>Commit、Rollback、Autocommit(false)和Autocommit(true)类型是特殊的，因为它们只会忽略给定的SQL语句并改变连接的状态。</strong></td><td>Yes</td></tr><tr><td>SQL Query</td><td>SQL query.    &lt;/br&gt;&lt;/br&gt;  <strong>Do not enter a trailing semi-colon.</strong></td><td>Yes</td></tr><tr><td>Parameter values</td><td>逗号分隔的参数值列表。使用<code>]NULL[</code>来表示<code>NULL</code>参数。(如果需要，可以通过定义属性"<code>jdbcsampler.nullmarker</code>"来更改空字符串。)例如，如果任何值包含逗号或双引号，列表必须用双引号括起来，并且任何嵌入的双引号必须是双引号</td><td>Yes, if a prepared or callable statement has parameters</td></tr><tr><td>Parameter types</td><td>逗号分隔的SQL参数类型列表(例如INTEGER, DATE, VARCHAR, DOUBLE)或Constants的整数值。当您使用驱动程序建议的自定义数据库类型(例如OracleTypes。CURSOR可以用其整数值-10表示)。 它们被定义为java.sql类中的字段。</td><td>Yes, if a prepared or callable statement has parameters</td></tr><tr><td>Variable Names</td><td>逗号分隔的变量名列表，用于保存Select语句、Prepared Select语句或CallableStatement返回的值。注意，当与CallableStatement一起使用时，变量列表必须与调用返回的OUT参数的顺序相同。如果变量名比OUT参数少，那么在线程上下文变量中存储的结果与提供的变量名相同。如果存在比OUT参数更多的变量名，则会忽略额外的变量</td><td>No</td></tr><tr><td>Result Variable Name</td><td>如果指定，这将创建一个包含行映射列表的Object变量。每个映射都包含列名作为键，列数据作为值。</td><td>No</td></tr><tr><td>Query timeout(s)</td><td>设置以秒为单位的查询超时时间，空值表示0，表示无穷大。-1意味着不设置任何查询超时，这可能需要用例或当某些驱动程序不支持超时。默认值为0。</td><td>No</td></tr><tr><td>Limit ResultSet</td><td>限制遍历ResultSet的行数。空值意味着-1，例如没有限制，这也是默认值。这可以帮助减少通过JDBC驱动程序从数据库中获取的数据量，但会分别影响Handle ResultSet的所有可能选项——例如:incomplete ResultSet和记录计数≤限制。</td><td>No</td></tr><tr><td>Handle ResultSet</td><td>定义如何处理可调用语句返回的ResultSet &lt;/br&gt; &lt;/br&gt; - <strong>Store As String</strong> (默认)——变量名列表中的所有变量都存储为字符串，当出现在列表中时，不会遍历ResultSet。clob将被转换为string。blob将被转换为string，就像它们是UTF-8编码的字节数组一样。在jdbcsampler之后，clob和blob都将被切断。max_retain_result_size字节。 &lt;/br&gt; - <strong>Store As Object</strong>——变量名称列表中的ResultSet类型的变量将存储为对象，可以在后续的测试/脚本中访问和迭代，不会遍历ResultSet。将像选择Store as String一样处理clob。blob将存储为字节数组。在jdbcsampler之后，clob和blob都将被切断。max_retain_result_size字节。 &lt;/br&gt; - <strong>Count Records</strong>——ResultSet类型的变量将通过显示作为结果的记录计数进行迭代。变量将被存储为string。对于blob，将存储对象的大小。</td><td>No</td></tr></tbody></table></div><h3 id="Java-Request-Java-请求"><a href="#Java-Request-Java-请求" class="headerlink" title="Java Request | Java 请求"></a>Java Request | Java 请求</h3><p>这个采样器允许您控制一个实现<code>org.apache.jmeter.protocol.java.sampler.JavaSamplerClient</code>接口的java类。通过编写您自己的这个接口的实现，您可以使用JMeter来利用多线程、输入参数控制和数据收集。</p><p>下拉菜单提供了JMeter在其类路径中找到的所有此类实现的列表。然后可以在下表中指定参数—由您的实现定义。提供了两个简单的示例(JavaTest和SleepTest)。</p><p>JavaTest示例采样器对于检查测试计划很有用，因为它允许在几乎所有字段中设置值。然后，断言等可以使用它们。字段允许使用变量，因此可以很容易地看到这些变量的值。</p><blockquote><p>如果方法teardownTest没有被AbstractJavaSamplerClient的子类覆盖，它的teardownTest方法将不会被调用。这减少了JMeter的内存需求。这不会对现有的Test计划产生任何影响。</p></blockquote><blockquote><p>添加/删除按钮目前没有任何作用。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cd1de1a1316e90d2ccc3756391c82334d.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Classname</td><td>要采样的JavaSamplerClient接口的具体实现。</td><td>Yes</td></tr><tr><td>Send Parameters with Request</td><td>将传递给采样类的参数列表。所有参数都作为字符串发送。具体设置见下文。</td><td>No</td></tr></tbody></table></div><h3 id="BeanShell-Sampler-BeanShell-采样器"><a href="#BeanShell-Sampler-BeanShell-采样器" class="headerlink" title="BeanShell Sampler | BeanShell 采样器"></a>BeanShell Sampler | BeanShell 采样器</h3><p>这个采样器允许您使用BeanShell脚本语言编写一个采样器。</p><p>test元素支持ThreadListener和TestListener接口方法。它们必须在初始化文件中定义。请参阅文件BeanShellListeners。示例定义为BSHRC。BeanShell采样器还支持可中断接口。可以在脚本或init文件中定义interrupt()方法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cceb6514c12ffddbf2784b0088cd6b460.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。名称存储在脚本变量Label中</td><td>No</td></tr><tr><td>Reset bsh.Interpreter before each call</td><td>如果选择此选项，则将为每个示例重新创建解释器。对于一些长期运行的脚本来说，这可能是必要的。有关更多信息，请参阅最佳实践—BeanShell脚本。</td><td>Yes</td></tr><tr><td>Parameters</td><td>传递给BeanShell脚本的参数。这是为了与脚本文件一起使用;对于在GUI中定义的脚本，您可以使用脚本本身中需要的任何变量和函数引用。</td><td>No</td></tr><tr><td>Script file</td><td>包含要运行的BeanShell脚本的文件。文件名存储在脚本变量FileName中</td><td>No</td></tr><tr><td>Script</td><td>要运行的BeanShell脚本。返回值(如果不是null)存储为采样结果。</td><td>Yes (unless script file is provided)</td></tr></tbody></table></div><h3 id="TCP-Sampler-TCP采样器"><a href="#TCP-Sampler-TCP采样器" class="headerlink" title="TCP Sampler | TCP采样器"></a>TCP Sampler | TCP采样器</h3><p>TCP采样器打开一个TCP/IP连接到指定的服务器。然后它发送文本，并等待响应。</p><p>如果选择 “Re-use connection”，在相同线程中的sampler之间共享连接，前提是使用完全相同的主机名字符串和端口。不同的主机/端口组合将使用不同的连接，就像不同的线程一样。如果”Re-use connection”和 “Close connection” 都被选中，套接字将在运行采样器后关闭。在下一个采样器上，将创建另一个 socket。您可能希望在每个线程循环结束时关闭一个 socket。</p><p>以下属性可用于控制其操作:</p><ul><li><code>tcp.status.prefix</code> 文本在状态号之前</li><li><code>tcp.status.suffix</code>文本在状态号之后</li><li><code>tcp.status.properties</code>属性文件的名称，用于将状态码转换为消息</li><li><code>tcp.handler</code> TCP处理程序类的名称(默认TCPClientImpl) -仅在GUI上没有指定时使用</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb4fe9d427f42f3072c562649e012e20e.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>TCPClient classname</td><td>TCPClient类的名称。默认为 <code>tcp.handler</code>。处理程序，<code>TCPClientImpl</code>失败。</td><td>Yes</td></tr><tr><td>ServerName or IP</td><td>TCP服务器的名称或IP</td><td>Yes</td></tr><tr><td>Port Number</td><td>使用的端口</td><td>Yes</td></tr><tr><td>Re-use connection</td><td>如果选中，连接将保持打开状态。否则在读取数据时关闭。</td><td>Yes</td></tr><tr><td>Close connection</td><td>如果选择，则在运行采样器后将关闭连接。</td><td>No</td></tr><tr><td>SO_LINGER</td><td>在创建 <code>socket</code> 时使用指定的延迟时间(秒)启用/禁用SO_LINGER。如果你设置"SO_LINGER"值为0，你可能会阻止大量带有TIME_WAIT状态的套接字闲置。</td><td>No</td></tr><tr><td>End of line(EOL) byte value</td><td>行尾的字节值，将其设置为范围<code>-128</code>到<code>+127</code>以外的值，以跳过<code>eol</code>检查。你可以在 <code>jmeter.properties</code> 中设置这个以及eolByte属性。如果你在TCP采样配置和jmeter中设置这个。属性文件的同时，将使用TCP采样器配置中的设置值。</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时(毫秒，0禁用)。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时(毫秒，0禁用)。</td><td>Yes</td></tr><tr><td>Set NoDelay</td><td>看<code>java.net.Socket.setTcpNoDelay()</code>。如果选中，将禁用Nagle的算法，否则将使用Nagle的算法。</td><td>Yes</td></tr><tr><td>Text to Send</td><td>要发送的文本</td><td>Yes</td></tr><tr><td>Login User</td><td>用户名-默认实现中未使用</td><td>No</td></tr><tr><td>Password</td><td>密码-默认实现中不使用(注意，这个未加密存储在测试计划中)</td><td>No</td></tr></tbody></table></div><h3 id="Mail-Reader-Sampler-邮件阅读采样器"><a href="#Mail-Reader-Sampler-邮件阅读采样器" class="headerlink" title="Mail Reader Sampler | 邮件阅读采样器"></a>Mail Reader Sampler | 邮件阅读采样器</h3><p>邮件阅读器采样器可以使用POP3(S)或IMAP(S)协议读取(并可选地删除)邮件消息。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C11aabe48e984000aa7f78cd7e353602f.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/采样器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Timers 定时器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-timers-ding-shi-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-timers-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter-组件详解-Timers-定时器"><a href="#JMeter-组件详解-Timers-定时器" class="headerlink" title="JMeter 组件详解-Timers 定时器"></a>JMeter 组件详解-Timers 定时器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeter 组件详解-Timers 定时器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/定时器categories:  - JMeterkeywords:  - JMeter  - 组件  - 定时器description: 通过设置属性计时器，可以对随机计时器计算的睡眠延迟应用乘数。</code></pre><h2 id="Timer-定时器"><a href="#Timer-定时器" class="headerlink" title="Timer | 定时器"></a>Timer | 定时器</h2><p>通过设置属性计时器，可以对随机计时器计算的睡眠延迟应用乘数。Factor =float number，其中float number为十进制正数。</p><p>JMeter将这个因子乘以计算出来的睡眠延迟。此功能可由:</p><p>注意，计时器在它们被发现的范围内的每个采样器之前被处理;如果在同一个作用域中有多个计时器，那么所有的计时器都会在每个采样器之前被处理。</p><p>定时器只能与采样器一起处理。与采样器不在同一范围内的计时器根本不会被处理。</p><p>若要将计时器应用于单个采样器，请将计时器添加为采样器的子元素。计时器将在采样器执行之前应用。要在采样器之后应用计时器，可以将它添加到下一个采样器，或者将它添加为流量控制动作采样器的子程序。</p><h3 id="Constant-Timer-固定定时器"><a href="#Constant-Timer-固定定时器" class="headerlink" title="Constant Timer | 固定定时器"></a>Constant Timer | 固定定时器</h3><p> 如果您想让每个线程在请求之间暂停相同的时间，可以使用这个计时器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C670da2d843541dc22ef5d6feeca8ec2c.png" alt></p></div><h3 id="Gaussian-Random-Timer-高斯随机定时器"><a href="#Gaussian-Random-Timer-高斯随机定时器" class="headerlink" title="Gaussian Random Timer | 高斯随机定时器"></a>Gaussian Random Timer | 高斯随机定时器</h3><p>这个计时器将每个线程请求暂停一段随机的时间，大多数时间间隔发生在某个特定值附近。总延迟是高斯分布值(平均值为0.0，标准差为1.0)乘以指定的偏差值和偏移值的总和。另一种解释方法是，在高斯随机计时器中，恒定偏移量附近的变化具有高斯曲线分布。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3c2a5923af3be03ea63fa1f53da2a0c4.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称</td><td>No</td></tr><tr><td>Deviation</td><td>偏差,以毫秒为单位</td><td>Yes</td></tr><tr><td>Constant Delay Offset</td><td>除了随机延迟外，暂停的毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Uniform-Random-Timer-统一随机定时器"><a href="#Uniform-Random-Timer-统一随机定时器" class="headerlink" title="Uniform Random Timer | 统一随机定时器"></a>Uniform Random Timer | 统一随机定时器</h3><p>这个计时器将每个线程请求暂停一段随机的时间，每个时间间隔发生的概率相同。总延迟是随机值和偏移值的总和。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cda68c0ac317482db8700f3886b7beceb.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称</td><td>No</td></tr><tr><td>Random Delay Maximun</td><td>暂停的最大随机毫秒数。</td><td>Yes</td></tr><tr><td>Constant Delay Offset</td><td>除了随机延迟外，暂停的毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Constant-Throughput-Timer-常量吞吐计时器"><a href="#Constant-Throughput-Timer-常量吞吐计时器" class="headerlink" title="Constant Throughput Timer | 常量吞吐计时器"></a>Constant Throughput Timer | 常量吞吐计时器</h3><p>这个计时器引入了可变的暂停，计算的目的是保持总吞吐量(以每分钟的样本为单位)尽可能接近给定的数字。当然，如果服务器不能处理它，或者其他计时器或耗时的测试元素阻止它，那么吞吐量将会更低。</p><p>注意:虽然Timer被称为常量吞吐量计时器，但吞吐量值不需要是常量。它可以根据变量或函数调用来定义，并且可以在测试期间更改值。可以通过多种方式改变该值:</p><ul><li>使用计数器变量</li><li>使用<code>__jexl3</code>， <code>__groovy</code>函数提供一个更改值</li><li>使用远程<code>BeanShell</code>服务器来更改JMeter属性</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意，在测试期间不应该太频繁地更改吞吐量值—新值需要一段时间才能生效。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C91688733433a106a2b6503cf51fc93b7.png" alt></p></div><h3 id="Synchronizing-Timer-同步定时器"><a href="#Synchronizing-Timer-同步定时器" class="headerlink" title="Synchronizing Timer | 同步定时器"></a>Synchronizing Timer | 同步定时器</h3><p>SyncTimer的目的是阻塞线程，直到X个线程被阻塞，然后它们一次被释放。因此，SyncTimer可以在测试计划的各个点上创建大的即时负载。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C61e29042423f8a1f484e68ff183bee51.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称。</td><td>No</td></tr><tr><td>Number of Simultaneous Users to Group by</td><td>一次释放的线程数。将其设置为0相当于将其设置为Thread Group中的线程数。</td><td>Yes</td></tr><tr><td>Timeout in milliseconds</td><td>如果设置为0,Timer将等待线程的数量达到“number of Simultaneous Users to Group”中的值。如果高于0，则计时器将在最大“Timeout in毫秒”等待线程数。如果超时时间未达到等待用户数量，则停止等待。默认值为0</td><td>No</td></tr></tbody></table><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果timeout(以毫秒为单位)设置为0，并且线程数永远不会达到“number of Simultaneous Users to Group by”，那么Test将无限暂停。只有强行阻止才能阻止它。在这种情况下，可以考虑将Timeout设置为毫秒。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>只在一个JVM中同步计时器块，因此如果使用分布式测试，请确保不要将“Number of Simultaneous Users to Group by”设置为比只考虑1个注入器的线程组的用户数高的值。</p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter</title>
      <link href="/jmeter/jmeter/"/>
      <url>/jmeter/jmeter/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: JMeterdate: 2022-12-13 13:16tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/测试工具  - 细化主题/JMetercategories:  - 工具keywords:  - 测试工具description: Apache JMeter™应用程序是开源软件，100%纯Java应用程序，用于加载测试功能行为和测量性能。它最初是为测试Web应用程序而设计的，但后来扩展到其他测试功能。</code></pre><h2 id="推荐指数："><a href="#推荐指数：" class="headerlink" title="推荐指数："></a>推荐指数：</h2><ul><li>实用性： ⭐⭐⭐</li><li>稳定性： ⭐⭐⭐⭐⭐</li><li>复杂性：⭐⭐⭐⭐</li></ul><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><pre><code class="line-numbers language-text">- bin - 启动jmeter的所有文件    - properties结尾的文件，都是jmeter的属性配置文件，最主要的是`jmeter.properties`    - create-rmi-keystore：创建证书    - jmeter.log：日志打印- docs  - 开发人员使用的api文档- extras  - 持续集成CI/CD使用- lib  - jmeter工具的源码二进制jar包    - `/ext`：使用第三方插件时，把第三方jar放到该目录- printable_docs  - jmeter工具，离线帮助文档</code></pre><h2 id="开发接口测试案例的整体方案"><a href="#开发接口测试案例的整体方案" class="headerlink" title="开发接口测试案例的整体方案"></a>开发接口测试案例的整体方案</h2><ul><li>第一步：我们要分析出测试需求，并拿到开发提供的接口说明文档；</li><li>第二步：从接口说明文档中整理出接口测试案例，里面要包括详细的入参和出参数据以及明确的格式和检查点。</li><li>第三步：和开发一起对接口测试案例进行评审。</li><li>第四步：结合开发库，准备接口测试案例中的入参数据和出参数据，并整理成 csv 格式的文件。</li><li>第五步：结合接口测试案例文档和 csv 格式的数据文档，做接口测试案例的自动化案例开发。</li></ul><h2 id="接口自动化适用场景"><a href="#接口自动化适用场景" class="headerlink" title="接口自动化适用场景"></a>接口自动化适用场景</h2><ol><li><p>测试前置、开发自测：一个新的自动化接口测试案例开发完成后，直接发给接口对应的开发，安排在开发本地环境执行，一旦开发确认完成接口开发，就开始执行接口测试案例，基本上可以实时拿到测试结果，方便开发快速做出判断。【开发本地运行的方式就是打开 JMeter 工具，导入 JMX 文件，开始执行可。】</p></li><li><p>回归测试：开发本地测试通过后，或整个需求手工测试通过后，把自动化的接口测试案例做分类整理，挑选出需要纳入到回归测试中的案例，在持续集成环境重新准备测试数据，并把案例纳入到持续集成的 job 中来，这些用于回归的接口测试案例需要配置到持续集成平台自动运行。</p></li></ol><h2 id="测试计划-元素"><a href="#测试计划-元素" class="headerlink" title="测试计划 元素"></a>测试计划 元素</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol start="0"><li>配置元素</li><li>预处理器</li><li>计时器</li><li>采样器</li><li>后处理器（除非 SampleResult 为null）</li><li>断言（除非 SampleResult 为null）</li><li>侦听器（除非 SampleResult 为null）</li></ol><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">测试计划</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">线程组</p><ul><li>线程组元素是任何测试计划的起点。</li><li>所有控制器和采样器都必须在一个线程组下。</li><li>线程组的控件允许您：<ul><li>设置线程数</li><li>设置加速周期</li><li>设置执行测试的次数</li></ul></li><li>设置完成时间</li><li>指定线程生命周期</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">采样器</p><p>采样器告诉 JMeter 向服务器发送请求并等待响应。它们按照它们在树中出现的顺序进行处理。控制器可用于修改采样器的重复次数。</p><p>采样器包括</p><ul><li>FTP 请求</li><li>HTTP 请求（也可用于 SOAP 或 REST Web 服务）</li><li>JDBC 请求</li><li>Java 对象请求</li><li>JMS 请求</li><li>JUnit 测试请求</li><li>LDAP 请求</li><li>邮件请求</li><li>操作系统进程请求</li><li>TCP 请求</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">逻辑控制器</p><p>允许您自定义 JMeter 用来决定何时发送请求的逻辑。逻辑控制器可以更改来自其子元素的请求的顺序。他们可以自己修改请求，导致 JMeter 重复请求等。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">监听器</p><ul><li>侦听器提供对 JMeter 在 JMeter 运行时收集的有关测试用例的信息的访问。</li><li>侦听器可以将数据定向到文件以供以后使用。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">计时器</p><p>添加到您的线程组来指定延迟</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">断言</p><p>断言允许您断言有关从正在测试的服务器收到的响应的事实。使用断言，您基本上可以“测试”您的应用程序正在返回您期望的结果。</p><p>断言适用于其<a href="#scoping_rules">范围内</a>的所有采样器。要将断言限制为单个采样器，请将断言添加为采样器的子级。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">配置元素</p><ul><li>配置元素与采样器密切合作。</li><li>只能从放置元素的树分支内部访问配置元素。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">预处理器</p><ul><li>预处理器在发出采样器请求之前执行一些操作。如果预处理器附加到采样器元素，则它将在该采样器元素运行之前执行。</li><li>预处理器最常用于在样本请求运行之前修改其设置，或更新未从响应文本中提取的变量。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">后处理器</p><ul><li>在发出采样器请求后，后处理器会执行一些操作。如果 Post-Processor 附加到 Sampler 元素，则它将在该 sampler 元素运行后立即执行。</li><li>后处理器最常用于处理响应数据，通常用于从中提取值。</li></ul></div><h2 id="构建测试计划"><a href="#构建测试计划" class="headerlink" title="构建测试计划"></a>构建测试计划</h2><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">添加和删除元素</p><p>可以通过右键单击树中的元素并从“添加”列表中选择一个新元素来向测试计划添加元素。或者，可以通过选择“合并”或“打开”选项从文件中加载元素并添加元素。</p><p>要删除一个元素，请确保该元素已被选中，右键单击该元素，然后选择“删除”选项。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">加载和保存元素</p><p>要从文件加载元素，右键单击要添加加载元素的现有树元素，然后选择“合并”选项。选择保存元素的文件。JMeter 会将元素合并到树中。</p><p>要保存树元素，请右键单击一个元素并选择“将选择另存为... ”选项。JMeter 将保存选定的元素，以及它下面的所有子元素。这样，您可以保存测试树片段和单个元素以供以后使用。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">配置树元素</p><p>测试树中的任何元素都将在 JMeter 的右侧框架中显示控件。这些控件允许您配置该特定测试元素的行为。可以为元素配置什么取决于它是什么类型的元素。</p><p>测试树本身可以通过在测试树周围拖放组件来操作。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">保存测试计划</p><p>尽管不是必需的，但我们建议您在运行测试计划之前将其保存到文件中。要保存测试计划，请从文件菜单中选择“保存”或“将测试计划另存为... ”（对于最新版本，不再需要先选择测试计划元素）。</p><p>JMeter 允许您保存整个测试计划树或仅保存其中的一部分。要仅保存位于测试计划树的特定“分支”中的元素，请在树中选择“测试计划”元素以启动“分支”，然后单击鼠标右键访问“将选择另存为... " 菜单项。或者，选择适当的测试计划元素，然后从“编辑”菜单中 选择“将选择另存为... ”。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">运行测试计划</p><p>要运行您的测试计划，请从“运行”菜单项中选择“开始”（Control  +  r） 。当 JMeter 运行时，它会在菜单栏下方的部分右侧显示一个绿色小框。您还可以检查“运行”菜单。如果“开始”被禁用，并且“停止”被启用，那么 JMeter 正在运行您的测试计划（或者，至少，它认为是这样）。</p><p>绿色框左侧的数字是活动线程数/线程总数。这些仅适用于本地运行的测试；它们不包括使用客户端-服务器模式时在远程系统上启动的任何线程。</p><p>仅在调试测试计划时才应使用此处描述的 GUI 模式。要运行实际负载测试，请使用 CLI 模式。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">停止测试</p><p>菜单中有两种可用的停止命令：</p><p>Stop ( Control  +  . ) - 如果可能，立即停止线程。许多采样器是可中断的，这意味着活动采样可以提前终止。stop 命令将检查所有线程是否已在默认超时时间内停止，即 5000 ms = 5 秒。[这可以使用 JMeter 属性jmeterengine.threadstop.wait进行更改] 如果线程没有停止，则会显示一条消息。停止命令可以重试，但如果失败，则需要退出 JMeter 进行清理。Shutdown ( Control  +  , ) - 请求线程在任何当前工作结束时停止。不会中断任何活动样本。模式关闭对话框将保持活动状态，直到所有线程都停止。如果关机时间过长。关闭 Shutdown 对话框并选择Run / Stop，或者只需按Control  +  。.</p><p>在 CLI 模式下运行 JMeter 时，没有菜单，并且 JMeter 不会对诸如Control  + 等按键做出反应。. 因此 JMeter CLI 模式将监听特定端口上的命令（默认4445，请参阅 JMeter 属性jmeterengine.nongui.port）。如果正在使用默认端口（例如由另一个 JMeter 实例），JMeter 支持自动选择备用端口。在这种情况下，JMeter 将尝试下一个更高的端口，一直持续到它到达默认为 4455 的JMeter属性<code>jmeterengine.nongui.maxport</code>。如果<code>maxport</code>小于或等于port，则不会进行端口扫描。</p><p>所选端口显示在控制台窗口中。</p><p>目前支持的命令有：</p><ul><li>shotdown - 优雅关机</li><li>StopTestNow - 立即关闭</li></ul><p>这些命令可以分别使用<code>shutdown[.cmd|.sh]</code>或<code>stoptest[.cmd|.sh]</code>脚本发送。这些脚本可以在 JMeter bin目录中找到。仅当脚本从同一主机运行时，才会接受这些命令。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">错误报告</p><p>JMeter 向jmeter.log文件 报告警告和错误，以及测试运行本身的一些信息。JMeter 在其窗口右侧的警告图标（三角形）旁边显示在jmeter.log文件中发现的警告/错误的数量。单击警告图标以在 JMeter 窗口的底部显示jmeter.log文件。只是偶尔可能会出现一些 JMeter 无法捕获和记录的错误；这些将出现在命令控制台上。如果测试没有按预期进行，请检查日志文件以防报告任何错误（例如，可能是函数调用中的语法错误）。</p><p>日志文件中通常不会报告采样错误（例如 HTTP 404 - 未找到文件）。相反，这些被存储为样本结果的属性。可以在各种不同的侦听器中看到样本结果的状态。</p></div><h2 id="命令行选项的完整列表"><a href="#命令行选项的完整列表" class="headerlink" title="命令行选项的完整列表"></a>命令行选项的完整列表</h2><p>调用JMeter作为<code>JMeter -?</code>将打印所有命令行选项的列表。它们如下所示。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">JMeter 命令行列表</p><pre><code class="language-shell">    --?        print command line options and exit    -h, --help        print usage information and exit    -v, --version        print the version information and exit    -p, --propfile &lt;argument&gt;        the jmeter property file to use    -q, --addprop &lt;argument&gt;        additional JMeter property file(s)    -t, --testfile &lt;argument&gt;        the jmeter test(.jmx) file to run    -l, --logfile &lt;argument&gt;        the file to log samples to    -i, --jmeterlogconf &lt;argument&gt;        jmeter logging configuration file (log4j2.xml)    -j, --jmeterlogfile &lt;argument&gt;        jmeter run log file (jmeter.log)    -n, --nongui        run JMeter in nongui mode    -s, --server        run the JMeter server    -H, --proxyHost &lt;argument&gt;        Set a proxy server for JMeter to use    -P, --proxyPort &lt;argument&gt;        Set proxy server port for JMeter to use    -N, --nonProxyHosts &lt;argument&gt;        Set nonproxy host list (e.g. *.apache.org|localhost)    -u, --username &lt;argument&gt;        Set username for proxy server that JMeter is to use    -a, --password &lt;argument&gt;        Set password for proxy server that JMeter is to use    -J, --jmeterproperty &lt;argument&gt;=&lt;value&gt;        Define additional JMeter properties    -G, --globalproperty &lt;argument&gt;=&lt;value&gt;        Define Global properties (sent to servers)        e.g. -Gport=123         or -Gglobal.properties    -D, --systemproperty &lt;argument&gt;=&lt;value&gt;        Define additional system properties    -S, --systemPropertyFile &lt;argument&gt;        additional system property file(s)    -f, --forceDeleteResultFile        force delete existing results files and web report folder if present before starting the test    -L, --loglevel &lt;argument&gt;=&lt;value&gt;        [category=]level e.g. jorphan=INFO, jmeter.util=DEBUG or com.example.foo=WARN    -r, --runremote        Start remote servers (as defined in remote_hosts)    -R, --remotestart &lt;argument&gt;        Start these remote servers (overrides remote_hosts)    -d, --homedir &lt;argument&gt;        the jmeter home directory to use    -X, --remoteexit        Exit the remote servers at end of test (CLI mode)    -g, --reportonly &lt;argument&gt;        generate report dashboard only, from a test results file    -e, --reportatendofloadtests        generate report dashboard after load test    -o, --reportoutputfolder &lt;argument&gt;        output folder for report dashboard</code></pre></div><h2 id="JMeter-配置"><a href="#JMeter-配置" class="headerlink" title="JMeter 配置"></a>JMeter 配置</h2><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>ssl.provider</td><td>如果不想使用内置Java实现，可以为SSL实现指定类。</td><td>No</td></tr><tr><td>xml.parser</td><td>您可以指定一个实现作为XML解析器。默认值为: <code>org.apache.xerces.parser . saxparser</code></td><td>No</td></tr><tr><td>remote_hosts</td><td>以逗号分隔的远程JMeter主机列表(如果需要，可以选择主机:端口)。如果您在分布式环境中运行JMeter，请列出运行JMeter远程服务器的机器。这将允许您从这台机器的GUI控制这些服务器</td><td>No</td></tr><tr><td>not_in_menu</td><td>不希望在JMeter菜单中看到的组件列表。随着JMeter添加了越来越多的组件，您可能希望自定义JMeter以只显示您感兴趣的那些组件。您可以在这里列出它们的类名或类标签(出现在JMeter UI中的字符串)，它们将不再出现在菜单中。</td><td>No</td></tr><tr><td>search_paths</td><td>JMeter将搜索JMeter插件类的路径列表(以;分隔)，例如额外的采样器。路径项可以是jar文件或目录。在这样一个目录中的任何jar文件将自动包含在search_path中，子目录中的jar文件将被忽略。给定的值是在lib/ext目录中找到的任何jar之外的值。</td><td>No</td></tr><tr><td>user.classpath</td><td>JMeter将搜索实用程序和插件依赖类的路径列表。使用平台路径分隔符分隔多个路径。路径项可以是jar文件或目录。这样一个目录中的任何jar文件都将自动包含在user中。类路径，子目录中的jar文件将被忽略。给定的值是在lib目录中找到的任何jar之外的值。所有条目都将添加到系统类装入器的类路径中，也会添加到JMeter内部装入器的路径中。</td><td>No</td></tr><tr><td>plugin_dependency_paths</td><td>JMeter将搜索实用程序和插件依赖类的路径列表(以;分隔)。路径项可以是jar文件或目录。在这样一个目录中的任何jar文件将自动包含在plugin_dependency_paths中，子目录中的jar文件将被忽略。给定的值是在lib目录中找到的jar文件之外的，或者是用户给出的。类路径属性。所有条目将只被添加到JMeter内部加载器的路径中。对于插件依赖，使用plugin_dependency_paths应该优于user.classpath。</td><td>No</td></tr><tr><td>user.properties</td><td>包含附加JMeter属性的文件的名称。它们添加在初始属性文件之后，但在处理-q和-J选项之前。</td><td>No</td></tr><tr><td>system.properties</td><td>包含附加系统属性的文件的名称。在处理-S和-D选项之前添加这些选项。</td><td>No</td></tr></tbody></table><p>命令行选项和属性文件的处理顺序如下:</p><ol><li>-p propfile</li><li>jmeter.properties (or the file from the -p option) is then loaded</li><li>-j logfile</li><li>Logging is initialised</li><li>user.properties is loaded</li><li>system.properties is loaded</li><li>all other command-line options are processed</li></ol><h2 id="组件详解"><a href="#组件详解" class="headerlink" title="组件详解"></a>组件详解</h2><ul><li><a href="../jmeter-zu-jian-xiang-jie-assertions-duan-yan">Assertions 断言</a></li><li><a href="../jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian">Configuration 配置原件</a></li><li><a href="../jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi">Listeners 监听器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi">Logic Controller 控制器</a></li><li><a href="jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi">Pre-Processors 前置处理器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi">Post Processors 后置处理器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi">Samplers 采样器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-timers-ding-shi-qi">Timers 定时器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/测试工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-个人博客-索引</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-suo-yin/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-个人博客-索引"><a href="#hexo-个人博客-索引" class="headerlink" title="hexo-个人博客-索引"></a>hexo-个人博客-索引</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">- title: hexo-个人博客-索引- date: 2022-08-09 14:42- version: Version 1.1.0- updated: 2022-08-09 14:42- aside: true- top_img: - comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - Blog  - index- categories:  - hexo- keyword:  - 索引- description: hexo的个人博客的相关文章索引</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="hexo-个人博客-构建教程"><a href="#hexo-个人博客-构建教程" class="headerlink" title="hexo-个人博客-构建教程"></a>hexo-个人博客-构建教程</h3><p><a href="../hexo-ge-ren-bo-ke-gou-jian-jiao-cheng">点我跳转</a></p><p><strong>TOC</strong></p><ul><li>安装及配置</li><li>hexo 的相关命令</li></ul><h3 id="hexo-个人博客-个性化-matery主题"><a href="#hexo-个人博客-个性化-matery主题" class="headerlink" title="hexo-个人博客-个性化-matery主题"></a>hexo-个人博客-个性化-matery主题</h3><p><a href="../hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti">点我跳转</a></p><p><strong>TOC</strong></p><ul><li>简介</li><li>下载</li><li>配置</li><li>文章 Front-matter 介绍</li><li>效果截图</li><li>自定制修改</li><li>版本变更记录</li><li>更多部署方式</li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="Version-1-0-0"><a href="#Version-1-0-0" class="headerlink" title="Version 1.0.0"></a>Version 1.0.0</h3><p><strong>Done</strong></p><ul><li>hexo-个人博客-构建教程</li><li>hexo-个人博客-个性化-matery主题</li></ul><p><strong>TODO</strong></p><p>- </p><h3 id="Version-1-1-0"><a href="#Version-1-1-0" class="headerlink" title="Version 1.1.0"></a>Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02_hexo-个人博客-个性化-matery主题</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-个人博客-个性化-matery主题"><a href="#hexo-个人博客-个性化-matery主题" class="headerlink" title="hexo-个人博客-个性化-matery主题"></a>hexo-个人博客-个性化-matery主题</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">- title: hexo-个人博客-个性化-matery主题- date: 2022-08-09 11:02- version: Version 1.1.0- updated: 2022-08-09 11:02- aside: true- top_img:- comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - hexo-theme  - Blog  - matery- categories:  - hexo- keywords:  - matery 主题- description: hexo-theme-matery主题的相关介绍和配置</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。</p></blockquote><h3 id="跳转链接"><a href="#跳转链接" class="headerlink" title="跳转链接"></a>跳转链接</h3><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery">github hexo-theme-matery</a></li><li><a href="http://blinkfox.com/">国内访问示例</a></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>简单漂亮，文章内容美观易读</li><li>Material Design 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 Banner 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li>词云的标签页和雷达图的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 MathJax</li><li>TOC 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li>Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk）</li><li>集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li><li>支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。</li><li>支持 DaoVoice、Tidio 在线聊天功能。</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。</p><p>当然你也可以在你的 themes 文件夹下使用 git clone 命令来下载:</p><pre><code class="line-numbers language-git">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 theme 的值：<code>theme: hexo-theme-matery</code></p><p><strong>_config.yml 文件的其它修改建议:</strong></p><ul><li>请修改 <code>_config.yml</code> 的 url 的值为你的网站主 URL（如：<a href="http://xxx.github.io)./">http://xxx.github.io）。</a></li><li>建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 language 的值为 zh-CN。</li></ul><h3 id="相关页面"><a href="#相关页面" class="headerlink" title="相关页面"></a>相关页面</h3><h4 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="line-numbers language-bash">hexo new page "categories"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre><code class="line-numbers language-yaml">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h4 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="line-numbers language-bash">hexo new page "tags"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code class="line-numbers language-yaml">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h4 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h4><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="line-numbers language-bash">hexo new page "about"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code class="line-numbers language-yaml">---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---</code></pre><h4 id="新建留言板-contact-页（可选的）"><a href="#新建留言板-contact-页（可选的）" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h4><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="line-numbers language-bash">hexo new page "contact"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre><code class="line-numbers language-yaml">---title: contactdate: 2018-09-30 17:25:30type: "contact"layout: "contact"---</code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h4 id="新建友情链接-friends-页（可选的）"><a href="#新建友情链接-friends-页（可选的）" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h4><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="line-numbers language-bash">hexo new page "friends"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre><code class="line-numbers language-yaml">---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---</code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre><code class="line-numbers language-json">[{    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",    "name": "码酱",    "introduction": "我不是大佬，只是在追寻大佬的脚步",    "url": "http://luokangyuan.com/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/4027734.jpeg",    "name": "闪烁之狐",    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",    "url": "https://blinkfox.github.io/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/avatar.jpg",    "name": "ja_rome",    "introduction": "平凡的脚步也可以走出伟大的行程",    "url": "https://me.csdn.net/jlh912008548",    "title": "前去学习"}]</code></pre><h4 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h4><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre><code class="line-numbers language-bash">hexo new page 404</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre><code class="line-numbers language-yaml">---title: 404date: 2018-09-30 17:25:30type: "404"layout: "404"description: "Oops～，我崩溃了！找不到你想要的页面 :("---</code></pre><h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon"><a href="#配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找   </p><pre><code class="line-numbers language-yaml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle  Friends:    url: /friends    icon: fas fa-address-book</code></pre><h4 id="二级菜单配置方法"><a href="#二级菜单配置方法" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)     </li><li>在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.      </li><li>注意每个二级菜单模块前要加 <code>-</code>.     </li><li>注意缩进格式</li></ol><pre><code class="line-numbers language-yaml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle-o  Friends:    url: /friends    icon: fas fa-address-book  Medias:    icon: fas fa-list    children:      - name: Music        url: /music        icon: fas fa-music      - name: Movies        url: /movies        icon: fas fa-film      - name: Books        url: /books        icon: fas fa-book      - name: Galleries        url: /galleries        icon: fas fa-image</code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre><code class="line-numbers language-yaml">highlight:  enable: false  line_number: true  auto_detect: false  tab_replace: ''  wrap: true  hljs: falseprismjs:  enable: true  preprocess: true  line_number: true  tab_replace: ''</code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre><code class="line-numbers language-bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="line-numbers language-yaml">search:  path: search.xml  field: post</code></pre><h3 id="中文链接转拼音（建议安装）"><a href="#中文链接转拼音（建议安装）" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre><code class="line-numbers language-bash">npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="line-numbers language-yaml">permalink_pinyin:  enable: true  separator: '-' # default: '-'</code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre><code class="line-numbers language-bash">npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre><code class="line-numbers language-yaml">postInfo:  date: true  update: false  wordCount: false # 设置文章字数统计为 true.  totalCount: false # 设置站点文章总字数统计为 true.  min2read: false # 阅读时长.  readCount: false # 阅读次数.</code></pre><h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre><code class="line-numbers language-bash">npm install hexo-filter-github-emojis --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="line-numbers language-yaml">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre><code class="line-numbers language-bash">npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="line-numbers language-yaml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）"><a href="#添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）"><a href="#添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre><code class="line-numbers language-html">&lt;% if (theme.socialLink.github) { %&gt;    &lt;a href="&lt;%= theme.socialLink.github %&gt;" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt;        &lt;i class="fab fa-github"&gt;&lt;/i&gt;    &lt;/a&gt;&lt;% } %&gt;</code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre><code class="line-numbers language-yaml"># 是否在首页显示音乐music:  enable: true  title:         # 非吸底模式有效    enable: true    show: 听听音乐  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 503838841     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠</code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="添加note"><a href="#添加note" class="headerlink" title="添加note"></a>添加note</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-note"></a></p></blockquote><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><pre><code>{% note [class] [no-icon] [summary] %}Any content (support inline tags too).{% endnote %}</code></pre><ul><li><code>[class]</code> : <em>Optional parameter.</em> Supported values: default | primary | success | info | warning | danger.</li><li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon in note.</li><li><code>[summary]</code> : <em>Optional parameter.</em> Optional summary of the note.</li></ul><p>All parameters are optional.</p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><pre><code>{% note %}#### Header(without define class style){% endnote %}</code></pre><h3 id="添加button"><a href="#添加button" class="headerlink" title="添加button"></a>添加button</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-button"></a></p></blockquote><h4 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h4><pre><code>{% button url, text, icon [class], [title] %}</code></pre><p>or</p><pre><code>{% btn url, text, icon [class], [title] %}</code></pre><ul><li><code>url</code> : Absolute or relative path to URL.</li><li><code>text</code> : Button text. Required if no icon specified.</li><li><code>icon</code> : Font Awesome icon name. Required if no text specified.</li><li><code>[class]</code> : <em>Optional parameter.</em> Font Awesome class(es): <code>fa-fw</code> | <code>fa-lg</code> | <code>fa-2x</code> | <code>fa-3x</code> | <code>fa-4x</code> | <code>fa-5x</code></li><li><code>[title]</code> : <em>Optional parameter.</em> Tooltip at mouseover.</li></ul><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre><code>{% button #, Text %}</code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre><code class="line-numbers language-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre><code class="line-numbers language-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre><code class="line-numbers language-css">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre><code class="line-numbers language-javascript">$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');</code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本变更记录"><a href="#版本变更记录" class="headerlink" title="版本变更记录"></a>版本变更记录</h2><p>参见 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/CHANGELOG.md">CHANGELOG.md</a></p><h2 id="更多部署方式"><a href="#更多部署方式" class="headerlink" title="更多部署方式"></a>更多部署方式</h2><blockquote><p>Jsdelivr 已经被封了，这两个可以加速访问快一点</p></blockquote><ul><li><p><a href="https://blog.17lai.site/posts/5311b619/#vercel-%E9%83%A8%E7%BD%B2"></a></p></li><li><p><a href="https://blog.17lai.site/posts/5311b619/#cloudflare-Pages-%E9%83%A8%E7%BD%B2"></a></p></li></ul><h2 id="BUG-及-解决"><a href="#BUG-及-解决" class="headerlink" title="BUG 及 解决"></a>BUG 及 解决</h2><p>- </p><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="Version-1-0-0"><a href="#Version-1-0-0" class="headerlink" title="Version 1.0.0"></a>Version 1.0.0</h3><p><strong>Done</strong></p><ul><li>文章的创建</li><li>matery 主题的介绍及下载配置</li></ul><p><strong>TODO</strong></p><p>- </p><h3 id="Version-1-1-0"><a href="#Version-1-1-0" class="headerlink" title="Version 1.1.0"></a>Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a><ul><li>README_CN.md</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo-theme </tag>
            
            <tag> Blog </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01_hexo-个人博客-构建教程</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-gou-jian-jiao-cheng/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-gou-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-个人博客-构建教程"><a href="#hexo-个人博客-构建教程" class="headerlink" title="hexo-个人博客-构建教程"></a>hexo-个人博客-构建教程</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">- title: hexo-个人博客 构建教程- date: 2022-08-07 15:44- version: Version 1.1.0- updated: 2022-08-07 15:44- aside: true- top_img: - comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - gitlab  - Blog- categories:  - hexo- keywords:  - 构建教程- description: hexo的个人博客搭建教程 - 包括基础的配置，bug的修复，与github的连接以及 matery主题的简记</code></pre><h2 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h2><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><ol><li>下载Node.js。</li><li>安装选项全部默认，一路点击Next。</li><li>输入node -v和npm -v，如果出现版本号，那么就安装成功了。</li></ol><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><p>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入git –version验证是否安装成功。</p><h3 id="Github-配置"><a href="#Github-配置" class="headerlink" title="Github 配置"></a>Github 配置</h3><p>打开 <code>https://github.com/</code> ，新建一个项目。</p><p>然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的github名字完全一样，比如你github名字叫abc，那么仓库名字一定要是abc.github.io。</p><p>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages。</p><p>点击那个链接，就会出现自己的网页。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件。</p><p>在终端中，定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<code>http://localhost:4000/</code>。</p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h3 id="连接-Github-与-本地"><a href="#连接-Github-与-本地" class="headerlink" title="连接 Github 与 本地"></a>连接 Github 与 本地</h3><h4 id="git-SSH-配置"><a href="#git-SSH-配置" class="headerlink" title="git SSH 配置"></a>git SSH 配置</h4><p>可参考其他教程，暂不赘述。</p><h4 id="hexo-连接-github"><a href="#hexo-连接-github" class="headerlink" title="hexo 连接 github"></a>hexo 连接 github</h4><p>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><pre><code class="line-numbers language-yml">deploy:  type: git  repository: https://github.com/【username】/【username】.github.io  branch: master</code></pre><ul><li>【username】:  替换成 github 的 username</li></ul><h2 id="hexo-的-相关命令"><a href="#hexo-的-相关命令" class="headerlink" title="hexo 的 相关命令"></a>hexo 的 相关命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><pre><code class="line-numbers language-bash">$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js"></a> 安装。</li></ol><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre><code class="line-numbers language-bash">$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code class="line-numbers language-bash">$ hexo new "post title with whitespace"</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, –path</td><td>自定义新文章的路径</td></tr><tr><td>-r, –replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, –slug</td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code class="line-numbers language-bash">hexo new page --path about/me "About me"</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>"About me"</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre><code class="line-numbers language-bash">hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>"page"</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><pre><code class="line-numbers language-bash">$ hexo generate</code></pre><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr><tr><td>-b, –bail</td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td>-f, –force</td><td>强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td>-c, –concurrency</td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><pre><code class="line-numbers language-bash">$ hexo g</code></pre><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><pre><code class="line-numbers language-bash">$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><pre><code class="line-numbers language-bash">$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p, –port</td><td>重设端口</td></tr><tr><td>-s, –static</td><td>只使用静态文件</td></tr><tr><td>-l, –log</td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><pre><code class="line-numbers language-bash">$ hexo deploy</code></pre><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-g, –generate</td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><pre><code class="line-numbers language-bash">$ hexo d</code></pre><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><pre><code class="line-numbers language-bash">$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-o, –output</td><td>设置输出路径</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><pre><code class="line-numbers language-bash">$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><pre><code class="line-numbers language-bash">$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><pre><code class="line-numbers language-bash">$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><pre><code class="line-numbers language-bash">$ hexo version</code></pre><p>显示 Hexo 版本。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><pre><code class="line-numbers language-bash">$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><pre><code class="line-numbers language-bash">$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。</p><h4 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h4><pre><code class="line-numbers language-bash">$ hexo --silent</code></pre><p>隐藏终端信息。</p><h4 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h4><pre><code class="line-numbers language-bash">$ hexo server --config custom.yml$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><pre><code class="line-numbers language-bash">$ hexo server --config custom.yml$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><pre><code class="line-numbers language-bash">$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h4 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义-CWD"></a>自定义-CWD</h4><pre><code class="line-numbers language-bash">$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p><h2 id="BUG-及-解决"><a href="#BUG-及-解决" class="headerlink" title="BUG 及 解决"></a>BUG 及 解决</h2><p>- </p><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="Version-1-0-1"><a href="#Version-1-0-1" class="headerlink" title="Version 1.0.1"></a>Version 1.0.1</h3><p><strong>Done</strong></p><ul><li>创建笔记</li><li>hexo 的安装及配置</li><li>笔记的拆分</li></ul><h3 id="Version-1-1-0"><a href="#Version-1-1-0" class="headerlink" title="Version 1.1.0"></a>Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-1"></a><ul><li>韦阳的博客</li><li>笔记的安装及配置</li></ul></li><li><a href="https://hexo.io/zh-cn/docs/commands">指令</a><ul><li>hexo 官网</li><li>hexo 的指令</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
