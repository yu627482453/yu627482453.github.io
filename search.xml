<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Java 多线程并发】 final</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 final</h1><h2 id="Metadata-34">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 finaldate: 2022-12-14 15:02tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 final</code></pre><h2 id="final-基础使用">final 基础使用</h2><h3 id="修饰类">修饰类</h3><p>当某个类的整体定义为 final 时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p><p>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中给任何方法添加 final 关键字是没有任何意义的。</p><h3 id="修饰方法">修饰方法</h3><ul><li>private 方法是隐式的 final</li><li>final 方法是可以被重载的</li></ul><h4 id="private-final">private final</h4><p>类中所有 private 方法都隐式地指定为 final 的，由于无法取用 private 方法，所以也就不能覆盖它。可以对 private 方法增添 final 关键字，但这样做并没有什么好处。</p><h4 id="final-方法是可以被重载的">final 方法是可以被重载的</h4><p>我们知道父类的 final 方法是不能够被子类重写的，那么 final 方法可以被重载吗? 答案是可以的，下面代码是正确的。</p><h3 id="修饰参数">修饰参数</h3><p>Java 允许在参数列表中以声明的方式将参数指明为 final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p><h4 id="所有的final修饰的字段都是编译期常量吗">所有的final修饰的字段都是编译期常量吗?</h4><p>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</p><h4 id="static-final">static final</h4><p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p><h4 id="blank-final">blank final</h4><p>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p><ul><li>在定义处进行赋值(这不叫空白final)</li><li>在构造器中进行赋值，保证了该值在被使用前赋值。</li></ul><p>这增强了final的灵活性。</p><h2 id="final域重排序规则">final域重排序规则</h2><h3 id="final域为基本类型">final域为基本类型</h3><h4 id="写final域重排序规则">写final域重排序规则</h4><p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外；</li><li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li></ul><h4 id="读final域重排序规则">读final域重排序规则</h4><p>read()方法主要包含了三个操作：</p><ul><li>初次读引用变量finalDemo;</li><li>初次读引用变量finalDemo的普通域a;</li><li>初次读引用变量finalDemo的final域b;</li></ul><h3 id="final域为引用类型">final域为引用类型</h3><h4 id="对final修饰的对象的成员域写操作">对final修饰的对象的成员域写操作</h4><p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。</p><h4 id="对final修饰的对象的成员域读操作">对final修饰的对象的成员域读操作</h4><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下<code>arrays[0] = 1</code>，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p><h3 id="关于final重排序的总结">关于final重排序的总结</h3><ul><li>基本数据类型:<ul><li>final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li><li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li></ul></li><li>引用数据类型：</li><li>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li></ul><h2 id="final再深入理解">final再深入理解</h2><h3 id="final的实现原理">final的实现原理</h3><p>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p><h3 id="为什么final引用不能从构造函数中“溢出”">为什么final引用不能从构造函数中“溢出”</h3><p>上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 volatile</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-volatile/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-volatile/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 volatile</h1><h2 id="Metadata-37">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 volatiledate: 2022-12-14 15:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 volatile</code></pre><h2 id="volatile-的作用详解">volatile 的作用详解</h2><h3 id="防重排序">防重排序</h3><pre><code class="language-java">public class Singleton {    public static volatile Singleton singleton;        private Singleton() {};    public static Singleton getInstance() {        if (singleton == null) {            synchronized (singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}</code></pre><p>现在我们分析一下为什么要在变量 singleton 之间加上 volatile 关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p><ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul><p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量。</p><h3 id="实现可见性">实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p><h3 id="保证原子性-单次读-写">保证原子性: 单次读 / 写</h3><h4 id="问题-1：-i-为什么不能保证原子性">问题 1： i++ 为什么不能保证原子性?</h4><p>对于原子性，需要强调一点，也是大家容易误解的一点：对 volatile 变量的单次读 / 写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++ 这种操作的原子性，因为本质上 i++ 是读、写两次操作。</p><h4 id="问题-2：-共享的-long-和-double-变量的为什么要用-volatile">问题 2： 共享的 long 和 double 变量的为什么要用 volatile?</h4><p>因为 long 和 double 两种数据类型的操作可分为高 32 位和低 32 位两部分，因此普通的 long 或 double 类型读 / 写可能不是原子的。因此，鼓励大家将共享的 long 和 double 变量设置为 volatile 类型，这样能保证任何情况下对 long 和 double 的单次读 / 写操作都具有原子性。</p><h2 id="volatile-的实现原理">volatile 的实现原理</h2><h3 id="volatile-可见性实现">volatile 可见性实现</h3><blockquote><p>volatile 变量的内存可见性是基于内存屏障 (Memory Barrier) 实现:</p></blockquote><ul><li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li><li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止 + 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</li></ul><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><h4 id="lock-指令">lock 指令</h4><p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议 (MESI) 来保证。</p><h4 id="缓存一致性">缓存一致性</h4><p>缓存是分段 (line) 的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “嗅探(snooping)” 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p><h3 id="volatile-有序性实现">volatile 有序性实现</h3><p>volatile 的 happens-before 关系</p><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-1.png" alt></p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读 / 写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-3.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-4.png" alt></p><h2 id="volatile-的应用场景">volatile 的应用场景</h2><p>使用 volatile 必须具备的条件</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><h3 id="模式-1：状态标志">模式 1：状态标志</h3><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p><h3 id="模式-2：一次性安全发布-one-time-safe-publication">模式 2：一次性安全发布 (one-time safe publication)</h3><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值 (由另一个线程写入) 和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定 (double-checked-locking) 问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p><h3 id="模式-3：独立观察-independent-observation">模式 3：独立观察 (independent observation)</h3><p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p><h3 id="模式-4：volatile-bean-模式">模式 4：volatile bean 模式</h3><p>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。</p><h3 id="模式-5：开销较低的读－写锁策略">模式 5：开销较低的读－写锁策略</h3><p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作 (读、添加、存储) 的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p><h3 id="模式-6：双重检查-double-checked">模式 6：双重检查 (double-checked)</h3><p>单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】synchronized</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-synchronized/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-synchronized/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】synchronized</h1><h2 id="Metadata-39">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】synchronizeddate: 2022-12-14 14:57tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 Synchronized</code></pre><h2 id="【Java-多线程并发】synchronized-2">【Java 多线程并发】synchronized</h2><blockquote><p>在Java中除了提供Lock API外还在语法层面上提供了synchronized关键字来实现互斥同步原语</p></blockquote><p>在应用 Sychronized 关键字时需要把握如下注意点：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li><li>每个实例都对应有自己的一把锁 (this), 不同实例之间互不影响；例外：锁对象是 *.class 以及 synchronized 修饰的是 static 方法的时候，所有对象公用同一把锁</li><li>synchronized 修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li></ul><h2 id="对象锁">对象锁</h2><p>包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)</p><h3 id="代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁">代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence = new SynchronizedObjectLock();    @Override    public void run() {        // 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行        synchronized (this) {            System.out.println("我是线程" + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "结束");        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instence);        Thread t2 = new Thread(instence);        t1.start();        t2.start();    }}</code></pre><h3 id="方法锁形式：synchronized修饰普通方法，锁对象默认为this">方法锁形式：synchronized修饰普通方法，锁对象默认为this</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence = new SynchronizedObjectLock();    @Override    public void run() {        method();    }    public synchronized void method() {        System.out.println("我是线程" + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "结束");    }    public static void main(String[] args) {        Thread t1 = new Thread(instence);        Thread t2 = new Thread(instence);        t1.start();        t2.start();    }}</code></pre><h2 id="类锁">类锁</h2><p>指synchronize修饰静态的方法或指定锁对象为Class对象</p><h3 id="synchronize修饰静态方法">synchronize修饰静态方法</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();    @Override    public void run() {        method();    }    // synchronized用在普通方法上，默认的锁就是this，当前实例    public synchronized void method() {        System.out.println("我是线程" + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "结束");    }    public static void main(String[] args) {        // t1和t2对应的this是两个不同的实例，所以代码不会串行        Thread t1 = new Thread(instence1);        Thread t2 = new Thread(instence2);        t1.start();        t2.start();    }}</code></pre><h3 id="synchronized指定锁对象为Class对象">synchronized指定锁对象为Class对象</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();    @Override    public void run() {        // 所有线程需要的锁都是同一把        synchronized(SynchronizedObjectLock.class){            System.out.println("我是线程" + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "结束");        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instence1);        Thread t2 = new Thread(instence2);        t1.start();        t2.start();    }}</code></pre><h2 id="Synchronized原理分析">Synchronized原理分析</h2><h3 id="加锁和释放锁的原理">加锁和释放锁的原理</h3><p><img src="/attachment%5C2bfd5508d9cb8a994c26149dac733340.png" alt></p><h3 id="可重入原理：加锁次数计数器">可重入原理：加锁次数计数器</h3><ul><li>什么是可重入？可重入锁？</li></ul><p><strong>可重入：</strong>（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</p><p><strong>可重入锁：</strong> 又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><h3 id="保证可见性的原理：内存模型和happens-before规则">保证可见性的原理：内存模型和happens-before规则</h3><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。</p><h2 id="JVM-中锁的优化">JVM 中锁的优化</h2><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。</p><ul><li><strong>锁粗化(Lock Coarsening)：</strong> 也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</li><li><strong>锁消除(Lock Elimination)：</strong> 通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</li><li><strong>轻量级锁(Lightweight Locking)：</strong> 这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</li><li><strong>偏向锁(Biased Locking)：</strong> 是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</li><li><strong>适应性自旋(Adaptive Spinning)：</strong> 当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。</li></ul><h3 id="锁的类型">锁的类型</h3><blockquote><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p></blockquote><h4 id="自旋锁">自旋锁</h4><blockquote><p>为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</p></blockquote><p>如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。</p><h4 id="自适应自旋锁">自适应自旋锁</h4><p>自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么 JVM 会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到 100 此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM 对程序的锁的状态预测会越来越准确，JVM 也会越来越聪明。</p><h3 id="锁消除">锁消除</h3><p>锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。<br>JVM 会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那 JVM 就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p><h3 id="锁粗化">锁粗化</h3><p>尽可能的将同步块的作用范围限制到尽量小的范围 (只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p><h3 id="轻量级锁">轻量级锁</h3><p>在对象头中 (<code>Object Header</code>) 存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为 32 位或者 64 位 (视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针 (<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p><h4 id="轻量级锁加锁">轻量级锁加锁</h4><p>在线程执行同步块之前，JVM 会先在当前线程的栈帧中创建一个名为锁记录 (<code>Lock Record</code>) 的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝 (JVM 会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>) 这个时候线程堆栈与对象头的状态如图：</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-5.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-6.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-7.png" alt></p><h3 id="偏向锁">偏向锁</h3><blockquote><p>在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p></blockquote><p>只需要简单的测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-8.png" alt></p><h4 id="偏向锁的撤销">偏向锁的撤销</h4><p>偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点 (就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM 会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-9.png" alt></p><h3 id="锁的优缺点对比">锁的优缺点对比</h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要 CAS 操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了响应速度</td><td>如线程成始终得不到锁竞争的线程，使用自旋会消耗 CPU 性能</td><td>追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不适用自旋，不会消耗 CPU</td><td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table><h2 id="Synchronized-与-Lock">Synchronized 与 Lock</h2><p>synchronized 的缺陷</p><ul><li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock 可以中断和设置超时</li><li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件 (某个对象)，相对而言，读写锁更加灵活</li><li><code>无法知道是否成功获得锁</code>，相对而言，Lock 可以拿到状态，如果成功获取锁，…，如果获取失败，…</li></ul><h3 id="Lock-解决相应问题">Lock 解决相应问题</h3><p>Lock 类这里不做过多解释，主要看里面的 4 个方法:</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个 boolean 值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized 只有锁只与一个条件 (是否获取锁) 相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p><h2 id="深入">深入</h2><p>synchronized 是通过软件 (JVM) 实现的，简单易用，即使在 JDK5 之后有了 Lock，仍然被广泛的使用。</p><p><strong>使用 Synchronized 有哪些要注意的？</strong></p><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用 Lock 也不要用 synchronized 关键字，用 java.util.concurrent 包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用 synchronized 关键，因为代码量少，避免出错</li></ul><p><strong>synchronized 是公平锁吗？</strong></p><p>synchronized 实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程并发</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1>Java 多线程并发</h1><h2 id="Metadata-33">Metadata</h2><pre><code class="language-yml">title: Java 多线程并发date: 2022-12-14 14:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题categories:  - Javakeywords:  - Java/多线程并发description: Java 多线程并发</code></pre><h2 id="Java-多线程并发-2">Java 多线程并发</h2><p><img src="/attachment%5C3041eb7b6dfc4a8cc4eb38ad02234ac8.png" alt></p><h2 id="【Java-多线程并发】-理论基础">【Java 多线程并发】 理论基础</h2><p><a href="../java-duo-xian-cheng-bing-fa-li-lun-ji-chu">【Java 多线程并发】 理论基础</a></p><h2 id="【Java-多线程并发】-final">【Java 多线程并发】 final</h2><p><a href="../java-duo-xian-cheng-bing-fa-final">【Java 多线程并发】 final</a></p><h2 id="【Java-多线程并发】-volatile">【Java 多线程并发】 volatile</h2><p><a href="../java-duo-xian-cheng-bing-fa-volatile">【Java 多线程并发】 volatile</a></p><h2 id="【Java-多线程并发】synchronized">【Java 多线程并发】synchronized</h2><p><a href="../java-duo-xian-cheng-bing-fa-synchronized">【Java 多线程并发】 synchronized</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 理论基础</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-li-lun-ji-chu/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-li-lun-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 理论基础</h1><h2 id="Metadata-38">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 理论基础date: 2022-12-14 14:55tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 理论基础</code></pre><h2 id="多线程的意义">多线程的意义</h2><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 <code>可见性</code>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 <code>原子性</code>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 <code>有序性</code>问题</li></ul><h2 id="并发出现问题的根源-并发三要素">并发出现问题的根源: 并发三要素</h2><h3 id="可见性-CPU-缓存引起">可见性: CPU 缓存引起</h3><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>这就是可见性问题，线程 1 对变量 i 修改了之后，线程 2 没有立即看到线程 1 修改的值。</p><h3 id="原子性-分时复用引起">原子性: 分时复用引起</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>由于 CPU 分时复用（线程切换）的存在，线程 1 执行了第一条指令后，就切换到线程 2 执行，假如线程 2 执行了这三条指令后，再切换会线程 1 执行后续两条指令，将造成最后写到内存中的 i 值是 2 而不是 3。</p><h3 id="有序性-重排序引起">有序性: 重排序引起</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-3.png" alt></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><h2 id="JAVA-是怎么解决并发问题的-JMM-Java-内存模型）">JAVA 是怎么解决并发问题的: JMM(Java 内存模型）</h2><p><strong>理解的第一个维度：核心知识点</strong></p><p>JMM 本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p><ul><li>原子性</li></ul><p>在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><blockquote><p>Java 内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></blockquote><ul><li>可见性</li></ul><p>Java 提供了 volatile 关键字来保证可见性。</p><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><ul><li>有序性</li></ul><p>在 Java 里面，可以通过 volatile 关键字来保证一定的 “有序性”（具体原理在下一节讲述）。另外可以通过 synchronized 和 Lock 来保证有序性，很显然，synchronized 和 Lock 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然 JMM 是通过 Happens-Before 规则来保证有序性的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】内存模型</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-mo-xing/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】内存模型</h1><h2 id="Metadata-17">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】内存模型date: 2022-12-14 14:50tags:  - 行动阶段/未完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 内存模型</code></pre><h2 id="JMM-引入">JMM 引入</h2><h3 id="从堆栈说起">从堆栈说起</h3><p>JVM 内部使用的 Java 内存模型在线程栈和堆之间划分内存。 此图从逻辑角度说明了 Java 内存模型：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-1.png" alt></p><h3 id="堆栈里面放了什么">堆栈里面放了什么?</h3><p>线程堆栈还包含正在执行的每个方法的所有局部变量 (调用堆栈上的所有方法)。 线程只能访问它自己的线程堆栈。 由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。 因此，每个线程都有自己的每个局部变量的版本。</p><p>基本类型的所有局部变量 (boolean，byte，short，char，int，long，float，double) 完全存储在线程堆栈中，因此对其他线程不可见。 一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身。</p><p>堆包含了在 Java 应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类 (例如 Byte，Integer，Long 等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-2.png" alt></p><p>局部变量可以是基本类型，在这种情况下，它完全保留在线程堆栈上。</p><p>局部变量也可以是对象的引用。 在这种情况下，引用 (局部变量) 存储在线程堆栈中，但是对象本身存储在堆 (Heap) 上。</p><p>对象的成员变量与对象本身一起存储在堆上。 当成员变量是基本类型时，以及它是对象的引用时都是如此。</p><p>静态类变量也与类定义一起存储在堆上。</p><h3 id="线程栈如何访问堆上对象">线程栈如何访问堆上对象?</h3><p>所有具有对象引用的线程都可以访问堆上的对象。 当一个线程有权访问一个对象时，它也可以访问该对象的成员变量。 如果两个线程同时在同一个对象上调用一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本。</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-3.png" alt></p><p>两个线程有一组局部变量。 其中一个局部变量 (局部变量 2) 指向堆上的共享对象(对象 3)。 两个线程各自对同一对象具有不同的引用。 它们的引用是局部变量，因此存储在每个线程的线程堆栈中(在每个线程堆栈上)。 但是，这两个不同的引用指向堆上的同一个对象。</p><p>注意共享对象 (对象 3) 如何将对象 2 和对象 4 作为成员变量引用(由对象 3 到对象 2 和对象 4 的箭头所示)。 通过对象 3 中的这些成员变量引用，两个线程可以访问对象 2 和对象 4.</p><p>该图还显示了一个局部变量，该变量指向堆上的两个不同对象。 在这种情况下，引用指向两个不同的对象 (对象 1 和对象 5)，而不是同一个对象。 理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象 1 和对象 5。 但是在上图中，每个线程只引用了两个对象中的一个。</p><h2 id="JMM-与硬件内存结构关系">JMM 与硬件内存结构关系</h2><h3 id="硬件内存结构简介">硬件内存结构简介</h3><p>现代硬件内存架构与内部 Java 内存模型略有不同。 了解硬件内存架构也很重要，以了解 Java 内存模型如何与其一起工作。 本节介绍了常见的硬件内存架构，后面的部分将介绍 Java 内存模型如何与其配合使用。</p><p>这是现代计算机硬件架构的简化图：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-4.png" alt></p><p>现代计算机通常有 2 个或更多 CPU。 其中一些 CPU 也可能有多个内核。 关键是，在具有 2 个或更多 CPU 的现代计算机上，可以同时运行多个线程。 每个 CPU 都能够在任何给定时间运行一个线程。 这意味着如果您的 Java 应用程序是多线程的，线程真的在可能同时运行.</p><p>每个 CPU 基本上都包含一组在 CPU 内存中的寄存器。 CPU 可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为 CPU 可以比访问主存储器更快地访问这些寄存器。</p><p>每个 CPU 还可以具有 CPU 高速缓存存储器层。 事实上，大多数现代 CPU 都有一些大小的缓存存储层。 CPU 可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU 高速缓存存储器介于内部寄存器和主存储器的速度之间。 某些 CPU 可能有多个缓存层 (级别 1 和级别 2)，但要了解 Java 内存模型如何与内存交互，这一点并不重要。 重要的是要知道 CPU 可以有某种缓存存储层。</p><p>计算机还包含主存储区 (RAM)。 所有 CPU 都可以访问主内存。 主存储区通常比 CPU 的高速缓存存储器大得多。同时访问速度也就较慢.</p><p>通常，当 CPU 需要访问主存储器时，它会将部分主存储器读入其 CPU 缓存。 它甚至可以将部分缓存读入其内部寄存器，然后对其执行操作。 当 CPU 需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。</p><h3 id="JMM-与硬件内存连接-引入">JMM 与硬件内存连接 - 引入</h3><p>如前所述，Java 内存模型和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于 CPU 高速缓存和内部 CPU 寄存器中。 这在图中说明：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-5.png" alt></p><h3 id="JMM-与硬件内存连接-对象共享后的可见性">JMM 与硬件内存连接 - 对象共享后的可见性</h3><p>如果两个或多个线程共享一个对象，而没有正确使用 volatile 声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。</p><p>想象一下，共享对象最初存储在主存储器中。 然后，在 CPU 上运行的线程将共享对象读入其 CPU 缓存中。 它在那里对共享对象进行了更改。 只要 CPU 缓存尚未刷新回主内存，共享对象的更改版本对于在其他 CPU 上运行的线程是不可见的。 这样，每个线程最终都可能拥有自己的共享对象副本，每个副本都位于不同的 CPU 缓存中。</p><p>下图描绘了该情况。 在左 CPU 上运行的一个线程将共享对象复制到其 CPU 缓存中，并将其 count 变量更改为 2. 对于在右边的 CPU 上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-6.png" alt></p><p>要解决此问题，您可以使用 Java 的 volatile 关键字。 volatile 关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存。</p><p>要解决此问题，您可以使用 Java synchronized 块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为 volatile</p><h2 id="基础">基础</h2><h3 id="并发编程模型的分类">并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<mark style="background: #FF5582A6;">共享内存</mark>和<mark style="background: #FF5582A6;">消息传递</mark>。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><h3 id="Java-内存模型的抽象">Java 内存模型的抽象</h3><p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用 “共享变量” 这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-1.png" alt></p><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ul><li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li><li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li></ul><p>下面通过示意图来说明这两个步骤：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-2.png" alt></p><p>如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。</p><p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</p><h3 id="重排序">重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-3.png" alt></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h3 id="处理器重排序与内存屏障指令">处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！</p><p>常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p><ul><li>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</li><li>※注 2：上表中的 x86 包括 x64 及 AMD64。</li><li>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</li><li>※注 4：数据依赖性后文会专门说明。</li></ul><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1; LoadLoad; Load2</td><td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td>Store1; StoreStore; Store2</td><td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td>Load1; LoadStore; Store2</td><td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td>Store1; StoreLoad; Load2</td><td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td></tr></tbody></table><p>StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p><p>StoreLoad Barriers 是一个 “全能型” 的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h3 id="happens-before">happens-before</h3><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p><p>happens-before 与 JMM 的关系如下图所示：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-5.png" alt></p><p>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><h2 id="重排序-2">重排序</h2><h3 id="数据依赖性">数据依赖性</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
            <tag> 行动阶段/未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 内存结构</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-jie-gou/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】 内存结构</h1><h2 id="Metadata-18">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】 内存结构date: 2022-12-14 14:48tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 内存结构</code></pre><h2 id="运行时数据区">运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法区</li><li><strong>线程共享</strong>：堆、方法区, 堆外内存（Java7 的永久代或 JDK8 的元空间、代码缓存）</li></ul><h2 id="一、程序计数器">一、程序计数器</h2><p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。</p><p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或 PC 计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</p><h3 id="1-1-作用">1.1 作用</h3><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5kmznm1sj31m50u0wph.jpg" alt></p><p>（分析：进入 class 文件所在目录，执行 <code>javap -v xx.class</code> 反解析（或者通过 IDEA 插件 <code>Jclasslib</code> 直接查看，上图），可以看到当前类对应的 Code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。）</p><h3 id="1-2-概述">1.2 概述</h3><ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li></ul><h2 id="二、虚拟机栈">二、虚拟机栈</h2><h3 id="2-1-概述">2.1 概述</h3><blockquote><p>Java 虚拟机栈 (Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧 (Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p></blockquote><p><strong>作用</strong>：</p><ul><li>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li></ul><p><strong>特点</strong>：</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈 / 压栈），方法执行结束<strong>出栈</strong></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><p><strong>栈中可能出现的异常</strong>：</p><p>Java 虚拟机规范允许 <strong>Java 虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 <strong>OutOfMemoryError</strong> 异常</li></ul><p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><h3 id="2-2-栈的存储单位">2.2 栈的存储单位</h3><p>栈中存储什么？</p><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li><li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h3 id="2-3-栈运行原理">2.3 栈运行原理</h3><ul><li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循 “先进后出 / 后进先出” 原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li></ul><h3 id="2-4-栈帧的内部结构">2.4 栈帧的内部结构</h3><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）(或称为表达式栈)</li><li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li><li>一些附加信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" alt></p><h4 id="2-4-1-局部变量表">2.4.1. 局部变量表</h4><ul><li>局部变量表也被称为局部变量数组或者本地变量表</li><li>是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li></ul><h5 id="槽-Slot">槽 Slot</h5><ul><li>局部变量表最基本的存储单元是 Slot（变量槽）</li><li>在局部变量表中，32 位以内的类型只占用一个 Slot(包括 returnAddress 类型)，64 位的类型（long 和 double）占用两个连续的 Slot<ul><li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true</li><li>long 和 double 则占据两个 Slot</li></ul></li><li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot 上</li><li><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</li><li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为 this 变量不存在于当前方法的局部变量表中）</li><li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）</li><li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul><h4 id="2-4-2-操作数栈">2.4.2. 操作数栈</h4><ul><li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称为<strong>表达式栈</strong>（Expression Stack）</li><li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong></li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li></ul><h5 id="概述">概述</h5><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 数据项中</li><li>栈中的任何一个元素都可以是任意的 Java 数据类型<ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 PC 寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说 <strong>Java 虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li></ul><h5 id="栈顶缓存（Top-of-stack-Cashing）">栈顶缓存（Top-of-stack-Cashing）</h5><p>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读 / 写速度非常迅速，甚至可以比内存的读 / 写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的 CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读 / 写次数。由于操作数是存储在内存中的，因此频繁的执行内存读 / 写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读 / 写次数，提升执行引擎的执行效率</strong></p><h4 id="2-4-3-动态链接（指向运行时常量池的方法引用）">2.4.3. 动态链接（指向运行时常量池的方法引用）</h4><ul><li><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 (Dynamic Linking)。</li><li>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gca4k4gndgj31d20o2td0.jpg" alt></p><h5 id="JVM-是如何执行方法调用的">JVM 是如何执行方法调用的</h5><p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class 文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p><ul><li><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li><li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p><ul><li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li></ul><h5 id="虚方法和非虚方法">虚方法和非虚方法</h5><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>其他方法称为虚方法</li></ul><h5 id="虚方法表">虚方法表</h5><p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。<br>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。<br>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><h4 id="2-4-4-方法返回地址（return-address）">2.4.4. 方法返回地址（return address）</h4><p>用来存放调用该方法的 PC 寄存器的值。</p><p>一个方法的结束，有两种方式</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。<br>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong><br>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定<br>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</li><li>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong><br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li></ol><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p><h4 id="2-4-5-附加信息">2.4.5. 附加信息</h4><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p><h2 id="三、本地方法栈">三、本地方法栈</h2><h3 id="3-1-本地方法接口">3.1 本地方法接口</h3><p>简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">为什么要使用本地方法（Native Method）?</p><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p><ul><li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li><li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li><li>Sun's Java：Sun 的解释器就是 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用 Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是 C 实现的，并被植入 JVM 内部。</li></ul></div><h3 id="3-2-本地方法栈（Native-Method-Stack）">3.2 本地方法栈（Native Method Stack）</h3><ul><li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈也是线程私有的</li><li>允许线程固定或者可动态扩展的内存大小<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li></ul></li><li>本地方法是使用 C 语言实现的</li><li>它的具体做法是 <code>Native Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li><li>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</li><li>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</li></ul><blockquote><p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote><h2 id="四、堆内存">四、堆内存</h2><h3 id="4-1-内存划分">4.1 内存划分</h3><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p><ul><li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li><li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li><li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg" alt></p><h4 id="年轻代-Young-Generation">年轻代 (Young Generation)</h4><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为 from/to 或 s0/s1），默认比例是<code>8:1:1</code></p><ul><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行 <strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ul><h4 id="老年代-Old-Generation">老年代 (Old Generation)</h4><p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主 GC（Major GC），通常需要更长的时间。</p><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg" alt></p><h4 id="元空间">元空间</h4><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p><h3 id="4-2-设置堆内存大小和-OOM">4.2 设置堆内存大小和 OOM</h3><p>Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 <code>-Xmx</code> 和 <code>-Xms</code> 来设定</p><ul><li><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></li></ul><p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p><p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p><ul><li>默认情况下，初始堆内存大小为：电脑内存大小 / 64</li><li>默认情况下，最大堆内存大小为：电脑内存大小 / 4</li></ul><h4 id="查看-JVM-堆内存分配">查看 JVM 堆内存分配</h4><ol><li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li><li>默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置<ul><li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li></ul></li><li>若在 JDK 7 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄<br>此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code> 将会失效，而 JDK 8 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code><br>在 JDK 8 中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划</li></ol><p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小<br>计算依据是 <strong>GC 过程</strong>中统计的 <strong>GC 时间</strong>、<strong>吞吐量</strong>、<strong>内存占用量</strong></p><h3 id="4-3-对象在堆中的生命周期">4.3 对象在堆中的生命周期</h3><ol><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代<ul><li>新生代又被进一步划分为 <strong>Eden 区</strong> 和 <strong>Survivor 区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul></li><li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区<ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul></li><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）<ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会 + 1</li></ul></li><li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li></ol><h3 id="4-4-对象的分配过程">4.4 对象的分配过程</h3><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new 的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li><li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li></ol><h3 id="4-5-GC-垃圾回收简介">4.5 GC 垃圾回收简介</h3><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li><li>目前只有 G1 GC 会有这种行为</li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><h3 id="4-6-TLAB">4.6 TLAB</h3><h4 id="什么是-TLAB-（Thread-Local-Allocation-Buffer）">什么是 TLAB （Thread Local Allocation Buffer）?</h4><ul><li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li><li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li></ul><h4 id="为什么要有-TLAB">为什么要有 TLAB ?</h4><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h3 id="4-7-堆是分配对象存储的唯一选择吗">4.7 堆是分配对象存储的唯一选择吗</h3><blockquote><p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么 “绝对” 了。 ——《深入理解 Java 虚拟机》</p></blockquote><h4 id="逃逸分析">逃逸分析</h4><p><strong>逃逸分析 (Escape Analysis) <strong>是目前 Java 虚拟机中比较前沿的优化技术</strong>。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li></ul><p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将 sb 返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，但是其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p><p><strong>参数设置：</strong></p><ul><li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li><li>如果使用较早版本，可以通过<code>-XX"+DoEscapeAnalysis</code>显式开启</li></ul><p>开发中使用局部变量，就不要在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做优化：</p><ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li></ul><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p><p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p><h5 id="代码优化之同步省略（消除）">代码优化之同步省略（消除）</h5><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li><li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li></ul><h5 id="代码优化之标量替换">代码优化之标量替换</h5><p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p><p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p><h5 id="代码优化之栈上分配">代码优化之栈上分配</h5><p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><p><strong>总结：</strong></p><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</p><p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><h2 id="五、方法区">五、方法区</h2><ul><li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li><li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本 / 字段 / 方法 / 接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</li><li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li><li>JVM 关闭后方法区即被释放</li></ul><h3 id="5-1-解惑">5.1 解惑</h3><ul><li><strong>方法区（method area）</strong> 只是 <strong>JVM 规范</strong>中定义的一个<strong>概念</strong>，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（PermGen）</strong> 是  <strong>Hotspot</strong> 虚拟机特有的概念， Java8 的时候又被<strong>元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li><li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生 OOM（都会有溢出异常）</li><li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li><li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</li><li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code></li><li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）</li></ul><p>所以对于方法区，Java8 之后的变化：</p><ul><li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li><li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li><li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul><h3 id="5-2-设置方法区内存的大小">5.2 设置方法区内存的大小</h3><p>JDK8 及以后：</p><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li><li>默认值依赖于平台。Windows 下，<code>-XX:MetaspaceSize</code> 是 21M，<code>-XX:MaxMetaspacaSize</code> 的值是 -1，即没有限制</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为 20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li></ul><h3 id="5-3-方法区内部结构">5.3 方法区内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><h4 id="类型信息">类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p><ul><li>这个类型的完整有效名称（全名 = 包名. 类名）</li><li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h4 id="域（Field）信息">域（Field）信息</h4><ul><li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li></ul><h4 id="方法（Method）信息">方法（Method）信息</h4><ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h3 id="5-4-运行时常量池">5.4 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p><h4 id="常量池">常量池</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p><h5 id="为什么需要常量池？">为什么需要常量池？</h5><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><p>如下，我们通过 jclasslib 查看一个只有 Main 方法的简单类，字节码中的 #2 指向的就是 Constant Pool</p><p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池">运行时常量池</h4><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li><li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址<ul><li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li></ul></li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li></ul><h3 id="5-5-方法区在-JDK6、7、8-中的演进细节">5.5 方法区在 JDK6、7、8 中的演进细节</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>jdk1.6 及之前</td><td>有永久代，静态变量存放在永久代上</td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池、静态变量移除，保存在堆中</td></tr><tr><td>jdk1.8 及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td></tr></tbody></table><h4 id="移除永久代原因">移除永久代原因</h4><ul><li>为永久代设置空间大小是很难确定的。<br>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</li><li>对永久代进行调优较困难</li></ul><h3 id="5-6-方法区的垃圾回收">5.6 方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>判定一个类型是否属于 “不再被使用的类”，需要同时满足三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】JAVA 类加载机制</title>
      <link href="/java/java-jvm/java-jvm-java-lei-jia-zai-ji-zhi/"/>
      <url>/java/java-jvm/java-jvm-java-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】JAVA 类加载机制</h1><h2 id="Metadata-16">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】JAVA 类加载机制date: 2022-12-14 14:47tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 类加载机制</code></pre><h2 id="类的生命周期">类的生命周期</h2><p>其中类加载的过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，<em>而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定 (也成为动态绑定或晚期绑定)</em>。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_2.png" alt></p><h3 id="类的加载-查找并加载类的二进制数据">类的加载: 查找并加载类的二进制数据</h3><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_1.png" alt></p><p>相对于类加载的其他阶段而言，<em>加载阶段 (准确地说，是加载阶段获取类的二进制字节流的动作) 是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被 “首次主动使用” 时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了. class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误 (LinkageError 错误) 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">加载. class 文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载. class 文件</li><li>从 zip，jar 等归档文件中加载. class 文件</li><li>从专有数据库中提取. class 文件</li><li>将 Java 源文件动态编译为. class 文件</li></ul></div><h3 id="连接">连接</h3><h4 id="验证-确保被加载的类的正确性">验证: 确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成 4 个阶段的检验动作:</p><ul><li><code>文件格式验证</code>: 验证字节流是否符合 Class 文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><code>元数据验证</code>: 对字节码描述的信息进行语义分析 (注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合 Java 语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><code>符号引用验证</code>: 确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p></blockquote><h4 id="准备-为类的静态变量分配内存，并将其初始化为默认值">准备: 为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意:</p><ul><li>这时候进行内存分配的仅包括类变量 (<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值 (如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在 Java 代码中被显式地赋予的值。<br>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量 value 在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">注意点</p><ul><li>对基本数据类型来说，对于类变量 (static) 和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li><li>如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。假设上面的类变量 value 被定义为: <code>public static final int value = 3；</code>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li></ul></div><h4 id="解析-把类中的符号引用转换为直接引用">解析: 把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符 7 类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><h3 id="初始化">初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p><strong>JVM 初始化步骤</strong></p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p><ul><li>创建类的实例，也就是 new 的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射 (如 Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java 虚拟机启动时被标明为启动类的类 (Java Test)，直接使用 java.exe 命令来运行某个主类</li></ul><h3 id="使用">使用</h3><p>类访问方法区内的数据结构的接口， 对象是 Heap 区的数据。</p><h3 id="卸载">卸载</h3><p><strong>Java 虚拟机将结束生命周期的几种情况</strong></p><ul><li>执行了 System.exit() 方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li></ul><h2 id="类加载器，-JVM-类加载机制">类加载器， JVM 类加载机制</h2><h3 id="类加载器的层次">类加载器的层次</h3><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_3.png" alt></p><blockquote><p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><blockquote><p>站在 Java 虚拟机的角度来讲，只存在两种不同的类加载器: 启动类加载器: 它使用 C++ 实现 (这里仅限于<code>Hotspot</code>，也就是 JDK1.5 之后默认的虚拟机，有很多其他的虚拟机是用 Java 语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p></blockquote><p><strong>站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类</strong> :</p><p><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在 JDK\jre\lib(JDK 代表 JDK 的安装目录，下同) 下，或被 - Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库 (如 rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载)。启动类加载器是无法被 Java 程序直接引用的。</p><p><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库 (如 javax.* 开头的类)，开发者可以直接使用扩展类加载器。</p><p><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径 (ClassPath) 所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为 JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassLoader，便可以做到如下几点:</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得 java class，例如数据库中和网络中。</li></ul><h3 id="寻找类加载器">寻找类加载器</h3><pre><code class="language-java">ClassLoader loader = Thread.currentThread().getContextClassLoader();</code></pre><h3 id="类的加载">类的加载</h3><p>类加载有三种方式:</p><p>1、命令行启动应用时候由 JVM 初始化加载<br>2、通过 Class.forName() 方法动态加载<br>3、通过 ClassLoader.loadClass() 方法动态加载</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">Class.forName() 和 ClassLoader.loadClass() 区别</p><p>collapse: open</p><ul><li>Class.forName(): 将类的. class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；</li><li>ClassLoader.loadClass(): 只干一件事情，就是将. class 文件加载到 jvm 中，不会执行 static 中的内容, 只有在 newInstance 才会去执行 static 块。</li><li>Class.forName(name, initialize, loader) 带参函数也可控制是否加载 static 块。并且只有调用了 newInstance() 方法采用调用构造函数，创建类的对象 。</li></ul></div><h2 id="JVM-类加载机制">JVM 类加载机制</h2><ul><li><code>全盘负责</code>，当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><code>缓存机制</code>，缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效</li><li><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">双亲委派机制过程</p><ol><li>当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。</li><li>当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。</li><li>如果 BootStrapClassLoader 加载失败 (例如在 $JAVA_HOME/jre/lib 里未查找到该 class)，会使用 ExtClassLoader 来尝试加载；</li><li>若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。</li></ol></div><p><strong>双亲委派优势</strong></p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证 Java 程序安全稳定运行</li></ul><h2 id="自定义类加载器">自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程:</p><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对 class 文件进行加密，因此没有解密的过程。</p><p><strong>这里有几点需要注意</strong> :</p><p>1、这里传递的文件名需要是类的全限定性名称，即<code>com.pdai.jvm.classloader.Test2</code>格式的，因为 defineClass 方法是按这种格式进行处理的。<br>2、最好不要重写 loadClass 方法，因为这样容易破坏双亲委托模式。<br>3、这类 Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM</title>
      <link href="/java/java-jvm/java-jvm/"/>
      <url>/java/java-jvm/java-jvm/</url>
      
        <content type="html"><![CDATA[<h1>Java JVM</h1><h2 id="Metadata-13">Metadata</h2><pre><code class="language-yml">title: Java JVMdate: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java JVM</code></pre><h2 id="【Java-JVM】字节码编码">【Java JVM】字节码编码</h2><p><a href="../java-jvm-zi-jie-ma-bian-ma/">【Java JVM】字节码编码</a></p><h2 id="【Java-JVM】JAVA-类加载机制">【Java JVM】JAVA 类加载机制</h2><p><a href="../java-jvm-java-lei-jia-zai-ji-zhi/">【Java JVM】JAVA 类加载机制</a></p><h2 id="【Java-JVM】-内存结构">【Java JVM】 内存结构</h2><p><a href="../java-jvm-nei-cun-jie-gou/">【Java JVM】 内存结构</a></p><h2 id="【Java-JVM】内存模型">【Java JVM】内存模型</h2><p><a href="../java-jvm-nei-cun-mo-xing/">【Java JVM】内存模型</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】字节码编码</title>
      <link href="/java/java-jvm/java-jvm-zi-jie-ma-bian-ma/"/>
      <url>/java/java-jvm/java-jvm-zi-jie-ma-bian-ma/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】字节码编码</h1><h2 id="Metadata-20">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】字节码编码date: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 字节码编码</code></pre><h2 id="简介-2">简介</h2><p>计算机是不能直接运行 java 代码的，必须要先运行 java 虚拟机，再由 java 虚拟机运行编译后的 java 代码。这个编译后的 java 代码，就是本文要介绍的 java 字节码。</p><ul><li>Java 代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的 JVM 虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li><li>JVM 也不再只支持 Java，由此衍生出了许多基于 JVM 的编程语言，如 Groovy, Scala, Koltin 等等。</li></ul><p><img src="https://pdai.tech/_images/jvm/java-jvm-class-1.png" alt></p><h2 id="Java-字节码文件">Java 字节码文件</h2><p>class 文件本质上是一个以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在 class 文件中。jvm 根据其特定的规则解析该二进制数据，从而得到相关信息。</p><p>Class 文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。</p><h3 id="Class-文件的结构属性">Class 文件的结构属性</h3><p><img src="https://pdai.tech/_images/jvm/java-jvm-class-2.png" alt></p><h3 id="示例">示例</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p>collapse: closed</p><p>以文本的形式打开生成的 class 文件，内容如下:</p><pre><code class="language-class">cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0007 0008 0c00 0500 0601 0010 636f 6d2f7268 7974 686d 372f 4d61 696e 0100 106a6176 612f 6c61 6e67 2f4f 626a 6563 74002100 0300 0400 0000 0100 0200 0500 06000000 0200 0100 0700 0800 0100 0900 00001d00 0100 0100 0000 052a b700 01b1 00000001 000a 0000 0006 0001 0000 0003 0001000b 000c 0001 0009 0000 001f 0002 00010000 0007 2ab4 0002 0460 ac00 0000 01000a00 0000 0600 0100 0000 0800 0100 0d000000 0200 0e</code><p><code class="language-class"></code></p></pre><p></p></div><ul><li>文件开头的 4 个字节 (“cafe babe”) 称之为 <code>魔数</code>，唯有以 “cafe babe” 开头的 class 文件方可被虚拟机所接受，这 4 个字节就是字节码文件的身份识别。</li><li>0000 是编译器 jdk 版本的次版本号 0，0034 转化为十进制是 52, 是主版本号，java 的版本号从 45 开始，除 1.0 和 1.1 都是使用 45.x 外, 以后每升一个大版本，版本号加一。也就是说，编译生成该 class 文件的 jdk 版本为 1.8.0。</li></ul><h3 id="反编译字节码文件">反编译字节码文件</h3><blockquote><p>使用到 java 内置的一个反编译工具 javap 可以反编译字节码文件, 用法: <code>javap &lt;options&gt; &lt;classes&gt;</code></p></blockquote><p>其中<code>&lt;options&gt;</code>选项包括:</p><pre><code class="language-text">  -help  --help  -?        输出此用法消息  -version                 版本信息  -v  -verbose             输出附加信息  -l                       输出行号和本地变量表  -public                  仅显示公共类和成员  -protected               显示受保护的/公共类和成员  -package                 显示程序包/受保护的/公共类                           和成员 (默认)  -p  -private             显示所有类和成员  -c                       对代码进行反汇编  -s                       输出内部类型签名  -sysinfo                 显示正在处理的类的                           系统信息 (路径, 大小, 日期, MD5 散列)  -constants               显示最终常量  -classpath &lt;path&gt;        指定查找用户类文件的位置  -cp &lt;path&gt;               指定查找用户类文件的位置  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</code></pre><p>输入命令<code>javap -verbose -p Main.class</code>查看输出内容:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">collapse: closed</p><pre><code>Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class  Last modified 2018-4-7; size 362 bytes  MD5 checksum 4aed8540b098992663b7ba08c65312de  Compiled from "Main.java"public class com.rhythm7.Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #4.#18            #2 = Fieldref           #3.#19            #3 = Class              #20               #4 = Class              #21               #5 = Utf8               m   #6 = Utf8               I   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               LocalVariableTable  #12 = Utf8               this  #13 = Utf8               Lcom/rhythm7/Main;  #14 = Utf8               inc  #15 = Utf8               ()I  #16 = Utf8               SourceFile  #17 = Utf8               Main.java  #18 = NameAndType        #7:#8            #19 = NameAndType        #5:#6            #20 = Utf8               com/rhythm7/Main  #21 = Utf8               java/lang/Object{  private int m;    descriptor: I    flags: ACC_PRIVATE<p>public com.rhythm7.Main();<br>descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack=1, locals=1, args_size=1<br>0: aload_0<br>1: invokespecial #1<br>4: return<br>LineNumberTable:<br>line 3: 0<br>LocalVariableTable:<br>Start  Length  Slot  Name   Signature<br>0       5     0  this   Lcom/rhythm7/Main;</p><p>public int inc();<br>descriptor: ()I<br>flags: ACC_PUBLIC<br>Code:<br>stack=2, locals=1, args_size=1<br>0: aload_0<br>1: getfield      #2<br>4: iconst_1<br>5: iadd<br>6: ireturn<br>LineNumberTable:<br>line 8: 0<br>LocalVariableTable:<br>Start  Length  Slot  Name   Signature<br>0       7     0  this   Lcom/rhythm7/Main;<br>}<br>SourceFile: "Main.java"</p></code><p><code></code></p></pre><p></p></div><h3 id="字节码文件信息">字节码文件信息</h3><p>开头的 7 行信息包括: Class 文件当前所在位置，最后修改时间，文件大小，MD5 值，编译自哪个文件，类的全限定名，jdk 次版本号，主版本号。</p><p>然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下:</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为 Public 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为 final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用 invokespecial 字节码指令的新语义．</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志这个类并非由用户代码产生</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h3 id="常量池-2">常量池</h3><p><code>Constant pool</code>意为常量池。</p><p>常量池可以理解成 Class 文件中的资源仓库。主要存放的是两大类常量：字面量 (Literal) 和符号引用(Symbolic References)。字面量类似于 java 中的常量概念，如文本字符串，final 常量等，而符号引用则属于编译原理方面的概念，包括以下三种:</p><ul><li>类和接口的全限定名 (Fully Qualified Name)</li><li>字段的名称和描述符号 (Descriptor)</li><li>方法的名称和描述符</li></ul><p>不同于 C/C++, JVM 是在加载 Class 文件的时候才进行的动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。 直接通过反编译文件来查看字节码内容：</p><pre><code>#1 = Methodref          #4.#18         #4 = Class              #21            #7 = Utf8               &lt;init&gt;#8 = Utf8               ()V#18 = NameAndType        #7:#8          #21 = Utf8               java/lang/Object</code></pre><p><strong>第一个常量</strong>是一个方法定义，指向了第 4 和第 18 个常量。以此类推查看第 4 和第 18 个常量。最后可以拼接成第一个常量右侧的注释内容:</p><pre><code>java/lang/Object."&lt;init&gt;":()V</code></pre><p>这段可以理解为该类的实例构造器的声明，由于 Main 类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了 Main 类的直接父类是 Object。 该方法默认返回值是 V, 也就是 void，无返回值。</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型 byte</td></tr><tr><td>C</td><td>基本类型 char</td></tr><tr><td>D</td><td>基本类型 double</td></tr><tr><td>F</td><td>基本类型 float</td></tr><tr><td>I</td><td>基本类型 int</td></tr><tr><td>J</td><td>基本类型 long</td></tr><tr><td>S</td><td>基本类型 short</td></tr><tr><td>Z</td><td>基本类型 boolean</td></tr><tr><td>V</td><td>特殊类型 void</td></tr><tr><td>L</td><td>对象类型，以分号结尾，如 Ljava/lang/Object;</td></tr></tbody></table><p>对于数组类型，每一位使用一个前置的<code>[</code>字符来描述，如定义一个<code>java.lang.String[][]</code>类型的维数组，将被记录为<code>[[Ljava/lang/String;</code></p><h3 id="方法表集合">方法表集合</h3><p>在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的 16 进制文件内容如何，我们直接看反编译后的内容。</p><p>code 内的主要属性为:</p><ul><li><p><strong>stack</strong>: 最大操作数栈，JVM 运行时会根据这个值来分配栈帧 (Frame) 中的操作栈深度, 此处为 1</p></li><li><p><strong>locals</strong>: 局部变量所需的存储空间，单位为 Slot, Slot 是虚拟机为局部变量分配内存时所使用的最小单位，为 4 个字节大小。方法参数 (包括实例方法中的隐藏参数 this)，显示异常处理器的参数 (try catch 中的 catch 块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals 的大小并不一定等于所有局部变量所占的 Slot 之和，因为局部变量中的 Slot 是可以重用的。</p></li><li><p><strong>args_size</strong>: 方法参数的个数，这里是 1，因为每个实例方法都会有一个隐藏参数 this</p></li><li><p><strong>attribute_info</strong>: 方法体内容，0,1,4 为字节码 “行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的<code>java/lang/Object."":()V</code>, 然后执行返回语句，结束方法。</p></li><li><p><strong>LineNumberTable</strong>: 该属性的作用是描述源码行号与字节码行号 (字节码偏移量) 之间的对应关系。可以使用 -g:none 或 - g:lines 选项来取消或要求生成这项信息，如果选择不生成 LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</p></li><li><p><strong>LocalVariableTable</strong>: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars 来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是 arg0, arg1 这样的占位符。 start 表示该局部变量在哪一行开始可见，length 表示可见行数，Slot 代表所在帧栈位置，Name 是变量名称，然后是类型签名。</p></li></ul><h3 id="类名">类名</h3><p>最后很显然是源码文件：</p><pre><code>SourceFile: "Main.java"</code></pre><h2 id="字节码增强技术">字节码增强技术</h2><p>从最直接操纵字节码的实现方式开始深入进行剖析</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-1.png" alt></p><h3 id="ASM">ASM</h3><h4 id="ASM-简介">ASM 简介</h4><p>ASM 是一个通用的 Java 字节码操作和分析框架。 它可以用于修改现有类或直接以二进制形式动态生成类。 ASM 提供了一些常见的字节码转换和分析算法，可以从中构建自定义复杂转换和代码分析工具。 ASM 提供与其他 Java 字节码框架类似的功能，但专注于性能。 因为它的设计和实现尽可能小而且快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中）。</p><p><mark style="background: #FF5582A6;">对于需要手动操纵字节码的需求，可以使用 ASM，它可以直接生产 .class 字节码文件，也可以在类被加载入 JVM 之前动态修改类行为。</mark></p><p>ASM 的应用场景有 AOP（Cglib 就是基于 ASM）、热部署、修改其他 jar 包中的类等。</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-2.png" alt></p><h4 id="ASM-API">ASM API</h4><h5 id="核心-API">核心 API</h5><p>ASM Core API 可以类比解析 XML 文件中的 SAX 方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用 Core API。在 Core API 中有以下几个关键类：</p><ul><li>ClassReader：用于读取已经编译好的. class 文件。</li><li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li><li>各种 Visitor 类：如上所述，CoreAPI 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 Visitor，比如用于访问方法的 MethodVisitor、用于访问类变量的 FieldVisitor、用于访问注解的 AnnotationVisitor 等。为了实现 AOP，重点要使用的是 MethodVisitor。</li></ul><h5 id="树形-API">树形 API</h5><p>ASM Tree API 可以类比解析 XML 文件中的 DOM 方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi 不同于 CoreAPI，TreeAPI 通过各种 Node 类来映射字节码的各个区域，类比 DOM 节点，就可以很好地理解这种编程方式。</p><h4 id="直接利用-ASM-实现-AOP">直接利用 ASM 实现 AOP</h4><p>利用 ASM 的 CoreAPI 来增强类。这里不纠结于 AOP 的专业名词如切片、通知，只实现在方法调用前、后增加逻辑，通俗易懂且方便理解。首先定义需要被增强的 Base 类：其中只包含一个 process() 方法，方法内输出一行 “process”。增强后，我们期望的是，方法执行前输出 “start”，之后输出”end”。</p><p>为了利用 ASM 实现 AOP，需要定义两个类：一个是 MyClassVisitor 类，用于对字节码的 visit 以及修改；另一个是 Generator 类，在这个类中定义 ClassReader 和 ClassWriter，其中的逻辑是，classReader 读取字节码，然后交给 MyClassVisitor 类处理，处理完成后由 ClassWriter 写字节码并将旧的字节码替换掉。Generator 类较简单，我们先看一下它的实现，如下所示，然后重点解释 MyClassVisitor 类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import org.objectweb.asm.ClassReader;import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.ClassWriter;<p>public class Generator {<br>public static void main(String[] args) throws Exception {</p><pre><code>    ClassReader classReader = new ClassReader(&amp;quot;meituan/bytecode/asm/Base&amp;quot;);    ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);        ClassVisitor classVisitor = new MyClassVisitor(classWriter);    classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);    byte[] data = classWriter.toByteArray();        File f = new File(&amp;quot;operation-server/target/classes/meituan/bytecode/asm/Base.class&amp;quot;);    FileOutputStream fout = new FileOutputStream(f);    fout.write(data);    fout.close();    System.out.println(&amp;quot;now generator cc success!!!!!&amp;quot;);}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><p>MyClassVisitor 继承自 ClassVisitor，用于对字节码的观察。它还包含一个内部类 MyMethodVisitor，继承自 MethodVisitor 用于对类内方法的观察，它的整体代码如下：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><p>利用这个类就可以实现对字节码的修改。详细解读其中的代码，对字节码做修改的步骤是：</p><ul><li>首先通过 MyClassVisitor 类中的 visitMethod 方法，判断当前字节码读到哪一个方法了。跳过构造方法 <code>&lt;init&gt;</code> 后，将需要被增强的方法交给内部类 MyMethodVisitor 来进行处理。</li><li>接下来，进入内部类 MyMethodVisitor 中的 visitCode 方法，它会在 ASM 开始访问某一个方法的 Code 区时被调用，重写 visitCode 方法，将 AOP 中的前置逻辑就放在这里。 MyMethodVisitor 继续读取字节码指令，每当 ASM 访问到无参数指令时，都会调用 MyMethodVisitor 中的 visitInsn 方法。我们判断了当前指令是否为无参数的 “return” 指令，如果是就在它的前面添加一些指令，也就是将 AOP 的后置逻辑放在该方法中。</li><li>综上，重写 MyMethodVisitor 中的两个方法，就可以实现 AOP 了，而重写方法时就需要用 ASM 的写法，手动写入或者修改字节码。通过调用 methodVisitor 的 visitXXXXInsn()方法就可以实现字节码的插入，XXXX 对应相应的操作码助记符类型，比如 mv.visitLdcInsn(“end”)对应的操作码就是 ldc “end”，即将字符串 “end” 压入栈。 完成这两个 visitor 类后，运行 Generator 中的 main 方法完成对 Base 类的字节码增强，增强后的结果可以在编译后的 target 文件夹中找到 Base.class 文件进行查看，可以看到反编译后的代码已经改变了。然后写一个测试类 MyTest，在其中 new Base()，并调用 base.process()方法，可以看到下图右侧所示的 AOP 实现效果：</li></ul><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-3.png" alt></p><pre><code class="language-java">import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.MethodVisitor;import org.objectweb.asm.Opcodes;<p>public class MyClassVisitor extends ClassVisitor implements Opcodes {<br>public MyClassVisitor(ClassVisitor cv) {<br>super(ASM5, cv);<br>}<br>@Override<br>public void visit(int version, int access, String name, String signature,<br>String superName, String[] interfaces) {<br>cv.visit(version, access, name, signature, superName, interfaces);<br>}<br>@Override<br>public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {<br>MethodVisitor mv = cv.visitMethod(access, name, desc, signature,<br>exceptions);</p><pre><code>    if (!name.equals(&amp;quot;&amp;lt;init&amp;gt;&amp;quot;) &amp;amp;&amp;amp; mv != null) {        mv = new MyMethodVisitor(mv);    }    return mv;}class MyMethodVisitor extends MethodVisitor implements Opcodes {    public MyMethodVisitor(MethodVisitor mv) {        super(Opcodes.ASM5, mv);    }    @Override    public void visitCode() {        super.visitCode();        mv.visitFieldInsn(GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);        mv.visitLdcInsn(&amp;quot;start&amp;quot;);        mv.visitMethodInsn(INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;, false);    }    @Override    public void visitInsn(int opcode) {        if ((opcode &amp;gt;= Opcodes.IRETURN &amp;amp;&amp;amp; opcode &amp;lt;= Opcodes.RETURN)                || opcode == Opcodes.ATHROW) {                        mv.visitFieldInsn(GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);            mv.visitLdcInsn(&amp;quot;end&amp;quot;);            mv.visitMethodInsn(INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;, false);        }        mv.visitInsn(opcode);    }}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="ASM-工具">ASM 工具</h4><p>利用 ASM 手写字节码时，需要利用一系列 visitXXXXInsn() 方法来写对应的助记符，所以需要先将每一行源代码转化为一个个的助记符，然后通过 ASM 的语法转换为 visitXXXXInsn() 这种写法。第一步将源码转化为助记符就已经够麻烦了，不熟悉字节码操作集合的话，需要我们将代码编译后再反编译，才能得到源代码对应的助记符。第二步利用 ASM 写字节码时，如何传参也很令人头疼。ASM 社区也知道这两个问题，所以提供了工具 <a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline">ASM ByteCode Outline (opens new window)</a>。</p><p>安装后，右键选择 “Show Bytecode Outline”，在新标签页中选择“ASMified” 这个 tab，如图 19 所示，就可以看到这个类中的代码对应的 ASM 写法了。图中上下两个红框分别对应 AOP 中的前置逻辑于后置逻辑，将这两块直接复制到 visitor 中的 visitMethod()以及 visitInsn()方法中，就可以了。</p><h3 id="Javassist">Javassist</h3><p>ASM 是在指令层次上操作字节码的，阅读上文后，我们的直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，我们再简单介绍另外一类框架：强调源代码层次操作字节码的框架 Javassist。</p><p>利用 Javassist 实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是 ClassPool、CtClass、CtMethod、CtField 这四个类：</p><ul><li>CtClass（compile-time class）：编译时类信息，它是一个 class 文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个 CtClass 对象，用来表示这个类文件。</li><li>ClassPool：从开发视角来看，ClassPool 是一张保存 CtClass 信息的 HashTable，key 为类名，value 为类名对应的 CtClass 对象。当我们需要对某个类进行修改时，就是通过 pool.getCtClass(“className”) 方法从 pool 中获取到相应的 CtClass。</li><li>CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。</li></ul><p>了解这四个类后，我们可以写一个小 Demo 来展示 Javassist 简单、快速的特点。我们依然是对 Base 中的 process() 方法做增强，在方法调用前后分别输出”start” 和”end”，实现代码如下。我们需要做的就是从 pool 中获取到相应的 CtClass 对象和其中的方法，然后执行 method.insertBefore 和 insertAfter 方法，参数为要插入的 Java 代码，再以字符串的形式传入即可，实现起来也极为简单。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import com.meituan.mtrace.agent.javassist.*;</code><p><code class="language-java">public class JavassistTest {<br>public static void main(String[] args) throws NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException, IOException {<br>ClassPool cp = ClassPool.getDefault();<br>CtClass cc = cp.get("meituan.bytecode.javassist.Base");<br>CtMethod m = cc.getDeclaredMethod("process");<br>m.insertBefore("{ System.out.println(&amp;quot;start&amp;quot;); }");<br>m.insertAfter("{ System.out.println(&amp;quot;end&amp;quot;); }");<br>Class c = cc.toClass();<br>cc.writeFile("/Users/zen/projects");<br>Base h = (Base)c.newInstance();<br>h.process();<br>}<br>}</code></p></pre><p></p></div><h2 id="运行时类的重载">运行时类的重载</h2><h3 id="Instrument">Instrument</h3><p>instrument 是 JVM 提供的一个可以修改已加载类的类库，专门为 Java 语言编写的插桩服务提供支持。它需要依赖 JVMTI 的 Attach API 机制实现，JVMTI 这一部分，我们将在下一小节进行介绍。在 JDK 1.6 以前，instrument 只能在 JVM 刚启动开始加载类时生效，而在 JDK 1.6 之后，instrument 支持了在运行时对类定义的修改。要使用 instrument 的类修改功能，我们需要实现它提供的 ClassFileTransformer 接口，定义一个类文件转换器。接口中的 transform() 方法会在类文件被加载时调用，而在 transform 方法里，我们可以利用上文中的 ASM 或 Javassist 对传入的字节码进行改写或替换，生成新的字节码数组后返回。</p><p>我们定义一个实现了 ClassFileTransformer 接口的类 TestTransformer，依然在其中利用 Javassist 对 Base 类中的 process()方法进行增强，在前后分别打印 “start” 和“end”，代码如下：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import java.lang.instrument.ClassFileTransformer;<p>public class TestTransformer implements ClassFileTransformer {<br>@Override<br>public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {<br>System.out.println("Transforming " + className);<br>try {<br>ClassPool cp = ClassPool.getDefault();<br>CtClass cc = cp.get("meituan.bytecode.jvmti.Base");<br>CtMethod m = cc.getDeclaredMethod("process");<br>m.insertBefore("{ System.out.println(&amp;quot;start&amp;quot;); }");<br>m.insertAfter("{ System.out.println(&amp;quot;end&amp;quot;); }");<br>return cc.toBytecode();<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>return null;<br>}<br>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><p>现在有了 Transformer，那么它要如何注入到正在运行的 JVM 呢？还需要定义一个 Agent，借助 Agent 的能力将 Instrument 注入到 JVM 中。我们将在下一小节介绍 Agent，现在要介绍的是 Agent 中用到的另一个类 Instrumentation。在 JDK 1.6 之后，Instrumentation 可以做启动后的 Instrument、本地代码（Native Code）的 Instrument，以及动态改变 Classpath 等等。我们可以向 Instrumentation 中添加上文中定义的 Transformer，并指定要被重加载的类，代码如下所示。这样，当 Agent 被 Attach 到一个 JVM 中时，就会执行类字节码替换并重载入 JVM 的操作。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import java.lang.instrument.Instrumentation;<p>public class TestAgent {<br>public static void agentmain(String args, Instrumentation inst) {</p><pre><code>    inst.addTransformer(new TestTransformer(), true);    try {                inst.retransformClasses(Base.class);        System.out.println(&amp;quot;Agent Load Done.&amp;quot;);    } catch (Exception e) {        System.out.println(&amp;quot;agent load failed!&amp;quot;);    }}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="JVMTI-Agent-Attach-API">JVMTI &amp; Agent &amp; Attach API</h3><p>追根溯源需要先介绍 JPDA（Java Platform Debugger Architecture）。如果 JVM 启动时开启了 JPDA，那么类是允许被重新加载的。在这种情况下，已被加载的旧版本类信息可以被卸载，然后重新加载新版本的类。正如 JDPA 名称中的 Debugger，JDPA 其实是一套用于调试 Java 程序的标准，任何 JDK 都必须实现该标准。</p><p>JPDA 定义了一整套完整的体系，它将调试体系分为三部分，并规定了三者之间的通信接口。三部分由低到高分别是 Java 虚拟机工具接口（JVMTI），Java 调试协议（JDWP）以及 Java 调试接口（JDI），三者之间的关系如下图所示：</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-6.png" alt></p><p>现在回到正题，我们可以借助 JVMTI 的一部分能力，帮助动态重载类信息。JVM TI（JVM TOOL INTERFACE，JVM 工具接口）是 JVM 提供的一套对 JVM 进行操作的工具接口。通过 JVMTI，可以实现对 JVM 的多种操作，它通过接口注册各种事件勾子，在 JVM 事件触发时，同时触发预定义的勾子，以实现对各个 JVM 事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC 开始和结束、方法调用进入和退出、临界区竞争与等待、VM 启动与退出等等。</p><p>而 Agent 就是 JVMTI 的一种实现，Agent 有两种启动方式，一是随 Java 进程启动而启动，经常见到的 java -agentlib 就是这种方式；二是运行时载入，通过 attach API，将模块（jar 包）动态地 Attach 到指定进程 id 的 Java 进程内。</p><p>Attach API 的作用是提供 JVM 进程间通信的能力，比如说我们为了让另外一个 JVM 进程把线上服务的线程 Dump 出来，会运行 jstack 或 jmap 的进程，并传递 pid 的参数，告诉它要对哪个进程进行线程 Dump，这就是 Attach API 做的事情。在下面，我们将通过 Attach API 的 loadAgent() 方法，将打包好的 Agent jar 包动态 Attach 到目标 JVM 上。具体实现起来的步骤如下：</p><ul><li>定义 Agent，并在其中实现 AgentMain 方法，如上一小节中定义的代码块 7 中的 TestAgent 类；</li><li>然后将 TestAgent 类打成一个包含 MANIFEST.MF 的 jar 包，其中 MANIFEST.MF 文件中将 Agent-Class 属性指定为 TestAgent 的全限定名</li><li>最后利用 Attach API，将我们打包好的 jar 包 Attach 到指定的 JVM pid 上</li><li>由于在 MANIFEST.MF 中指定了 Agent-Class，所以在 Attach 后，目标 JVM 在运行时会走到 TestAgent 类中定义的 agentmain()方法，而在这个方法中，我们利用 Instrumentation，将指定类的字节码通过定义的类转化器 TestTransformer 做了 Base 类的字节码替换（通过 javassist），并完成了类的重新加载。由此，我们达成了 “在 JVM 运行时，改变类的字节码并重新载入类信息” 的目的。</li></ul><h3 id="使用场景">使用场景</h3><ul><li>热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。</li><li>Mock：测试时候对某些服务做 Mock。</li><li>性能诊断工具：比如 bTrace 就是利用 Instrument，实现无侵入地跟踪一个正在运行的 JVM，监控到类和方法级别的状态信息。</li></ul><h2 id="总结">总结</h2><p>字节码增强技术相当于是一把打开运行时 JVM 的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪 JVM 运行中程序的状态。此外，我们平时使用的动态代理、AOP 也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。综上所述，掌握字节码增强后可以高效地定位并快速修复一些棘手的问题（如线上性能问题、方法出现不可控的出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 WeakHashMap</title>
      <link href="/java/java-ji-he/java-ji-he-weakhashmap/"/>
      <url>/java/java-ji-he/java-ji-he-weakhashmap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 WeakHashMap</h1><h2 id="Metadata-31">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 WeakHashMapdate: 2022-12-14 14:29tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: WeakHashMap</code></pre><h2 id="总体介绍-3">总体介绍</h2><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。<br>更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况:</p><ul><li>调用两次<code>size()</code>方法返回不同的值；</li><li>两次调用<code>isEmpty()</code>方法，第一次返回false，第二次返回true；</li><li>两次调用<code>containsKey()</code>方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；</li><li>两次调用<code>get()</code>方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。<br>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，WeakHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。<br>要明白 WeakHashMap 的工作原理，还需要引入一个概念 : 弱引用(WeakReference)。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的有效引用 并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。<br>WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。<br>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</li></ul><h2 id="具体实现">具体实现</h2><p>WeakHashMap的存储结构类似于Map - HashSet &amp; HashMap 源码解析，这里不再赘述。<br>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p><h2 id="Weak-HashSet">Weak HashSet?</h2><p>如果你看过前几篇关于 Map 和 Set 的讲解，一定会问: 既然有 WeakHashMap，是否有 WeekHashSet 呢? 答案是没有:( 。不过Java Collections工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 Map包装成一个Set。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 TreeSet &amp; TreeMap</title>
      <link href="/java/java-ji-he/java-ji-he-treeset-treemap/"/>
      <url>/java/java-ji-he/java-ji-he-treeset-treemap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 TreeSet &amp; TreeMap</h1><h2 id="Metadata-30">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 TreeSet &amp; TreeMapdate: 2022-12-14 14:28tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: TreeSet &amp; TreeMap</code></pre><h2 id="总体介绍-2">总体介绍</h2><p>之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)**。因此本文将重点分析TreeMap。</p><p>Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p><p>TreeMap底层通过红黑树(Red-Black tree)实现，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="/attachment%5C7a7166f88bbf82409e0ea2dfef3fb432.png" alt></p><p>出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成(wrapped)同步的:</p><pre><code class="language-java">SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></pre><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h2 id="预备知识">预备知识</h2><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(Rotate Left)，右旋(RotateRight)**。</p><h3 id="左旋">左旋</h3><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment%5C5032edc39f7b7fc0d8b1bb352641b5c9.png" alt></p><h3 id="右旋">右旋</h3><p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment%5C4a47735be3f67803d2bb86f0b523126e.png" alt></p><h3 id="寻找节点后继">寻找节点后继</h3><p>对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="/attachment%5C5a8f8447940c459fdcfa2e59ccd2376a.png" alt></p><h2 id="方法剖析-2">方法剖析</h2><h3 id="get-3">get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据key的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的entry。</p><p><img src="/attachment%5Ceb8661b88f7261fb41c2730481d104d0.png" alt></p><h3 id="put-2">put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。</p><p>上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的entry并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。<br><img src="/attachment%5C92a9af8db273d3091dea45a5cb592716.png" alt><br>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><h3 id="remove-3">remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到key值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p><p>getEntry()函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p><p>由于<strong>红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。</p><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/attachment%5C92a9af8db273d3091dea45a5cb592716.png" alt></p><p>上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。</p><p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><h3 id="TreeSet">TreeSet</h3><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedHashSet&amp;Map</title>
      <link href="/java/java-ji-he/java-ji-he-linkedhashset-map/"/>
      <url>/java/java-ji-he/java-ji-he-linkedhashset-map/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 LinkedHashSet&amp;Map</h1><h2 id="Metadata-28">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 LinkedHashSet&amp;Mapdate: 2022-12-14 14:27tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedHashSet&amp;Map</code></pre><h2 id="总体介绍">总体介绍</h2><p>如果你已看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文将要讲解的LinkedHashSet和LinkedHashMap其实也是一回事。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap(适配器模式)。因此本文将重点分析LinkedHashMap。</p><p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。</p><p><img src="/attachment%5Ca2a0572e540cb3667a33ff02a9506ba3.png" alt></p><p>事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。</p><p>除了可以保迭代历顺序，这种结构还有一个好处 : 迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。</p><p>有两个参数可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要<code>@Override hashCode()</code>和<code>equals()</code>方法。</p><p>出于性能原因，LinkedHashMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成(wrapped)同步的:</p><pre><code class="language-java">Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></pre><h2 id="方法剖析">方法剖析</h2><h3 id="get-2">get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行参考前文，这里不再赘述。</p><h3 id="put">put()</h3><p><code>put(K key, V value)</code>方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的entry。</p><p>注意，这里的插入有<strong>两重含义</strong>:</p><ol><li>从table的角度看，新的<code>entry</code>需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol><p><img src="/attachment%5Cb3a124c667ece2d44b38023cf6b28415.png" alt></p><p>上述代码中用到了<code>addBefore()</code>方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。</p><p>上述代码只是简单修改相关entry的引用而已。</p><h3 id="remove-2">remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到key值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的删除也有两重含义:</p><blockquote><ol><li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="/attachment%5Cb2057acdb4b57a0381c29f3da5e18e07.png" alt></p><h2 id="LinkedHashSet">LinkedHashSet</h2><p>前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。</p><h2 id="LinkedHashMap经典用法">LinkedHashMap经典用法</h2><p>LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问<code>removeEldestEntry()</code>是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让<code>removeEldestEntry()</code>返回true，就能够实现一个固定大小的FIFO策略的缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】HashSet &amp; HashMap</title>
      <link href="/java/java-ji-he/java-ji-he-hashset-hashmap/"/>
      <url>/java/java-ji-he/java-ji-he-hashset-hashmap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】HashSet &amp; HashMap</h1><h2 id="Metadata-36">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】HashSet &amp; HashMapdate: 2022-12-14 14:26tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: HashSet &amp; HashMap</code></pre><h2 id="Java7-HashMap">Java7 HashMap</h2><h3 id="概述-5">概述</h3><p>之所以把HashSet和HashMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap(适配器模式)。因此本文将重点分析HashMap。</p><p>HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式。</strong></p><p><img src="/attachment%5C0e757c0ad4f83dc5a4d23e3766a40b5b.png" alt></p><p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。</p><p>有两个参数可以影响HashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到HashMap或HashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要<code>@Override</code> hashCode()和equals()方法。</p><h3 id="get-4">get()</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个entry。</p><p><img src="/attachment%5C657342a08666fd428fa01da97955e06a.png" alt></p><p>上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><h3 id="put-3">put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为头插法。</p><p><img src="/attachment%5C8352c0cd711fff93e7177ecf74436844.png" alt></p><h2 id="Java8-HashMap">Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>来一张图简单示意一下吧：</p><p><img src="/attachment%5C46d8f27734298c8228231f63d3948780.png" alt></p><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="数组扩容">数组扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><h3 id="get-过程分析">get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ul><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等( = = 或equals)的 key</li></ul><h3 id="HashSet">HashSet</h3><p>前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】PriorityQueue</title>
      <link href="/java/java-ji-he/java-ji-he-priorityqueue/"/>
      <url>/java/java-ji-he/java-ji-he-priorityqueue/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】PriorityQueue</h1><h2 id="Metadata-35">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】PriorityQueuedate: 2022-12-14 14:25tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: PriorityQueue</code></pre><h2 id="概述-4">概述</h2><p>前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><p>Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为PriorityQueue的底层实现。</p><p><img src="/attachment%5C312394fa06a43080329f9f1fafa64962.png" alt></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:</p><ul><li><code>leftNo = parentNo*2+1</code></li><li><code>rightNo = parentNo*2+2</code></li><li><code>parentNo = (nodeNo-1)/2</code></li></ul><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p>PriorityQueue的<code>peek()</code>和<code>element</code>操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。</p><h2 id="方法剖析-4">方法剖析</h2><h3 id="add-和offer">add()和offer()</h3><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。</p><p><img src="/attachment%5C4d6d38c41256871b2dc7aaff20f458c9.png" alt></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素x并维持堆的特性。</p><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为 : <strong>从k指定的位置开始，将<code>x</code>逐层与当前点的parent进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong> 。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h3 id="element-和peek">element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p><p><img src="/attachment%5C659365dc4d6a29fc83e2ca41681c0958.png" alt></p><h3 id="remove-和poll">remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/attachment%5C824b6d4b5dd97fa012eb0331473a4b30.png" alt></p><h3 id="remove-Object-o">remove(Object o)</h3><p><code>remove(Object o)</code>方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况:</p><ol><li>删除的是最后一个元素。直接删除即可，不需要调整。</li><li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</li></ol><p><img src="/attachment%5C59bbb3fa3b3e9145fb9ad09faa16a7dc.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 Stack&amp;Queue</title>
      <link href="/java/java-ji-he/java-ji-he-stack-queue/"/>
      <url>/java/java-ji-he/java-ji-he-stack-queue/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 Stack&amp;Queue</h1><h2 id="Metadata-32">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 Stack&amp;Queuedate: 2022-12-14 14:24tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: Stack&amp;Queue</code></pre><h2 id="Stack-Queue概述">Stack &amp; Queue概述</h2><p>Java里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。</p><h2 id="Queue">Queue</h2><p>Queue接口继承自Collection接口，除了最基本的<code>Collection</code>的方法之外，它还支持额外的<code>insertion</code>, <code>extraction</code>和<code>inspection</code>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td></tr><tr><td>Remove</td><td>remove()</td></tr><tr><td>Examine</td><td>element()</td></tr></tbody></table><h2 id="Deque">Deque</h2><p><code>Deque</code>是"<code>double ended queue</code>", 表示双向的队列，英文读作"deck". Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p><table><thead><tr><th>First Element - Head</th><th>Last Element - Tail</th></tr></thead><tbody><tr><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td></tr><tr><td>Examine</td><td>getFirst()</td></tr></tbody></table><p>当把<code>Deque</code>当做<code>FIFO</code>的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下:</p><p>Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td><td>向队尾插入元素，失败则返回false</td></tr><tr><td>remove()</td><td>removeFirst()</td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td>poll()</td><td>pollFirst()</td><td>获取并删除队首元素，失败则返回null</td></tr><tr><td>element()</td><td>getFirst()</td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除队首元素，失败则返回null</td></tr></tbody></table><p>下表列出了Deque与Stack对应的接口:</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td>offerFirst(e)</td><td>向栈顶插入元素，失败则返回false</td></tr><tr><td>pop()</td><td>removeFirst()</td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>pollFirst()</td><td>获取并删除栈顶元素，失败则返回null</td></tr><tr><td>peek()</td><td>getFirst()</td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则返回null</td></tr></tbody></table><p>上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。</p><p>ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。</p><p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p><img src="/attachment%5C08d0890337e4677367a3599ba968166b.png" alt></p><p>上图中我们看到，<code>head</code> <strong>指向首端第一个有效元素</strong>，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><h2 id="方法剖析-3">方法剖析</h2><h3 id="addFirst">addFirst()</h3><p><code>addFirst(E e)</code> 的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[–head] = e即可。</p><p><img src="/attachment%5C978a80c9de15f7d5c8f028867fb3ee9f.png" alt></p><p>实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。</p><pre><code class="language-java">//addFirst(E e)public void addFirst(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界    if (head == tail)//1.空间是否够用        doubleCapacity();//扩容}</code></pre><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。</p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p><p><img src="/attachment%5C06c965f8d110aa684fc6e289c3b0ff97.png" alt></p><p>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><pre><code class="language-java">//doubleCapacity()private void doubleCapacity() {    assert head == tail;    int p = head;    int n = elements.length;    int r = n - p; // head右边元素的个数    int newCapacity = n &lt;&lt; 1;//原空间的2倍    if (newCapacity &lt; 0)        throw new IllegalStateException("Sorry, deque too big");    Object[] a = new Object[newCapacity];    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分    elements = (E[])a;    head = 0;    tail = n;}</code></pre><h3 id="addLast">addLast()</h3><p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。</p><p><img src="/attachment%5Cb46ab44c8c54c0ab4dcaf88edb518eb7.png" alt></p><pre><code class="language-java">public void addLast(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[tail] = e;//赋值    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理        doubleCapacity();//扩容}</code></pre><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h3 id="pollFirst">pollFirst()</h3><p><code>pollFirst()</code>的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当<code>elements[head] == null</code>时，意味着容器为空。</p><pre><code class="language-java">public E pollFirst() {    E result = elements[head];    if (result == null)//null值意味着deque为空        return null;    elements[h] = null;//let GC work    head = (head + 1) &amp; (elements.length - 1);//下标越界处理    return result;}</code></pre><h3 id="pollLast">pollLast()</h3><p>pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="language-java">public E pollLast() {    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素    E result = elements[t];    if (result == null)//null值意味着deque为空        return null;    elements[t] = null;//let GC work    tail = t;    return result;}</code></pre><h3 id="peekFirst">peekFirst()</h3><p><code>peekFirst()</code>的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回<code>elements[head]</code>即可。</p><h3 id="peekLast">peekLast()</h3><p><code>peekLast()</code>的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="language-java">public E peekLast() {    return elements[(tail - 1) &amp; (elements.length - 1)];} </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedList</title>
      <link href="/java/java-ji-he/java-ji-he-linkedlist/"/>
      <url>/java/java-ji-he/java-ji-he-linkedlist/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 LinkedList</h1><h2 id="Metadata-29">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 LinkedListdate: 2022-12-14 14:23tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedList</code></pre><h2 id="概述-3">概述</h2><p>LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类(它是个接口名字)。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。</p><p><img src="/attachment%5C68cde8f6127c75943241f2fec6f1fb9b.png" alt></p><p>LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。</p><h2 id="LinkedLists实现">LinkedLists实现</h2><h3 id="底层数据结构-2">底层数据结构</h3><p>LinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，而将Queue和Stack以及Deque相关的知识放在下一节讲。双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。</p><pre><code class="language-java">    transient int size = 0;    /**     * Pointer to first node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (first.prev == null &amp;&amp; first.item != null)     */    transient Node&lt;E&gt; first;    /**     * Pointer to last node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     */    transient Node&lt;E&gt; last;</code></pre><p>其中Node是私有的内部类:</p><pre><code class="language-java">    private static class Node&lt;E&gt; {        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {            this.item = element;            this.next = next;            this.prev = prev;        }    }</code></pre><h3 id="构造函数">构造函数</h3><pre><code class="language-java">    /**     * Constructs an empty list.     */    public LinkedList() {    }    /**     * Constructs a list containing the elements of the specified     * collection, in the order they are returned by the collection's     * iterator.     *     * @param  c the collection whose elements are to be placed into this list     * @throws NullPointerException if the specified collection is null     */    public LinkedList(Collection&lt;? extends E&gt; c) {        this();        addAll(c);    }</code></pre><h3 id="getFirst-getLast">getFirst(), getLast()</h3><p>获取第一个元素， 和获取最后一个元素:</p><pre><code class="language-java">    /**     * Returns the first element in this list.     *     * @return the first element in this list     * @throws NoSuchElementException if this list is empty     */    public E getFirst() {        final Node&lt;E&gt; f = first;        if (f == null)            throw new NoSuchElementException();        return f.item;    }    /**     * Returns the last element in this list.     *     * @return the last element in this list     * @throws NoSuchElementException if this list is empty     */    public E getLast() {        final Node&lt;E&gt; l = last;        if (l == null)            throw new NoSuchElementException();        return l.item;    }</code></pre><h3 id="removeFirst-removeLast-remove-e-remove-index">removeFirst(), removeLast(), remove(e), remove(index)</h3><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><img src="/attachment%5Cb190f02840a986ee73942dda0f3e37b8.png" alt></p><p>删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p><p><code>remove(int index)</code>使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。</p><h3 id="add">add()</h3><p><code>add()</code>方法有两个版本，一个是<code>add(E e)</code>，该方法在<code>LinkedList</code>的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><p><img src="/attachment%5Cdfc813989f550f643c970e9dcfd90051.png" alt></p><p><code>add(int index, E element)</code>, 当<code>index==size</code>时，等同于<code>add(E e)</code>; 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p><p>上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</p><h3 id="addAll">addAll()</h3><p>addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p><h3 id="clear">clear()</h3><p>为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。</p><h3 id="Positional-Access-方法">Positional Access 方法</h3><p>通过index获取元素</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/java/java-ji-he/java-ji-he/"/>
      <url>/java/java-ji-he/java-ji-he/</url>
      
        <content type="html"><![CDATA[<h1>Java 集合</h1><h2 id="Metadata-26">Metadata</h2><pre><code class="language-yml">title: Java 集合date: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 集合</code></pre><h2 id="Java-集合-2">Java 集合</h2><p><img src="/attachment%5C7727cae2e6a5956678ac0bbedc6748d6.png" alt></p><h2 id="【Java-集合】-ArrayList">【Java 集合】 ArrayList</h2><p><a href="../java-ji-he-arraylist">【Java 集合】 ArrayList</a></p><h2 id="【Java-集合】-LinkedList">【Java 集合】 LinkedList</h2><p><a href="../java-ji-he-linkedlist">【Java 集合】 LinkedList</a></p><h2 id="【Java-集合】-LinkedHashSet-Map">【Java 集合】 LinkedHashSet&amp;Map</h2><p><a href="../java-ji-he-linkedhashset-map">【Java 集合】 LinkedHashSet&amp;Map</a></p><h2 id="【Java-集合】-Stack-Queue">【Java 集合】 Stack&amp;Queue</h2><p><a href="../java-ji-he-stack-queue">【Java 集合】 Stack&amp;Queue</a></p><h2 id="【Java-集合】-TreeSet-TreeMap">【Java 集合】 TreeSet &amp; TreeMap</h2><p><a href="../java-ji-he-treeset-treemap">【Java 集合】 TreeSet &amp; TreeMap</a></p><h2 id="【Java-集合】-WeakHashMap">【Java 集合】 WeakHashMap</h2><p><a href="../java-ji-he-weakhashmap">【Java 集合】 WeakHashMap</a></p><h2 id="【Java-集合】PriorityQueue">【Java 集合】PriorityQueue</h2><p><a href="../java-ji-he-priorityqueue">【Java 集合】PriorityQueue</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 ArrayList</title>
      <link href="/java/java-ji-he/java-ji-he-arraylist/"/>
      <url>/java/java-ji-he/java-ji-he-arraylist/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 ArrayList</h1><h2 id="Metadata-27">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 ArrayListdate: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: 集合</code></pre><h2 id="概述-2">概述</h2><p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><p><img src="/attachment%5C8bcaee4d397913b246c1598cac55fea4.png" alt></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><h2 id="ArrayList的实现">ArrayList的实现</h2><h3 id="底层数据结构">底层数据结构</h3><pre><code class="language-java">/**     * The array buffer into which the elements of the ArrayList are stored.     * The capacity of the ArrayList is the length of this array buffer. Any     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA     * will be expanded to DEFAULT_CAPACITY when the first element is added.     */    transient Object[] elementData; // non-private to simplify nested class access    /**     * The size of the ArrayList (the number of elements it contains).     *     * @serial     */    private int size;</code></pre><h3 id="自动扩容">自动扩容</h3><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><pre><code class="language-ad-tip">当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。</code></pre><p><img src="/attachment%5C63ae74eaa7189b56a8ac2d7407e60a57.png" alt></p><h3 id="add-addAll">add(), addAll()</h3><p>跟C++ 的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。</p><p><img src="/attachment%5Ce68ac4bef1a5e34817cbd016daef64c8.png" alt></p><h3 id="set">set()</h3><p>既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。</p><h3 id="get">get()</h3><p>get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</p><h3 id="remove">remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。</p><h3 id="trimToSize">trimToSize()</h3><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。</p><h3 id="indexOf-lastIndexOf">indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index<br>获取元素的最后一次出现的index</p><h3 id="Fail-Fast机制">Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 注解</title>
      <link href="/java/java-ji-chu/java-ji-chu-zhu-jie/"/>
      <url>/java/java-ji-chu/java-ji-chu-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 注解</h1><h2 id="Metadata-23">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 注解date: 2022-12-14 14:13tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/注解categories:  - Javakeywords:  - Java/基础  - 注解description: 注解</code></pre><h2 id="作用">作用</h2><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="分类">分类</h2><ul><li><strong>Java自带的标准注解</strong>，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li><li><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li><li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li></ul><h3 id="内置注解">内置注解</h3><ul><li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li></ul><h4 id="Override">@Override</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li><strong>用来修饰方法</strong></li><li><strong>编译时有效</strong></li><li><strong>重写的父类的中的相同签名的方法</strong></li></ul><h4 id="Deprecated">@Deprecated</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {}</code></pre></div><ul><li>被文档化</li><li>保留到运行时</li><li>修饰构造方法、属性、局部变量、方法、包、参数、类型</li></ul><p>告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h4 id="SuppressWarnings">@SuppressWarnings</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings {    String[] value();}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li>修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量</li><li>只能存活在源码时</li><li>取值为<code>String[]</code></li></ul><p>告诉编译器忽略指定的警告信息</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing/unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table></div><h3 id="元注解">元注解</h3><h4 id="Target">@Target</h4><p><strong>作用</strong></p><p>描述注解的使用范围（即：被修饰的注解可以用在什么地方）</p><p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了<code>@Target</code> 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在<code>ElementType</code> 枚举中。</p><p><strong>ElementType</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum ElementType {<pre><code>TYPE, // 类、接口、枚举类FIELD, // 成员变量（包括：枚举常量）METHOD, // 成员方法PARAMETER, // 方法参数CONSTRUCTOR, // 构造方法LOCAL_VARIABLE, // 局部变量ANNOTATION_TYPE, // 注解类PACKAGE, // 可用于修饰：包TYPE_PARAMETER, // 类型参数，JDK 1.8 新增TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Retention-RetentionTarget">@Retention &amp; @RetentionTarget</h4><p><strong>作用</strong></p><p>描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。<br>用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在<code>RetentionPolicy</code>枚举中。</p><p><strong>RetentionPolicy</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum RetentionPolicy {<pre><code>SOURCE,    // 源文件保留CLASS,       // 编译期保留，默认值RUNTIME   // 运行期保留，可通过反射去获取注解信息</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Documented">@Documented</h4><p><strong>作用</strong></p><p>描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p><h4 id="Inherited">@Inherited</h4><p><strong>作用</strong></p><p>被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p><h4 id="Repeatable">@Repeatable</h4><p><strong>作用</strong></p><p>重复注解 <code>ElementType.TYPE_USE</code></p><h4 id="Native">@Native</h4><p><strong>作用</strong></p><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p><h3 id="注解与反射接口">注解与反射接口</h3><p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。</p><ul><li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li></ul><p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p><p><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></p><p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p><ul><li><code>Annotation[] getAnnotations()</code></li></ul><p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p><ul><li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p><ul><li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p><ul><li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code></li></ul><p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p><h3 id="自定义注解">自定义注解</h3><ul><li></li></ul><h2 id="注解实现的原理">注解实现的原理</h2><h3 id="注解的本质">注解的本质</h3><p>注解是一个接口，一个继承自Annotation的接口。<br>里面每一个属性，其实就是接口的一个抽象方法。</p><p>这里推荐你两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li><li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li></ul><h2 id="注解的应用场景">注解的应用场景</h2><h3 id="配置化到注解化-框架的演进">配置化到注解化 - 框架的演进</h3><p>Spring 框架 配置化到注解化的转变。</p><h3 id="继承实现到注解实现-Junit3到Junit4">继承实现到注解实现 - Junit3到Junit4</h3><blockquote><p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p></blockquote><h3 id="自定义注解和AOP-通过切面实现解耦">自定义注解和AOP - 通过切面实现解耦</h3><ul><li>自定义Log注解</li><li>实现日志的切面, 对自定义注解Log作切点进行拦截</li></ul><h2 id="Tips">Tips</h2><h3 id="注解不支持继承">注解不支持继承</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 泛型</title>
      <link href="/java/java-ji-chu/java-ji-chu-fan-xing/"/>
      <url>/java/java-ji-chu/java-ji-chu-fan-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 泛型</h1><h2 id="Metadata-22">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 泛型date: 2022-12-14 14:12tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/泛型categories:  - Javakeywords:  - Java/基础  - 泛型description: 泛型</code></pre><h2 id="描述-2">描述</h2><p>泛型的本质是为了参数化类型。</p><ul><li>适用于多种数据类型执行相同的代码（代码复用）</li><li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li></ul><h2 id="泛型的基本使用">泛型的基本使用</h2><h3 id="泛型类">泛型类</h3><h3 id="泛型接口">泛型接口</h3><h3 id="泛型方法">泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p><p>定义泛型方法语法格式</p><p><img src="/attachment%5Cddcdc6a539768f8dc7017062098af3bb.png" alt></p><ul><li>调用泛型方法语法格式</li></ul><p><img src="/attachment%5Cef4e9cc951e4f6e085f5e62fd0156c58.png" alt></p><h3 id="泛型数组">泛型数组</h3><ul><li></li></ul><h3 id="小结">小结</h3><pre><code class="language-java">&lt;?&gt; 无限制通配符&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类// 使用原则《Effictive Java》// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限1. 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;2. 如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 异常</title>
      <link href="/java/java-ji-chu/java-ji-chu-yi-chang/"/>
      <url>/java/java-ji-chu/java-ji-chu-yi-chang/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 异常</h1><h2 id="Metadata-21">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 异常date: 2022-12-14 14:11tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/异常categories:  - Javakeywords:  - Java/基础  - 异常description: 异常</code></pre><h2 id="描述">描述</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:</p><ul><li>受检异常 : 需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li>非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><h2 id="异常基础">异常基础</h2><h3 id="异常关键字">异常关键字</h3><ul><li><code>try</code> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><code>catch</code> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><code>finally</code> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><code>throw</code> – 用于抛出异常。</li><li><code>throws</code> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h3 id="异常的申明-throws">异常的申明(throws)</h3><p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><h3 id="Throws抛出异常的规则">Throws抛出异常的规则</h3><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="异常的自定义">异常的自定义</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public class MyException extends Exception {    public MyException(){ }    public MyException(String msg){        super(msg);    }    // ...}</code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="异常的捕获">异常的捕获</h3><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h4 id="try-catch">try-catch</h4><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private static void readFile(String filePath) {    try {        // code    } catch (FileNotFoundException | UnknownHostException e) {        // handle FileNotFoundException or UnknownHostException    } catch (IOException e){        // handle IOException    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-catch-finally">try-catch-finally</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">try {                            //执行程序代码，可能会出现异常                 } catch(Exception e) {       //捕获异常并处理   } finally {    //必执行的代码}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-finally">try-finally</h4><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h4 id="try-with-resource">try-with-resource</h4><p>JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 <code>AutoCloseable</code> 接口的类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private  static void tryWithResourceTest(){    try (Scanner scanner = new Scanner(new FileInputStream("c:/abc"),"UTF-8")){        // code    } catch (IOException e){        // handle exception    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h2 id="异常的层次结构">异常的层次结构</h2><p>Java异常类层次结构图：</p><p><img src="/attachment%5C33441534b3f04acef0aca20b2b192abb.png" alt></p><h3 id="Throwable">Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h3 id="Error">Error</h3><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>此类错误一般表示代码运行时 JVM 出现问题。通常有 <code>Virtual MachineError</code>（虚拟机运行错误）、<code>NoClassDefFoundError</code>（类定义错误）等。比如 <code>OutOfMemoryError</code>：内存不足错误；<code>StackOverflowError</code>：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><h3 id="Exception-异常">Exception (异常)</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><h4 id="运行时异常">运行时异常</h4><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h4 id="非运行时异常-（编译异常）">非运行时异常 （编译异常）</h4><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）">可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</h3><h4 id="可查异常（编译器要求必须处置的异常）：">可查异常（编译器要求必须处置的异常）：</h4><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h4 id="不可查异常-编译器不要求强制处置的异常">不可查异常(编译器不要求强制处置的异常)</h4><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h2 id="注意点">注意点</h2><h3 id="尽量使用标准的异常">尽量使用标准的异常</h3><p>重用现有的异常有几个好处：</p><ul><li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li><li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li><li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li></ul><p>Java标准异常中有几个是经常被使用的异常。如下表格：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table></div><h3 id="对异常进行文档说明">对异常进行文档说明</h3><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p><p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><h3 id="优先捕获最具体的异常">优先捕获最具体的异常</h3><h3 id="不要捕获-Throwable-类">不要捕获 Throwable 类</h3><h3 id="不要忽略异常">不要忽略异常</h3><h3 id="不要记录并抛出异常">不要记录并抛出异常</h3><h3 id="包装异常时不要抛弃原始的异常">包装异常时不要抛弃原始的异常</h3><h3 id="不要使用异常控制程序的流程">不要使用异常控制程序的流程</h3><h3 id="不要在finally块中使用return">不要在finally块中使用return</h3><h2 id></h2><h2 id="总结-2">总结</h2><ul><li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li><li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li><li>finally语句块中的代码一定会被执行，常用于回收资源 。</li><li>throws：声明一个异常，告知方法调用者。</li><li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li></ul><p>Java编程思想一书中，对异常的总结。</p><ul><li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li><li>让类库和程序更安全。</li></ul><h2 id="常用的异常">常用的异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ul><li>RuntimeException<ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li>IOException<ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li>其他<ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 反射</title>
      <link href="/java/java-ji-chu/java-ji-chu-fan-she/"/>
      <url>/java/java-ji-chu/java-ji-chu-fan-she/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 反射</h1><h2 id="Metadata-19">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 反射date: 2022-12-14 14:09tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/反射categories:  - Javakeywords:  - Java/基础  - 反射description: 反射</code></pre><h2 id="基础-2">基础</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:</p><ul><li>Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor : 可以用 Constructor 创建新的对象。</li></ul><h3 id="Class-类">Class 类</h3><p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p><ul><li>Class类也是类的一种，与class关键字是不一样的。</li><li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li><li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 面向对象</title>
      <link href="/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/"/>
      <url>/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 面向对象</h1><h2 id="Metadata-24">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 面向对象date: 2022-12-14 14:07tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/面向对象categories:  - Javakeywords:  - Java/基础  - 面向对象description: 面向对象</code></pre><h2 id="三大特性">三大特性</h2><h3 id="封装">封装</h3><p>利用抽象数据类型<mark style="background: #FF5582A6;">将数据和基于数据的操作封装在一起</mark>，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p><strong>优点:</strong></p><ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><h3 id="继承">继承</h3><p>继承实现了 <mark style="background: #FF5582A6;">IS-A 关系</mark>，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循<strong>里氏替换原则</strong>，<mark style="background: #FF5582A6;">子类对象必须能够替换掉所有父类对象</mark>。</p><h3 id="多态">多态</h3><p>多态分为编译时多态和运行时多态:</p><ul><li><strong>编译时多态</strong>主要指<mark style="background: #ABF7F7A6;">方法的重载</mark></li><li><strong>运行时多态</strong>指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><h2 id="类图">类图</h2><h3 id="泛化关系-Generalization">泛化关系 (Generalization)</h3><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE3NXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNzUgMjA3IiB3aWR0aD0iMTc1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE0IiB4PSIyMy41IiB5PSIyMi45OTUxIj5HZW5lcmFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgVmVoaWNhbC0tPjxnIGlkPSJlbGVtX1ZlaGljYWwiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iVmVoaWNhbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODEiIHg9IjQzIiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjU4IiBjeT0iNjAuMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik02MC45Njg4LDY1LjkzNzUgUTYwLjM5MDYsNjYuMjM0NCA1OS43NSw2Ni4zNzUgUTU5LjEwOTQsNjYuNTMxMyA1OC40MDYzLDY2LjUzMTMgUTU1LjkwNjMsNjYuNTMxMyA1NC41NzgxLDY0Ljg5MDYgUTUzLjI2NTYsNjMuMjM0NCA1My4yNjU2LDYwLjEwOTQgUTUzLjI2NTYsNTYuOTg0NCA1NC41NzgxLDU1LjMyODEgUTU1LjkwNjMsNTMuNjcxOSA1OC40MDYzLDUzLjY3MTkgUTU5LjEwOTQsNTMuNjcxOSA1OS43NSw1My44MjgxIFE2MC40MDYzLDUzLjk4NDQgNjAuOTY4OCw1NC4yODEzIEw2MC45Njg4LDU3IFE2MC4zNDM4LDU2LjQyMTkgNTkuNzUsNTYuMTU2MyBRNTkuMTU2Myw1NS44NzUgNTguNTMxMyw1NS44NzUgUTU3LjE4NzUsNTUuODc1IDU2LjUsNTYuOTUzMSBRNTUuODEyNSw1OC4wMTU2IDU1LjgxMjUsNjAuMTA5NCBRNTUuODEyNSw2Mi4yMDMxIDU2LjUsNjMuMjgxMyBRNTcuMTg3NSw2NC4zNDM4IDU4LjUzMTMsNjQuMzQzOCBRNTkuMTU2Myw2NC4zNDM4IDU5Ljc1LDY0LjA3ODEgUTYwLjM0MzgsNjMuNzk2OSA2MC45Njg4LDYzLjIxODggTDYwLjk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSI3MiIgeT0iNjUuMTQzNiI+VmVoaWNhbDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI0NCIgeDI9IjEyMyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iNDQiIHgyPSIxMjMiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgQ2FyLS0+PGcgaWQ9ImVsZW1fQ2FyIj48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IkNhciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNTUiIHg9IjciIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuOTY4OCwxNzMuOTM3NSBRMjQuMzkwNiwxNzQuMjM0NCAyMy43NSwxNzQuMzc1IFEyMy4xMDk0LDE3NC41MzEzIDIyLjQwNjMsMTc0LjUzMTMgUTE5LjkwNjMsMTc0LjUzMTMgMTguNTc4MSwxNzIuODkwNiBRMTcuMjY1NiwxNzEuMjM0NCAxNy4yNjU2LDE2OC4xMDk0IFExNy4yNjU2LDE2NC45ODQ0IDE4LjU3ODEsMTYzLjMyODEgUTE5LjkwNjMsMTYxLjY3MTkgMjIuNDA2MywxNjEuNjcxOSBRMjMuMTA5NCwxNjEuNjcxOSAyMy43NSwxNjEuODI4MSBRMjQuNDA2MywxNjEuOTg0NCAyNC45Njg4LDE2Mi4yODEzIEwyNC45Njg4LDE2NSBRMjQuMzQzOCwxNjQuNDIxOSAyMy43NSwxNjQuMTU2MyBRMjMuMTU2MywxNjMuODc1IDIyLjUzMTMsMTYzLjg3NSBRMjEuMTg3NSwxNjMuODc1IDIwLjUsMTY0Ljk1MzEgUTE5LjgxMjUsMTY2LjAxNTYgMTkuODEyNSwxNjguMTA5NCBRMTkuODEyNSwxNzAuMjAzMSAyMC41LDE3MS4yODEzIFEyMS4xODc1LDE3Mi4zNDM4IDIyLjUzMTMsMTcyLjM0MzggUTIzLjE1NjMsMTcyLjM0MzggMjMuNzUsMTcyLjA3ODEgUTI0LjM0MzgsMTcxLjc5NjkgMjQuOTY4OCwxNzEuMjE4OCBMMjQuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIzIiB4PSIzNiIgeT0iMTczLjE0MzYiPkNhcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNjEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjYxIiB5MT0iMTkyLjI5NjkiIHkyPSIxOTIuMjk2OSIvPjwvZz48IS0tY2xhc3MgVHJ1Y2stLT48ZyBpZD0iZWxlbV9UcnVjayI+PHJlY3QgY29kZUxpbmU9IjYiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJUcnVjayIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzEiIHg9Ijk3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMTIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTQuOTY4OCwxNzMuOTM3NSBRMTE0LjM5MDYsMTc0LjIzNDQgMTEzLjc1LDE3NC4zNzUgUTExMy4xMDk0LDE3NC41MzEzIDExMi40MDYzLDE3NC41MzEzIFExMDkuOTA2MywxNzQuNTMxMyAxMDguNTc4MSwxNzIuODkwNiBRMTA3LjI2NTYsMTcxLjIzNDQgMTA3LjI2NTYsMTY4LjEwOTQgUTEwNy4yNjU2LDE2NC45ODQ0IDEwOC41NzgxLDE2My4zMjgxIFExMDkuOTA2MywxNjEuNjcxOSAxMTIuNDA2MywxNjEuNjcxOSBRMTEzLjEwOTQsMTYxLjY3MTkgMTEzLjc1LDE2MS44MjgxIFExMTQuNDA2MywxNjEuOTg0NCAxMTQuOTY4OCwxNjIuMjgxMyBMMTE0Ljk2ODgsMTY1IFExMTQuMzQzOCwxNjQuNDIxOSAxMTMuNzUsMTY0LjE1NjMgUTExMy4xNTYzLDE2My44NzUgMTEyLjUzMTMsMTYzLjg3NSBRMTExLjE4NzUsMTYzLjg3NSAxMTAuNSwxNjQuOTUzMSBRMTA5LjgxMjUsMTY2LjAxNTYgMTA5LjgxMjUsMTY4LjEwOTQgUTEwOS44MTI1LDE3MC4yMDMxIDExMC41LDE3MS4yODEzIFExMTEuMTg3NSwxNzIuMzQzOCAxMTIuNTMxMywxNzIuMzQzOCBRMTEzLjE1NjMsMTcyLjM0MzggMTEzLjc1LDE3Mi4wNzgxIFExMTQuMzQzOCwxNzEuNzk2OSAxMTQuOTY4OCwxNzEuMjE4OCBMMTE0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzOSIgeD0iMTI2IiB5PSIxNzMuMTQzNiI+VHJ1Y2s8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgVmVoaWNhbCB0byBDYXItLT48ZyBpZD0ibGlua19WZWhpY2FsX0NhciI+PHBhdGggY29kZUxpbmU9IjgiIGQ9Ik02My43MiwxMTIuMDg2OSBDNTcuNCwxMjUuNzQ2OSA1MC42NSwxNDAuMzU2OSA0NS4yMywxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJWZWhpY2FsLWJhY2t0by1DYXIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iNTcuMzcsMTA5LjE0NjksNzIuMTEsOTMuOTM2OSw3MC4wNywxMTUuMDI2OSw1Ny4zNywxMDkuMTQ2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgVmVoaWNhbCB0byBUcnVjay0tPjxnIGlkPSJsaW5rX1ZlaGljYWxfVHJ1Y2siPjxwYXRoIGNvZGVMaW5lPSI5IiBkPSJNMTAzLjI4LDExMi4wODY5IEMxMDkuNiwxMjUuNzQ2OSAxMTYuMzUsMTQwLjM1NjkgMTIxLjc3LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9IlZlaGljYWwtYmFja3RvLVRydWNrIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijk2LjkzLDExNS4wMjY5LDk0Ljg5LDkzLjkzNjksMTA5LjYzLDEwOS4xNDY5LDk2LjkzLDExNS4wMjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNF9ESW9yQXBDY2lJWXA5cENfWnVhaEVJSW1rTFdYQnBTWENKaW8xeWZtSll3MmlhQUJJdjZta0JnWXFXYXNEaFl2TzVhSzBlV1cwXS0tPjwvZz48L3N2Zz4="><h3 id="实现关系-Realization">实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE1OXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNTkgMjA3IiB3aWR0aD0iMTU5cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODUiIHg9IjMwIiB5PSIyMi45OTUxIj5SZWFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgTW92ZUJlaGF2aW9yLS0+PGcgaWQ9ImVsZW1fTW92ZUJlaGF2aW9yIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTMxIiB4PSIxMS41IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI2LjUiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIyLjQyMTksNTYuMDYyNSBMMjIuNDIxOSw1My45MDYzIEwyOS44MTI1LDUzLjkwNjMgTDI5LjgxMjUsNTYuMDYyNSBMMjcuMzQzOCw1Ni4wNjI1IEwyNy4zNDM4LDY0LjE0MDYgTDI5LjgxMjUsNjQuMTQwNiBMMjkuODEyNSw2Ni4yOTY5IEwyMi40MjE5LDY2LjI5NjkgTDIyLjQyMTksNjQuMTQwNiBMMjQuODkwNiw2NC4xNDA2IEwyNC44OTA2LDU2LjA2MjUgTDIyLjQyMTksNTYuMDYyNSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBmb250LXN0eWxlPSJpdGFsaWMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9IjQwLjUiIHk9IjY1LjE0MzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMi41IiB4Mj0iMTQxLjUiIHkxPSI3Ni4yOTY5IiB5Mj0iNzYuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyLjUiIHgyPSIxNDEuNSIgeTE9Ijg0LjI5NjkiIHkyPSI4NC4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBGbHktLT48ZyBpZD0iZWxlbV9GbHkiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRmx5IiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI1MCIgeD0iNyIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNC45Njg4LDE3My45Mzc1IFEyNC4zOTA2LDE3NC4yMzQ0IDIzLjc1LDE3NC4zNzUgUTIzLjEwOTQsMTc0LjUzMTMgMjIuNDA2MywxNzQuNTMxMyBRMTkuOTA2MywxNzQuNTMxMyAxOC41NzgxLDE3Mi44OTA2IFExNy4yNjU2LDE3MS4yMzQ0IDE3LjI2NTYsMTY4LjEwOTQgUTE3LjI2NTYsMTY0Ljk4NDQgMTguNTc4MSwxNjMuMzI4MSBRMTkuOTA2MywxNjEuNjcxOSAyMi40MDYzLDE2MS42NzE5IFEyMy4xMDk0LDE2MS42NzE5IDIzLjc1LDE2MS44MjgxIFEyNC40MDYzLDE2MS45ODQ0IDI0Ljk2ODgsMTYyLjI4MTMgTDI0Ljk2ODgsMTY1IFEyNC4zNDM4LDE2NC40MjE5IDIzLjc1LDE2NC4xNTYzIFEyMy4xNTYzLDE2My44NzUgMjIuNTMxMywxNjMuODc1IFEyMS4xODc1LDE2My44NzUgMjAuNSwxNjQuOTUzMSBRMTkuODEyNSwxNjYuMDE1NiAxOS44MTI1LDE2OC4xMDk0IFExOS44MTI1LDE3MC4yMDMxIDIwLjUsMTcxLjI4MTMgUTIxLjE4NzUsMTcyLjM0MzggMjIuNTMxMywxNzIuMzQzOCBRMjMuMTU2MywxNzIuMzQzOCAyMy43NSwxNzIuMDc4MSBRMjQuMzQzOCwxNzEuNzk2OSAyNC45Njg4LDE3MS4yMTg4IEwyNC45Njg4LDE3My45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTgiIHg9IjM2IiB5PSIxNzMuMTQzNiI+Rmx5PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSI1NiIgeTE9IjE4NC4yOTY5IiB5Mj0iMTg0LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNTYiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBSdW4tLT48ZyBpZD0iZWxlbV9SdW4iPjxyZWN0IGNvZGVMaW5lPSI2IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iUnVuIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI2MCIgeD0iOTIiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEwNyIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEwOS45Njg4LDE3My45Mzc1IFExMDkuMzkwNiwxNzQuMjM0NCAxMDguNzUsMTc0LjM3NSBRMTA4LjEwOTQsMTc0LjUzMTMgMTA3LjQwNjMsMTc0LjUzMTMgUTEwNC45MDYzLDE3NC41MzEzIDEwMy41NzgxLDE3Mi44OTA2IFExMDIuMjY1NiwxNzEuMjM0NCAxMDIuMjY1NiwxNjguMTA5NCBRMTAyLjI2NTYsMTY0Ljk4NDQgMTAzLjU3ODEsMTYzLjMyODEgUTEwNC45MDYzLDE2MS42NzE5IDEwNy40MDYzLDE2MS42NzE5IFExMDguMTA5NCwxNjEuNjcxOSAxMDguNzUsMTYxLjgyODEgUTEwOS40MDYzLDE2MS45ODQ0IDEwOS45Njg4LDE2Mi4yODEzIEwxMDkuOTY4OCwxNjUgUTEwOS4zNDM4LDE2NC40MjE5IDEwOC43NSwxNjQuMTU2MyBRMTA4LjE1NjMsMTYzLjg3NSAxMDcuNTMxMywxNjMuODc1IFExMDYuMTg3NSwxNjMuODc1IDEwNS41LDE2NC45NTMxIFExMDQuODEyNSwxNjYuMDE1NiAxMDQuODEyNSwxNjguMTA5NCBRMTA0LjgxMjUsMTcwLjIwMzEgMTA1LjUsMTcxLjI4MTMgUTEwNi4xODc1LDE3Mi4zNDM4IDEwNy41MzEzLDE3Mi4zNDM4IFExMDguMTU2MywxNzIuMzQzOCAxMDguNzUsMTcyLjA3ODEgUTEwOS4zNDM4LDE3MS43OTY5IDEwOS45Njg4LDE3MS4yMTg4IEwxMDkuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSIxMjEiIHk9IjE3My4xNDM2Ij5SdW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgTW92ZUJlaGF2aW9yIHRvIEZseS0tPjxnIGlkPSJsaW5rX01vdmVCZWhhdmlvcl9GbHkiPjxwYXRoIGNvZGVMaW5lPSI4IiBkPSJNNTguODQsMTEyLjA4NjkgQzUzLjAzLDEyNS43NDY5IDQ2LjgzLDE0MC4zNTY5IDQxLjg1LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9Ik1vdmVCZWhhdmlvci1iYWNrdG8tRmx5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSI1Mi4yNywxMDkuNjI2OSw2Ni41Myw5My45NTY5LDY1LjE2LDExNS4wOTY5LDUyLjI3LDEwOS42MjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBNb3ZlQmVoYXZpb3IgdG8gUnVuLS0+PGcgaWQ9ImxpbmtfTW92ZUJlaGF2aW9yX1J1biI+PHBhdGggY29kZUxpbmU9IjkiIGQ9Ik05NS4xNiwxMTIuMDg2OSBDMTAwLjk3LDEyNS43NDY5IDEwNy4xNywxNDAuMzU2OSAxMTIuMTUsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iTW92ZUJlaGF2aW9yLWJhY2t0by1SdW4iIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijg4Ljg0LDExNS4wOTY5LDg3LjQ3LDkzLjk1NjksMTAxLjczLDEwOS42MjY5LDg4Ljg0LDExNS4wOTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkwyNGZEcENjaUlZcDlwQ19adWloQ0FxYWpJYWpDSmJObXBJekJUS2hESTJwQnAyX1lJaXY5QjJ2TVNDa2ZYQkEySWU1Z2FMS2VzREpld080TE84ZzI1MEMwXS0tPjwvZz48L3N2Zz4="><h3 id="聚合关系-Aggregation">聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM0MXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNDEgMjA3IiB3aWR0aD0iMzQxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTciIHg9IjExNSIgeT0iMjIuOTk1MSI+QWdncmVnYXRpb248L3RleHQ+PCEtLWNsYXNzIENvbXB1dGVyLS0+PGcgaWQ9ImVsZW1fQ29tcHV0ZXIiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcHV0ZXIiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEwMSIgeD0iMTI4IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjE0MyIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTQ1Ljk2ODgsNjUuOTM3NSBRMTQ1LjM5MDYsNjYuMjM0NCAxNDQuNzUsNjYuMzc1IFExNDQuMTA5NCw2Ni41MzEzIDE0My40MDYzLDY2LjUzMTMgUTE0MC45MDYzLDY2LjUzMTMgMTM5LjU3ODEsNjQuODkwNiBRMTM4LjI2NTYsNjMuMjM0NCAxMzguMjY1Niw2MC4xMDk0IFExMzguMjY1Niw1Ni45ODQ0IDEzOS41NzgxLDU1LjMyODEgUTE0MC45MDYzLDUzLjY3MTkgMTQzLjQwNjMsNTMuNjcxOSBRMTQ0LjEwOTQsNTMuNjcxOSAxNDQuNzUsNTMuODI4MSBRMTQ1LjQwNjMsNTMuOTg0NCAxNDUuOTY4OCw1NC4yODEzIEwxNDUuOTY4OCw1NyBRMTQ1LjM0MzgsNTYuNDIxOSAxNDQuNzUsNTYuMTU2MyBRMTQ0LjE1NjMsNTUuODc1IDE0My41MzEzLDU1Ljg3NSBRMTQyLjE4NzUsNTUuODc1IDE0MS41LDU2Ljk1MzEgUTE0MC44MTI1LDU4LjAxNTYgMTQwLjgxMjUsNjAuMTA5NCBRMTQwLjgxMjUsNjIuMjAzMSAxNDEuNSw2My4yODEzIFExNDIuMTg3NSw2NC4zNDM4IDE0My41MzEzLDY0LjM0MzggUTE0NC4xNTYzLDY0LjM0MzggMTQ0Ljc1LDY0LjA3ODEgUTE0NS4zNDM4LDYzLjc5NjkgMTQ1Ljk2ODgsNjMuMjE4OCBMMTQ1Ljk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSIxNTciIHk9IjY1LjE0MzYiPkNvbXB1dGVyPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyOSIgeDI9IjIyOCIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTI5IiB4Mj0iMjI4IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWNsYXNzIEtleWJvYXJkLS0+PGcgaWQ9ImVsZW1fS2V5Ym9hcmQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iS2V5Ym9hcmQiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijk3IiB4PSI3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsMTczLjkzNzUgUTI0LjM5MDYsMTc0LjIzNDQgMjMuNzUsMTc0LjM3NSBRMjMuMTA5NCwxNzQuNTMxMyAyMi40MDYzLDE3NC41MzEzIFExOS45MDYzLDE3NC41MzEzIDE4LjU3ODEsMTcyLjg5MDYgUTE3LjI2NTYsMTcxLjIzNDQgMTcuMjY1NiwxNjguMTA5NCBRMTcuMjY1NiwxNjQuOTg0NCAxOC41NzgxLDE2My4zMjgxIFExOS45MDYzLDE2MS42NzE5IDIyLjQwNjMsMTYxLjY3MTkgUTIzLjEwOTQsMTYxLjY3MTkgMjMuNzUsMTYxLjgyODEgUTI0LjQwNjMsMTYxLjk4NDQgMjQuOTY4OCwxNjIuMjgxMyBMMjQuOTY4OCwxNjUgUTI0LjM0MzgsMTY0LjQyMTkgMjMuNzUsMTY0LjE1NjMgUTIzLjE1NjMsMTYzLjg3NSAyMi41MzEzLDE2My44NzUgUTIxLjE4NzUsMTYzLjg3NSAyMC41LDE2NC45NTMxIFExOS44MTI1LDE2Ni4wMTU2IDE5LjgxMjUsMTY4LjEwOTQgUTE5LjgxMjUsMTcwLjIwMzEgMjAuNSwxNzEuMjgxMyBRMjEuMTg3NSwxNzIuMzQzOCAyMi41MzEzLDE3Mi4zNDM4IFEyMy4xNTYzLDE3Mi4zNDM4IDIzLjc1LDE3Mi4wNzgxIFEyNC4zNDM4LDE3MS43OTY5IDI0Ljk2ODgsMTcxLjIxODggTDI0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NSIgeD0iMzYiIHk9IjE3My4xNDM2Ij5LZXlib2FyZDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTAzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMDMiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBNb3VzZS0tPjxnIGlkPSJlbGVtX01vdXNlIj48cmVjdCBjb2RlTGluZT0iNiIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdXNlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI3OSIgeD0iMTM5IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxNTQiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xNTYuOTY4OCwxNzMuOTM3NSBRMTU2LjM5MDYsMTc0LjIzNDQgMTU1Ljc1LDE3NC4zNzUgUTE1NS4xMDk0LDE3NC41MzEzIDE1NC40MDYzLDE3NC41MzEzIFExNTEuOTA2MywxNzQuNTMxMyAxNTAuNTc4MSwxNzIuODkwNiBRMTQ5LjI2NTYsMTcxLjIzNDQgMTQ5LjI2NTYsMTY4LjEwOTQgUTE0OS4yNjU2LDE2NC45ODQ0IDE1MC41NzgxLDE2My4zMjgxIFExNTEuOTA2MywxNjEuNjcxOSAxNTQuNDA2MywxNjEuNjcxOSBRMTU1LjEwOTQsMTYxLjY3MTkgMTU1Ljc1LDE2MS44MjgxIFExNTYuNDA2MywxNjEuOTg0NCAxNTYuOTY4OCwxNjIuMjgxMyBMMTU2Ljk2ODgsMTY1IFExNTYuMzQzOCwxNjQuNDIxOSAxNTUuNzUsMTY0LjE1NjMgUTE1NS4xNTYzLDE2My44NzUgMTU0LjUzMTMsMTYzLjg3NSBRMTUzLjE4NzUsMTYzLjg3NSAxNTIuNSwxNjQuOTUzMSBRMTUxLjgxMjUsMTY2LjAxNTYgMTUxLjgxMjUsMTY4LjEwOTQgUTE1MS44MTI1LDE3MC4yMDMxIDE1Mi41LDE3MS4yODEzIFExNTMuMTg3NSwxNzIuMzQzOCAxNTQuNTMxMywxNzIuMzQzOCBRMTU1LjE1NjMsMTcyLjM0MzggMTU1Ljc1LDE3Mi4wNzgxIFExNTYuMzQzOCwxNzEuNzk2OSAxNTYuOTY4OCwxNzEuMjE4OCBMMTU2Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0NyIgeD0iMTY4IiB5PSIxNzMuMTQzNiI+TW91c2U8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTQwIiB4Mj0iMjE3IiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE0MCIgeDI9IjIxNyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLWNsYXNzIFNjcmVlbi0tPjxnIGlkPSJlbGVtX1NjcmVlbiI+PHJlY3QgY29kZUxpbmU9IjciIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJTY3JlZW4iIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjgxIiB4PSIyNTMiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI2OCIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI3MC45Njg4LDE3My45Mzc1IFEyNzAuMzkwNiwxNzQuMjM0NCAyNjkuNzUsMTc0LjM3NSBRMjY5LjEwOTQsMTc0LjUzMTMgMjY4LjQwNjMsMTc0LjUzMTMgUTI2NS45MDYzLDE3NC41MzEzIDI2NC41NzgxLDE3Mi44OTA2IFEyNjMuMjY1NiwxNzEuMjM0NCAyNjMuMjY1NiwxNjguMTA5NCBRMjYzLjI2NTYsMTY0Ljk4NDQgMjY0LjU3ODEsMTYzLjMyODEgUTI2NS45MDYzLDE2MS42NzE5IDI2OC40MDYzLDE2MS42NzE5IFEyNjkuMTA5NCwxNjEuNjcxOSAyNjkuNzUsMTYxLjgyODEgUTI3MC40MDYzLDE2MS45ODQ0IDI3MC45Njg4LDE2Mi4yODEzIEwyNzAuOTY4OCwxNjUgUTI3MC4zNDM4LDE2NC40MjE5IDI2OS43NSwxNjQuMTU2MyBRMjY5LjE1NjMsMTYzLjg3NSAyNjguNTMxMywxNjMuODc1IFEyNjcuMTg3NSwxNjMuODc1IDI2Ni41LDE2NC45NTMxIFEyNjUuODEyNSwxNjYuMDE1NiAyNjUuODEyNSwxNjguMTA5NCBRMjY1LjgxMjUsMTcwLjIwMzEgMjY2LjUsMTcxLjI4MTMgUTI2Ny4xODc1LDE3Mi4zNDM4IDI2OC41MzEzLDE3Mi4zNDM4IFEyNjkuMTU2MywxNzIuMzQzOCAyNjkuNzUsMTcyLjA3ODEgUTI3MC4zNDM4LDE3MS43OTY5IDI3MC45Njg4LDE3MS4yMTg4IEwyNzAuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSIyODIiIHk9IjE3My4xNDM2Ij5TY3JlZW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMjU0IiB4Mj0iMzMzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjI1NCIgeDI9IjMzMyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBLZXlib2FyZC0tPjxnIGlkPSJsaW5rX0NvbXB1dGVyX0tleWJvYXJkIj48cGF0aCBjb2RlTGluZT0iOSIgZD0iTTE0MC42LDEwMS45NTY5IEMxMjEuNzgsMTE4LjE3NjkgOTkuNDgsMTM3LjM5NjkgODIuNDMsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLUtleWJvYXJkIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9IjE1MC4zNiw5My41NDY5LDE0My4yMDM4LDk0LjQzNTEsMTQxLjI3MTMsMTAxLjM4MjQsMTQ4LjQyNzUsMTAwLjQ5NDIsMTUwLjM2LDkzLjU0NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tcmV2ZXJzZSBsaW5rIENvbXB1dGVyIHRvIE1vdXNlLS0+PGcgaWQ9ImxpbmtfQ29tcHV0ZXJfTW91c2UiPjxwYXRoIGNvZGVMaW5lPSIxMCIgZD0iTTE3OC41LDEwNi44MzY5IEMxNzguNSwxMjEuOTI2OSAxNzguNSwxMzguODQ2OSAxNzguNSwxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJDb21wdXRlci1iYWNrdG8tTW91c2UiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iMTc4LjUsOTQuMDc2OSwxNzQuNSwxMDAuMDc2OSwxNzguNSwxMDYuMDc2OSwxODIuNSwxMDAuMDc2OSwxNzguNSw5NC4wNzY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBTY3JlZW4tLT48ZyBpZD0ibGlua19Db21wdXRlcl9TY3JlZW4iPjxwYXRoIGNvZGVMaW5lPSIxMSIgZD0iTTIxNC4xOCwxMDIuMTg2OSBDMjMxLjczLDExOC4zNTY5IDI1Mi40NiwxMzcuNDY2OSAyNjguMzIsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLVNjcmVlbiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIyMDQuODUsOTMuNTg2OSwyMDYuNTU0NCwxMDAuNTkzNywyMTMuNjc3OCwxMDEuNzE1MywyMTEuOTczMyw5NC43MDg1LDIwNC44NSw5My41ODY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNG5GQnFmREpvcDlwQ19adWFoRUlJbWtMZDNFcG9xZUJLYWpXZEF6S29rSnlYRUJLZzFTdF9wSXViR2VFcFl2QTNLTGcwLWNHbzVWTG5VWDdhS0tlV3I1MkFlUjAwMDBdLS0+PC9nPjwvc3ZnPg=="><h3 id="组合关系-Composition">组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjI5OHB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyOTggMjA3IiB3aWR0aD0iMjk4cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTgiIHg9IjkzLjI1IiB5PSIyMi45OTUxIj5Db21wb3NpdGlvbjwvdGV4dD48IS0tY2xhc3MgQ29tcGFueS0tPjxnIGlkPSJlbGVtX0NvbXBhbnkiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcGFueSIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iOTciIHg9IjEwMC41IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjExNS41IiBjeT0iNjAuMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTguNDY4OCw2NS45Mzc1IFExMTcuODkwNiw2Ni4yMzQ0IDExNy4yNSw2Ni4zNzUgUTExNi42MDk0LDY2LjUzMTMgMTE1LjkwNjMsNjYuNTMxMyBRMTEzLjQwNjMsNjYuNTMxMyAxMTIuMDc4MSw2NC44OTA2IFExMTAuNzY1Niw2My4yMzQ0IDExMC43NjU2LDYwLjEwOTQgUTExMC43NjU2LDU2Ljk4NDQgMTEyLjA3ODEsNTUuMzI4MSBRMTEzLjQwNjMsNTMuNjcxOSAxMTUuOTA2Myw1My42NzE5IFExMTYuNjA5NCw1My42NzE5IDExNy4yNSw1My44MjgxIFExMTcuOTA2Myw1My45ODQ0IDExOC40Njg4LDU0LjI4MTMgTDExOC40Njg4LDU3IFExMTcuODQzOCw1Ni40MjE5IDExNy4yNSw1Ni4xNTYzIFExMTYuNjU2Myw1NS44NzUgMTE2LjAzMTMsNTUuODc1IFExMTQuNjg3NSw1NS44NzUgMTE0LDU2Ljk1MzEgUTExMy4zMTI1LDU4LjAxNTYgMTEzLjMxMjUsNjAuMTA5NCBRMTEzLjMxMjUsNjIuMjAzMSAxMTQsNjMuMjgxMyBRMTE0LjY4NzUsNjQuMzQzOCAxMTYuMDMxMyw2NC4zNDM4IFExMTYuNjU2Myw2NC4zNDM4IDExNy4yNSw2NC4wNzgxIFExMTcuODQzOCw2My43OTY5IDExOC40Njg4LDYzLjIxODggTDExOC40Njg4LDY1LjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NSIgeD0iMTI5LjUiIHk9IjY1LjE0MzYiPkNvbXBhbnk8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTAxLjUiIHgyPSIxOTYuNSIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTAxLjUiIHgyPSIxOTYuNSIgeTE9Ijg0LjI5NjkiIHkyPSI4NC4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBEZXBhcnRtZW50QS0tPjxnIGlkPSJlbGVtX0RlcGFydG1lbnRBIj48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IkRlcGFydG1lbnRBIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxMjQiIHg9IjciIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuOTY4OCwxNzMuOTM3NSBRMjQuMzkwNiwxNzQuMjM0NCAyMy43NSwxNzQuMzc1IFEyMy4xMDk0LDE3NC41MzEzIDIyLjQwNjMsMTc0LjUzMTMgUTE5LjkwNjMsMTc0LjUzMTMgMTguNTc4MSwxNzIuODkwNiBRMTcuMjY1NiwxNzEuMjM0NCAxNy4yNjU2LDE2OC4xMDk0IFExNy4yNjU2LDE2NC45ODQ0IDE4LjU3ODEsMTYzLjMyODEgUTE5LjkwNjMsMTYxLjY3MTkgMjIuNDA2MywxNjEuNjcxOSBRMjMuMTA5NCwxNjEuNjcxOSAyMy43NSwxNjEuODI4MSBRMjQuNDA2MywxNjEuOTg0NCAyNC45Njg4LDE2Mi4yODEzIEwyNC45Njg4LDE2NSBRMjQuMzQzOCwxNjQuNDIxOSAyMy43NSwxNjQuMTU2MyBRMjMuMTU2MywxNjMuODc1IDIyLjUzMTMsMTYzLjg3NSBRMjEuMTg3NSwxNjMuODc1IDIwLjUsMTY0Ljk1MzEgUTE5LjgxMjUsMTY2LjAxNTYgMTkuODEyNSwxNjguMTA5NCBRMTkuODEyNSwxNzAuMjAzMSAyMC41LDE3MS4yODEzIFEyMS4xODc1LDE3Mi4zNDM4IDIyLjUzMTMsMTcyLjM0MzggUTIzLjE1NjMsMTcyLjM0MzggMjMuNzUsMTcyLjA3ODEgUTI0LjM0MzgsMTcxLjc5NjkgMjQuOTY4OCwxNzEuMjE4OCBMMjQuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkyIiB4PSIzNiIgeT0iMTczLjE0MzYiPkRlcGFydG1lbnRBPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMzAiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjEzMCIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLWNsYXNzIERlcGFydG1lbnRCLS0+PGcgaWQ9ImVsZW1fRGVwYXJ0bWVudEIiPjxyZWN0IGNvZGVMaW5lPSI2IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRGVwYXJ0bWVudEIiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEyNSIgeD0iMTY2LjUiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjE4MS41IiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTg0LjQ2ODgsMTczLjkzNzUgUTE4My44OTA2LDE3NC4yMzQ0IDE4My4yNSwxNzQuMzc1IFExODIuNjA5NCwxNzQuNTMxMyAxODEuOTA2MywxNzQuNTMxMyBRMTc5LjQwNjMsMTc0LjUzMTMgMTc4LjA3ODEsMTcyLjg5MDYgUTE3Ni43NjU2LDE3MS4yMzQ0IDE3Ni43NjU2LDE2OC4xMDk0IFExNzYuNzY1NiwxNjQuOTg0NCAxNzguMDc4MSwxNjMuMzI4MSBRMTc5LjQwNjMsMTYxLjY3MTkgMTgxLjkwNjMsMTYxLjY3MTkgUTE4Mi42MDk0LDE2MS42NzE5IDE4My4yNSwxNjEuODI4MSBRMTgzLjkwNjMsMTYxLjk4NDQgMTg0LjQ2ODgsMTYyLjI4MTMgTDE4NC40Njg4LDE2NSBRMTgzLjg0MzgsMTY0LjQyMTkgMTgzLjI1LDE2NC4xNTYzIFExODIuNjU2MywxNjMuODc1IDE4Mi4wMzEzLDE2My44NzUgUTE4MC42ODc1LDE2My44NzUgMTgwLDE2NC45NTMxIFExNzkuMzEyNSwxNjYuMDE1NiAxNzkuMzEyNSwxNjguMTA5NCBRMTc5LjMxMjUsMTcwLjIwMzEgMTgwLDE3MS4yODEzIFExODAuNjg3NSwxNzIuMzQzOCAxODIuMDMxMywxNzIuMzQzOCBRMTgyLjY1NjMsMTcyLjM0MzggMTgzLjI1LDE3Mi4wNzgxIFExODMuODQzOCwxNzEuNzk2OSAxODQuNDY4OCwxNzEuMjE4OCBMMTg0LjQ2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MyIgeD0iMTk1LjUiIHk9IjE3My4xNDM2Ij5EZXBhcnRtZW50QjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxNjcuNSIgeDI9IjI5MC41IiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE2Ny41IiB4Mj0iMjkwLjUiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcGFueSB0byBEZXBhcnRtZW50QS0tPjxnIGlkPSJsaW5rX0NvbXBhbnlfRGVwYXJ0bWVudEEiPjxwYXRoIGNvZGVMaW5lPSI4IiBkPSJNMTIyLjc5LDEwNC4wMjY5IEMxMTAuODksMTE5Ljc5NjkgOTcuMTQsMTM4LjAxNjkgODYuNTIsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcGFueS1iYWNrdG8tRGVwYXJ0bWVudEEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iMTMwLjUzLDkzLjc2NjksMTIzLjcyMjYsOTYuMTQ1OSwxMjMuMzAwNSwxMDMuMzQ0NywxMzAuMTA3OCwxMDAuOTY1NiwxMzAuNTMsOTMuNzY2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcGFueSB0byBEZXBhcnRtZW50Qi0tPjxnIGlkPSJsaW5rX0NvbXBhbnlfRGVwYXJ0bWVudEIiPjxwYXRoIGNvZGVMaW5lPSI5IiBkPSJNMTc1LjIxLDEwNC4wMjY5IEMxODcuMTEsMTE5Ljc5NjkgMjAwLjg2LDEzOC4wMTY5IDIxMS40OCwxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJDb21wYW55LWJhY2t0by1EZXBhcnRtZW50QiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxNjcuNDcsOTMuNzY2OSwxNjcuODkyMiwxMDAuOTY1NiwxNzQuNjk5NSwxMDMuMzQ0NywxNzQuMjc3NCw5Ni4xNDU5LDE2Ny40Nyw5My43NjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTQ3hGQlNXbHBZcDlwQ19adWFoRUlJbWsxV2lidmJMMlVJd2YxT2I1OVJjZlVJTUU2MjlFTjVuR25HZlFraGVlSWg2QkV0NDEwMDAwXS0tPjwvZz48L3N2Zz4="><h3 id="关联关系-Association">关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSI5OXB4IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiBzdHlsZT0id2lkdGg6MjE1cHg7aGVpZ2h0Ojk5cHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjE1IDk5IiB3aWR0aD0iMjE1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTEiIHg9IjU1IiB5PSIyMi45OTUxIj5Bc3NvY2lhdGlvbjwvdGV4dD48IS0tY2xhc3MgU2Nob29sLS0+PGcgaWQ9ImVsZW1fU2Nob29sIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IlNjaG9vbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzkiIHg9IjciIHk9IjQ0LjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsNjUuOTM3NSBRMjQuMzkwNiw2Ni4yMzQ0IDIzLjc1LDY2LjM3NSBRMjMuMTA5NCw2Ni41MzEzIDIyLjQwNjMsNjYuNTMxMyBRMTkuOTA2Myw2Ni41MzEzIDE4LjU3ODEsNjQuODkwNiBRMTcuMjY1Niw2My4yMzQ0IDE3LjI2NTYsNjAuMTA5NCBRMTcuMjY1Niw1Ni45ODQ0IDE4LjU3ODEsNTUuMzI4MSBRMTkuOTA2Myw1My42NzE5IDIyLjQwNjMsNTMuNjcxOSBRMjMuMTA5NCw1My42NzE5IDIzLjc1LDUzLjgyODEgUTI0LjQwNjMsNTMuOTg0NCAyNC45Njg4LDU0LjI4MTMgTDI0Ljk2ODgsNTcgUTI0LjM0MzgsNTYuNDIxOSAyMy43NSw1Ni4xNTYzIFEyMy4xNTYzLDU1Ljg3NSAyMi41MzEzLDU1Ljg3NSBRMjEuMTg3NSw1NS44NzUgMjAuNSw1Ni45NTMxIFExOS44MTI1LDU4LjAxNTYgMTkuODEyNSw2MC4xMDk0IFExOS44MTI1LDYyLjIwMzEgMjAuNSw2My4yODEzIFEyMS4xODc1LDY0LjM0MzggMjIuNTMxMyw2NC4zNDM4IFEyMy4xNTYzLDY0LjM0MzggMjMuNzUsNjQuMDc4MSBRMjQuMzQzOCw2My43OTY5IDI0Ljk2ODgsNjMuMjE4OCBMMjQuOTY4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDciIHg9IjM2IiB5PSI2NS4xNDM2Ij5TY2hvb2w8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9Ijg1IiB5MT0iNzYuMjk2OSIgeTI9Ijc2LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iODUiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgU3R1ZGVudC0tPjxnIGlkPSJlbGVtX1N0dWRlbnQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iU3R1ZGVudCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODciIHg9IjEyMSIgeT0iNDQuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMzYiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEzOC45Njg4LDY1LjkzNzUgUTEzOC4zOTA2LDY2LjIzNDQgMTM3Ljc1LDY2LjM3NSBRMTM3LjEwOTQsNjYuNTMxMyAxMzYuNDA2Myw2Ni41MzEzIFExMzMuOTA2Myw2Ni41MzEzIDEzMi41NzgxLDY0Ljg5MDYgUTEzMS4yNjU2LDYzLjIzNDQgMTMxLjI2NTYsNjAuMTA5NCBRMTMxLjI2NTYsNTYuOTg0NCAxMzIuNTc4MSw1NS4zMjgxIFExMzMuOTA2Myw1My42NzE5IDEzNi40MDYzLDUzLjY3MTkgUTEzNy4xMDk0LDUzLjY3MTkgMTM3Ljc1LDUzLjgyODEgUTEzOC40MDYzLDUzLjk4NDQgMTM4Ljk2ODgsNTQuMjgxMyBMMTM4Ljk2ODgsNTcgUTEzOC4zNDM4LDU2LjQyMTkgMTM3Ljc1LDU2LjE1NjMgUTEzNy4xNTYzLDU1Ljg3NSAxMzYuNTMxMyw1NS44NzUgUTEzNS4xODc1LDU1Ljg3NSAxMzQuNSw1Ni45NTMxIFExMzMuODEyNSw1OC4wMTU2IDEzMy44MTI1LDYwLjEwOTQgUTEzMy44MTI1LDYyLjIwMzEgMTM0LjUsNjMuMjgxMyBRMTM1LjE4NzUsNjQuMzQzOCAxMzYuNTMxMyw2NC4zNDM4IFExMzcuMTU2Myw2NC4zNDM4IDEzNy43NSw2NC4wNzgxIFExMzguMzQzOCw2My43OTY5IDEzOC45Njg4LDYzLjIxODggTDEzOC45Njg4LDY1LjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NSIgeD0iMTUwIiB5PSI2NS4xNDM2Ij5TdHVkZW50PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyMiIgeDI9IjIwNyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTIyIiB4Mj0iMjA3IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWxpbmsgU2Nob29sIHRvIFN0dWRlbnQtLT48ZyBpZD0ibGlua19TY2hvb2xfU3R1ZGVudCI+PHBhdGggY29kZUxpbmU9IjciIGQ9Ik04Ni4xNCw2OC4yOTY5IEM5Ny42Nyw2OC4yOTY5IDEwOS4yLDY4LjI5NjkgMTIwLjczLDY4LjI5NjkgIiBmaWxsPSJub25lIiBpZD0iU2Nob29sLVN0dWRlbnQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgiIHg9IjkzLjkxMzQiIHk9IjY0LjAzOTciPjE8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOCIgeD0iMTA1LjExNjciIHk9IjY0LjE3OSI+bjwvdGV4dD48L2c+PCEtLVNSQz1bQXlhaW9LYkxTMm1rcGFfRUoycDlwQ19adWFoRUlJbWtMV1hFcGlaRnB1NW5JYWZKS2xEQWtCV1dlV2ZBWGFlQWtXZkFVS2ZtNkcwMF0tLT48L2c+PC9zdmc+"><h3 id="依赖关系-Dependency">依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:</p><ul><li>A 类是 B 类中的(某中方法的)局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMzlweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM0MXB4O2hlaWdodDoyMzlweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNDEgMjM5IiB3aWR0aD0iMzQxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9IjExNCIgeT0iMjIuOTk1MSI+RGVwZW5kZW5jeTwvdGV4dD48IS0tY2xhc3MgVmVoaWNsZS0tPjxnIGlkPSJlbGVtX1ZlaGljbGUiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjY0LjI5NjkiIGlkPSJWZWhpY2xlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxNTciIHg9Ijg0IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEzMy4yNSIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTM2LjIxODgsNjUuOTM3NSBRMTM1LjY0MDYsNjYuMjM0NCAxMzUsNjYuMzc1IFExMzQuMzU5NCw2Ni41MzEzIDEzMy42NTYzLDY2LjUzMTMgUTEzMS4xNTYzLDY2LjUzMTMgMTI5LjgyODEsNjQuODkwNiBRMTI4LjUxNTYsNjMuMjM0NCAxMjguNTE1Niw2MC4xMDk0IFExMjguNTE1Niw1Ni45ODQ0IDEyOS44MjgxLDU1LjMyODEgUTEzMS4xNTYzLDUzLjY3MTkgMTMzLjY1NjMsNTMuNjcxOSBRMTM0LjM1OTQsNTMuNjcxOSAxMzUsNTMuODI4MSBRMTM1LjY1NjMsNTMuOTg0NCAxMzYuMjE4OCw1NC4yODEzIEwxMzYuMjE4OCw1NyBRMTM1LjU5MzgsNTYuNDIxOSAxMzUsNTYuMTU2MyBRMTM0LjQwNjMsNTUuODc1IDEzMy43ODEzLDU1Ljg3NSBRMTMyLjQzNzUsNTUuODc1IDEzMS43NSw1Ni45NTMxIFExMzEuMDYyNSw1OC4wMTU2IDEzMS4wNjI1LDYwLjEwOTQgUTEzMS4wNjI1LDYyLjIwMzEgMTMxLjc1LDYzLjI4MTMgUTEzMi40Mzc1LDY0LjM0MzggMTMzLjc4MTMsNjQuMzQzOCBRMTM0LjQwNjMsNjQuMzQzOCAxMzUsNjQuMDc4MSBRMTM1LjU5MzgsNjMuNzk2OSAxMzYuMjE4OCw2My4yMTg4IEwxMzYuMjE4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTAiIHg9IjE1My43NSIgeT0iNjUuMTQzNiI+VmVoaWNsZTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4NSIgeDI9IjI0MCIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iODUiIHgyPSIyNDAiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0NSIgeD0iOTAiIHk9IjEwMS4yOTIiPm1vdmUoTW92ZUJlaGF2aW9yKTwvdGV4dD48L2c+PCEtLWNsYXNzIE1vdmVCZWhhdmlvci0tPjxnIGlkPSJlbGVtX01vdmVCZWhhdmlvciI+PHJlY3QgY29kZUxpbmU9IjgiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNjQuMjk2OSIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTMxIiB4PSI3IiB5PSIxNjguMjk2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE4NC4yOTY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTE3LjkyMTksMTgwLjA2MjUgTDE3LjkyMTksMTc3LjkwNjMgTDI1LjMxMjUsMTc3LjkwNjMgTDI1LjMxMjUsMTgwLjA2MjUgTDIyLjg0MzgsMTgwLjA2MjUgTDIyLjg0MzgsMTg4LjE0MDYgTDI1LjMxMjUsMTg4LjE0MDYgTDI1LjMxMjUsMTkwLjI5NjkgTDE3LjkyMTksMTkwLjI5NjkgTDE3LjkyMTksMTg4LjE0MDYgTDIwLjM5MDYsMTg4LjE0MDYgTDIwLjM5MDYsMTgwLjA2MjUgTDE3LjkyMTksMTgwLjA2MjUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC1zdHlsZT0iaXRhbGljIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk5IiB4PSIzNiIgeT0iMTg5LjE0MzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTM3IiB5MT0iMjAwLjI5NjkiIHkyPSIyMDAuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMzciIHkxPSIyMDguMjk2OSIgeTI9IjIwOC4yOTY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDgiIHg9IjEzIiB5PSIyMjUuMjkyIj5tb3ZlKCk8L3RleHQ+PC9nPjxnIGlkPSJlbGVtX04iPjxwYXRoIGQ9Ik0xNzMsMTg3Ljc5NjkgTDE3MywyMTIuOTI5NyBBMCwwIDAgMCAwIDE3MywyMTIuOTI5NyBMMzM0LDIxMi45Mjk3IEEwLDAgMCAwIDAgMzM0LDIxMi45Mjk3IEwzMzQsMTk3Ljc5NjkgTDMyNCwxODcuNzk2OSBMMjQ4LjYzLDE4Ny43OTY5IEwxODUuOTMsMTA4LjcxNjkgTDI0MC42MywxODcuNzk2OSBMMTczLDE4Ny43OTY5IEEwLDAgMCAwIDAgMTczLDE4Ny43OTY5ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTMyNCwxODcuNzk2OSBMMzI0LDE5Ny43OTY5IEwzMzQsMTk3Ljc5NjkgTDMyNCwxODcuNzk2OSAiIGZpbGw9IiNGRUZGREQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0MCIgeD0iMTc5IiB5PSIyMDQuODYzOCI+TW92ZUJlaGF2aW9yLm1vdmUoKTwvdGV4dD48L2c+PCEtLWxpbmsgVmVoaWNsZSB0byBNb3ZlQmVoYXZpb3ItLT48ZyBpZD0ibGlua19WZWhpY2xlX01vdmVCZWhhdmlvciI+PHBhdGggY29kZUxpbmU9IjE0IiBkPSJNMTM5LjMyLDEwOC43MTY5IEMxMjcuMTUsMTI1LjIyNjkgMTEyLjE1LDE0NS41NDY5IDk5LjQ2LDE2Mi43NTY5ICIgZmlsbD0ibm9uZSIgaWQ9IlZlaGljbGUtdG8tTW92ZUJlaGF2aW9yIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSI5Ni41LDE2Ni43NjY5LDEwNS4wNjk2LDE2MS45MTI5LDk5LjQ3NDgsMTYyLjc0ODEsOTguNjM5NSwxNTcuMTUzMiw5Ni41LDE2Ni43NjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNGFqSUNyQklTckJoa0pZSWl2OUIydk0yNGxEbzRtNm9iSHBBRzExUmR2UGdlT2xhNzFBcEtXaW95bWxxa0lndlVCQXAyajlCS2ZCSjR2TEc5UDJyVzlNYmZUVmFnZ1dYQW40M29BZmY5MU9oRTM3bkdNcElxX0YzaUthUDFjV0VXMDBdLS0+PC9nPjwvc3ZnPg=="><h2 id="面向对象设计的-SOLID-原则">面向对象设计的 SOLID 原则</h2><table><thead><tr><th>缩写</th><th>全名</th><th>中文</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr></tbody></table><h3 id="SRP-单一责任原则">SRP 单一责任原则</h3><p>当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是<mark style="background: #FF5582A6;">让一个类只做一种类型责任</mark>，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</p><h3 id="OCP-开放封闭原则">OCP 开放封闭原则</h3><p>软件实体应该是<mark style="background: #FF5582A6;">可扩展，而不可修改的</mark>。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。</p><h3 id="LSP-里氏替换原则">LSP 里氏替换原则</h3><p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有 is-A 关系</p><h3 id="DIP-依赖倒置原则">DIP 依赖倒置原则</h3><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ol><h3 id="ISP-接口分离原则">ISP 接口分离原则</h3><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用<mark style="background: #FF5582A6;">多个专门的接口比使用单一的总接口总要好</mark>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/java/java-ji-chu/java-ji-chu/"/>
      <url>/java/java-ji-chu/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1>Java 基础</h1><h2 id="Metadata-15">Metadata</h2><pre><code class="language-yml">title: Java 基础date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 基础</code></pre><h2 id="【Java-基础】-面向对象">【Java 基础】 面向对象</h2><p><a href="../java-ji-chu-mian-xiang-dui-xiang/">【Java 基础】 面向对象</a></p><h2 id="【Java-基础】数据类型">【Java 基础】数据类型</h2><p><a href="../java-ji-chu-shu-ju-lei-xing/">【Java 基础】数据类型</a></p><h2 id="【Java-基础】-泛型">【Java 基础】 泛型</h2><p><a href="../java-ji-chu-fan-xing/">【Java 基础】 泛型</a></p><h2 id="【Java-基础】-注解">【Java 基础】 注解</h2><p><a href="../java-ji-chu-zhu-jie/">【Java 基础】 注解</a></p><h2 id="【Java-基础】-反射">【Java 基础】 反射</h2><p><a href="../java-ji-chu-fan-she/">【Java 基础】 反射</a></p><h2 id="【Java-基础】-异常">【Java 基础】 异常</h2><p><a href="../java-ji-chu-yi-chang/">【Java 基础】 异常</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】数据类型</title>
      <link href="/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/"/>
      <url>/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】数据类型</h1><h2 id="Metadata-25">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】数据类型date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/数据类型categories:  - Javakeywords:  - Java/基础  - 数据类型description: 数据类型</code></pre><h2 id="String">String</h2><h4 id="概览">概览</h4><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h4 id="不可变的好处">不可变的好处</h4><ol><li>可以缓存 hash 值</li><li>String Pool 的需要</li><li>安全性</li><li>线程安全</li></ol><h4 id="String-StringBuffer-and-StringBuilder">String, StringBuffer and StringBuilder</h4><ol><li>可变性</li></ol><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><ol start="2"><li>线程安全</li></ol><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="Object">Object</h2><h3 id="概览-2">概览</h3><pre><code class="language-java">public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable {}</code></pre><h3 id="Equals">Equals()</h3><h4 id="等价关系">等价关系</h4><p><strong>自反性</strong><br><strong>对称性</strong><br><strong>传递性</strong><br><strong>一致性</strong><br><strong>与 null 的比较</strong></p><h4 id="equals-与">equals() 与 ==</h4><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><h4 id="实现">实现</h4><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><h3 id="hashCode">hashCode()</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><h3 id="toString">toString()</h3><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 <code>@</code> 后面的数值为散列码的无符号十六进制表示。</p><h3 id="clone">clone()</h3><h4 id="cloneable">cloneable</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><h4 id="浅拷贝">浅拷贝</h4><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><h4 id="深拷贝">深拷贝</h4><p>拷贝对象和原始对象的引用类型引用不同对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/java/java/"/>
      <url>/java/java/</url>
      
        <content type="html"><![CDATA[<h1>Java</h1><h2 id="Metadata-2">Metadata</h2><pre><code class="language-yml">title: Javadate: 2022-12-14 14:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</code></pre><h2 id="Java-基础">Java 基础</h2><p><a href="../java-ji-chu/java-ji-chu/">Java 基础</a></p><h2 id="Java-集合">Java 集合</h2><p><a href="../java-ji-he/java-ji-he/">Java 集合</a></p><h2 id="Java-多线程并发">Java 多线程并发</h2><p><a href="../java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/">Java 多线程并发</a></p><h2 id="Java-JVM">Java JVM</h2><p><a href="../java-jvm/java-jvm/">Java JVM</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解 -Assertions 断言</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-assertions-duan-yan/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-assertions-duan-yan/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解 -Assertions 断言</h1><h2 id="Metadata-5">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解 -Assertions 断言date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/断言categories:  - JMeterkeywords:  - JMeter  - 组件  - 断言description: 断言用于对采样器执行额外的检查，并在相同范围内的每个采样器之后进行处理。要确保Assertion只应用于特定的采样器，请将其添加为该采样器的子元素。</code></pre><h2 id="Assertions-断言">Assertions | 断言</h2><p>断言用于对采样器执行额外的检查，并在相同范围内的每个采样器之后进行处理。要确保Assertion只应用于特定的采样器，请将其添加为该采样器的子元素。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:除非另有说明，断言不应用于子样本(子样本)—只应用于父样本。对于JSR223和BeanShell断言，脚本可以使用prev.getSubResults()方法检索子示例，该方法返回一个samplerresults数组。如果没有，则数组为空。</p></div><p>断言可以应用于主样例、子样例，也可以同时应用于两者。默认情况是只对主示例应用断言。如果Assertion支持此选项，那么GUI上会出现如下条目:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C43dcd57acadeb98ecb2d1d0e5096a5e3.png" alt></p></div><p>如果子采样器失败而主样本成功，则主样本将被设置为失败状态，并将添加断言结果。如果使用了JMeter变量选项，则假定它与主示例有关，任何失败都将只应用于主示例。</p><h3 id="Response-Assertion-响应断言">Response Assertion | 响应断言</h3><p>响应断言控制面板允许您添加模式字符串，以便与请求或响应的各种字段进行比较。模式字符串是:</p><ul><li><code>Contains, Matches</code>: Perl5-style正则表达式</li><li><code>Equals, Substring</code>: 纯文本,区分大小写</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cd48cec173c79631705b5dc72f79918af.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Apply to:</td><td>这是用于可以生成子样本的采样器，例如带有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。</td><td>Yes</td></tr><tr><td>Field to Test</td><td>指示JMeter测试请求或响应的哪个字段。</td><td>Yes</td></tr><tr><td>Ignore status</td><td>指示JMeter将初始状态设置为成功。</td><td>Yes</td></tr><tr><td>Pattern Matching Rules</td><td>指示如何根据模式检查被测试的文本。</td><td>Yes</td></tr><tr><td>Patterns to Test</td><td>要测试的模式列表。每个模式都是单独测试的。如果一个模式失败，则不会检查其他模式。使用多个模式设置一个断言与使用每个模式设置多个断言之间没有区别(假设其他选项相同)。</td><td>Yes</td></tr><tr><td>Custom failure message</td><td>允许您定义将替换生成的失败消息的失败消息</td><td>No</td></tr></tbody></table></div><h3 id="Duration-Assertion-断言持续时间">Duration Assertion | 断言持续时间</h3><p>持续时间断言测试是否在给定的时间内收到每个响应。任何超过给定毫秒数(由用户指定)的响应都被标记为失败的响应。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6848b3fb438834313ee585358d5ea3d7.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Duration in Milliseconds</td><td>在被标记为失败之前，允许每个响应的最大毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Size-Assertion-大小断言">Size Assertion | 大小断言</h3><p>大小断言测试每个响应中包含正确的字节数。可以指定大小等于、大于、小于或不等于给定字节数。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C16813019eccbc6c7461bd5122168683f.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Size in bytes</td><td>用于测试响应大小(或JMeter变量的值)的字节数。</td><td>Yes</td></tr><tr><td>Type of Comparison</td><td>是否测试响应是否等于、大于、小于或不等于指定的字节数。</td><td>Yes</td></tr></tbody></table></div><h3 id="XML-Assertion-XML-断言">XML Assertion | XML 断言</h3><p>XML断言测试响应数据由形式上正确的XML文档组成。它不基于DTD或模式验证XML，也不做任何进一步的验证。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C813fb287b364bfa545c3d3a8ec1c060a.png" alt></p></div><h3 id="BeanShell-Assertion-BeanShell-断言">BeanShell Assertion | BeanShell 断言</h3><p>BeanShell断言允许用户使用BeanShell脚本执行断言检查。</p><p>请注意，在测试脚本的每个线程中，断言的每个独立出现都使用不同的解释器，但后续调用使用相同的解释器。这意味着变量将在对断言的调用之间持久化。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C39526932dc308f283bd5884807864725.png" alt></p></div><h3 id="MD5Hex-Assertion-MD5Hex-断言">MD5Hex Assertion | MD5Hex 断言</h3><p>MD5Hex断言允许用户检查响应数据的MD5哈希值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca12d5ee2fc45124ba60f1b43f18685fc.png" alt></p></div><h3 id="HTML-Assertion-HTML-断言">HTML Assertion | HTML 断言</h3><p>HTML断言允许用户使用JTidy检查响应数据的HTML语法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C2526877b0515200861c2c2950455cca9.png" alt></p></div><h3 id="XPath-Assertion-XPath-断言">XPath Assertion | XPath 断言</h3><p>XPath断言测试文档的格式是否良好，可以根据DTD进行验证，也可以通过JTidy对文档进行XPath测试。如果XPath存在，断言为真。使用“<code>/</code>”将匹配任何格式良好的文档，并且是默认的XPath表达式。该断言还支持布尔表达式，如“<code>count(//*error)=2</code>”。有关XPath的更多信息，请参见http://www.w3.org/TR/xpath。</p><h3 id="Compare-Assertion-比较断言">Compare Assertion | 比较断言</h3><p>比较断言可用于在其范围内比较样本结果。可以比较内容或运行时间，并且可以在比较之前过滤内容。可以在比较断言可视化工具中看到断言比较。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C837dc552d4a8b425c36abd68d45351ac.png" alt></p></div><h3 id="JSON-Assertion-JSON-断言">JSON Assertion | JSON 断言</h3><p>该组件允许您执行JSON文档的验证。首先，它将解析JSON，如果数据不是JSON，则会失败。其次，它将搜索指定的路径，使用来自Jayway JsonPath 1.2.0的语法。如果没有找到路径，它将失败。第三，如果在文档中找到了JSON路径，并且请求对预期值进行验证，它将执行验证。对于空值，GUI中有一个特殊的复选框。注意，如果路径将返回数组对象，则将对其进行迭代，如果找到预期值，则断言将成功。要验证空数组，请使用<code>[]</code>string。此外，如果patch将返回字典对象，它将在比较之前被转换为字符串。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ccbc9c846557f6aa5e44884c749538fd3.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/断言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Logic Controllers 逻辑控制器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Logic Controllers 逻辑控制器</h1><h2 id="Metadata-6">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Logic Controllers 逻辑控制器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/控制器categories:  - JMeterkeywords:  - JMeter  - 组件  - 控制器description: 逻辑控制器决定了采样器被处理的顺序。</code></pre><h2 id="Logic-Controllers-逻辑控制器">Logic Controllers | 逻辑控制器</h2><p>逻辑控制器决定了采样器被处理的顺序。</p><h3 id="Simple-Controller-简单逻辑控制器">Simple Controller | 简单逻辑控制器</h3><p>简单逻辑控制器让你组织你的采样器和其他逻辑控制器。与其他逻辑控制器不同，此控制器除了存储设备之外不提供任何功能。</p><p>简单控制器可以将在其之下的所有组件，作为一个整体。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5b75893a30784a65622306cdd5eee7e5.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Loop-Controller-循环控制器">Loop Controller | 循环控制器</h3><p>如果你将生成或逻辑控制器添加到一个循环控制器，JMeter将通过它们循环一定的次数，除了你为线程组指定的循环值。例如，如果您添加一个循环次数为2的HTTP请求到一个循环控制器，并配置Thread Group循环次数为3,JMeter将总共发送2 * 3 = 6个HTTP请求。</p><p>JMeter将把循环索引作为一个名为<code>__jm__&lt;元素名&gt;__idx</code>的变量公开。例如，如果你的循环控制器名为LC，那么你可以通过<code>${__jm__LC__idx}</code>访问循环索引。索引从0开始</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cf2f9ef537a2838592a6a22213705163f.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Loop Count</td><td>这个控制器的子元素在每次测试运行中迭代的次数。&lt;/br&gt; 值-1相当于检查永远切换。</td><td>Yes, unless "Forever" is checked</td></tr></tbody></table></div><h3 id="Once-Only-Controller-仅一次控制器">Once Only Controller | 仅一次控制器</h3><p>Once Only逻辑控制器告诉JMeter每个线程只处理它内部的控制器一次，并在测试计划的进一步迭代期间传递它下面的任何请求。</p><p>Once Only控制器现在将始终在任何循环父控制器的第一次迭代期间执行。因此，如果Once Only控制器被放置在一个指定循环5次的环路控制器下，那么Once Only控制器将只在通过环路控制器的第一次迭代时执行(即每5次)。</p><p>注意，这意味着Once Only控制器的行为仍将与之前预期的一样</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca518627998462bc10d3a24c5274f70d5.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Interleave-Controller-交替控制器">Interleave Controller | 交替控制器</h3><p>如果你将生成或逻辑控制器添加到交错控制器中，JMeter将在每个循环迭代中交替使用其他控制器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">交替控制器</p><p><img src="/attachment%5C5c85cc68f4017a652e96d46c4efc05ef.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>ignore sub-controller blocks</td><td>如果选中此项，交错控制器将把子控制器当作单个请求元素来处理，并且每次只允许每个控制器一个请求。</td><td>No</td></tr><tr><td>交错跨线程</td><td>如果勾选，交错控制器将在每个循环迭代中交替使用其子控制器，但在所有线程中，例如，在4个线程和3个子控制器的配置中，在第一次迭代中，线程1将运行第一个子控制器，线程2第二子控制器，线程3第三子控制器，线程4第一个子控制器，在下一次迭代中，每个线程将运行下面的子控制器</td><td>No</td></tr></tbody></table></div><blockquote><p>注： 外部交错控制器在两个内部交错控制器之间交替。然后，每个内部交错控制器在每个HTTP请求之间交替。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p><img src="https://jmeter.apache.org/images/screenshots/logic-controller/interleave2.png" alt></p><p>如果交错控制器下 是两个交错控制器</p><p>Home Page, Interleaved, Bug Page, Interleaved, CVS Page, Interleaved, and FAQ Page, Interleaved.</p><p>如果交错主控制器下的两个交错控制器是简单控制器，那么顺序就是: Home Page, CVS Page, Interleaved, Bug Page, FAQ Page, Interleaved.</p></div><h3 id="Random-Controller-随机控制器">Random Controller | 随机控制器</h3><p>随机逻辑控制器的行为类似于交错控制器，不同的是，它不是按顺序通过其子控制器和采样器，而是在每次经过时随机选择一个。</p><blockquote><p>多个控制器之间的交互可以产生复杂的行为。随机控制器尤其如此。在你假设任何给定的相互作用会带来什么结果之前，先进行实验</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C267d5a22a02335f1421605825fb15764.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>ignore sub-controller blocks</td><td>如果选中此项，交错控制器将把子控制器当作单个请求元素来处理，并且每次只允许每个控制器一个请求。</td><td>No</td></tr></tbody></table></div><h3 id="Random-Order-Controller-随机顺序控制器">Random Order Controller | 随机顺序控制器</h3><p>Random Order Controller很像Simple Controller，因为它最多只执行每个子元素一次，但节点的执行顺序是随机的。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6330929ffafcc3c4a18de57586014b18.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Throughput-Controller-吞吐量控制器">Throughput Controller | 吞吐量控制器</h3><p>吞吐量控制器允许用户控制它的执行频率。有两种模式:</p><ul><li>百分比执行<ul><li>使控制器通过测试计划执行一定百分比的迭代。</li></ul></li><li>总数执行<ul><li>使控制器在执行了一定的次数后停止执行。</li></ul></li></ul><p>与Once Only控制器一样，当父回路控制器重启时，此设置将被重置。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C9f431050da107da7416d467b37b34adb.png" alt></p></div><blockquote><p>当与其他控制器组合时，吞吐量控制器可以产生非常复杂的行为——特别是与交错或随机控制器作为父控制器(也非常有用)。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Execution Style</td><td>控制器将以百分比执行模式还是总执行模式运行。</td><td>Yes</td></tr><tr><td>Throughput</td><td>一个数字。对于百分比执行模式，一个0-100的数字，表示控制器执行时间的百分比。"50"表示控制器将在测试计划的一半迭代中执行。对于总执行模式，number表示控制器将执行的总次数。</td><td>Yes</td></tr><tr><td>Per User</td><td>如果选中此选项，则per user将导致控制器计算是否应该以每个用户(每个线程)为基础执行。如果未选中，则计算将对所有用户是全局的。例如，如果使用总执行模式，而不选中"per user"，则给出的吞吐量数将是执行的总次数。如果检查了"每个用户"，那么执行的总数量将是用户数量乘以给定的吞吐量。</td><td>No</td></tr></tbody></table></div><h3 id="Runtime-Controller-运行时间控制器">Runtime Controller | 运行时间控制器</h3><p>运行时控制器控制其子程序的运行时间。控制器将运行其子控制器，直到超过配置的运行时为止。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3762bea8a2a37cdebb442a2309981c85.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>Yes</td></tr><tr><td>Runtime (seconds)</td><td>所需的运行时间(以秒为单位)。0表示不运行。</td><td>Yes</td></tr></tbody></table></div><h3 id="If-Controller-If-控制器">If Controller | If 控制器</h3><p>If控制器允许用户控制是否运行它(其子元素)下面的test元素。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C64b180d15fefb537f4d7776e828003f8.png" alt></p></div><p>默认情况下，条件只在初始条目上计算一次，但是您可以选择对控制器中包含的每个可运行元素进行计算。</p><p>最好的选项(默认选项)是检查 <code>Interpret Condition as Variable Expression?</code>，然后在条件字段中有两个选项:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">选项1:使用包含true或false的变量</p><p>如果你想测试最后一个样本是否成功，你可以使用 <code>${JMeterThread.last_sample_ok}</code></p><p><img src="https://jmeter.apache.org/images/screenshots/if_controller_variable.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">选项2:使用函数(建议使用`${__jexl3()}`)来计算必须返回true或false的表达式</p><p><img src="https://jmeter.apache.org/images/screenshots/if_controller_expression.png" alt></p></div><p>例如，以前可以使用条件:<code>${__jexl3(${VAR} == 23)}</code>，这将被评估为true/false，然后将结果传递给JavaScript，然后返回true/false。如果选择了变量表达式，那么表达式将被计算并与"true"进行比较，而不需要使用JavaScript。</p><p>如果取消选择<code>Interpret Condition as Variable Expression?</code>， If Controller将在内部使用javascript来评估条件，这可能会造成非常大的性能损失，并使您的测试不太可伸缩。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Condition (default JavaScript)</td><td>默认情况下，该条件被解释为返回"true"或"false"的JavaScript代码，但这可以被重写(见下文)</td><td>Yes</td></tr><tr><td>Interpret Condition as Variable Expression?</td><td>如果选中此选项，那么条件必须是一个计算结果为"<code>true</code>"的表达式(忽略大小写)。例如，<code>${FOUND}</code>或<code>${__jexl3(${VAR} &amp;gt;100)}</code>。与JavaScript的大小写不同，只检查条件是否匹配"true"(大小写被忽略)。</td><td>Yes</td></tr><tr><td>Evaluate for all children</td><td>是否应该对所有 Children 进行状况评估?如果没有选中，则只在进入时对条件进行计算。</td><td>Yes</td></tr></tbody></table></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><ul><li><code>${__groovy(vars.get("myVar") != "Invalid" )}</code> (Groovy check myVar is not equal to Invalid)</li><li><code>${__groovy(vars.get("myInt").toInteger() &lt;=4 )}</code> (Groovy check myInt is less then or equal to 4)</li><li><code>${__groovy(vars.get("myMissing") != null )}</code> (Groovy check if the myMissing variable is not set)</li><li><code>${__jexl3(${COUNT} &lt; 10)}</code></li><li><code>${RESULT}</code></li><li><code>${JMeterThread.last_sample_ok}</code> (check if the last sample succeeded)</li></ul></div><h3 id="While-Controller-While-控制器">While Controller | While 控制器</h3><p>While控制器运行它的子控制器，直到条件为"false"。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb6ab801f14714f9176c2af3babdfb1d2.png" alt></p></div><p>JMeter将把循环索引作为一个名为<code>__jm__&lt;元素名&gt;__idx</code>的变量公开。例如，如果你的While控制器名为WC，那么你可以通过<code>${__jm__WC__idx}</code>访问循环索引。索引从0开始</p><p>可能的条件值:</p><ul><li>blank - 当循环中的最后一个样本失败时退出循环</li><li>LAST - 当循环中的最后一个样本失败时退出循环。如果循环之前的最后一个样本失败了，就不要进入循环。</li><li>Otherwise - 当条件等于字符串"false"时退出(或不进入)循环</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p>举例</p><ul><li><code>${VAR}</code> - VAR被其他测试元素设置为false</li><li><code>$ {__jexl3 ($ {C} = = 10)}</code></li><li><code>$ {__jexl3 (" $ {VAR2} " = = " abcd ")}</code></li><li><code>${_P(property)}</code> - property在其他地方设置为"false"</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>No</td></tr><tr><td>Condition</td><td>blank, LAST, or variable/function</td><td>No</td></tr></tbody></table></div><h3 id="Switch-Controller-选择控制器">Switch Controller | 选择控制器</h3><p>Switch Controller的行为类似于Interleave Controller，它在每次迭代中运行一个从属元素，但不是按顺序运行它们，而是运行由Switch值定义的元素。</p><blockquote><p>switch的值也可以是名称。</p></blockquote><p>如果开关值超出范围，它将运行第0个元素，因此充当数值情况的默认值。如果值是空字符串，它还运行第0个元素。<br>如果该值是非数字(且非空)，则Switch Controller查找同名元素(大小写重要)。如果名称都不匹配，则选择名为"<code>default</code>"的元素(大小写不重要)。如果没有默认值，则没有选择任何元素，控制器将不运行任何东西。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb8db55fa62d65dcfd7db3650b5ff12bd.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Switch Value</td><td>要调用的从属元素的编号(或名称)。元素从0开始编号。默认值为0</td><td>No</td></tr></tbody></table></div><h3 id="ForEach-Controller-ForEach控制器">ForEach Controller | ForEach控制器</h3><p>ForEach控制器循环遍历一组相关变量的值。当您向ForEach控制器添加采样器(或控制器)时，每个采样器(或控制器)将执行一次或多次，在每次循环期间，变量都有一个新值。输入应该由几个变量组成，每个变量都有一个下划线和一个数字。每个这样的变量都必须有一个值。例如，当输入变量名为<code>inputVar</code>时，应该定义以下变量:</p><ul><li>inputVar_1 = wendy</li><li>inputVar_2 = charles</li><li>inputVar_3 = peter</li><li>inputVar_4 = john</li></ul><p>当返回变量给定为"<code>returnVar</code>"时，ForEach控制器下的采样器和控制器的集合将连续执行4次，返回变量分别具有上述值，然后可以在采样器中使用。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cadd5994075ef8e32743f10bb4a63e643.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Input variable prefix</td><td>用作输入的变量名的前缀。默认为一个空字符串作为前缀。</td><td>No</td></tr><tr><td>Start index for loop</td><td>循环遍历变量的起始索引(独占)(第一个元素在起始索引+ 1处)</td><td>No</td></tr><tr><td>End index for loop</td><td>结束变量循环索引(包括)</td><td>No</td></tr><tr><td>Output variable</td><td>变量的名称，该变量可以在循环中用于在采样器中替换。默认为空变量名，这很可能是不需要的。</td><td>No</td></tr><tr><td>Use Separator</td><td>如果不勾选，则省略"<code>_</code>"分隔符。</td><td>Yes</td></tr></tbody></table></div><h3 id="Module-Controller-模块控制器">Module Controller | 模块控制器</h3><p>模块控制器提供了一种在运行时将测试计划片段替换为当前测试计划的机制。</p><p>一个测试计划片段由一个控制器和它包含的所有测试元素(采样器等)组成。片段可以位于任何线程组中。如果片段位于一个线程组中，那么它的控制器可以被禁用，以防止除了模块控制器之外的片段运行。或者您可以将片段存储在一个虚拟线程组中，并禁用整个线程组。</p><p>可以有多个碎片，每个碎片下都有不同系列的采样器。通过在下拉框中选择适当的控制器，模块控制器就可以轻松地在这些多个测试用例之间切换。这为快速轻松地运行许多备用测试计划提供了便利。</p><p><strong>模块控制器使用的任何片段都必须有一个唯一的名称</strong>，因为该名称用于在重新加载测试计划时找到目标控制器。由于这个原因，最好确保Controller名称从默认更改为Controller名称，否则在向测试计划添加新元素时可能会意外创建副本。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5923e6dbb68b425da6d5685f2918c08a.png" alt></p></div><h3 id="Transaction-Controller-事务控制器">Transaction Controller | 事务控制器</h3><p>事务控制器生成一个额外的示例，用于度量执行嵌套测试元素所花费的总时间。</p><blockquote><p>注意:当勾选"包含生成样本中定时器和前后处理器的持续时间"复选框时，该时间包括控制器范围内的所有处理，而不仅仅是样本。</p></blockquote><p>有两种操作模式:</p><ul><li>在嵌套样例之后添加附加样例</li><li>附加样例作为嵌套样例的父类添加</li></ul><p>生成的采样时间包括所有嵌套采样的时间，不包括默认的(自2.11起)计时器和前后处理器的处理时间，除非选中了 <code>Include duration of timer and pre-post processors in generated sample</code> (包括生成样本中的计时器和前后处理器的持续时间)复选框。根据时钟分辨率的不同，它可能比单个采样器加计时器的总和稍长。时钟可能在控制器记录开始时间后滴答作响，但在第一个样本开始之前。最后也是一样。</p><p>只有在所有子样本都成功的情况下，生成的样本才被认为是成功的。</p><blockquote><p>在父模式中，断言(等等)可以添加到事务控制器。但是默认情况下，它们将同时应用于单个示例和整个事务示例。为了限制断言的范围，可以使用一个简单控制器来包含示例，并将断言添加到简单控制器。父模式控制器目前不支持任何类型的嵌套事务控制器。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cad75c9a98968eb36d939f9c9a7996ebb.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>Yes</td></tr><tr><td>Generate Parent Sample</td><td>生成父样本</td><td>Yes</td></tr><tr><td>Include duration of timer and pre-post processors in generated sample</td><td>是否在生成的样本中包括定时器、预处理和后处理延迟。默认的是假的</td><td>Yes</td></tr></tbody></table><h3 id="Recording-Controller-记录控制器">Recording Controller | 记录控制器</h3><p>记录控制器是一个占位符，指示代理服务器应该将样本记录到何处。在测试运行期间，它没有效果，类似于简单控制器。但是在使用HTTP(S)测试脚本记录器进行记录的过程中，所有记录的样本将默认保存在记录控制器下。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C949ce70f7f1c76f11507f448576da701.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Critical-Section-Controller-临界区控制器">Critical Section Controller | 临界区控制器</h3><p>临界区控制器确保它的子元素(采样/控制器等)将只被一个线程执行，因为在执行控制器的子元素之前会获取一个命名锁。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C4a78d82bcdd498f4c60ceae7fd93685c.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Listeners 监听器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Listeners 监听器</h1><h2 id="Metadata-7">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Listeners 监听器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/监听器categories:  - JMeterkeywords:  - JMeter  - 组件  - 监听器description: 监听结果，还提供了查看、保存和读取保存的测试结果的方法。</code></pre><h2 id="Listeners-监听器">Listeners | 监听器</h2><p>除了"听"测试结果之外，大多数监听器还扮演着几个角色。它们还提供了查看、保存和读取保存的测试结果的方法。</p><p>注意，侦听器在找到它们的范围的末尾处理。</p><p>测试结果的保存和读取是通用的。各种侦听器都有一个面板，可以通过该面板指定将结果写入(或读取)的文件。默认情况下，结果存储为XML文件，通常带有 <code>.jtl</code> 扩展。将其存储为CSV是最有效的选项，但没有XML(另一种可用选项)详细。</p><p>**侦听器不会在CLI模式下处理示例数据，但是如果配置了输出文件，则会保存原始数据。**为了分析CLI运行生成的数据，您需要将文件加载到适当的Listener中。</p><blockquote><p>要读取现有结果并显示它们，请使用文件面板Browse按钮打开文件。</p></blockquote><p>如果您想在加载一个新文件之前清除任何当前数据，请在加载文件之前使用菜单项<code>Run→clear (Ctrl + Shift + E)</code>或<code>Run→clear All (Ctrl + E)</code>。</p><p>结果可以从XML或CSV格式文件中读取。当读取CSV结果文件时，使用头(如果存在)来确定存在哪些字段。为了正确地解释<code>无头CSV</code>文件，必须在<code>jmeter.properties</code>中设置适当的属性。</p><p><strong>如果样本很多，监听器会占用大量内存</strong>。为尽量减少所需的内存，请使用<code>Simple Data Writer</code>，并使用<code>CSV</code>格式。</p><h3 id="Simple-Data-Writer-简单数据写入器">Simple Data Writer | 简单数据写入器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3d0ba23ab6cc18a90fd6043e33bda676.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Filename</td><td>包含示例结果的文件的名称。可以使用相对路径名或绝对路径名指定文件名。相对路径是相对于当前工作目录解析的(默认为bin/目录)。JMeter还支持相对于包含当前测试计划(JMX文件)的目录的路径。如果路径名以"~/"(或jmeter.save.saveservice。base_prefix JMeter属性)，则假定路径相对于JMX文件位置。</td><td>No</td></tr><tr><td>Browse</td><td>文件浏览按钮</td><td>No</td></tr><tr><td>Errors</td><td>选择此选项将导致只写/读的结果带有错误</td><td>No</td></tr><tr><td>Success</td><td>选择这个选项，只写/读结果，不出错。如果既没有选择Errors也没有选择successful，那么将处理所有结果。</td><td>No</td></tr><tr><td>Configure</td><td>配置按钮，参见下面</td><td>No</td></tr></tbody></table><h3 id="Graph-Results-图结果">Graph Results  | 图结果</h3><blockquote><p>图结果绝对不能在负载测试期间使用，因为它会消耗大量资源(内存和CPU)。只在功能测试或测试计划调试和验证期间使用它。</p></blockquote><p>Graph Results侦听器生成一个简单的图来绘制所有样本时间。在图的底部，以毫秒为单位显示当前样本(黑色)、所有样本的当前平均值(蓝色)、当前标准差(红色)和当前吞吐量率(绿色)。</p><p>吞吐量数字表示服务器每分钟处理的实际请求数。这个计算包括您添加到测试中的任何延迟和JMeter自己的内部处理时间。这样计算的好处是，这个数字代表真实的东西—您的服务器所在的东西</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C70bba1717e63c269deee6df4487e92de.png" alt></p></div><p>下表简要描述了图表中的项目。关于统计术语的精确含义的进一步细节可以在网上找到，如维基百科，或通过查阅统计书籍。</p><p>Data - 绘制实际数据值<br>Average - 绘制平均值<br>Median - 绘制中位数(中间值)<br>Deviation - 绘制标准差(一种变化的度量)<br>Throughput - 绘制出单位时间内的样本数量</p><h3 id="Assertion-Results-断言结果">Assertion Results | 断言结果</h3><blockquote><p>在负载测试期间绝对不能使用断言结果，因为它会消耗大量资源(内存和CPU)。只在功能测试或测试计划调试和验证期间使用它。</p></blockquote><p>Assertion Results可视化工具显示每个样本的Label。它还报告测试计划中任何断言的失败。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C65fc9b6fb51159cbd447672860b3b5f3.png" alt></p></div><h3 id="View-Results-Tree-查看结果树">View Results Tree | 查看结果树</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C331167fcf04e16b77e624fa176f61cb5.png" alt></p></div><p>视图结果树显示所有示例响应的树，允许您查看任何示例的响应。除了显示响应之外，您还可以看到获取此响应所需的时间和一些响应代码。请注意，请求面板只显示JMeter添加的标题。它不显示HTTP协议实现可能添加的任何报头(如Host)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Renderer</th><th>Description</th></tr></thead><tbody><tr><td>CSS/JQuery Tester</td><td>CSS/JQuery测试器只适用于文本响应。它在上面的面板中显示纯文本。"测试"按钮允许用户将CSS/JQuery应用到上面的面板，结果将显示在下面的面板。CSS/JQuery表达式引擎可以是JSoup或Jodd，这两种实现的语法略有不同。&lt;/br&gt; 例如，将href属性应用到当前JMeter函数页面的Selector a[class=sectionlink]会给出如下输出: &lt;/br&gt; Match count: 74 &lt;/br&gt; Match[1]=<code>#functions</code> &lt;/br&gt; Match[2]=<code>#what_can_do</code> &lt;/br&gt; Match[3]=<code>#where</code> &lt;/br&gt; Match[4]=<code>#how</code> &lt;/br&gt; Match[5]=<code>#function_helper</code> &lt;/br&gt; Match[6]=<code>#functions</code> &lt;/br&gt; Match[7]=<code>#__regexFunction</code> Match[8]=<code>#__regexFunction_parms</code> &lt;/br&gt; Match[9]=<code>#__counter</code> &lt;/br&gt; … and so on …</td></tr><tr><td>Document</td><td>文档视图将显示从各种类型的文档中提取的文本，如Microsoft Office(Word, Excel, PowerPoint 97-2003, 2007-2010 (openxml)， Apache OpenOffice (writer, calc, impress)， HTML, gzip, jar/zip文件(内容列表)，以及一些"多媒体"文件的元数据，如mp3, mp4, flv等。完整的支持格式列表可以在Apache Tika格式页面上找到。&lt;/br&gt; &gt; Document视图的一个要求是下载Apache Tika二进制包(Tika -app-x.x.jar)，并将其放在JMETER_HOME/lib目录中。&lt;/br&gt;如果文档大于10mb，则不显示。要更改此限制，请设置JMeter属性文档。Max_size(单位为字节)或设置为0以删除限制。</td></tr><tr><td>HTML</td><td>HTML视图试图将响应呈现为HTML。渲染的HTML很可能比较差，一个人会在任何web浏览器获得的视图;然而，它确实提供了一个快速的近似值，有助于初步结果的评估。不下载图像、样式表等。</td></tr><tr><td>HTML (download resources)</td><td>如果选择了 HTML（下载资源）视图选项，则渲染器可以下载 HTML 代码引用的图像、样式表等。</td></tr><tr><td>HTML Source formatted</td><td>如果选择了 HTML Source formatted view 选项，渲染器将显示由 Jsoup 格式化和清理的 HTML 源代码。</td></tr><tr><td>JSON</td><td>JSON 视图将以树形样式显示响应（也处理嵌入在 JavaScript 中的 JSON）。</td></tr><tr><td>JSON Path Tester</td><td>JSON Path Tester 视图将让您测试您的 JSON-PATH 表达式并查看从特定响应中提取的数据。</td></tr><tr><td>JSON JMESPath Tester</td><td>JSON JMESPath Tester 视图将让您测试 JMESPath 表达式并查看从特定响应中提取的数据。</td></tr><tr><td>Regexp Tester</td><td>Regexp Tester 视图仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将正则表达式应用到上面板，结果将显示在下面板中。 正则表达式引擎与正则表达式提取器中使用的引擎相同。 例如，应用于当前 JMeter 主页的 <code>RE (JMeter\w*).*</code> 会给出以下输出： &lt;/br&gt; <code>Match count: 26</code> &lt;/br&gt; <code>Match[1][0]=JMeter - Apache JMeter &lt;/title&gt;</code> &lt;/br&gt; <code>Match[1][1]=JMeter</code> &lt;/br&gt; <code>Match[2][0]=JMeter" title="JMeter" border="0"&gt;&lt;/a&gt;</code> &lt;/br&gt; <code>Match[2][1]=JMeter</code> &lt;/br&gt; <code>Match[3][0]=JMeterCommitters"&gt;Contributors&lt;/a&gt;</code> &lt;/br&gt; <code>Match[3][1]=JMeterCommitters</code> &lt;/br&gt;… and so on … &lt;/br&gt; []中的第一个数字是匹配号； 第二个数字是组。 组 [0] 是与整个 RE 匹配的任何内容。 组 [1] 是与第一组匹配的任何内容，即在这种情况下为 <code>(JMeter\w*)</code>。</td></tr><tr><td>Text</td><td>默认文本视图显示响应中包含的所有文本。 请注意，这仅在响应内容类型被视为文本时才有效。 如果 content-type 以下列任何一种开头，则认为是二进制，否则认为是文本。 &lt;/br&gt; image/ &lt;/br&gt; audio/ &lt;/br&gt; video/</td></tr><tr><td>XML</td><td>XML 视图将以树形样式显示响应。 任何 DTD 节点或 Prolog 节点都不会出现在树中； 但是，响应可能包含这些节点。 您可以右键单击任何节点并展开或折叠其下方的所有节点。</td></tr><tr><td>XPath Tester</td><td>XPath 测试器仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将 XPath 查询应用到上面板，结果将显示在下面板中。</td></tr><tr><td>Boundary Extractor Tester</td><td>边界提取器测试器仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将边界提取器查询应用到上面板，结果将显示在下面板中。</td></tr></tbody></table></div><p>使用Search选项，大多数视图还允许搜索显示的数据;搜索结果将在上面的显示中高亮显示。例如下面的控制面板截图显示了搜索"Java"的结果。注意，搜索对可见文本进行操作，因此在搜索text和HTML视图时，您可能会得到不同的结果。</p><p>注意:正则表达式使用Java引擎(而不是像正则表达式提取器或Regexp Tester视图那样的ORO引擎)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_xml.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_regex.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_document.png" alt></p></div><h3 id="Aggregate-Report-汇总报告">Aggregate Report | 汇总报告</h3><p>聚合报告为测试中的每个不同名称的请求创建一个表行。对于每个请求，它汇总响应信息，并提供请求计数、最小、最大、平均、错误率、大致吞吐量(请求/秒)和每秒千字节吞吐量。一旦测试完成，吞吐量就是整个测试期间的实际吞吐量。</p><p>吞吐量是从采样器目标的角度计算的(例如，在HTTP采样的情况下，远程服务器)。JMeter会考虑生成请求的总时间。如果其他采样器和计时器在同一个线程中，这将增加总时间，从而降低吞吐量值。所以两个名称不同的相同采样器的吞吐量是两个名称相同的采样器的一半。正确选择采样器名称以从聚合报告中获得最佳结果是很重要的。</p><p>计算中位数和90 % Line(第90百分位)值需要额外的内存。JMeter现在结合了具有相同运行时间的示例，因此使用的内存更少。然而，对于花费超过几秒的样本，概率是更少的样本将有相同的时间，在这种情况下，将需要更多的内存。注意，您可以在之后使用这个侦听器重新加载CSV或XML结果文件，这是避免性能影响的推荐方法。参见摘要报告了解类似的监听器，该监听器不存储单个示例，因此需要固定的内存。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca64d56f2914c2724d59c566b94769543.png" alt></p></div><ul><li><code>Label</code> - 样品的标签。如果选择<code>Include group name in label?</code>，则将线程组的名称作为前缀添加。这允许在需要时分别对来自不同线程组的相同标签进行排序。</li><li><code># Samples</code> - 相同标签的样品数量</li><li><code>Average</code> - 一组结果的平均时间</li><li><code>Median</code> - 中位数是一组结果中间的时间。50 %的样本不超过这次;剩下的至少花了同样长的时间。</li><li><code>90% Line</code> - 90 %的样本不超过这次。剩下的样本至少花了这么长时间。(90)</li><li><code>95% Line</code> - 95 %的样本不超过这次。剩下的样本至少花了这么长时间。(95)</li><li><code>99% Line</code> - 99% %的样本不超过这次。剩下的样本至少花了这么长时间。(99)</li><li><code>Min</code> - 相同标签的样品时间最短</li><li><code>Max</code> - 相同标签的样品时间最长</li><li><code>Error %</code> - 请求错误的百分比</li><li><code>Throughput</code> - 吞吐量以每秒/分钟/小时的请求数来衡量。选择时间单位使显示的速率至少为1.0。当吞吐量被保存到一个CSV文件时，它被表示为请求/秒，即30.0请求/分钟被保存为0.5。</li><li><code>Received KB/sec</code> - 以每秒接收千字节为单位的吞吐量</li><li><code>Sent KB/sec</code> - 以每秒发送千字节为单位的吞吐量</li></ul><p>Times are in milliseconds.</p><h3 id="View-Results-in-Table-用表格查看结果">View Results in Table | 用表格查看结果</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cdc2cf9f66bfeb7ce18f87d258912228a.png" alt></p></div><p>这个可视化工具为每个示例结果创建一行。与View Results Tree一样，这个可视化工具也使用大量内存。</p><p>默认情况下，它只显示主(父)样例;它不显示子样本(子样本)。JMeter有一个"Child Samples?"复选框。如果选中此选项，则显示子样本而不是主样本。</p><h3 id="Simple-Data-Writer-简单数据写入器-2">Simple Data Writer | 简单数据写入器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfd590e5f3b82b4b58e0765ca686ad7bd.png" alt></p></div><p>这个侦听器可以将结果记录到文件中，但不能记录到UI中。它旨在通过消除GUI开销来提供记录数据的有效方法。在CLI模式下运行时，可以使用<code>-l</code>标志创建数据文件。要保存的字段是由JMeter属性定义的。看到 <code>jmeter.properties</code> 查看详细信息。</p><h3 id="Aggregate-Graph-汇总图">Aggregate Graph | 汇总图</h3><p>聚合图类似于聚合报告。主要的区别是聚合图提供了一种简单的方法来生成条形图并将图保存为PNG文件。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7f01d0b57ce976023f98bd370d6c84c4.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Column settings</td><td>- <code>Columns to display:</code> 选择要在图形中显示的列。 &lt;/br&gt; - <code>Rectangles color:</code> 点击右边的颜色矩形打开一个弹出对话框，为列选择一个自定义的颜色。 &lt;/br&gt; - <code>Foreground color</code> 允许改变值文本颜色。 &lt;/br&gt; - <code>Value font:</code> 允许定义文本的字体设置。 &lt;/br&gt; - <code>Draw outlines bar?</code> 在柱状图上画或不画边线 &lt;/br&gt; - <code>Show number grouping?</code> 是否显示Y轴标签中的数字分组。 &lt;/br&gt;  - <code>Value labels vertical?</code> 更改值标签的方向。(默认是水平) &lt;/br&gt; - <code>Column label selection:</code> 根据结果标签进行筛选。可以使用正则表达式，例如: <code>.*Transaction.*</code> 在显示图形之前，单击<code>Apply filter</code>按钮以刷新内部数据。</td><td>Yes</td></tr><tr><td>Title</td><td>在图表的头部定义图表的标题。空值为默认值:"聚合图"。Synchronize with name按钮用监听器的标签定义标题。并定义图形标题的字体设置</td><td>No</td></tr><tr><td>Graph size</td><td>根据当前JMeter窗口大小的宽度和高度计算图形大小。使用宽度和高度字段定义自定义大小。单位为像素。</td><td>No</td></tr><tr><td>X Axis settings</td><td>定义X轴标签的最大长度(像素)。</td><td>No</td></tr><tr><td>Y Axis settings</td><td>为Y轴定义一个自定义最大值。</td><td>No</td></tr><tr><td>Legend</td><td>定义图表图例的位置和字体设置</td><td>Yes</td></tr></tbody></table></div><h3 id="Response-Time-Graph-响应时间图">Response Time Graph | 响应时间图</h3><p>响应时间图绘制了一个折线图，显示了测试期间每个标记的请求响应时间的演变。如果同一时间戳存在多个样本，则显示平均值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cad233a5e67ca717331f26c4c3033e4d6.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Interval (ms)</td><td>X轴间隔的时间，以毫秒为单位。样本根据这个值分组。在显示图形之前，单击应用间隔按钮来刷新内部数据。</td><td>Yes</td></tr><tr><td>Sampler label selection</td><td>根据结果标签进行筛选。可以使用正则表达式，例如:<code>*Transaction.*</code>。在显示图形之前，单击Apply filter按钮以刷新内部数据。</td><td>No</td></tr><tr><td>Title</td><td>在图表的头部定义图表的标题。空值为默认值:"响应时间图"。Synchronize with name按钮用监听器的标签定义标题。并定义图形标题的字体设置</td><td>No</td></tr><tr><td>Line settings</td><td>定义线的宽度。定义每个值点的类型。选择none将有一条没有标记的线</td><td>Yes</td></tr><tr><td>Graph size</td><td>根据当前JMeter窗口大小的宽度和高度计算图形大小。使用宽度和高度字段定义自定义大小。单位为像素。</td><td>No</td></tr><tr><td>X Axis settings</td><td>定制X轴标签的日期格式。语法是Java SimpleDateFormat API。</td><td>No</td></tr><tr><td>Y Axis settings</td><td>以毫秒为单位定义Y轴的自定义最大值。显示或不显示Y轴标签中的数字分组。</td><td>No</td></tr><tr><td>Legend</td><td>定义图表图例的位置和字体设置</td><td>Yes</td></tr></tbody></table></div><h3 id="Summary-Report-汇总报告">Summary Report | 汇总报告</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb55b93e85bb21e37fd31f53c9422e9fb.png" alt></p></div><p>摘要报告为测试中的每个不同名称的请求创建一个表行。这类似于聚合报告，只是它使用更少的内存。</p><p>吞吐量是从采样器目标的角度计算的(例如，在HTTP采样的情况下，远程服务器)。JMeter会考虑生成请求的总时间。如果其他采样器和计时器在同一个线程中，这将增加总时间，从而降低吞吐量值。所以两个名称不同的相同采样器的吞吐量是两个名称相同的采样器的一半。正确选择取样器标签是很重要的，以便从报告中得到最好的结果。</p><ul><li><code>Label</code> - 样品的标签。如果选择<code>Include group name in label?</code>，则将线程组的名称作为前缀添加。这允许在需要时分别对来自不同线程组的相同标签进行排序。</li><li><code># Samples</code> - 相同标签的样品数量</li><li><code>Average</code> - 一组结果的平均时间</li><li><code>Min</code> - 相同标签的样品时间最短</li><li><code>Max</code> - 相同标签的样品时间最长</li><li><code>Std. Dev.</code> - 样本运行时间的标准偏差</li><li><code>Error %</code> - 请求错误的百分比</li><li><code>Throughput</code> - 吞吐量以每秒/分钟/小时的请求数来衡量。选择时间单位使显示的速率至少为1.0。当吞吐量被保存到一个CSV文件时，它被表示为请求/秒，即30.0请求/分钟被保存为0.5。</li><li><code>Received KB/sec</code> - 以每秒接收千字节为单位的吞吐量</li><li><code>Sent KB/sec</code> - 以每秒发送千字节为单位的吞吐量</li><li><code>Avg. Bytes</code> - 样本响应的平均大小(以字节为单位)。</li></ul><h3 id="Save-Responses-to-a-file-保存响应到文件">Save Responses to a file | 保存响应到文件</h3><p>这个测试元素可以放置在测试计划中的任何地方。对于其范围内的每个示例，它将创建一个响应Data文件。它的主要用途是创建功能测试，但当响应太大而无法在"视图结果树侦听器"中显示时，它也很有用。文件名是从指定的前缀加上一个数字创建的(除非禁用了这个前缀，请参阅下面的内容)。文件扩展名根据文档类型创建(如果已知的话)。如果不知道，文件扩展名设置为’unknown’。如果禁用了编号，并且禁用了添加后缀，那么文件前缀将被用作整个文件名。这允许在需要时生成一个固定的文件名。生成的文件名存储在示例响应中，如果需要，可以保存在测试日志输出文件中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb01b3cb405edec2c42945587bbc5a86a.png" alt></p></div><h3 id="Generate-Summary-Results-生成概要结果">Generate Summary Results | 生成概要结果</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7f24cca56183626429571f7c033363ca.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/监听器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Pre-Processors 前置处理器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Pre-Processors 前置处理器</h1><h2 id="Metadata-8">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Pre-Processors 前置处理器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/处理器categories:  - JMeterkeywords:  - JMeter  - 组件  - 处理器description: 预处理器用于在其范围内修改采样器。</code></pre><h2 id="Pre-Processors-前置处理器">Pre Processors | 前置处理器</h2><p>预处理器用于在其范围内修改采样器。</p><h3 id="HTML-Link-Parser-HTML-链接解析器">HTML Link Parser | HTML 链接解析器</h3><p>这个修饰符解析来自服务器的HTML响应并提取链接和表单。通过此修饰符的URL测试示例将被检查，以确定它是否“匹配”从上一个立即响应中提取的任何链接或表单。然后，它将用匹配链接或表单中的适当值替换URL测试示例中的值。perl类型的正则表达式用于查找匹配。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ceaa6a9fdad32bfe0dd77ac9b87804da4.png" alt></p></div><p>使用协议、主机、路径和参数名称进行匹配。目标采样器不能包含响应链接中没有的参数。</p><h3 id="HTTP-URL-Re-writing-Modifier-HTTP-重写修饰符">HTTP URL Re-writing Modifier | HTTP 重写修饰符</h3><p>这个修饰符的工作原理与HTML Link Parser类似，只是它有一个特定的用途，它比HTML Link Parser更容易使用，而且更高效。对于使用URL重写来存储会话id而不是Cookie的web应用程序，这个元素可以附加在ThreadGroup级别，就像HTTP Cookie Manager一样。只需给它指定会话id参数的名称，它就会在页面上找到它，并将该参数添加到该ThreadGroup的每个请求中。</p><p>或者，这个修饰符可以附加到选择请求，它将只修改它们。聪明的用户甚至会确定这个修饰符可以用来获取避开HTML链接解析器的值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7deb56f9f97a3e9528764e2af1912256.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>测试树中这个元素的描述性名称。</td><td>No</td></tr><tr><td>Session Argument Name</td><td>要从以前的响应中获取的参数的名称。该修饰符将在页面上任何存在参数的地方找到参数，并获取分配给它的值，无论它是在HREF或表单中。</td><td>Yes</td></tr><tr><td>Path Extension</td><td>一些web应用程序通过添加分号和会话id参数来重写url。如果是这样，请勾选此框。</td><td>No</td></tr><tr><td>Do not use equals in path extension</td><td>一些web应用程序重写url时不需要在参数名和值之间使用"="符号(如Intershop Enfinity)。</td><td>No</td></tr><tr><td>Do not use questionmark in path extension</td><td>防止查询字符串结束在路径扩展(如Intershop Enfinity)。</td><td>No</td></tr><tr><td>Cache Session Id?</td><td>当会话Id不存在时，是否应该保存会话Id的值以备以后使用?</td><td>Yes</td></tr><tr><td>URL Encode</td><td>URL写入参数时的编码值</td><td>No</td></tr></tbody></table></div><h3 id="User-Parameters-用户参数">User Parameters | 用户参数</h3><p>允许用户指定特定于单个线程的用户变量值。</p><p>用户变量也可以在Test Plan中指定，但不是特定于单个线程。此面板允许您为任意用户变量指定一系列值。对于每个线程，将按顺序为变量分配序列中的一个值。如果线程比值多，则重用值。例如，这可以用来为每个线程分配一个不同的用户id。用户变量可以在任何JMeter组件的任何字段中引用。</p><p>通过单击面板底部的“添加变量”按钮，并在“name:”列中填写变量名称，可以指定变量。要向系列添加新值，请单击“添加用户”按钮，并在新添加的列中填写所需的值。</p><p>可以使用函数语法:<code>${variable}</code>在同一线程组中的任何测试组件中访问值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">参数</p><p><img src="/attachment%5Ca3098c8fa35a478a9efda43f7869bfa4.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Post-Processors 后置处理器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Post-Processors 后置处理器</h1><h2 id="Metadata-9">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Post-Processors 后置处理器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/处理器categories:  - JMeterkeywords:  - JMeter  - 组件  - 处理器description: 后处理器应用于采样器之后。请注意，它们应用于相同范围内的所有采样器，因此要确保后处理器只应用于特定的采样器，请将其添加为该采样器的子级。</code></pre><h2 id="Post-Processors-后置处理器">Post Processors | 后置处理器</h2><p>顾名思义，后处理器应用于采样器之后。请注意，它们应用于相同范围内的所有采样器，因此要确保后处理器只应用于特定的采样器，请将其添加为该采样器的子级。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:除非另有说明，否则后处理程序不会应用于子样本(子样本)-只适用于父样本。对于JSR223和BeanShell后处理器，脚本可以使用prev.getSubResults()方法检索子示例，该方法返回一个samplerresults数组。如果没有，则数组为空。</p></div><p>后处理器在断言之前运行，因此它们不能访问任何断言结果，示例状态也不能反映任何断言的结果。如果您需要访问断言结果，请尝试使用侦听器。还要注意变量JMeterThread。在运行所有断言之后，last_sample_ok设置为“true”或“false”。</p><h3 id="Regular-Expression-Extractor-正则表达式提取器">Regular Expression Extractor | 正则表达式提取器</h3><p>允许用户使用perl类型的正则表达式从服务器响应中提取值。作为一个后处理器，该元素将在其范围内的每个Sample请求之后执行，应用正则表达式，提取请求的值，生成模板字符串，并将结果存储到给定的变量名中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C63a8726b7e5b75834e0dcefadfce8b6a.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称</td><td>No</td></tr><tr><td>Apply to:</td><td>这是用于可以生成子样本的采样器，例如带有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。</td><td>Yes</td></tr><tr><td>Field to check</td><td><code>Body</code>  <code>Body (unescaped)</code> <code>Body as a Document</code>   <code>Request Headers</code>        <code>Response Headers</code>   <code>URL</code>   <code>Response Code</code>  <code>Response Message</code></td><td>Yes</td></tr><tr><td>Name of created variable</td><td>要在其中存储结果的JMeter变量的名称。还要注意，每个组都存储为<code>[refname]_g#</code>，其中<code>[refname]</code>是作为引用名输入的字符串，<code>#</code>是组号，其中<code>组0</code>是整个匹配，<code>组1</code>是来自第一组圆括号的匹配，等等。</td><td>Yes</td></tr><tr><td>Regular Expression</td><td>用于解析响应数据的正则表达式。这必须包含至少一组圆括号“()”来捕获字符串的一部分，除非使用组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。不要将表达式包含在/ /中——当然，除非您也想匹配这些字符。</td><td>Yes</td></tr><tr><td>Template</td><td>用于根据找到的匹配项创建字符串的模板。这是一个任意字符串，其中包含用于引用正则表达式中的组的特殊元素。表示组的语法是:'<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>'表示组1，'<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>'表示组2，等等。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>表示整个表达式匹配的任何内容。</td><td>Yes</td></tr><tr><td>Match No. (0 for Random)</td><td>指示要使用哪个匹配。正则表达式可以匹配多次。 -1表示全部</td><td>Yes</td></tr><tr><td>Default Value</td><td>如果正则表达式不匹配，那么引用变量将被设置为默认值。这对于调试测试特别有用。如果没有提供缺省值，那么很难判断是正则表达式不匹配，还是没有处理RE元素，或者可能使用了错误的变量。</td><td>No, but recommended</td></tr><tr><td>Use empty default value</td><td>如果复选框被选中并且默认值为空，那么JMeter将把变量设置为空字符串，而不是不设置它。因此，当你在你的测试计划中使用<code>${var}</code>(如果引用名称是var)时，如果没有找到提取的值，那么<code>${var}</code>将等于空字符串，而不是包含<code>${var}</code>，如果提取的值是可选的，它可能是有用的。</td><td>No</td></tr></tbody></table></div><h3 id="CSS-JQuery-Extractor-CSS-JQuery-提取器">CSS/JQuery Extractor  | CSS/JQuery 提取器</h3><p>允许用户使用CSS选择器语法从服务器HTML响应中提取值。作为一个后处理器，该元素将在其范围内的每个Sample请求之后执行，应用CSS/JQuery表达式，提取被请求的节点，提取节点作为文本或属性值，并将结果存储到给定的变量名中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C11a88c2a90612ebd0679902ccc96a469.png" alt></p></div><h3 id="Result-Status-Action-Handler-结果状态处理器">Result Status Action Handler | 结果状态处理器</h3><p>如果相关的采样器失败，这个test元素允许用户停止线程或整个测试。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5eb30e766f2119f8ff0da88fd90c4cbd.png" alt></p></div><h3 id="JSON-Extractor-JSON-提取器">JSON Extractor | JSON 提取器</h3><p>JSON PostProcessor允许您使用JSON- path语法从JSON响应中提取数据。这个后处理器非常类似于正则表达式提取器。它必须被放置为HTTP采样器或任何其他有响应的采样器的子级。它将允许您以非常简单的方式提取文本内容，请参阅JSON路径语法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cae263477a4ba574f58c7dbea086aa0f6.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Configuration 配置元件</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Configuration 配置元件</h1><h2 id="Metadata-10">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Configuration 配置元件date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/配置categories:  - JMeterkeywords:  - JMeter  - 组件  - 配置description: 配置元素可用于设置默认值和变量，供采样器稍后使用。注意，这些元素在找到它们的范围的开始处处理，即在同一范围内的任何采样器之前处理。</code></pre><h2 id="Configuration-配置元件">Configuration | 配置元件</h2><p>配置元素可用于设置默认值和变量，供采样器稍后使用。注意，这些元素在找到它们的范围的开始处处理，即在同一范围内的任何采样器之前处理。</p><h3 id="CSV-Data-Set-Config-CSV-数据集配置">CSV Data Set Config | CSV 数据集配置</h3><p>CSV数据集配置用于从文件中读取行，并将它们分割为变量。它比<code>__CSVRead()</code>和<code>__StringFromFile()</code>函数更容易使用。它非常适合处理大量变量，并且对于使用"随机"和惟一值进行测试也很有用。</p><p>就CPU和内存而言，在运行时生成唯一的随机值非常昂贵，所以只需在测试之前创建数据。如果有必要，文件中的"随机"数据可以与运行时参数结合使用，从而在每次运行中创建不同的值集——例如使用串联——这比在运行时生成所有值要便宜得多。</p><p>JMeter允许值被引用;这允许值包含分隔符。如果启用了 “<code>allow quoted data</code>”(“允许引用数据”)，值可以用双引号括起来。这些都是删除。要在带引号的字段中包含双引号，请使用两个双引号。</p><p>JMeter支持用标题行定义列名的CSV文件。要启用此功能，请将 “<code>Variable Names</code>” "变量名称"字段保留为空。必须提供正确的分隔符。</p><p>默认情况下，文件只打开一次，每个线程将使用文件中的不同行。但是，将行传递给线程的顺序取决于它们的执行顺序，这在迭代之间可能会有所不同。在每个测试迭代的开始读取行。在第一次迭代中解析文件名和模式。</p><p>有关其他选项，请参阅下面对共享模式的描述。如果希望每个线程都有自己的一组值，那么需要创建一组文件，每个线程一个文件。例如test1.csv, test2.csv，…，testn.csv。使用文件名<code>test${__threadNum}.csv</code>，将"<code>Sharing mode</code>"(“共享模式”)设置为 “<code>Current thread</code>”(“当前线程”)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cce47f39f5ccee667dcd4f0ef5d3b0baf.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。<br> 要读取的文件的名称。相对文件名根据活动测试计划的路径进行解析。对于分布式测试，CSV文件必须存储在服务器主机系统中启动JMeter服务器的正确相对目录中。也支持绝对文件名，但是请注意，它们不太可能在远程模式下工作，除非远程服务器具有相同的目录结构。如果以两种不同的方式引用同一个物理文件——例如csvdata.txt和./csvdata.txt——那么这些文件将被视为不同的文件。如果操作系统不区分大小写，也会单独打开csvData.TXT。</td><td>Yes</td></tr><tr><td>File Encoding</td><td>用于读取文件的编码，如果不是平台默认值的话。</td><td>No</td></tr><tr><td>Variable Names</td><td>变量名列表。名称必须由分隔符分隔。它们可以用双引号引用。JMeter支持CSV标题行:如果变量名字段为空，那么文件的第一行将被读取并解释为列名列表。</td><td>No</td></tr><tr><td>Use first line as Variable Names</td><td>忽略CSV文件的第一行，它只会在变量名不为空时使用，如果变量名为空，第一行必须包含标题。</td><td>No</td></tr><tr><td>Delimiter</td><td>分隔符，用于分割文件中的记录。如果行上的值比变量的值少，那么剩余的变量将不会更新——因此它们将保留以前的值(如果有的话)。</td><td>Yes</td></tr><tr><td>Allow quoted data?</td><td>CSV文件是否允许值被引用?如果启用，值可以括在 <code>"</code>-双引号-允许值包含分隔符。</td><td>Yes</td></tr><tr><td>Recycle on EOF?</td><td>文件是否应该在到达EOF时从头重新读取?(默认是<code>true</code>的)</td><td>Yes</td></tr><tr><td>Stop thread on EOF?</td><td>如果循环是假的，线程应该停止在EOF ?(默认是假的)</td><td>Yes</td></tr><tr><td>Sharing mode</td><td>- All threads - (the default) 该文件在所有线程之间共享。<br> - Current thread group - 对于出现该元素的每个线程组，每个文件都会打开一次 <br> - Current thread - 每个文件为每个线程分别打开 <br> - Identifier - 共享相同标识符的所有线程共享相同的文件。例如，如果您有4个线程组，您可以为两个或多个组使用一个公共id来在它们之间共享文件。或者可以使用线程号在不同线程组中的相同线程号之间共享文件。</td><td>Yes</td></tr></tbody></table><h3 id="DNS-Cache-Manager-DNS缓存管理器">DNS Cache Manager | DNS缓存管理器</h3><p>DNS缓存管理器元素允许测试应用程序，当用户从不同的IP接收内容时，负载均衡器(CDN等)后面有多个服务器。JMeter默认使用JVM DNS缓存。这就是为什么集群中只有一个服务器接收负载的原因。DNS缓存管理器在每次迭代时分别为每个线程解析名称，并将解析结果保存到其内部DNS缓存中，该缓存独立于JVM和OS的DNS缓存。</p><p>静态主机的映射可以用来模拟类似于<code>/etc/hosts</code>文件的内容。这些条目将优先于自定义解析器。如果要使用此映射，必须启用自定义DNS解析器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6a3ba849bb5754e150f44e07fc37eeed.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>DNS缓存管理器设计用于在线程组或测试计划的根目录中使用。不把它作为子元素的特定HTTP采样</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>DNS缓存管理器只适用于使用HTTPClient4实现的HTTP请求。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear cache each Iteration</td><td>如果选中，每次新的迭代开始时，每个线程的DNS缓存都会被清除。</td><td>No</td></tr><tr><td>Use system DNS resolver</td><td>系统DNS解析器将被使用。对于正确的工作编辑 <code>$JAVA_HOME/jre/lib/security/java.security</code> 并且添加 <code>networkaddress.cache.ttl=0</code></td><td>N/A</td></tr><tr><td>Use custom DNS resolver</td><td>将使用自定义DNS解析器(来自dnsjava库)。</td><td>N/A</td></tr><tr><td>Hostname or IP address</td><td>使用的DNS服务器列表。如果为空，则使用网络配置DNS。</td><td>No</td></tr><tr><td>Add Button</td><td>在DNS服务器表中添加一条表项。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Host and Hostname or IP address</td><td>将主机名映射到静态主机条目，该条目将使用自定义DNS解析器进行解析。</td><td>No</td></tr><tr><td>Add static host Button</td><td>在静态主机表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete static host Button</td><td>删除表中当前选择的静态主机。</td><td>N/A</td></tr></tbody></table></div><h3 id="HTTP-Authorization-Manager-HTTP授权管理器">HTTP Authorization Manager | HTTP授权管理器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cbc7857565fd9ff73dbe5e04ea209b160.png" alt></p></div><p>授权管理器允许您为使用服务器身份验证限制的网页指定一个或多个用户登录。当您使用浏览器访问受限制的页面，并且浏览器显示登录对话框时，您会看到这种类型的身份验证。JMeter在遇到这种类型的页面时传输登录信息。</p><p>授权标头可能不会显示在树视图侦听器的"请求"选项卡中。Java实现执行了先发制人的身份验证，但是当JMeter获取授权报头时，它不返回授权报头。HttpComponents (HC 4.5.X)实现自3.2开始默认为先发制人，头部将显示。要禁用此功能，请设置以下值，在这种情况下，身份验证将只在响应质询时执行。</p><p>在 <code>jmeter.properties</code> 文件中 设置 <code>httpclient4.auth.preemptive=false</code></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:上述设置仅适用于HttpClient采样器。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>当针对URL查找匹配项时，JMeter依次检查每个条目，并在找到第一个匹配项时停止。因此，最特定的url应该出现在列表的最前面，其次是不那么特定的url。重复的url将被忽略。如果你想为不同的线程使用不同的用户名/密码，你可以使用变量。这些可以使用CSV数据集配置元素(例如)来设置。</p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear auth on each iteration?</td><td>用于Kerberos认证。如果勾选此项，将对每一次主线程组循环的迭代进行身份验证，即使它已经在前一次循环中完成了。如果每个主线程组迭代代表一个虚拟用户的行为，这通常是有用的。</td><td>Yes</td></tr><tr><td>Base URL</td><td>匹配一个或多个HTTP请求URL的部分或完整URL。例如，您指定一个Base URL为 “<code>http://localhost/restricted/</code>”，用户名为"<code>jmeter</code>"，密码为"<code>jmeter</code>"。如果您向URL"<code>http://localhost/restricted/ant/myPage.html</code>"发送HTTP请求，授权管理器将发送名为"jmeter"的用户的登录信息。</td><td>yES</td></tr><tr><td>Username</td><td>需要授权的用户名。</td><td>Yes</td></tr><tr><td>Password</td><td>用户的密码。(注意，此数据未加密存储在测试计划中)</td><td>Yes</td></tr><tr><td>Domain</td><td>用于NTLM的域。</td><td>No</td></tr><tr><td>Realm</td><td>用于NTLM的领域。</td><td>No</td></tr><tr><td>Mechanism</td><td>执行的认证类型。JMeter可以基于使用的Http采样器执行不同类型的认证:</td><td>No</td></tr></tbody></table><h3 id="HTTP-Cache-Manager-HTTP-缓存控制器">HTTP Cache Manager | HTTP 缓存控制器</h3><p>HTTP缓存管理器用于在其作用域内向HTTP请求添加缓存功能，以模拟浏览器缓存特性。每个虚拟用户线程都有自己的缓存。默认情况下，缓存管理器将使用LRU算法在每个虚拟用户线程的缓存中存储最多5000个条目。使用属性"maxSize"来修改这个值。请注意，这个值增加越多，HTTP缓存管理器消耗的内存就越多，因此一定要相应地调整-Xmx JVM选项。</p><p>如果一个样本是成功的(即有响应代码2xx)，然后最后修改和Etag(和过期，如果相关)的值为URL保存。在执行下一个示例之前，采样器检查缓存中是否有条目，如果有，则为请求设置if - last - modified和if - none - match条件报头。</p><p>此外，如果"使用Cache-Control/Expires头"选项被选中，那么Cache-Control/Expires值将根据当前时间进行检查。如果请求是一个GET请求，并且时间戳在将来，那么采样器将立即返回，而不需要从远程服务器请求URL。这是为了模拟浏览器的行为。注意，如果cache - control报头为"no-cache"，响应将被存储在缓存中，因此将生成一个有条件的GET请求。如果Cache-Control有其他值，则处理"max-age"过期选项来计算条目的生存期，如果缺少则使用过期头，如果也缺少条目将使用RFC 2616章节13.2.4中指定的Last-Modified time和response Date进行缓存。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果所请求的文档自缓存以来没有更改，那么响应体将为空。同样，如果过期日期在未来。这可能会给断言带来问题。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C431a1b16f59e2a2a78ff45601e41b2fa.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear cache each iteration</td><td>如果选择该选项，则在线程开始时清除缓存。</td><td>Yes</td></tr><tr><td>Use Cache Control/Expires header when processing GET requests</td><td>参见上面的描述。</td><td>Yes</td></tr><tr><td>Max缓存中的元素个数</td><td>参见上面的描述。</td><td>Yes</td></tr></tbody></table></div><h3 id="HTTP-Cookie-Manager-HTTP-Cookie-管理器">HTTP Cookie Manager | HTTP Cookie 管理器</h3><p>Cookie Manager元素有两个功能:</p><p>首先，它像网络浏览器一样存储和发送cookie。如果您有一个HTTP请求和响应包含一个cookie, cookie管理器自动存储该cookie，并将使用它为所有未来的请求，以特定的网站。每个JMeter线程都有自己的“cookie存储区域”。因此，如果您正在测试一个使用cookie存储会话信息的网站，那么每个JMeter线程将拥有自己的会话。注意，这样的Cookie不会出现在Cookie Manager的显示中，但是可以使用View Results Tree Listener查看它们。</p><p>JMeter检查接收到的cookie对URL是否有效。这意味着不存储跨域cookie。如果您有错误行为或希望使用跨域cookie，定义JMeter属性 “<code>CookieManager.check.cookies=false</code>”</p><p>接收到的cookie可以存储为JMeter线程变量。要将cookie保存为变量，需要定义属性"<code>CookieManager.save.cookies=true</code>"。此外，cookie名称在存储之前会以“COOKIE_”作为前缀(这可以避免局部变量的意外损坏)。要恢复到原来的行为，需要定义属性"<code>CookieManager.name.prefix=</code>"(一个或多个空格)。如果启用，一个名为TEST的cookie的值可以被引用为<code>${COOKIE_TEST}</code>。</p><p>其次，您可以手动添加cookie到cookie管理器。但是，如果您这样做，cookie将被所有JMeter线程共享。</p><p>注意，这样的cookie创建时的过期时间较远</p><p>默认情况下，具有<strong>空值</strong>的cookie将被忽略。这可以通过设置JMeter属性来改变:<code>CookieManager.delete_null_cookies=false</code>。注意，这也适用于手动定义的cookie -任何这样的cookie在更新时将从显示中删除。还要注意cookie名称必须是唯一的——如果第二个cookie定义为相同的名称，它将替换第一个cookie。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C230dad077b303fe9551fe423dc86b965.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果在一个采样器的范围内有多个Cookie Manager，目前没有办法指定要使用哪个。另外，存储在一个cookie管理器中的cookie对任何其他管理器都不可用，所以要小心使用多个cookie管理器。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear Cookies each Iteration</td><td>如果选中该选项，则在每次执行主线程组循环时清除所有服务器定义的cookie。在GUI中定义的cookie不会被清除。</td><td>Yes</td></tr><tr><td>Cookie Policy</td><td>用于管理cookie的cookie策略。"standard"是3.0之后的默认设置，应该在大多数情况下都可以使用。参见Cookie规范和CookieSpec实现<code>[注:"ignoreCookies"等价于省略CookieManager。]</code></td><td>Yes</td></tr><tr><td>Implementation</td><td>HC4CookieHandler (HttpClient 4.5。X的API)。从3.0开始默认为HC4CookieHandler。 <code>[注:如果你有一个网站来测试IPv6地址，选择HC4CookieHandler (IPv6兼容)]</code></td><td>Yes</td></tr><tr><td>User-Defined Cookies</td><td>这使您有机会使用将在测试执行期间被所有线程使用的硬编码cookie。 <code>域</code>是服务器的主机名(没有http://);端口当前被忽略。</td><td>N/A</td></tr><tr><td>Add Button</td><td>向cookie表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Load Button</td><td>加载之前保存的cookie表，并将条目添加到现有的cookie表条目中。</td><td>N/A</td></tr><tr><td>Save As Button</td><td>将当前cookie表保存到一个文件中(不保存从HTTP响应中提取的任何cookie)。</td><td>N/A</td></tr></tbody></table></div><h3 id="HTTP-Request-Defaults-HTTP-请求默认值">HTTP Request Defaults | HTTP 请求默认值</h3><p>这个元素允许你设置HTTP请求控制器使用的默认值。例如，如果您正在使用25个HTTP请求控制器创建一个Test Plan，并且所有的请求都被发送到相同的服务器，您可以添加一个单独的HTTP Request Defaults元素，填充“服务器名称或IP”字段。然后，当您添加25个HTTP请求控制器时，<mark style="background: #ABF7F7A6;">将“服务器名称或IP”字段保留为空</mark> 。控制器将从HTTP Request Defaults元素继承这个字段值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C4b94edb137f5ce1ac2fc7f273c5b352c.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>所有端口值都被同等对待;一个没有指定端口的采样器将使用HTTP请求默认端口(如果提供了)。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attibute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Server</td><td>web服务器的域名或IP地址。例如,www.example.com。<code>[不包含http://前缀。</code></td><td>No</td></tr><tr><td>Port</td><td>web服务器正在监听的端口。</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时。等待连接打开的毫秒数。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时。等待响应的毫秒数。</td><td>No</td></tr><tr><td>Implementation</td><td>Java, HttpClient4。如果没有指定，默认值取决于JMeter属性JMeter的值。httpsampler，如果失败，则使用Java实现。</td><td>No</td></tr><tr><td>Protocol</td><td>HTTP or HTTPS.</td><td>No</td></tr><tr><td>Content encoding</td><td>用于请求的编码。</td><td>No</td></tr><tr><td>Path</td><td>资源的路径(例如/servlets/myServlet)。如果资源需要查询字符串参数，在下面的“发送请求参数”部分添加它们。注意，该路径是完整路径的默认值，而不是应用于HTTP请求屏幕上指定的路径的前缀。</td><td>No</td></tr><tr><td>Send Parameters With the Request</td><td>查询字符串将从您提供的参数列表中生成。每个参数都有一个名称和值。查询字符串将以正确的方式生成，取决于你所做的“方法”的选择(即，如果你选择了GET，查询字符串将被附加到URL，如果是POST，那么它将被单独发送)。此外，如果您正在使用多部分表单发送文件，那么查询字符串将使用多部分表单规范创建。</td><td>No</td></tr><tr><td>Server (proxy)</td><td>执行请求的代理服务器的主机名或IP地址。<code>[不包含http://前缀。]</code></td><td>No</td></tr><tr><td>Port</td><td>代理服务器正在监听的端口。不能，除非指定了代理主机名</td><td>No</td></tr><tr><td>Username</td><td>代理服务器的用户名(可选)。</td><td>No</td></tr><tr><td>Password</td><td>代理服务器密码(可选)。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Retrieve All Embedded Resources from HTML Files</td><td>告诉JMeter解析HTML文件，并对文件中引用的所有图像、Java小程序、JavaScript文件、css等发送HTTP/HTTPS请求。</td><td>No</td></tr><tr><td>Use concurrent pool</td><td>使用并发连接池来获得嵌入式资源。</td><td>No</td></tr><tr><td>Size</td><td>用于获取嵌入式资源的并发连接的池大小。</td><td>No</td></tr><tr><td>URLs must match:</td><td>如果存在，则必须是一个正则表达式，用于匹配找到的任何嵌入式url。因此，如果您只想从<code>http://example.invalid/</code>下载嵌入式资源，请使用表达式:<code>http://example\.invalid/.*</code></td><td>No</td></tr><tr><td>URLs must not match:</td><td>如果存在，则必须是一个正则表达式，用于过滤掉找到的任何嵌入的url。所以，如果你不想从任何来源下载PNG或SVG文件，使用表达式:<code>.*\.(?i: SVG | PNG)</code></td><td>No</td></tr></tbody></table></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注:单选按钮只有两种状态-开或关。这使得不可能始终如一地覆盖设置——关闭意味着关闭，还是意味着使用当前的默认值?JMeter使用后者(否则默认值根本不起作用)。因此，如果按钮是关闭的，那么后面的元素可以将其设置为开启，但如果按钮是开启的，后面的元素就不能将其设置为关闭。</p></div><h3 id="HTTP-Header-Manager-HTTP-头信息管理器">HTTP Header Manager | HTTP 头信息管理器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C0333bdcf912b8486049febc4d746f591.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Name (Header)</td><td>请求头的名称。您可能想要试验的两个常见请求头是"<code>User-Agent</code>"和"<code>Referer</code>"。</td><td>No (You should have at least one, however)</td></tr><tr><td>Value</td><td>请求头的值</td><td>No (You should have at least one, however)</td></tr><tr><td>Add Button</td><td>向标题表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Load Button</td><td>加载先前保存的头表，并将条目添加到现有的头表条目中。</td><td>N/A</td></tr><tr><td>Save As Button</td><td>将当前头表保存到一个文件中。</td><td>N/A</td></tr></tbody></table></div><h3 id="Java-Request-Defaults-java-请求默认值">Java Request Defaults | java 请求默认值</h3><p>Java Request Defaults组件允许您为Java测试设置默认值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C18f4c033bd431c9dd7b76f52ce282a52.png" alt></p></div><h3 id="JDBC-Connection-Configuration-JDBC-连接-配置">JDBC Connection Configuration | JDBC 连接 配置</h3><p>从提供的JDBC connection设置创建一个数据库连接(由JDBC RequestSampler使用)。连接可以在线程之间选择性地池化。否则，每个线程将获得自己的连接。JDBC Sampler使用连接配置名称来选择适当的连接。已用池为DBCP，请参见BasicDataSource配置参数</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C1833bb3bf3831447c387e587824ac09a.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的连接配置的描述性名称。</td><td>No</td></tr><tr><td>Variable Name for created pool</td><td>连接绑定到的变量的名称。可以使用多个连接，每个连接绑定到不同的变量，从而允许JDBC sampler选择适当的连接。</td><td>Yes</td></tr><tr><td>Max Number of Connections</td><td>池中允许的最大连接数。在大多数情况下，设置为0(0)。这意味着每个线程将得到它自己的池，其中有一个连接，即连接不是线程之间共享的。</td><td>Yes</td></tr><tr><td>Max Wait (ms)</td><td>如果在尝试检索连接的过程中超过了超时时间，池将抛出一个错误</td><td>Yes</td></tr><tr><td>Time Between Eviction Runs (ms)</td><td>空闲对象回收器线程运行之间休眠的毫秒数。当非正值时，不会运行空闲的对象驱逐符线程。(默认为60000,1分钟)。看到</td><td>Yes</td></tr><tr><td>Auto Commit</td><td>打开或关闭连接的自动提交。</td><td>Yes</td></tr><tr><td>Transaction isolation</td><td>事务隔离</td><td>Yes</td></tr><tr><td>Pool Prepared Statements</td><td>每个连接池中准备语句的最大数量。“-1”禁用池，“0”表示不限制准备语句池的数量。(默认为“1”)</td><td>Yes</td></tr><tr><td>Preinit Pool</td><td>可以立即初始化连接池。如果设置为False(默认值)，使用该池的JDBC请求采样器可能会为第一次查询度量更高的响应时间—因为包括了整个池的连接建立时间。</td><td>No</td></tr><tr><td>Init SQL statements separated by new line</td><td>一组SQL语句，在第一次创建物理连接时，这些SQL语句将用于初始化它们。这些语句只执行一次—当配置的连接工厂创建连接时。</td><td>No</td></tr><tr><td>Test While Idle</td><td>测试池的空闲连接</td><td>Yes</td></tr><tr><td>Soft Min Evictable Idle Time(ms)</td><td>在空闲对象回收器有资格回收连接之前，连接在池中空闲的最短时间，附加条件是至少有minIdle连接保留在池中。 默认值为5000(5秒)</td><td>Yes</td></tr><tr><td>Validation Query</td><td>一个简单的查询，用于确定数据库是否仍在响应。这默认是jdbc驱动程序的’isValid()'方法，它适用于许多数据库。然而，有些可能需要不同的查询;例如，Oracle类似于“SELECT 1 FROM DUAL”可以使用。</td><td>No</td></tr><tr><td>Database URL</td><td>JDBC数据库连接字符串。</td><td>Yes</td></tr><tr><td>JDBC Driver class</td><td>驱动程序类的完全限定名称。(必须在JMeter的类路径-最容易复制.jar文件到JMeter的/lib目录)。</td><td>Yes</td></tr><tr><td>Username</td><td>要连接的用户名。</td><td>No</td></tr><tr><td>Password</td><td>连接的密码。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Connection Properties</td><td>建立连接时设置的连接属性(例如Oracle的internal_logon=sysdba)</td><td>No</td></tr></tbody></table><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">Some examples for databases and their parameters are given below.</p><p>MySQLDriver classcom.mysql.jdbc.DriverDatabase URLjdbc:mysql://host[:port]/dbnamePostgreSQLDriver classorg.postgresql.DriverDatabase URLjdbc:postgresql:{dbname}OracleDriver classoracle.jdbc.OracleDriverDatabase URLjdbc:oracle:thin:@//host:port/service OR jdbc:oracle:thin:@(description=(address=(host={mc-name})(protocol=tcp)(port={port-no}))(connect_data=(sid={sid})))Ingress (2006)Driver classingres.jdbc.IngresDriverDatabase URLjdbc:ingres://host:port/db[;attr=value]Microsoft SQL Server (MS JDBC driver)Driver classcom.microsoft.sqlserver.jdbc.SQLServerDriverDatabase URLjdbc:sqlserver://host:port;DatabaseName=dbnameApache DerbyDriver classorg.apache.derby.jdbc.ClientDriverDatabase URLjdbc:derby://server[:port]/databaseName[;URLAttributes=value[;…]]MariaDBDriver classorg.mariadb.jdbc.DriverDatabase URLjdbc:mariadb://host[:port]/dbname[;URLAttributes=value[;…]]Exasol (see also JDBC driver documentation)Driver classcom.exasol.jdbc.EXADriverDatabase URLjdbc:exa:host[:port][;schema=SCHEMA_NAME][;prop_x=value_x]</p></div><h3 id="Keystore-Configuration-密钥库配置">Keystore Configuration | 密钥库配置</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfc1e3f1718138d5076fed611399657fd.png" alt></p></div><h3 id="Login-Config-Element-登录配置">Login Config Element | 登录配置</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C2b3e839344fae2210caac4697f84f470.png" alt></p></div><h3 id="TCP-Sampler-Config-TCP-采样器-配置">TCP Sampler Config | TCP 采样器 配置</h3><p>TCP采样器配置为TCP采样器提供缺省数据</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3149a737279a4e4563260c1d0fac8e54.png" alt></p></div><h3 id="User-Defined-Variables-用户定义变量">User Defined Variables | 用户定义变量</h3><p>User Defined Variables元素允许您定义一组初始变量，就像在Test Plan中一样。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfe2292d00bd006cbb0a5b6d2fa7b0d5e.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意，测试计划中的所有UDV元素—无论它们在哪里—都在开始时处理。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td></td></tr><tr><td>User Defined Variables</td><td>变量名称/值对。"<code>Name</code>"列下的字符串是您需要放在<code>${…}</code>构造中方括号内的内容，以便稍后使用变量。整个<code>${…}</code>将被"Value"列中的字符串替换。</td><td></td></tr></tbody></table></div><h3 id="Random-Variable-随机变量">Random Variable | 随机变量</h3><p>随机变量配置元素用于生成随机数字字符串，并将它们存储在变量中以备以后使用。它比使用用户定义变量和<code>__Random()</code>函数更简单。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca323effcee9ceb4d9e663ed1674deb4c.png" alt></p></div><table><thead><tr><th>Attibute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>Yes</td></tr><tr><td>Variable Name</td><td>存储随机字符串的变量的名称。</td><td>Yes</td></tr><tr><td>Format String</td><td>要使用的<code>java.text.DecimalFormat</code>格式字符串。例如，"000"将生成至少3位的数字，或"<code>USER_000</code>"将生成形式为<code>USER_nnn</code>的输出。如果未指定，则默认使用<code>Long.toString()</code>生成数字。</td><td>No</td></tr><tr><td>Minimum Value</td><td>生成的随机数的最小值(长)。</td><td>Yes</td></tr><tr><td>Maximum Value</td><td>生成的随机数的最大值(长)。</td><td>Yes</td></tr><tr><td>Random Seed</td><td>随机数生成器的种子。如果您使用相同的种子值，将Per Thread设置为true，您将为每个Thread获得与每个Random类相同的值。如果没有设置种子，将使用Random的默认构造函数。</td><td>No</td></tr><tr><td>Per Thread(User)?</td><td>如果为False，则线程组中的所有线程共享生成器。如果为True，则每个线程都有自己的随机生成器。</td><td>Yes</td></tr></tbody></table><h3 id="Counter-计数器">Counter | 计数器</h3><p>允许用户创建一个计数器，该计数器可以在线程组的任何位置引用。计数器配置允许用户配置起始点、最大值和增量。计数器将从开始循环到最大，然后重新开始，像这样继续下去，直到测试结束。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C1b0a8607c0781b426f35bd5043f77014.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Starting value</td><td>计数器的起始值。计数器将在第一次迭代期间等于这个值(默认为0)。</td><td>Yes</td></tr><tr><td>Increment</td><td>在每次迭代之后计数器增加多少(默认为0，表示没有增加)。</td><td>No</td></tr><tr><td>Maximum value</td><td>如果计数器超过最大值，则将其重置为起始值。默认是长。MAX_VALUE</td><td>No</td></tr><tr><td>Format</td><td>可选的格式，例如000将格式为001、002等。它被传递给DecimalFormat，因此可以使用任何有效的格式。如果解释格式有问题，就会忽略它。<code>[默认格式是使用Long.toString()生成的]</code></td><td>No</td></tr><tr><td>Exported Variable Name</td><td>这将是计数器值可用的变量名。如果你把它命名为counterA，你可以使用用户定义值中的<code>${counterA}</code>来访问它(默认情况下，它会创建一个空的字符串变量，可以使用<code>${}</code>来访问，但这是非常不鼓励的)</td><td>No</td></tr><tr><td>Track Counter Independently for each User</td><td>换句话说，这是一个全局计数器，还是每个用户都有自己的计数器?如果未选中，计数器是全局的(即，用户#1将在第一次迭代中获得值“1”，用户#2将获得值“2”)。如果勾选此项，每个用户都有一个独立的计数器。</td><td>No</td></tr><tr><td>Reset counter on each Thread Group Iteration</td><td>此选项仅在每个用户跟踪计数器时可用，如果选中，计数器将在每次线程组迭代时重置为Start值。当计数器在循环控制器中时，这是很有用的。</td><td>No</td></tr></tbody></table><h3 id="Simple-Config-Element-简单配置元件">Simple Config Element | 简单配置元件</h3><p>简单配置元素允许您在采样器中添加或重写任意值。您可以选择值的名称和值本身。尽管一些喜欢冒险的用户可能会找到这个元素的用途，但它主要是供开发人员在开发新的JMeter组件时作为基本GUI使用的。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C57794dfe00c7db8952e1c7cef2f3d50a.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Name</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>Yes</td></tr><tr><td>Parameter Name</td><td>每个参数的名称。这些值是JMeter工作的内部值，通常没有文档记录。只有熟悉代码的人才知道这些值。</td><td>Yes</td></tr><tr><td>Parameter Value</td><td>应用于该参数的值。</td><td>Yes</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Timers 定时器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-timers-ding-shi-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-timers-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Timers 定时器</h1><h2 id="Metadata-11">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Timers 定时器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/定时器categories:  - JMeterkeywords:  - JMeter  - 组件  - 定时器description: 通过设置属性计时器，可以对随机计时器计算的睡眠延迟应用乘数。</code></pre><h2 id="Timer-定时器">Timer | 定时器</h2><p>通过设置属性计时器，可以对随机计时器计算的睡眠延迟应用乘数。Factor =float number，其中float number为十进制正数。</p><p>JMeter将这个因子乘以计算出来的睡眠延迟。此功能可由:</p><p>注意，计时器在它们被发现的范围内的每个采样器之前被处理;如果在同一个作用域中有多个计时器，那么所有的计时器都会在每个采样器之前被处理。</p><p>定时器只能与采样器一起处理。与采样器不在同一范围内的计时器根本不会被处理。</p><p>若要将计时器应用于单个采样器，请将计时器添加为采样器的子元素。计时器将在采样器执行之前应用。要在采样器之后应用计时器，可以将它添加到下一个采样器，或者将它添加为流量控制动作采样器的子程序。</p><h3 id="Constant-Timer-固定定时器">Constant Timer | 固定定时器</h3><p>如果您想让每个线程在请求之间暂停相同的时间，可以使用这个计时器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C670da2d843541dc22ef5d6feeca8ec2c.png" alt></p></div><h3 id="Gaussian-Random-Timer-高斯随机定时器">Gaussian Random Timer | 高斯随机定时器</h3><p>这个计时器将每个线程请求暂停一段随机的时间，大多数时间间隔发生在某个特定值附近。总延迟是高斯分布值(平均值为0.0，标准差为1.0)乘以指定的偏差值和偏移值的总和。另一种解释方法是，在高斯随机计时器中，恒定偏移量附近的变化具有高斯曲线分布。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3c2a5923af3be03ea63fa1f53da2a0c4.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称</td><td>No</td></tr><tr><td>Deviation</td><td>偏差,以毫秒为单位</td><td>Yes</td></tr><tr><td>Constant Delay Offset</td><td>除了随机延迟外，暂停的毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Uniform-Random-Timer-统一随机定时器">Uniform Random Timer | 统一随机定时器</h3><p>这个计时器将每个线程请求暂停一段随机的时间，每个时间间隔发生的概率相同。总延迟是随机值和偏移值的总和。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cda68c0ac317482db8700f3886b7beceb.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称</td><td>No</td></tr><tr><td>Random Delay Maximun</td><td>暂停的最大随机毫秒数。</td><td>Yes</td></tr><tr><td>Constant Delay Offset</td><td>除了随机延迟外，暂停的毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Constant-Throughput-Timer-常量吞吐计时器">Constant Throughput Timer | 常量吞吐计时器</h3><p>这个计时器引入了可变的暂停，计算的目的是保持总吞吐量(以每分钟的样本为单位)尽可能接近给定的数字。当然，如果服务器不能处理它，或者其他计时器或耗时的测试元素阻止它，那么吞吐量将会更低。</p><p>注意:虽然Timer被称为常量吞吐量计时器，但吞吐量值不需要是常量。它可以根据变量或函数调用来定义，并且可以在测试期间更改值。可以通过多种方式改变该值:</p><ul><li>使用计数器变量</li><li>使用<code>__jexl3</code>， <code>__groovy</code>函数提供一个更改值</li><li>使用远程<code>BeanShell</code>服务器来更改JMeter属性</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意，在测试期间不应该太频繁地更改吞吐量值—新值需要一段时间才能生效。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C91688733433a106a2b6503cf51fc93b7.png" alt></p></div><h3 id="Synchronizing-Timer-同步定时器">Synchronizing Timer | 同步定时器</h3><p>SyncTimer的目的是阻塞线程，直到X个线程被阻塞，然后它们一次被释放。因此，SyncTimer可以在测试计划的各个点上创建大的即时负载。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C61e29042423f8a1f484e68ff183bee51.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称。</td><td>No</td></tr><tr><td>Number of Simultaneous Users to Group by</td><td>一次释放的线程数。将其设置为0相当于将其设置为Thread Group中的线程数。</td><td>Yes</td></tr><tr><td>Timeout in milliseconds</td><td>如果设置为0,Timer将等待线程的数量达到“number of Simultaneous Users to Group”中的值。如果高于0，则计时器将在最大“Timeout in毫秒”等待线程数。如果超时时间未达到等待用户数量，则停止等待。默认值为0</td><td>No</td></tr></tbody></table><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果timeout(以毫秒为单位)设置为0，并且线程数永远不会达到“number of Simultaneous Users to Group by”，那么Test将无限暂停。只有强行阻止才能阻止它。在这种情况下，可以考虑将Timeout设置为毫秒。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>只在一个JVM中同步计时器块，因此如果使用分布式测试，请确保不要将“Number of Simultaneous Users to Group by”设置为比只考虑1个注入器的线程组的用户数高的值。</p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Samplers 采样器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Samplers 采样器</h1><h2 id="Metadata-12">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Samplers 采样器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/采样器categories:  - JMeterkeywords:  - JMeter  - 组件  - 采样器description: 采样器执行JMeter的实际工作。每个采样器(流量控制动作除外)产生一个或多个采样结果。示例结果具有各种属性(成功/失败、运行时间、数据大小等)，可以在各种侦听器中查看。</code></pre><h2 id="Samplers-采样器">Samplers 采样器</h2><p>采样器执行JMeter的实际工作。每个采样器(流量控制动作除外)产生一个或多个采样结果。示例结果具有各种属性(成功/失败、运行时间、数据大小等)，可以在各种侦听器中查看。</p><h3 id="FTP-Request-FTP请求">FTP Request | FTP请求</h3><p>这个控制器允许你向FTP服务器发送一个FTP"检索文件"或"上传文件"请求。如果你打算向同一个FTP服务器发送多个请求，考虑使用FTP请求默认配置元素，这样你就不必为每个FTP请求生成控制器输入相同的信息。当下载一个文件时，它可以存储在磁盘(本地文件)或响应数据中，或两者都有。</p><p>延迟时间设置为登录所需的时间。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C119383d6ef62fda8d58e5c22b8881e21.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Server Name or IP</td><td>FTP服务器的域名或IP地址。</td><td>Yes</td></tr><tr><td>Port</td><td>端口使用。如果是&gt;0，则使用这个特定的端口，否则JMeter使用默认的FTP端口。</td><td>No</td></tr><tr><td>Remote File:</td><td>要检索的文件或要上传的目标文件的名称。</td><td>Yes</td></tr><tr><td>Local File:</td><td>要上传的文件或下载的目标文件(默认为远程文件名)。</td><td>"Yes, if uploading (*)"</td></tr><tr><td>Local File Contents:</td><td>提供上传的内容，重写"本地文件"属性。</td><td>"Yes, if uploading (*)"</td></tr><tr><td>get(RETR) / put(STOR)</td><td>是否检索或上传文件。</td><td>Yes</td></tr><tr><td>Use Binary mode?</td><td>检查此选项以使用二进制模式(默认ASCII)</td><td>Yes</td></tr><tr><td>Save File in Response?</td><td>是否在响应数据中存储检索到的文件的内容。如果模式是ASCII，则内容将在视图结果树中可见。</td><td>"Yes, if downloading"</td></tr><tr><td>Username</td><td>FTP帐户的用户名。</td><td>Usually</td></tr><tr><td>Password</td><td>FTP帐户密码。注意:这将在测试计划中可见。</td><td>Usually</td></tr></tbody></table></div><h3 id="HTTP-Request-HTTP请求">HTTP Request | HTTP请求</h3><p>这个示例程序允许您向web服务器发送HTTP/HTTPS请求。它还允许您控制JMeter是否解析图像和其他嵌入资源的HTML文件，并发送HTTP请求来检索它们。可以检索以下类型的嵌入式资源:</p><ul><li>图片</li><li>小应用程序</li><li>样式表(CSS)和从这些文件引用的资源</li><li>外部脚本</li><li>框架,iframes</li><li>背景图片(主体，表，TD, TR)</li><li>背景声音</li></ul><p>默认的解析器是 <code>org.apache.jmeter.protocol.http.parser.LagartoBasedHtmlParser</code>。这可以通过使用 <code>htmlparser.className</code> 属性来改变。-参见jmeter.properties 的细节。</p><p>如果你打算向同一个web服务器发送多个请求，考虑使用HTTP请求默认配置元素，这样你就不必为每个HTTP请求输入相同的信息。</p><p>或者，代替手动添加HTTP请求，您可能想使用JMeter的HTTP(S)测试脚本记录器来创建它们。如果您有很多HTTP请求或带有许多参数的请求，这可以节省您的时间。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C10fa23d3cd01ba4376173c9450dfa1ab.png" alt></p><p>Screenshot of Control-Panel of HTTP Request</p><p><img src="/attachment%5C8614d4e8dba9153e66454d0393117cbb.png" alt>HTTP Request Advanced config fields</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Server</td><td>web服务器的域名或IP地址，如 <code>www.example.com</code> 。不包含<code>http://</code>前缀。注意:如果"Host"头是在header Manager中定义的，那么它将被用作虚拟主机名。</td><td>No</td></tr><tr><td>Port</td><td>web服务器正在监听的端口。默认值:80</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时。等待连接打开的毫秒数。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时。等待响应的毫秒数。注意，这适用于每次等待响应。如果服务器响应是在几个块中发送的，那么总的运行时间可能会比超时时间长。&lt;/br&gt; 持续时间断言可用于检测需要太长时间才能完成的响应。</td><td>No</td></tr><tr><td>Server (proxy)</td><td>执行请求的代理服务器的主机名或IP地址。不包含http://前缀。</td><td>No</td></tr><tr><td>Port (proxy)</td><td>代理服务器正在监听的端口。</td><td>No, unless proxy hostname is specified</td></tr><tr><td>Username</td><td>代理服务器的用户名(可选)。</td><td>No</td></tr><tr><td>Password</td><td>代理服务器密码(可选)。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Implementation</td><td>Java, HttpClient4。如果没有指定(也没有由HTTP请求默认值定义)，默认值取决于JMeter属性JMeter的值。httpsampler，如果失败，就使用HttpClient4实现。</td><td>No</td></tr><tr><td>Protocol</td><td>HTTP, HTTPS或文件。默认值:HTTP</td><td>No</td></tr><tr><td>Method</td><td>GET, POST, HEAD, TRACE, OPTIONS, PUT, DELETE, PATCH (JAVA实现不支持)。使用HttpClient4，以下与WebDav相关的方法也被允许:COPY, LOCK, MKCOL, MOVE, PROPFIND, PROPPATCH, UNLOCK, REPORT, MKCALENDAR, SEARCH。 &lt;/br&gt; 通过使用JMeter属性httpsampler.user_defined_methods，可以为HttpClient4预定义更多方法。</td><td>Yes</td></tr><tr><td>Content Encoding</td><td>要使用的内容编码(用于POST、PUT、PATCH和FILE)。这是要使用的字符编码，与内容编码HTTP报头无关。</td><td>No</td></tr><tr><td>Redirect Automatically</td><td>将底层http协议处理程序设置为自动遵循重定向，因此它们不会被JMeter看到，因此不会显示为示例。应该只用于GET和HEAD请求。HttpClient采样器将拒绝将其用于POST或PUT的尝试。</td><td>No</td></tr><tr><td>Follow Redirects</td><td>这只有在"自动重定向"未启用的情况下才有效。如果设置了，JMeter采样器将检查响应是否是重定向，如果是，则跟踪它。初始重定向和进一步的响应将作为额外的样本显示。父样例的URL和数据字段将取自最终样例(未重定向)，但父样例的字节计数和运行时间包括所有样例。延迟是从初始响应中提取的。注意HttpClient采样器可能会记录以下消息: &lt;/br&gt; <code>"Redirect requested but followRedirects is disabled"</code></td><td>No</td></tr><tr><td>Use KeepAlive</td><td>JMeter设置Connection: keep-alive头。这在默认HTTP实现中不能正常工作，因为连接重用不在用户控制之下。它与Apache HttpComponents HttpClient实现一起工作。</td><td>No</td></tr><tr><td>Use multipart/form-data for HTTP POST</td><td>使用multipart/form-data或application/x-www-form-urlencoded post请求</td><td>No</td></tr><tr><td>Browser-compatible headers</td><td>当使用multipart/form-data时，这会抑制Content-Type和Content-Transfer-Encoding头;只发送Content-Disposition头部。</td><td>No</td></tr><tr><td>Path</td><td>资源的路径(例如/servlets/myServlet)。如果资源需要查询字符串参数，在下面的"发送请求参数"部分添加它们。 &lt;/br&gt; 在这种情况下，服务器、端口和协议字段被忽略;参数对于GET和DELETE方法也会被忽略。另外请注意，该路径没有被编码——除了用%20替换空格之外——因此可能需要对不安全字符进行编码，以避免出现URISyntaxException等错误。</td><td>No</td></tr><tr><td>Send Parameters With the Request</td><td>查询字符串将从您提供的参数列表中生成。每个参数都有一个名称和值，编码参数的选项，以及包含或排除等号的选项(一些应用程序在值为空字符串时不希望有等号)。查询字符串将以正确的方式生成，取决于你所做的"方法"的选择(即，如果你选择了GET或DELETE，查询字符串将被附加到URL，如果POST或PUT，那么它将被单独发送)。此外，如果您正在使用多部分表单发送文件，那么查询字符串将使用多部分表单规范创建。</td><td>No</td></tr><tr><td>File Path</td><td>要发送的文件的名称。如果留空，JMeter不发送文件，如果填写，JMeter自动发送请求作为一个多部分表单请求。</td><td>No</td></tr><tr><td>Parameter name</td><td>"name"web请求参数的值。</td><td>No</td></tr><tr><td>MIME Type</td><td>MIME类型(例如，文本/普通)。如果是一个POST、PUT或PATCH请求，并且省略了"name"属性(下面)或者请求正文仅由参数值构造，那么该字段的值将被用作内容类型请求头的值。</td><td>No</td></tr><tr><td>从HTML文件中检索所有嵌入式资源</td><td>告诉JMeter解析HTML文件，并对文件中引用的所有图像、Java小程序、JavaScript文件、css等发送HTTP/HTTPS请求。详见下文。</td><td>No</td></tr><tr><td>Save response as MD5 hash?</td><td>如果选择此选项，则响应不会存储在示例结果中。相反，计算并存储数据的32个字符的MD5哈希值。这是为了测试大量数据。</td><td>No</td></tr><tr><td>URLs must match</td><td>如果存在，则必须是一个正则表达式，用于匹配找到的任何嵌入式url。因此，如果您只想从<code>http://example.invalid/</code>下载嵌入式资源，请使用表达式:<code>http://example\.invalid/.*</code></td><td>No</td></tr><tr><td>URLs must not match</td><td>如果存在，则必须是一个正则表达式，用于过滤掉找到的任何嵌入的url。所以，如果你不想从任何来源下载PNG或SVG文件，使用表达式:<code>.*\.(?i: SVG | PNG)</code></td><td>No</td></tr><tr><td>Use concurrent pool</td><td>使用并发连接池来获得嵌入式资源。</td><td>No</td></tr><tr><td>Size</td><td>用于获取嵌入式资源的并发连接的池大小。</td><td>No</td></tr><tr><td>Source address type</td><td>只适用于HTTPClient实现的HTTP请求 &lt;/br&gt;要区分源地址值</td><td>No</td></tr><tr><td>Source address field</td><td>只适用于HTTPClient实现的HTTP请求&lt;/br&gt;此属性用于启用IP欺骗。它覆盖了这个示例的默认本地IP地址。JMeter主机必须有多个IP地址(即IP别名、网络接口、设备)。取值为主机名、IP地址或网口设备，如"eth0"、"lo"、"wlan0"。&lt;/br&gt;如果属性httpclient。定义了localaddress，用于所有HttpClient请求。</td><td>No</td></tr></tbody></table></div><h3 id="JDBC-Request-JDBC-请求">JDBC Request | JDBC 请求</h3><p>这个示例程序允许向数据库发送JDBC请求(一个SQL查询)。</p><p>在使用它之前，您需要设置一个[JDBC Connection Configuration] Configuration元素</p><p>如果提供了Variable Names列表，那么对于Select语句返回的每一行，将使用相应列的值设置变量(如果提供了变量名)，并设置行数。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C9c9ae2a4f9139da9cf540c698bfaf715.png" alt>Screenshot of Control-Panel of JDBC Request</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Variable Name of Pool declared in JDBC Connection Configuration</td><td>连接池绑定到的JMeter变量的名称。这必须与 [JDBC Connection Configuration] 中的 <code>Variable Name</code> 字段一致。</td><td>No</td></tr><tr><td>Query Type</td><td>根据语句类型设置 &lt;/br&gt; - Select Statement&lt;/br&gt; - Update Statement - use this for Inserts and Deletes as well&lt;/br&gt; - Callable Statement&lt;/br&gt;Prepared Select Statement&lt;/br&gt; - Prepared Update Statement - use this for Inserts and Deletes as well&lt;/br&gt; - Commit&lt;/br&gt; - Rollback&lt;/br&gt; - Autocommit(false)&lt;/br&gt; - Autocommit(true)&lt;/br&gt; - Edit - this should be a variable reference that evaluates to one of the above &lt;/br&gt; &lt;/br&gt; <strong>Commit、Rollback、Autocommit(false)和Autocommit(true)类型是特殊的，因为它们只会忽略给定的SQL语句并改变连接的状态。</strong></td><td>Yes</td></tr><tr><td>SQL Query</td><td>SQL query.    &lt;/br&gt;&lt;/br&gt;  <strong>Do not enter a trailing semi-colon.</strong></td><td>Yes</td></tr><tr><td>Parameter values</td><td>逗号分隔的参数值列表。使用<code>]NULL[</code>来表示<code>NULL</code>参数。(如果需要，可以通过定义属性"<code>jdbcsampler.nullmarker</code>"来更改空字符串。)例如，如果任何值包含逗号或双引号，列表必须用双引号括起来，并且任何嵌入的双引号必须是双引号</td><td>Yes, if a prepared or callable statement has parameters</td></tr><tr><td>Parameter types</td><td>逗号分隔的SQL参数类型列表(例如INTEGER, DATE, VARCHAR, DOUBLE)或Constants的整数值。当您使用驱动程序建议的自定义数据库类型(例如OracleTypes。CURSOR可以用其整数值-10表示)。 它们被定义为java.sql类中的字段。</td><td>Yes, if a prepared or callable statement has parameters</td></tr><tr><td>Variable Names</td><td>逗号分隔的变量名列表，用于保存Select语句、Prepared Select语句或CallableStatement返回的值。注意，当与CallableStatement一起使用时，变量列表必须与调用返回的OUT参数的顺序相同。如果变量名比OUT参数少，那么在线程上下文变量中存储的结果与提供的变量名相同。如果存在比OUT参数更多的变量名，则会忽略额外的变量</td><td>No</td></tr><tr><td>Result Variable Name</td><td>如果指定，这将创建一个包含行映射列表的Object变量。每个映射都包含列名作为键，列数据作为值。</td><td>No</td></tr><tr><td>Query timeout(s)</td><td>设置以秒为单位的查询超时时间，空值表示0，表示无穷大。-1意味着不设置任何查询超时，这可能需要用例或当某些驱动程序不支持超时。默认值为0。</td><td>No</td></tr><tr><td>Limit ResultSet</td><td>限制遍历ResultSet的行数。空值意味着-1，例如没有限制，这也是默认值。这可以帮助减少通过JDBC驱动程序从数据库中获取的数据量，但会分别影响Handle ResultSet的所有可能选项——例如:incomplete ResultSet和记录计数≤限制。</td><td>No</td></tr><tr><td>Handle ResultSet</td><td>定义如何处理可调用语句返回的ResultSet &lt;/br&gt; &lt;/br&gt; - <strong>Store As String</strong> (默认)——变量名列表中的所有变量都存储为字符串，当出现在列表中时，不会遍历ResultSet。clob将被转换为string。blob将被转换为string，就像它们是UTF-8编码的字节数组一样。在jdbcsampler之后，clob和blob都将被切断。max_retain_result_size字节。 &lt;/br&gt; - <strong>Store As Object</strong>——变量名称列表中的ResultSet类型的变量将存储为对象，可以在后续的测试/脚本中访问和迭代，不会遍历ResultSet。将像选择Store as String一样处理clob。blob将存储为字节数组。在jdbcsampler之后，clob和blob都将被切断。max_retain_result_size字节。 &lt;/br&gt; - <strong>Count Records</strong>——ResultSet类型的变量将通过显示作为结果的记录计数进行迭代。变量将被存储为string。对于blob，将存储对象的大小。</td><td>No</td></tr></tbody></table></div><h3 id="Java-Request-Java-请求">Java Request | Java 请求</h3><p>这个采样器允许您控制一个实现<code>org.apache.jmeter.protocol.java.sampler.JavaSamplerClient</code>接口的java类。通过编写您自己的这个接口的实现，您可以使用JMeter来利用多线程、输入参数控制和数据收集。</p><p>下拉菜单提供了JMeter在其类路径中找到的所有此类实现的列表。然后可以在下表中指定参数—由您的实现定义。提供了两个简单的示例(JavaTest和SleepTest)。</p><p>JavaTest示例采样器对于检查测试计划很有用，因为它允许在几乎所有字段中设置值。然后，断言等可以使用它们。字段允许使用变量，因此可以很容易地看到这些变量的值。</p><blockquote><p>如果方法teardownTest没有被AbstractJavaSamplerClient的子类覆盖，它的teardownTest方法将不会被调用。这减少了JMeter的内存需求。这不会对现有的Test计划产生任何影响。</p></blockquote><blockquote><p>添加/删除按钮目前没有任何作用。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cd1de1a1316e90d2ccc3756391c82334d.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Classname</td><td>要采样的JavaSamplerClient接口的具体实现。</td><td>Yes</td></tr><tr><td>Send Parameters with Request</td><td>将传递给采样类的参数列表。所有参数都作为字符串发送。具体设置见下文。</td><td>No</td></tr></tbody></table></div><h3 id="BeanShell-Sampler-BeanShell-采样器">BeanShell Sampler | BeanShell 采样器</h3><p>这个采样器允许您使用BeanShell脚本语言编写一个采样器。</p><p>test元素支持ThreadListener和TestListener接口方法。它们必须在初始化文件中定义。请参阅文件BeanShellListeners。示例定义为BSHRC。BeanShell采样器还支持可中断接口。可以在脚本或init文件中定义interrupt()方法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cceb6514c12ffddbf2784b0088cd6b460.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。名称存储在脚本变量Label中</td><td>No</td></tr><tr><td>Reset bsh.Interpreter before each call</td><td>如果选择此选项，则将为每个示例重新创建解释器。对于一些长期运行的脚本来说，这可能是必要的。有关更多信息，请参阅最佳实践—BeanShell脚本。</td><td>Yes</td></tr><tr><td>Parameters</td><td>传递给BeanShell脚本的参数。这是为了与脚本文件一起使用;对于在GUI中定义的脚本，您可以使用脚本本身中需要的任何变量和函数引用。</td><td>No</td></tr><tr><td>Script file</td><td>包含要运行的BeanShell脚本的文件。文件名存储在脚本变量FileName中</td><td>No</td></tr><tr><td>Script</td><td>要运行的BeanShell脚本。返回值(如果不是null)存储为采样结果。</td><td>Yes (unless script file is provided)</td></tr></tbody></table></div><h3 id="TCP-Sampler-TCP采样器">TCP Sampler | TCP采样器</h3><p>TCP采样器打开一个TCP/IP连接到指定的服务器。然后它发送文本，并等待响应。</p><p>如果选择 “Re-use connection”，在相同线程中的sampler之间共享连接，前提是使用完全相同的主机名字符串和端口。不同的主机/端口组合将使用不同的连接，就像不同的线程一样。如果"Re-use connection"和 “Close connection” 都被选中，套接字将在运行采样器后关闭。在下一个采样器上，将创建另一个 socket。您可能希望在每个线程循环结束时关闭一个 socket。</p><p>以下属性可用于控制其操作:</p><ul><li><code>tcp.status.prefix</code> 文本在状态号之前</li><li><code>tcp.status.suffix</code>文本在状态号之后</li><li><code>tcp.status.properties</code>属性文件的名称，用于将状态码转换为消息</li><li><code>tcp.handler</code> TCP处理程序类的名称(默认TCPClientImpl) -仅在GUI上没有指定时使用</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb4fe9d427f42f3072c562649e012e20e.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>TCPClient classname</td><td>TCPClient类的名称。默认为 <code>tcp.handler</code>。处理程序，<code>TCPClientImpl</code>失败。</td><td>Yes</td></tr><tr><td>ServerName or IP</td><td>TCP服务器的名称或IP</td><td>Yes</td></tr><tr><td>Port Number</td><td>使用的端口</td><td>Yes</td></tr><tr><td>Re-use connection</td><td>如果选中，连接将保持打开状态。否则在读取数据时关闭。</td><td>Yes</td></tr><tr><td>Close connection</td><td>如果选择，则在运行采样器后将关闭连接。</td><td>No</td></tr><tr><td>SO_LINGER</td><td>在创建 <code>socket</code> 时使用指定的延迟时间(秒)启用/禁用SO_LINGER。如果你设置"SO_LINGER"值为0，你可能会阻止大量带有TIME_WAIT状态的套接字闲置。</td><td>No</td></tr><tr><td>End of line(EOL) byte value</td><td>行尾的字节值，将其设置为范围<code>-128</code>到<code>+127</code>以外的值，以跳过<code>eol</code>检查。你可以在 <code>jmeter.properties</code> 中设置这个以及eolByte属性。如果你在TCP采样配置和jmeter中设置这个。属性文件的同时，将使用TCP采样器配置中的设置值。</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时(毫秒，0禁用)。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时(毫秒，0禁用)。</td><td>Yes</td></tr><tr><td>Set NoDelay</td><td>看<code>java.net.Socket.setTcpNoDelay()</code>。如果选中，将禁用Nagle的算法，否则将使用Nagle的算法。</td><td>Yes</td></tr><tr><td>Text to Send</td><td>要发送的文本</td><td>Yes</td></tr><tr><td>Login User</td><td>用户名-默认实现中未使用</td><td>No</td></tr><tr><td>Password</td><td>密码-默认实现中不使用(注意，这个未加密存储在测试计划中)</td><td>No</td></tr></tbody></table></div><h3 id="Mail-Reader-Sampler-邮件阅读采样器">Mail Reader Sampler | 邮件阅读采样器</h3><p>邮件阅读器采样器可以使用POP3(S)或IMAP(S)协议读取(并可选地删除)邮件消息。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C11aabe48e984000aa7f78cd7e353602f.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/采样器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter</title>
      <link href="/jmeter/jmeter/"/>
      <url>/jmeter/jmeter/</url>
      
        <content type="html"><![CDATA[<h1>JMeter</h1><h2 id="Metadata-14">Metadata</h2><pre><code class="language-yml">title: JMeterdate: 2022-12-13 13:16tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/测试工具  - 细化主题/JMetercategories:  - 工具keywords:  - 测试工具description: Apache JMeter™应用程序是开源软件，100%纯Java应用程序，用于加载测试功能行为和测量性能。它最初是为测试Web应用程序而设计的，但后来扩展到其他测试功能。</code></pre><h2 id="推荐指数：">推荐指数：</h2><ul><li>实用性： ⭐⭐⭐</li><li>稳定性： ⭐⭐⭐⭐⭐</li><li>复杂性：⭐⭐⭐⭐</li></ul><h2 id="文件结构">文件结构</h2><pre><code class="language-text">- bin - 启动jmeter的所有文件    - properties结尾的文件，都是jmeter的属性配置文件，最主要的是`jmeter.properties`    - create-rmi-keystore：创建证书    - jmeter.log：日志打印- docs  - 开发人员使用的api文档- extras  - 持续集成CI/CD使用- lib  - jmeter工具的源码二进制jar包    - `/ext`：使用第三方插件时，把第三方jar放到该目录- printable_docs  - jmeter工具，离线帮助文档</code></pre><h2 id="开发接口测试案例的整体方案">开发接口测试案例的整体方案</h2><ul><li>第一步：我们要分析出测试需求，并拿到开发提供的接口说明文档；</li><li>第二步：从接口说明文档中整理出接口测试案例，里面要包括详细的入参和出参数据以及明确的格式和检查点。</li><li>第三步：和开发一起对接口测试案例进行评审。</li><li>第四步：结合开发库，准备接口测试案例中的入参数据和出参数据，并整理成 csv 格式的文件。</li><li>第五步：结合接口测试案例文档和 csv 格式的数据文档，做接口测试案例的自动化案例开发。</li></ul><h2 id="接口自动化适用场景">接口自动化适用场景</h2><ol><li><p>测试前置、开发自测：一个新的自动化接口测试案例开发完成后，直接发给接口对应的开发，安排在开发本地环境执行，一旦开发确认完成接口开发，就开始执行接口测试案例，基本上可以实时拿到测试结果，方便开发快速做出判断。【开发本地运行的方式就是打开 JMeter 工具，导入 JMX 文件，开始执行可。】</p></li><li><p>回归测试：开发本地测试通过后，或整个需求手工测试通过后，把自动化的接口测试案例做分类整理，挑选出需要纳入到回归测试中的案例，在持续集成环境重新准备测试数据，并把案例纳入到持续集成的 job 中来，这些用于回归的接口测试案例需要配置到持续集成平台自动运行。</p></li></ol><h2 id="测试计划-元素">测试计划 元素</h2><h3 id="执行顺序">执行顺序</h3><ol start="0"><li>配置元素</li><li>预处理器</li><li>计时器</li><li>采样器</li><li>后处理器（除非 SampleResult 为null）</li><li>断言（除非 SampleResult 为null）</li><li>侦听器（除非 SampleResult 为null）</li></ol><h3 id="组件">组件</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">测试计划</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">线程组</p><ul><li>线程组元素是任何测试计划的起点。</li><li>所有控制器和采样器都必须在一个线程组下。</li><li>线程组的控件允许您：<ul><li>设置线程数</li><li>设置加速周期</li><li>设置执行测试的次数</li></ul></li><li>设置完成时间</li><li>指定线程生命周期</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">采样器</p><p>采样器告诉 JMeter 向服务器发送请求并等待响应。它们按照它们在树中出现的顺序进行处理。控制器可用于修改采样器的重复次数。</p><p>采样器包括</p><ul><li>FTP 请求</li><li>HTTP 请求（也可用于 SOAP 或 REST Web 服务）</li><li>JDBC 请求</li><li>Java 对象请求</li><li>JMS 请求</li><li>JUnit 测试请求</li><li>LDAP 请求</li><li>邮件请求</li><li>操作系统进程请求</li><li>TCP 请求</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">逻辑控制器</p><p>允许您自定义 JMeter 用来决定何时发送请求的逻辑。逻辑控制器可以更改来自其子元素的请求的顺序。他们可以自己修改请求，导致 JMeter 重复请求等。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">监听器</p><ul><li>侦听器提供对 JMeter 在 JMeter 运行时收集的有关测试用例的信息的访问。</li><li>侦听器可以将数据定向到文件以供以后使用。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">计时器</p><p>添加到您的线程组来指定延迟</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">断言</p><p>断言允许您断言有关从正在测试的服务器收到的响应的事实。使用断言，您基本上可以“测试”您的应用程序正在返回您期望的结果。</p><p>断言适用于其<a href="#scoping_rules">范围内</a>的所有采样器。要将断言限制为单个采样器，请将断言添加为采样器的子级。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">配置元素</p><ul><li>配置元素与采样器密切合作。</li><li>只能从放置元素的树分支内部访问配置元素。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">预处理器</p><ul><li>预处理器在发出采样器请求之前执行一些操作。如果预处理器附加到采样器元素，则它将在该采样器元素运行之前执行。</li><li>预处理器最常用于在样本请求运行之前修改其设置，或更新未从响应文本中提取的变量。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">后处理器</p><ul><li>在发出采样器请求后，后处理器会执行一些操作。如果 Post-Processor 附加到 Sampler 元素，则它将在该 sampler 元素运行后立即执行。</li><li>后处理器最常用于处理响应数据，通常用于从中提取值。</li></ul></div><h2 id="构建测试计划">构建测试计划</h2><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">添加和删除元素</p><p>可以通过右键单击树中的元素并从“添加”列表中选择一个新元素来向测试计划添加元素。或者，可以通过选择“合并”或“打开”选项从文件中加载元素并添加元素。</p><p>要删除一个元素，请确保该元素已被选中，右键单击该元素，然后选择“删除”选项。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">加载和保存元素</p><p>要从文件加载元素，右键单击要添加加载元素的现有树元素，然后选择“合并”选项。选择保存元素的文件。JMeter 会将元素合并到树中。</p><p>要保存树元素，请右键单击一个元素并选择“将选择另存为... ”选项。JMeter 将保存选定的元素，以及它下面的所有子元素。这样，您可以保存测试树片段和单个元素以供以后使用。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">配置树元素</p><p>测试树中的任何元素都将在 JMeter 的右侧框架中显示控件。这些控件允许您配置该特定测试元素的行为。可以为元素配置什么取决于它是什么类型的元素。</p><p>测试树本身可以通过在测试树周围拖放组件来操作。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">保存测试计划</p><p>尽管不是必需的，但我们建议您在运行测试计划之前将其保存到文件中。要保存测试计划，请从文件菜单中选择“保存”或“将测试计划另存为... ”（对于最新版本，不再需要先选择测试计划元素）。</p><p>JMeter 允许您保存整个测试计划树或仅保存其中的一部分。要仅保存位于测试计划树的特定“分支”中的元素，请在树中选择“测试计划”元素以启动“分支”，然后单击鼠标右键访问“将选择另存为... " 菜单项。或者，选择适当的测试计划元素，然后从“编辑”菜单中 选择“将选择另存为... ”。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">运行测试计划</p><p>要运行您的测试计划，请从“运行”菜单项中选择“开始”（Control  +  r） 。当 JMeter 运行时，它会在菜单栏下方的部分右侧显示一个绿色小框。您还可以检查“运行”菜单。如果“开始”被禁用，并且“停止”被启用，那么 JMeter 正在运行您的测试计划（或者，至少，它认为是这样）。</p><p>绿色框左侧的数字是活动线程数/线程总数。这些仅适用于本地运行的测试；它们不包括使用客户端-服务器模式时在远程系统上启动的任何线程。</p><p>仅在调试测试计划时才应使用此处描述的 GUI 模式。要运行实际负载测试，请使用 CLI 模式。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">停止测试</p><p>菜单中有两种可用的停止命令：</p><p>Stop ( Control  +  . ) - 如果可能，立即停止线程。许多采样器是可中断的，这意味着活动采样可以提前终止。stop 命令将检查所有线程是否已在默认超时时间内停止，即 5000 ms = 5 秒。[这可以使用 JMeter 属性jmeterengine.threadstop.wait进行更改] 如果线程没有停止，则会显示一条消息。停止命令可以重试，但如果失败，则需要退出 JMeter 进行清理。Shutdown ( Control  +  , ) - 请求线程在任何当前工作结束时停止。不会中断任何活动样本。模式关闭对话框将保持活动状态，直到所有线程都停止。如果关机时间过长。关闭 Shutdown 对话框并选择Run / Stop，或者只需按Control  +  。.</p><p>在 CLI 模式下运行 JMeter 时，没有菜单，并且 JMeter 不会对诸如Control  + 等按键做出反应。. 因此 JMeter CLI 模式将监听特定端口上的命令（默认4445，请参阅 JMeter 属性jmeterengine.nongui.port）。如果正在使用默认端口（例如由另一个 JMeter 实例），JMeter 支持自动选择备用端口。在这种情况下，JMeter 将尝试下一个更高的端口，一直持续到它到达默认为 4455 的JMeter属性<code>jmeterengine.nongui.maxport</code>。如果<code>maxport</code>小于或等于port，则不会进行端口扫描。</p><p>所选端口显示在控制台窗口中。</p><p>目前支持的命令有：</p><ul><li>shotdown - 优雅关机</li><li>StopTestNow - 立即关闭</li></ul><p>这些命令可以分别使用<code>shutdown[.cmd|.sh]</code>或<code>stoptest[.cmd|.sh]</code>脚本发送。这些脚本可以在 JMeter bin目录中找到。仅当脚本从同一主机运行时，才会接受这些命令。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">错误报告</p><p>JMeter 向jmeter.log文件 报告警告和错误，以及测试运行本身的一些信息。JMeter 在其窗口右侧的警告图标（三角形）旁边显示在jmeter.log文件中发现的警告/错误的数量。单击警告图标以在 JMeter 窗口的底部显示jmeter.log文件。只是偶尔可能会出现一些 JMeter 无法捕获和记录的错误；这些将出现在命令控制台上。如果测试没有按预期进行，请检查日志文件以防报告任何错误（例如，可能是函数调用中的语法错误）。</p><p>日志文件中通常不会报告采样错误（例如 HTTP 404 - 未找到文件）。相反，这些被存储为样本结果的属性。可以在各种不同的侦听器中看到样本结果的状态。</p></div><h2 id="命令行选项的完整列表">命令行选项的完整列表</h2><p>调用JMeter作为<code>JMeter -?</code>将打印所有命令行选项的列表。它们如下所示。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">JMeter 命令行列表</p><pre><code class="language-shell">    --?        print command line options and exit    -h, --help        print usage information and exit    -v, --version        print the version information and exit    -p, --propfile &lt;argument&gt;        the jmeter property file to use    -q, --addprop &lt;argument&gt;        additional JMeter property file(s)    -t, --testfile &lt;argument&gt;        the jmeter test(.jmx) file to run    -l, --logfile &lt;argument&gt;        the file to log samples to    -i, --jmeterlogconf &lt;argument&gt;        jmeter logging configuration file (log4j2.xml)    -j, --jmeterlogfile &lt;argument&gt;        jmeter run log file (jmeter.log)    -n, --nongui        run JMeter in nongui mode    -s, --server        run the JMeter server    -H, --proxyHost &lt;argument&gt;        Set a proxy server for JMeter to use    -P, --proxyPort &lt;argument&gt;        Set proxy server port for JMeter to use    -N, --nonProxyHosts &lt;argument&gt;        Set nonproxy host list (e.g. *.apache.org|localhost)    -u, --username &lt;argument&gt;        Set username for proxy server that JMeter is to use    -a, --password &lt;argument&gt;        Set password for proxy server that JMeter is to use    -J, --jmeterproperty &lt;argument&gt;=&lt;value&gt;        Define additional JMeter properties    -G, --globalproperty &lt;argument&gt;=&lt;value&gt;        Define Global properties (sent to servers)        e.g. -Gport=123         or -Gglobal.properties    -D, --systemproperty &lt;argument&gt;=&lt;value&gt;        Define additional system properties    -S, --systemPropertyFile &lt;argument&gt;        additional system property file(s)    -f, --forceDeleteResultFile        force delete existing results files and web report folder if present before starting the test    -L, --loglevel &lt;argument&gt;=&lt;value&gt;        [category=]level e.g. jorphan=INFO, jmeter.util=DEBUG or com.example.foo=WARN    -r, --runremote        Start remote servers (as defined in remote_hosts)    -R, --remotestart &lt;argument&gt;        Start these remote servers (overrides remote_hosts)    -d, --homedir &lt;argument&gt;        the jmeter home directory to use    -X, --remoteexit        Exit the remote servers at end of test (CLI mode)    -g, --reportonly &lt;argument&gt;        generate report dashboard only, from a test results file    -e, --reportatendofloadtests        generate report dashboard after load test    -o, --reportoutputfolder &lt;argument&gt;        output folder for report dashboard</code></pre></div><h2 id="JMeter-配置">JMeter 配置</h2><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>ssl.provider</td><td>如果不想使用内置Java实现，可以为SSL实现指定类。</td><td>No</td></tr><tr><td>xml.parser</td><td>您可以指定一个实现作为XML解析器。默认值为: <code>org.apache.xerces.parser . saxparser</code></td><td>No</td></tr><tr><td>remote_hosts</td><td>以逗号分隔的远程JMeter主机列表(如果需要，可以选择主机:端口)。如果您在分布式环境中运行JMeter，请列出运行JMeter远程服务器的机器。这将允许您从这台机器的GUI控制这些服务器</td><td>No</td></tr><tr><td>not_in_menu</td><td>不希望在JMeter菜单中看到的组件列表。随着JMeter添加了越来越多的组件，您可能希望自定义JMeter以只显示您感兴趣的那些组件。您可以在这里列出它们的类名或类标签(出现在JMeter UI中的字符串)，它们将不再出现在菜单中。</td><td>No</td></tr><tr><td>search_paths</td><td>JMeter将搜索JMeter插件类的路径列表(以;分隔)，例如额外的采样器。路径项可以是jar文件或目录。在这样一个目录中的任何jar文件将自动包含在search_path中，子目录中的jar文件将被忽略。给定的值是在lib/ext目录中找到的任何jar之外的值。</td><td>No</td></tr><tr><td>user.classpath</td><td>JMeter将搜索实用程序和插件依赖类的路径列表。使用平台路径分隔符分隔多个路径。路径项可以是jar文件或目录。这样一个目录中的任何jar文件都将自动包含在user中。类路径，子目录中的jar文件将被忽略。给定的值是在lib目录中找到的任何jar之外的值。所有条目都将添加到系统类装入器的类路径中，也会添加到JMeter内部装入器的路径中。</td><td>No</td></tr><tr><td>plugin_dependency_paths</td><td>JMeter将搜索实用程序和插件依赖类的路径列表(以;分隔)。路径项可以是jar文件或目录。在这样一个目录中的任何jar文件将自动包含在plugin_dependency_paths中，子目录中的jar文件将被忽略。给定的值是在lib目录中找到的jar文件之外的，或者是用户给出的。类路径属性。所有条目将只被添加到JMeter内部加载器的路径中。对于插件依赖，使用plugin_dependency_paths应该优于user.classpath。</td><td>No</td></tr><tr><td>user.properties</td><td>包含附加JMeter属性的文件的名称。它们添加在初始属性文件之后，但在处理-q和-J选项之前。</td><td>No</td></tr><tr><td>system.properties</td><td>包含附加系统属性的文件的名称。在处理-S和-D选项之前添加这些选项。</td><td>No</td></tr></tbody></table><p>命令行选项和属性文件的处理顺序如下:</p><ol><li>-p propfile</li><li>jmeter.properties (or the file from the -p option) is then loaded</li><li>-j logfile</li><li>Logging is initialised</li><li>user.properties is loaded</li><li>system.properties is loaded</li><li>all other command-line options are processed</li></ol><h2 id="组件详解">组件详解</h2><ul><li><a href="../jmeter-zu-jian-xiang-jie-assertions-duan-yan">Assertions 断言</a></li><li><a href="../jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian">Configuration 配置原件</a></li><li><a href="../jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi">Listeners 监听器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi">Logic Controller 控制器</a></li><li><a href="jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi">Pre-Processors 前置处理器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi">Post Processors 后置处理器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi">Samplers 采样器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-timers-ding-shi-qi">Timers 定时器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/测试工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-个人博客-索引</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-suo-yin/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1>hexo-个人博客-索引</h1><h2 id="Metadata-3">Metadata</h2><pre><code class="language-yml">- title: hexo-个人博客-索引- date: 2022-08-09 14:42- version: Version 1.1.0- updated: 2022-08-09 14:42- aside: true- top_img: - comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - Blog  - index- categories:  - hexo- keyword:  - 索引- description: hexo的个人博客的相关文章索引</code></pre><h2 id="索引">索引</h2><h3 id="hexo-个人博客-构建教程">hexo-个人博客-构建教程</h3><p><a href="../hexo-ge-ren-bo-ke-gou-jian-jiao-cheng">点我跳转</a></p><p><strong>TOC</strong></p><ul><li>安装及配置</li><li>hexo 的相关命令</li></ul><h3 id="hexo-个人博客-个性化-matery主题">hexo-个人博客-个性化-matery主题</h3><p><a href="../hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti">点我跳转</a></p><p><strong>TOC</strong></p><ul><li>简介</li><li>下载</li><li>配置</li><li>文章 Front-matter 介绍</li><li>效果截图</li><li>自定制修改</li><li>版本变更记录</li><li>更多部署方式</li></ul><h2 id="更新日志-2">更新日志</h2><h3 id="Version-1-0-0-2">Version 1.0.0</h3><p><strong>Done</strong></p><ul><li>hexo-个人博客-构建教程</li><li>hexo-个人博客-个性化-matery主题</li></ul><p><strong>TODO</strong></p><ul><li></li></ul><h3 id="Version-1-1-0-2">Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02_hexo-个人博客-个性化-matery主题</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti/</url>
      
        <content type="html"><![CDATA[<h1>hexo-个人博客-个性化-matery主题</h1><h2 id="Metadata">Metadata</h2><pre><code class="language-yml">- title: hexo-个人博客-个性化-matery主题- date: 2022-08-09 11:02- version: Version 1.1.0- updated: 2022-08-09 11:02- aside: true- top_img:- comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - hexo-theme  - Blog  - matery- categories:  - hexo- keywords:  - matery 主题- description: hexo-theme-matery主题的相关介绍和配置</code></pre><h2 id="简介">简介</h2><blockquote><p>这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。</p></blockquote><h3 id="跳转链接">跳转链接</h3><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery">github hexo-theme-matery</a></li><li><a href="http://blinkfox.com/">国内访问示例</a></li></ul><h3 id="特性">特性</h3><ul><li>简单漂亮，文章内容美观易读</li><li>Material Design 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 Banner 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li>词云的标签页和雷达图的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 MathJax</li><li>TOC 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li>Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk）</li><li>集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li><li>支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。</li><li>支持 DaoVoice、Tidio 在线聊天功能。</li></ul><h2 id="下载">下载</h2><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。</p><p>当然你也可以在你的 themes 文件夹下使用 git clone 命令来下载:</p><pre><code class="language-git">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置">配置</h2><h3 id="切换主题">切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 theme 的值：<code>theme: hexo-theme-matery</code></p><p><strong>_config.yml 文件的其它修改建议:</strong></p><ul><li>请修改 <code>_config.yml</code> 的 url 的值为你的网站主 URL（如：<a href="http://xxx.github.io">http://xxx.github.io</a>）。</li><li>建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 language 的值为 zh-CN。</li></ul><h3 id="相关页面">相关页面</h3><h4 id="新建分类-categories-页">新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "categories"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h4 id="新建标签-tags-页">新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "tags"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h4 id="新建关于我-about-页">新建关于我 about 页</h4><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "about"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---</code></pre><h4 id="新建留言板-contact-页（可选的）">新建留言板 contact 页（可选的）</h4><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "contact"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: contactdate: 2018-09-30 17:25:30type: "contact"layout: "contact"---</code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h4 id="新建友情链接-friends-页（可选的）">新建友情链接 friends 页（可选的）</h4><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "friends"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---</code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre><code class="language-json">[{    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",    "name": "码酱",    "introduction": "我不是大佬，只是在追寻大佬的脚步",    "url": "http://luokangyuan.com/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/4027734.jpeg",    "name": "闪烁之狐",    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",    "url": "https://blinkfox.github.io/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/avatar.jpg",    "name": "ja_rome",    "introduction": "平凡的脚步也可以走出伟大的行程",    "url": "https://me.csdn.net/jlh912008548",    "title": "前去学习"}]</code></pre><h4 id="新建-404-页">新建 404 页</h4><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre><code class="language-bash">hexo new page 404</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: 404date: 2018-09-30 17:25:30type: "404"layout: "404"description: "Oops～，我崩溃了！找不到你想要的页面 :("---</code></pre><h3 id="菜单导航配置">菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon">配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找</p><pre><code class="language-yaml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle  Friends:    url: /friends    icon: fas fa-address-book</code></pre><h4 id="二级菜单配置方法">二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)</li><li>在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.</li><li>注意每个二级菜单模块前要加 <code>-</code>.</li><li>注意缩进格式</li></ol><pre><code class="language-yaml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle-o  Friends:    url: /friends    icon: fas fa-address-book  Medias:    icon: fas fa-list    children:      - name: Music        url: /music        icon: fas fa-music      - name: Movies        url: /movies        icon: fas fa-film      - name: Books        url: /books        icon: fas fa-book      - name: Galleries        url: /galleries        icon: fas fa-image</code></pre><h3 id="代码高亮">代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre><code class="language-yaml">highlight:  enable: false  line_number: true  auto_detect: false  tab_replace: ''  wrap: true  hljs: falseprismjs:  enable: true  preprocess: true  line_number: true  tab_replace: ''</code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索">搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre><code class="language-bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="language-yaml">search:  path: search.xml  field: post</code></pre><h3 id="中文链接转拼音（建议安装）">中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre><code class="language-bash">npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="language-yaml">permalink_pinyin:  enable: true  separator: '-' # default: '-'</code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）">文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre><code class="language-bash">npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre><code class="language-yaml">postInfo:  date: true  update: false  wordCount: false # 设置文章字数统计为 true.  totalCount: false # 设置站点文章总字数统计为 true.  min2read: false # 阅读时长.  readCount: false # 阅读次数.</code></pre><h3 id="添加emoji表情支持（可选的）">添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre><code class="language-bash">npm install hexo-filter-github-emojis --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="language-yaml">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h3 id="添加-RSS-订阅支持（可选的）">添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre><code class="language-bash">npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="language-yaml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）">添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）">添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚">修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接">修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre><code class="language-html">&lt;% if (theme.socialLink.github) { %&gt;    &lt;a href="&lt;%= theme.socialLink.github %&gt;" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt;        &lt;i class="fab fa-github"&gt;&lt;/i&gt;    &lt;/a&gt;&lt;% } %&gt;</code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片">修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）">配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre><code class="language-yaml"># 是否在首页显示音乐music:  enable: true  title:         # 非吸底模式有效    enable: true    show: 听听音乐  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 503838841     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠</code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="添加note">添加note</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-note"></a></p></blockquote><h4 id="Usage">Usage</h4><pre><code>{% note [class] [no-icon] [summary] %}Any content (support inline tags too).{% endnote %}</code></pre><ul><li><code>[class]</code> : <em>Optional parameter.</em> Supported values: default | primary | success | info | warning | danger.</li><li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon in note.</li><li><code>[summary]</code> : <em>Optional parameter.</em> Optional summary of the note.</li></ul><p>All parameters are optional.</p><h4 id="example">example</h4><pre><code>{% note %}#### Header(without define class style){% endnote %}</code></pre><h3 id="添加button">添加button</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-button"></a></p></blockquote><h4 id="Usage-2">Usage</h4><pre><code>{% button url, text, icon [class], [title] %}</code></pre><p>or</p><pre><code>{% btn url, text, icon [class], [title] %}</code></pre><ul><li><code>url</code> : Absolute or relative path to URL.</li><li><code>text</code> : Button text. Required if no icon specified.</li><li><code>icon</code> : Font Awesome icon name. Required if no text specified.</li><li><code>[class]</code> : <em>Optional parameter.</em> Font Awesome class(es): <code>fa-fw</code> | <code>fa-lg</code> | <code>fa-2x</code> | <code>fa-3x</code> | <code>fa-4x</code> | <code>fa-5x</code></li><li><code>[title]</code> : <em>Optional parameter.</em> Tooltip at mouseover.</li></ul><h4 id="Examples">Examples</h4><pre><code>{% button #, Text %}</code></pre><h2 id="文章-Front-matter-介绍">文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解">Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例">最简示例</h3><pre><code class="language-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例">最全示例</h3><pre><code class="language-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="效果截图">效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改">自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色">修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre><code class="language-css">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="修改-banner-图和文章特色图">修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre><code class="language-javascript">$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');</code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本变更记录">版本变更记录</h2><p>参见 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/CHANGELOG.md">CHANGELOG.md</a></p><h2 id="更多部署方式">更多部署方式</h2><blockquote><p>Jsdelivr 已经被封了，这两个可以加速访问快一点</p></blockquote><ul><li><p><a href="https://blog.17lai.site/posts/5311b619/#vercel-%E9%83%A8%E7%BD%B2"></a></p></li><li><p><a href="https://blog.17lai.site/posts/5311b619/#cloudflare-Pages-%E9%83%A8%E7%BD%B2"></a></p></li></ul><h2 id="BUG-及-解决">BUG 及 解决</h2><ul><li></li></ul><h2 id="更新日志">更新日志</h2><h3 id="Version-1-0-0">Version 1.0.0</h3><p><strong>Done</strong></p><ul><li>文章的创建</li><li>matery 主题的介绍及下载配置</li></ul><p><strong>TODO</strong></p><ul><li></li></ul><h3 id="Version-1-1-0">Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul><h2 id="参考文献">参考文献</h2><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a><ul><li>README_CN.md</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo-theme </tag>
            
            <tag> Blog </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01_hexo-个人博客-构建教程</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-gou-jian-jiao-cheng/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-gou-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1>hexo-个人博客-构建教程</h1><h2 id="Metadata-4">Metadata</h2><pre><code class="language-yml">- title: hexo-个人博客 构建教程- date: 2022-08-07 15:44- version: Version 1.1.0- updated: 2022-08-07 15:44- aside: true- top_img: - comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - gitlab  - Blog- categories:  - hexo- keywords:  - 构建教程- description: hexo的个人博客搭建教程 - 包括基础的配置，bug的修复，与github的连接以及 matery主题的简记</code></pre><h2 id="安装及配置">安装及配置</h2><h3 id="安装-Node-js">安装 Node.js</h3><ol><li>下载Node.js。</li><li>安装选项全部默认，一路点击Next。</li><li>输入node -v和npm -v，如果出现版本号，那么就安装成功了。</li></ol><h3 id="安装-git">安装 git</h3><p>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入git --version验证是否安装成功。</p><h3 id="Github-配置">Github 配置</h3><p>打开 <code>https://github.com/</code> ，新建一个项目。</p><p>然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的github名字完全一样，比如你github名字叫abc，<a href="http://xn--abc-p18dxmy1av1ys8ojraw1vmswd20h9mta.github.io">那么仓库名字一定要是abc.github.io</a>。</p><p>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages。</p><p>点击那个链接，就会出现自己的网页。</p><h3 id="安装-Hexo">安装 Hexo</h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件。</p><p>在终端中，定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<code>http://localhost:4000/</code>。</p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h3 id="连接-Github-与-本地">连接 Github 与 本地</h3><h4 id="git-SSH-配置">git SSH 配置</h4><p>可参考其他教程，暂不赘述。</p><h4 id="hexo-连接-github">hexo 连接 github</h4><p>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><pre><code class="language-yml">deploy:  type: git  repository: https://github.com/【username】/【username】.github.io  branch: master</code></pre><ul><li>【username】:  替换成 github 的 username</li></ul><h2 id="hexo-的-相关命令">hexo 的 相关命令</h2><h3 id="init">init</h3><pre><code class="language-bash">$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js"></a> 安装。</li></ol><h3 id="new">new</h3><pre><code class="language-bash">$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code class="language-bash">$ hexo new "post title with whitespace"</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, --path</td><td>自定义新文章的路径</td></tr><tr><td>-r, --replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, --slug</td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code class="language-bash">hexo new page --path about/me "About me"</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>"About me"</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre><code class="language-bash">hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>"page"</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h3 id="generate">generate</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d, --deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, --watch</td><td>监视文件变动</td></tr><tr><td>-b, --bail</td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td>-f, --force</td><td>强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td>-c, --concurrency</td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><pre><code class="language-bash">$ hexo g</code></pre><h3 id="publish">publish</h3><pre><code class="language-bash">$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><h3 id="server">server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p, --port</td><td>重设端口</td></tr><tr><td>-s, --static</td><td>只使用静态文件</td></tr><tr><td>-l, --log</td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="deploy">deploy</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-g, --generate</td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><pre><code class="language-bash">$ hexo d</code></pre><h3 id="render">render</h3><pre><code class="language-bash">$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-o, --output</td><td>设置输出路径</td></tr></tbody></table><h3 id="migrate">migrate</h3><pre><code class="language-bash">$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h3 id="clean">clean</h3><pre><code class="language-bash">$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list">list</h3><pre><code class="language-bash">$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><h3 id="version">version</h3><pre><code class="language-bash">$ hexo version</code></pre><p>显示 Hexo 版本。</p><h3 id="选项">选项</h3><h4 id="安全模式">安全模式</h4><pre><code class="language-bash">$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="调试模式">调试模式</h4><pre><code class="language-bash">$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。</p><h4 id="简洁模式">简洁模式</h4><pre><code class="language-bash">$ hexo --silent</code></pre><p>隐藏终端信息。</p><h4 id="自定义配置文件的路径">自定义配置文件的路径</h4><pre><code class="language-bash">$ hexo server --config custom.yml$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><pre><code class="language-bash">$ hexo server --config custom.yml$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h4 id="显示草稿">显示草稿</h4><pre><code class="language-bash">$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h4 id="自定义-CWD">自定义-CWD</h4><pre><code class="language-bash">$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p><h2 id="BUG-及-解决-2">BUG 及 解决</h2><ul><li></li></ul><h2 id="更新日志-3">更新日志</h2><h3 id="Version-1-0-1">Version 1.0.1</h3><p><strong>Done</strong></p><ul><li>创建笔记</li><li>hexo 的安装及配置</li><li>笔记的拆分</li></ul><h3 id="Version-1-1-0-3">Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul><h2 id="参考文献-2">参考文献</h2><ul><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-1"></a><ul><li>韦阳的博客</li><li>笔记的安装及配置</li></ul></li><li><a href="https://hexo.io/zh-cn/docs/commands">指令</a><ul><li>hexo 官网</li><li>hexo 的指令</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
