<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Redis】 排序</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-排序"><a href="#【Redis】-排序" class="headerlink" title="【Redis】 排序"></a>【Redis】 排序</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 排序date: 2023-07-09 14:07tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 排序</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。</p><p>本章将对SORT命令的实现原理进行介绍，并说明包括ASC、DESC、ALPHA、LIMIT、STORE、BY、GET在内的所有SORT命令选项的实现原理。</p><ul><li>SORT命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作。</li><li>在默认情况下，SORT命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序。</li><li>如果SORT命令使用了ALPHA选项，那么SORT命令假设被排序键包含的都是字符串值，并且以字符串的方式来进行排序。</li><li>SORT命令的排序操作由快速排序算法实现。</li><li>SORT命令会根据用户是否使用了DESC选项来决定是使用升序对比还是降序对比来比较被排序的元素，升序对比会产生升序排序结果，被排序的元素按值的大小从小到大排列，降序对比会产生降序排序结果，被排序的元素按值的大小从大到小排列。</li><li>当SORT命令使用了BY选项时，命令使用其他键的值作为权重来进行排序操作。</li><li>当SORT命令使用了LIMIT选项时，命令只保留排序结果集中LIMIT选项指定的元素。</li><li>当SORT命令使用了GET选项时，命令会根据排序结果集中的元素，以及GET选项给定的模式，查找并返回其他键的值，而不是返回被排序的元素。</li><li>当SORT命令使用了STORE选项时，命令会将排序结果集保存在指定的键里面。</li><li>当SORT命令同时使用多个选项时，命令先执行排序操作（可用的选项为ALPHA、ASC或DESC、BY），然后执行LIMIT选项，之后执行GET选项，再之后执行STORE选项，最后才将排序结果集返回给客户端。</li><li>除了GET选项之外，调整选项的摆放位置不会影响SORT命令的排序结果。</li></ul><h2 id="SORT-lt-key-gt-命令的实现"><a href="#SORT-lt-key-gt-命令的实现" class="headerlink" title="SORT<key>命令的实现"></a>SORT&lt;key&gt;命令的实现</h2><p>SORT命令的最简单执行形式为：</p><pre><code class="line-numbers language-shell">SORT &lt;key&gt;</code></pre><p>这个命令可以对一个包含数字值的键key进行排序。</p><p>服务器执行SORT numbers命令的详细步骤如下：<br>1）创建一个和numbers列表长度相同的数组，该数组的每个项都是一个redis.h/redisSortObject结构。<br>2）遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系，如图21-2所示。<br>3）遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面，如图21-3所示。<br>4）根据数组项u.score属性的值，对数组进行数字值排序，排序后的数组项按u.score属性的值从小到大排列，如图21-4所示。<br>5）遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端，程序首先访问数组的索引0，返回u.score值为1.0的列表项”1”；然后访问数组的索引1，返回u.score值为2.0的列表项”2”；最后访问数组的索引2，返回u.score值为3.0的列表项”3”。</p><p><img src="/attachment/7f58ee61186466651879c634c72c190b.png"></p><p><img src="/attachment/6225efc06c70ead035d058fbbc9ec735.png"></p><p><img src="/attachment/e77f29d96d42f41435a7b05146d29fd8.png"></p><p><img src="/attachment/e9d851b2fbdac6b77d4710b5edbe7b38.png"></p><h3 id="ALPHA选项的实现"><a href="#ALPHA选项的实现" class="headerlink" title="ALPHA选项的实现"></a>ALPHA选项的实现</h3><p>通过使用ALPHA选项，SORT命令可以对包含字符串值的键进行排序：</p><pre><code class="line-numbers language-shell">SORT &lt;key&gt; ALPHA</code></pre><p>以下命令展示了如何使用SORT命令对一个包含三个字符串值的集合键进行排序：</p><p>服务器执行SORT fruits ALPHA命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素，如图21-5所示。<br>3）根据obj指针所指向的集合元素，对数组进行字符串排序，排序后的数组项按集合元素的字符串值从小到大排列：因为”apple”、”banana”、”cherry “三个字符串的大小顺序为”apple”&lt;”banana”&lt;”cherry “，所以排序后数组的第一项指向”apple”元素，第二项指向”banana”元素，第三项指向”cherry “元素，如图21-6所示。<br>4）遍历数组，依次将数组项的obj指针所指向的元素返回给客户端。</p><p><img src="/attachment/86587c78daa3cf927085ffc47dcf8659.png"></p><h3 id="ASC选项和DESC选项的实现"><a href="#ASC选项和DESC选项的实现" class="headerlink" title="ASC选项和DESC选项的实现"></a>ASC选项和DESC选项的实现</h3><p>在默认情况下，SORT命令执行升序排序，排序后的结果按值的大小从小到大排列，以下<br>两个命令是完全等价的：</p><pre><code class="line-numbers language-shell">SORT &lt;key&gt;SORT &lt;key&gt; ASC</code></pre><h3 id="BY选项的实现"><a href="#BY选项的实现" class="headerlink" title="BY选项的实现"></a>BY选项的实现</h3><p>在默认情况下，SORT命令使用被排序键包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置。</p><p><img src="/attachment/135b6f1d6931168e1bfb17cb76f37d6d.png"></p><h3 id="带有ALPHA选项的BY选项的实现"><a href="#带有ALPHA选项的BY选项的实现" class="headerlink" title="带有ALPHA选项的BY选项的实现"></a>带有ALPHA选项的BY选项的实现</h3><p>服务器执行SORT fruits BY*-id ALPHA命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素。<br>3）遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式<code>*-id</code>，查找相应的权重键：<br>将各个数组项的u.cmpobj指针分别指向相应的权重键（一个字符串对象）。<br>5）以各个数组项的权重键的值为权重，对数组执行字符串排序<br>6）遍历数组，依次将数组项的obj指针所指向的集合元素返回给客户端。</p><p><img src="/attachment/40203b5ca3358319d79409433799a9fa.png"></p><p><img src="/attachment/5310dc891c0206b6067e85075ada558c.png"></p><p><img src="/attachment/03b8b5231809d6e52de8b23f58d46969.png"></p><h2 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h2><p>通过LIMIT选项，我们可以让SORT命令只返回其中一部分已排序的元素。<br>LIMIT选项的格式为<code>LIMIT&lt;offset&gt;&lt;count&gt;</code>：</p><ul><li>offset参数表示要跳过的已排序元素数量。</li><li>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量。</li></ul><p>服务器执行SORT alphabet ALPHA LIMIT 0 4命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于alphabet集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向alphabet集合的各个元素，如图21-15所示。<br>3）根据obj指针所指向的集合元素，对数组进行字符串排序，排序后的数组如图21-16所示。<br>4）根据选项LIMIT 0 4，将指针移动到数组的索引0上面，然后依次访问array [0]、array [1]、array [2]、array [3]这4个数组项，并将数组项的obj指针所指向的元素”a”、”b”、”c”、”d”返回给客户端。<br>服务器执行SORT alphabet ALPHA LIMIT 2 3命令时的第一至第三步都和执行SORTalphabet ALPHA LIMIT 0 4命令时的步骤一样，只是第四步有所不同，上面的第4步如下：<br>4）根据选项LIMIT 2 3，将指针移动到数组的索引2上面，然后依次访问array [2]、array [3]、array [4]这3个数组项，并将数组项的obj指针所指向的元素”c”、”d”、”e”返回给客户端。</p><p><img src="/attachment/e78b5b5a95e94ea157fc343f7fe2223c.png"></p><p><img src="/attachment/1b5637327392cd5f3d8afecc6bd176b4.png"></p><h2 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h2><p>在默认情况下，SORT命令在对键进行排序之后，总是返回被排序键本身所包含的元素。</p><p>通过使用GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p><p>服务器执行SORT students ALPHA GET*-name命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于students集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向students集合的各个元素，<br>3）根据obj指针所指向的集合元素，对数组进行字符串排序<br>4）遍历数组，根据数组项obj指针所指向的集合元素，以及GET选项所给定的模式， 查找响应的键<br>5）遍历查找程序返回的三个键，并向客户端返回它们的值：<br>6）遍历数组，根据数组项obj指针所指向的集合元素，以及两个GET选项所给定的*-name模式和*-birth模式，查找相应的键：<br>7）遍历查找程序返回的六个键，并向客户端返回它们的值：</p><p><img src="/attachment/7336d92037d0f3ea7d26215cd0c370e3.png"></p><h2 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h2><p>通过使用STORE选项，我们可以将排序结果保存在指定的键里面，并在有需要时重用这个排序结果：</p><p>服务器执行SORT students ALPHA STORE sorted_students命令的详细步骤如下：<br>1）创建一个redisSortObject结构数组，数组的长度等于students集合的大小。<br>2）遍历数组，将各个数组项的obj指针分别指向students集合的各个元素。<br>3）根据obj指针所指向的集合元素，对数组进行字符串排序。<br>4）检查sorted_students键是否存在，如果存在的话，那么删除该键。<br>5）设置sorted_students为空白的列表键。<br>6）遍历数组，将排序后的三个元素”jack”、”peter”和”tom”依次推入sorted_students列表的末尾，相当于执行命令RPUSH sorted_students”jack”、”peter”、”tom”。<br>7）遍历数组，向客户端返回”jack”、”peter”、”tom”三个元素。</p><h2 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h2><h3 id="选项的执行顺序"><a href="#选项的执行顺序" class="headerlink" title="选项的执行顺序"></a>选项的执行顺序</h3><p>1）排序：在这一步，命令会使用ALPHA、ASC或DESC、BY这几个选项，对输入键进行排序，并得到一个排序结果集。<br>2）限制排序结果集的长度：在这一步，命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中。<br>3）获取外部键：在这一步，命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。<br>4）保存排序结果集：在这一步，命令会使用STORE选项，将排序结果集保存到指定的键上面去。<br>5）向客户端返回排序结果集：在最后这一步，命令遍历排序结果集，并依次向客户端返回排序结果集中的元素。</p><h3 id="选项的摆放顺序"><a href="#选项的摆放顺序" class="headerlink" title="选项的摆放顺序"></a>选项的摆放顺序</h3><p>另外要提醒的一点是，调用SORT命令时，除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 Lua脚本</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-Lua脚本"><a href="#【Redis】-Lua脚本" class="headerlink" title="【Redis】 Lua脚本"></a>【Redis】 Lua脚本</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 Lua脚本date: 2023-07-09 13:56tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 Lua脚本</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p><ul><li>Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性、安全性等方面的需要。</li><li>Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令。</li><li>Redis使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能。</li><li>EVAL命令为客户端输入的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。</li><li>EVALSHA命令通过直接调用Lua环境中已定义的函数来执行脚本。</li><li>SCRIPT FLUSH命令会清空服务器lua_scripts字典中保存的脚本，并重置Lua环境。</li><li>SCRIPT EXISTS命令接受一个或多个SHA1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。</li><li>SCRIPT LOAD命令接受一个Lua脚本为参数，为该脚本在Lua环境中创建函数，并将脚本保存到lua_scripts字典中。</li><li>服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行情况时，客户端可以通过向服务器发送SCRIPT KILL命令来让钩子停止正在执行的脚本，或者发送SHUTDOWN nosave命令来让钩子关闭整个服务器。</li><li>主服务器复制EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的方法和复制普通Redis命令一样，只要将相同的命令传播给从服务器就可以了。</li><li>主服务器在复制EVALSHA命令时，必须确保所有从服务器都已经载入了EVALSHA命令指定的SHA1校验和所对应的Lua脚本，如果不能确保这一点的话，主服务器会将EVALSHA命令转换成等效的EVAL命令，并通过传播EVAL命令来获得相同的脚本执行效果。</li></ul><h2 id="创建并修改Lua环境"><a href="#创建并修改Lua环境" class="headerlink" title="创建并修改Lua环境"></a>创建并修改Lua环境</h2><p>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境（environment），<br>并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。<br>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成：<br>1）创建一个基础的Lua环境，之后的所有修改都是针对这个环境进行的。<br>2）载入多个函数库到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作。<br>3）创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中执行Redis命令的redis.call函数。<br>4）使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本中引入副作用。<br>5）创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排序，从而消除这些命令的不确定性。<br>6）创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。<br>7）对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全局变量添加到Lua环境中。<br>8）将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本。接下来的各个小节将分别介绍这些步骤。</p><h2 id="Lua环境协作组件"><a href="#Lua环境协作组件" class="headerlink" title="Lua环境协作组件"></a>Lua环境协作组件</h2><p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的lua_scripts字典。</p><h3 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h3><p>因为执行Redis命令必须有相应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。</p><p>Lua脚本使用redis.call函数或者redis.pcall函数执行一个Redis命令，需要完成以下步骤：<br>1）Lua环境将redis.call函数或者redis.pcall函数想要执行的命令传给伪客户端。<br>2）伪客户端将脚本想要执行的命令传给命令执行器。<br>3）命令执行器执行伪客户端传给它的命令，并将命令的执行结果返回给伪客户端。<br>4）伪客户端接收命令执行器返回的命令结果，并将这个命令结果返回给Lua环境。<br>5）Lua环境在接收到命令结果之后，将该结果返回给redis.call函数或者redis.pcall函数。<br>6）接收到结果的redis.call函数或者redis.pcall函数会将命令结果作为函数返回值返回给脚本中的调用者。</p><p><img src="/attachment/3679632435845ee77164fdd1aa82de68.png"></p><p><img src="/attachment/b01d7cb6f4c142e04421d0a1684cccdf.png"></p><h3 id="lua-scripts字典"><a href="#lua-scripts字典" class="headerlink" title="lua_scripts字典"></a>lua_scripts字典</h3><pre><code class="line-numbers language-c">struct redisServer {    // ...    dict *lua_scripts;    // ...};</code></pre><h2 id="EVAL命令的实现"><a href="#EVAL命令的实现" class="headerlink" title="EVAL命令的实现"></a>EVAL命令的实现</h2><p>EVAL命令的执行过程可以分为以下三个步骤：<br>1）根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。<br>2）将客户端给定的脚本保存到lua_scripts字典，等待将来进一步使用。<br>3）执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</p><h2 id="EVALSHA命令的实现"><a href="#EVALSHA命令的实现" class="headerlink" title="EVALSHA命令的实现"></a>EVALSHA命令的实现</h2><p>可以用伪代码来描述这一原理：</p><pre><code class="line-numbers language-c">def EVALSHA(sha1):    # 拼接出函数的名字    # 例如：f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91    func_name = "f_" + sha1    # 查看这个函数在Lua 环境中是否存在    if function_exists_in_lua_env(func_name):        # 如果函数存在，那么执行它        execute_lua_function(func_name)    else:        # 如果函数不存在，那么返回一个错误        send_script_error("SCRIPT NOT FOUND")</code></pre><h2 id="脚本管理命令的实现"><a href="#脚本管理命令的实现" class="headerlink" title="脚本管理命令的实现"></a>脚本管理命令的实现</h2><h3 id="SCRIPT-FLUSH"><a href="#SCRIPT-FLUSH" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h3><p>SCRIPT FLUSH命令用于清除服务器中所有和Lua脚本有关的信息，这个命令会释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境。</p><h3 id="SCRIPT-EXISTS"><a href="#SCRIPT-EXISTS" class="headerlink" title="SCRIPT EXISTS"></a>SCRIPT EXISTS</h3><p>SCRIPT EXISTS命令根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p><h3 id="SCRIPT-LOAD"><a href="#SCRIPT-LOAD" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h3><p>SCRIPT LOAD命令所做的事情和EVAL命令执行脚本时所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典里面。</p><h3 id="SCRIPT-KILL"><a href="#SCRIPT-KILL" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h3><p>如果服务器设置了lua-time-limit配置选项，那么在每次执行Lua脚本之前，服务器都会在Lua环境里面设置一个超时处理钩子（hook）。<br>超时处理钩子在脚本运行期间，会定期检查脚本已经运行了多长时间，一旦钩子发现脚本的运行时间已经超过了lua-time-limit选项设置的时长，钩子将定期在脚本运行的间隙中，查看是否有SCRIPT KILL命令或者SHUTDOWN命令到达服务器。</p><p><img src="/attachment/ab65ef386f8f3ad28189f4fc103ce021.png"></p><h2 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h2><p>与其他普通Redis命令一样，当服务器运行在复制模式之下时，具有写性质的脚本命令也会被复制到从服务器，这些命令包括EVAL命令、EVALSHA命令、SCRIPT FLUSH命令，以及SCRIPT LOAD命令。</p><h3 id="复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令"><a href="#复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令" class="headerlink" title="复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令"></a>复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令</h3><p><img src="/attachment/47da079ce18611e1d9b0427d785804db.png"></p><h3 id="复制EVALSHA命令"><a href="#复制EVALSHA命令" class="headerlink" title="复制EVALSHA命令"></a>复制EVALSHA命令</h3><h4 id="判断传播EVALSHA命令是否安全的方法"><a href="#判断传播EVALSHA命令是否安全的方法" class="headerlink" title="判断传播EVALSHA命令是否安全的方法"></a>判断传播EVALSHA命令是否安全的方法</h4><h4 id="清空repl-scriptcache-dict字典"><a href="#清空repl-scriptcache-dict字典" class="headerlink" title="清空repl_scriptcache_dict字典"></a>清空repl_scriptcache_dict字典</h4><h4 id="EVALSHA命令转换成EVAL命令的方法"><a href="#EVALSHA命令转换成EVAL命令的方法" class="headerlink" title="EVALSHA命令转换成EVAL命令的方法"></a>EVALSHA命令转换成EVAL命令的方法</h4><p>1）根据SHA1校验和sha1，在lua_scripts字典中查找sha1对应的Lua脚本script。<br>2）将原来的EVALSHA命令请求改写成EVAL命令请求，并且将校验和sha1改成脚本script，至于numkey s、key、arg等参数则保持不变。</p><h4 id="传播EVALSHA命令的方法"><a href="#传播EVALSHA命令的方法" class="headerlink" title="传播EVALSHA命令的方法"></a>传播EVALSHA命令的方法</h4><p><img src="/attachment/89eafd3932d4c4af0e3e2990a5336123.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 发布和订阅</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-fa-bu-he-ding-yue/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-fa-bu-he-ding-yue/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-发布和订阅"><a href="#【Redis】-发布和订阅" class="headerlink" title="【Redis】 发布和订阅"></a>【Redis】 发布和订阅</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 发布和订阅date: 2023-07-09 13:30tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 发布和订阅</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。</p><p>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。</p><p><img src="/attachment/e0bbc535676b4582378334c66bd6694d.png"></p><ul><li><strong>服务器状态</strong>在<strong>pubsub_channels字典</strong>保存了<strong>所有频道的订阅关系</strong>：SUBSCRIBE命令负责将客户端和被订阅的频道关联到这个字典里面，而UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关联。</li><li><strong>服务器状态</strong>在<strong>pubsub_patterns链表</strong>保存了<strong>所有模式的订阅关系</strong>：PSUBSCRIBE命令负责将客户端和被订阅的模式记录到这个链表中，而PUNSUBSCRIBE命令则负责移除客户端和被退订模式在链表中的记录。</li><li>PUBLISH命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息，通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息。</li><li>PUBSUB命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的。</li></ul><h2 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h2><p>当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立起了一种订阅关系。</p><p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端：</p><pre><code class="line-numbers language-c">struct redisServer {    // ...    // 保存所有频道的订阅关系    dict *pubsub_channels;    // ...};</code></pre><p><img src="/attachment/13416e5e120317f97edd7793a20758d4.png"></p><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><pre><code class="line-numbers language-shell">SUBSCRIBE "news.sport" "news.movie"</code></pre><p><img src="/attachment/799d9ace72090fd41c5b82dc16c0e00b.png"></p><p>SUBSCRIBE命令的实现可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def subscribe(*all_input_channels):    # 遍历输入的所有频道    for channel in all_input_channels:        # 如果channel 不存在于pubsub_channels 字典（没有任何订阅者）        # 那么在字典中添加channel 键，并设置它的值为空链表        if channel not in server.pubsub_channels:            server.pubsub_channels[channel] = []        # 将订阅者添加到频道所对应的链表的末尾        server.pubsub_channels[channel].append(client)</code></pre><h3 id="退订频道"><a href="#退订频道" class="headerlink" title="退订频道"></a>退订频道</h3><p>UNSUBSCRIBE命令的行为和SUBSCRIBE命令的行为正好相反</p><pre><code class="line-numbers language-shell">UNSUBSCRIBE "news.sport" "news.movie"</code></pre><p><img src="/attachment/94b730d8e5a9c7f1016613609182464f.png"></p><p>UNSUBSCRIBE命令的实现可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def unsubscribe(*all_input_channels):    # 遍历要退订的所有频道    for channel in all_input_channels:        # 在订阅者链表中删除退订的客户端        server.pubsub_channels[channel].remove(client)        # 如果频道已经没有任何订阅者了（订阅者链表为空）        # 那么将频道从字典中删除        if len(server.pubsub_channels[channel]) == 0:            server.pubsub_channels.remove(channel)</code></pre><h2 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h2><p>服务器也将所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性里面：</p><pre><code class="line-numbers language-c">struct redisServer {// ...// 保存所有模式订阅关系list *pubsub_patterns;// ...};</code></pre><p>pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsub Pattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端：</p><pre><code class="line-numbers language-c">typedef struct pubsubPattern {    // 订阅模式的客户端    redisClient *client;    // 被订阅的模式    robj *pattern;} pubsubPattern;</code></pre><p><img src="/attachment/b09d32632c35e8e4b35a472866bfbf56.png"></p><p><img src="/attachment/bb09d4fac2b511566fa6abdd857a8249.png"></p><h3 id="PSUBSCRIBE"><a href="#PSUBSCRIBE" class="headerlink" title="PSUBSCRIBE"></a>PSUBSCRIBE</h3><p>PSUBSCRIBE命令的实现原理可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def psubscribe(*all_input_patterns):    # 遍历输入的所有模式    for pattern in all_input_patterns:        # 创建新的pubsubPattern 结构        # 记录被订阅的模式，以及订阅模式的客户端        pubsubPattern = create_new_pubsubPattern()        pubsubPattern.client = client        pubsubPattern.pattern = pattern        # 将新的pubsubPattern        追加到pubsub_patterns 链表末尾        server.pubsub_patterns.append(pubsubPattern)</code></pre><p><img src="/attachment/6c9d441d311613716d919559dcc57860.png"></p><h3 id="PUNSUBSCRIBE"><a href="#PUNSUBSCRIBE" class="headerlink" title="PUNSUBSCRIBE"></a>PUNSUBSCRIBE</h3><p><img src="/attachment/95be4f088930c0594c05dc87acd37087.png"></p><p>PUNSUBSCRIBE命令的实现原理可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def punsubscribe(*all_input_patterns):    # 遍历所有要退订的模式    for pattern in all_input_patterns:        # 遍历pubsub_patterns 链表中的所有pubsubPattern 结构        for pubsubPattern in server.pubsub_patterns:            #            如果当前客户端和pubsubPattern 记录的客户端相同            # 并且要退订的模式也和pubsubPattern 记录的模式相同            if client == pubsubPattern.client and pattern == pubsubPattern.pattern:                # 那么将这个pubsubPattern 从链表中删除                server.pubsub_patterns.remove(pubsubPattern)</code></pre><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>当一个Redis客户端执行<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：<br>1）将消息message发送给channel频道的所有订阅者。<br>2）如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。</p><h3 id="将消息发送给频道订阅者"><a href="#将消息发送给频道订阅者" class="headerlink" title="将消息发送给频道订阅者"></a>将消息发送给频道订阅者</h3><p><img src="/attachment/d644ac2c6acee20f01fe9c57174f0bc3.png"></p><p>PUBLISH命令将消息发送给频道订阅者的方法可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def channel_publish(channel, message):    # 如果channel键不存在于pubsub_channels 字典中    # 那么说明channel 频道没有任何订阅者    # 程序不做发送动作，直接返回    if channel not in server.pubsub_channels:        return    # 运行到这里，说明channel 频道至少有一个订阅者    # 程序遍历channel 频道的订阅者链表    # 将消息发送给所有订阅者    for subscriber in server.pubsub_channels[channel]:        send_message(subscriber, message)</code></pre><h3 id="将消息发送给模式订阅者"><a href="#将消息发送给模式订阅者" class="headerlink" title="将消息发送给模式订阅者"></a>将消息发送给模式订阅者</h3><p>因为服务器状态中的pubsub_patterns链表记录了所有模式的订阅关系，所以为了将消息发送给所有与channel频道相匹配的模式的订阅者，PUBLISH命令要做的就是遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端。</p><p>PUBLISH命令的实现可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def publish(channel, message):    # 将消息发送给channel 频道的所有订阅者    channel_publish(channel, message)    # 将消息发送给所有和channel 频道相匹配的模式的订阅者    pattern_publish(channel, message)</code></pre><h2 id="查看订阅信息"><a href="#查看订阅信息" class="headerlink" title="查看订阅信息"></a>查看订阅信息</h2><h3 id="PUBSUB-CHANNELS"><a href="#PUBSUB-CHANNELS" class="headerlink" title="PUBSUB CHANNELS"></a>PUBSUB CHANNELS</h3><p><code>PUBSUB CHANNELS[pattern]</code>子命令用于返回服务器当前被订阅的频道，其中pattern参数是可选的：</p><ul><li>如果不给定pattern参数，那么命令返回服务器当前被订阅的所有频道。</li><li>如果给定pattern参数，那么命令返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道。</li></ul><p>这个子命令是通过遍历服务器pubsub_channels字典的所有键（每个键都是一个被订阅的频道），然后记录并返回所有符合条件的频道来实现的，这个过程可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def pubsub_channels(pattern=None):    # 一个列表，用于记录所有符合条件的频道    channel_list = []    # 遍历服务器中的所有频道    # （也即是pubsub_channels 字典的所有键）    for channel in server.pubsub_channels:        # 当以下两个条件的任意一个满足时，将频道添加到链表里面：        #1 ）用户没有指定pattern 参数        #2 ）用户指定了pattern 参数，并且channel 和pattern 匹配        if (pattern is None) or match(channel, pattern):            channel_list.append(channel)    # 向客户端返回频道列表    return channel_list</code></pre><p><img src="/attachment/5cb3e19068600d52f278dab2f76695bf.png"></p><h3 id="PUBSUB-NUMSUB"><a href="#PUBSUB-NUMSUB" class="headerlink" title="PUBSUB NUMSUB"></a>PUBSUB NUMSUB</h3><p><code>PUBSUB NUMSUB[channel-1 channel-2...channel-n]</code>子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。</p><p>这个子命令是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的（订阅者链表的长度就是频道订阅者的数量），这个过程可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def pubsub_numsub(*all_input_channels):    # 遍历输入的所有频道    for channel in all_input_channels:        # 如果pubsub_channels 字典中没有channel 这个键        # 那么说明channel 频道没有任何订阅者        if channel not in server.pubsub_channels:            # 返回频道名            reply_channel_name(channel)            # 订阅者数量为0            reply_subscribe_count(0)        # 如果pubsub_channels 字典中存在channel 键        # 那么说明channel 频道至少有一个订阅者        else:            # 返回频道名            reply_channel_name(channel)            # 订阅者链表的长度就是订阅者数量            reply_subscribe_count(len(server.pubsub_channels[channel]))</code></pre><p><img src="/attachment/6be7a421f800f74c88c293bee6d604e6.png"></p><h3 id="PUBSUB-NUMPAT"><a href="#PUBSUB-NUMPAT" class="headerlink" title="PUBSUB NUMPAT"></a>PUBSUB NUMPAT</h3><p>PUBSUB NUMPAT子命令用于返回服务器当前被订阅模式的数量。这个子命令是通过返回pubsub_patterns链表的长度来实现的，因为这个链表的长度就是服务器被订阅模式的数量，这个过程可以用以下伪代码来描述：</p><pre><code class="line-numbers language-c">def pubsub_numpat():    # pubsub_patterns 链表的长度就是被订阅模式的数量    reply_pattern_count(len(server.pubsub_patterns))</code></pre><p><img src="/attachment/71436e54ca721c4b9faa043fbd4c2288.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 监视器</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-jian-shi-qi/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-jian-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-监视器"><a href="#【Redis】-监视器" class="headerlink" title="【Redis】 监视器"></a>【Redis】 监视器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 监视器date: 2023-07-09 13:24tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 监视器</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行 MONITOR 命令，客户端就成为了监视器，<strong>实时接收打印服务器处理的命令</strong>。当客户端发送请求时，服务器除了执行，还会将相关信息发送给所有监视器。</p><p>·客户端可以通过执行MONITOR命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息。<br>·当一个客户端从普通客户端变为监视器时，该客户端的REDIS_MONITOR标识会被打开。<br>·服务器将所有监视器都记录在monitors链表中。<br>·每次处理命令请求时，服务器都会遍历monitors链表，将相关信息发送给监视器。</p><h2 id="成为监视器"><a href="#成为监视器" class="headerlink" title="成为监视器"></a>成为监视器</h2><p>redisServer 中有 monitors 链表，记录所有成为监视器的客户端。如果某个客户端发送 MONITOR 命令，就会打开它的<code>REDIS_MONITOR</code>标志，并插入到链表的<strong>尾部</strong>。</p><h2 id="向监视器发送命令信息"><a href="#向监视器发送命令信息" class="headerlink" title="向监视器发送命令信息"></a>向监视器发送命令信息</h2><p>服务器处理命令前都会调用<code>replicationFeedMonitors</code>函数，将相关信息发送给各个监视器。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 慢查询日志</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-man-cha-xun-ri-zhi/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-man-cha-xun-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-慢查询日志"><a href="#【Redis】-慢查询日志" class="headerlink" title="【Redis】 慢查询日志"></a>【Redis】 慢查询日志</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 慢查询日志date: 2023-07-09 13:23tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 慢查询日志</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求。可通过两个参数配置：</p><ul><li><code>slowlog-log-slower-than</code>：执行时间超过多少微秒的命令会被记录到日志上。</li><li><code>slowlog-max-len</code>：指定服务器最多保存多少条慢查询日志，超过时会删除最久的那条日志。</li></ul><p>可以使用<code>CONSIG SET slowlog-log-slower-than &lt;microsecond&gt;</code>直接<strong>修改配置</strong>，使用<code>SLOWLOG GET</code>来<strong>查询慢查询日志</strong>。</p><ul><li>Redis的慢查询日志功能用于记录执行时间超过指定时长的命令。</li><li>Redis服务器将所有的慢查询日志保存在服务器状态的slowlog链表中，每个链表节点都包含一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志。</li><li>打印和删除慢查询日志可以通过遍历slowlog链表来完成。</li><li>slowlog链表的长度就是服务器所保存慢查询日志的数量。</li><li>新的慢查询日志会被添加到slowlog链表的表头，如果日志的数量超过slowlog-max-len选项的值，那么多出来的日志会被删除。</li></ul><h2 id="慢查询记录的保存"><a href="#慢查询记录的保存" class="headerlink" title="慢查询记录的保存"></a>慢查询记录的保存</h2><p>相关慢查询日志的属性记录在 redisServer 中：</p><pre><code class="line-numbers language-c">struct redisServer {​    //下一条慢查询日志的ID，初始为0，每产生一条就加1    long long slowlog_entry_id;    //保存了所有慢查询日志的链表    list *slow1og;    //服务器配置slowlog-log-slower-than选项的值    long 1ong slowlog_1og_slower_than;    //服务器配置slowlog-max-len选项的值    unsigned long slowlog_max_len;    // ...};</code></pre><p>slowlog 是一个链表，有几个节点就表示有几条慢查询日志，节点是一个 slowlogEntry 实例：</p><pre><code class="line-numbers language-c">typedef struct slow1ogEntry {    //唯一标识符    long 1ong id;    //命令执行时的时间，格式为UNIX时间戥    time_t time;    //执行命令消耗的时间，以微秒为单位    1ong long duration;    //命令与命令参数    robj **argv;    //命令与命令参数的数量    int argc;} slowlogEntry;​</code></pre><p>新添加的日志会呗放到 slowlog 的表头。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 事务</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-shi-wu/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-事务"><a href="#【Redis】-事务" class="headerlink" title="【Redis】 事务"></a>【Redis】 事务</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 事务date: 2023-07-09 13:04tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 事务</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 通过<code>MULTI</code>，<code>EXEC</code>，<code>WATCH</code>等命令实现事务功能。事务是将<strong>多个命令打包</strong>，然后<strong>原子地按顺序地执行</strong>的机制，执行期间服务器<strong>不会中断事务</strong>执行其他客户端的命令请求。下面展示了一次完整事务的执行命令：</p><pre><code class="line-numbers language-shell">redis&gt; MULTIOKredis&gt; SET "name" "The Design and Implementation of Redis"QUEUEDredis&gt; GET "name"QUEUEDredis&gt; EXEC1) OK2) "The Design and Implementation of Redis"</code></pre><ul><li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li><li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li><li>事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。</li><li>带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的REDIS_DIRTY_CAS标志打开。</li><li>只有在客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。</li><li>Redis的事务总是具有ACID中的原子性、一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsy nc选项的值为alway s时，事务也具有耐久性。</li></ul><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>可以看出，事务主要有 3 个阶段：事务开始、命令入队、事务执行。</p><h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p>MULTI 命令表示事务的开始，将客户端从非事务状态切换为事务状态，在 flags 属性中<strong>打开<code>REDIS_MULTI</code>标识</strong>。</p><h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><p>当客户端处于事务状态时，命令不会被立即执行（除了 EXEC、DISCARD、WATCH、MULTI），而是加入事务队列。</p><p><img src="/attachment/39bf9be431678093b83ff18845a86dea.png"></p><h3 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h3><p>客户端的事务状态保存在 mstate 里：</p><pre><code class="line-numbers language-c">typedef struct redisCLient{    //事务状态    multiState mstate;    ...} redisClient;</code></pre><p>事务状态包括<strong>事务队列</strong>和<strong>入队命令计数器</strong>：</p><pre><code class="line-numbers language-c">typedef struct multiState{    //数组，事务队列    multiCmd *commands;    //入队命令计数器    int count;} multiState;</code></pre><p>事务队列的实例结构：</p><pre><code class="line-numbers language-c">typedef struct multiCmd {    //参数    robj **argv;    //参数数量    int argc;    //命令指针    struct redisCommand *cmd;} multiCmd;</code></pre><p>先入队的命令先放入数组，后入队的后放入。</p><p><img src="/attachment/de5fc77137b727a07b95fad0788d938d.png"></p><h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><p>当收到客户端的 EXEC 命令时，将被立即执行，然后服务器遍历客户端的事务队列，保存命令，执行命令给，返回结果给客户端，移除事务标识。</p><h2 id="WATCH-命令的实现"><a href="#WATCH-命令的实现" class="headerlink" title="WATCH 命令的实现"></a>WATCH 命令的实现</h2><p>WATCH 命令是一个<strong>乐观锁</strong>，可以在 EXEC 前<strong>监视任意数量的键</strong>，如果在 EXEC 执行时，键被修改过，服务器将拒绝执行事务。</p><h3 id="使用-WATCH-命令监视数据库键"><a href="#使用-WATCH-命令监视数据库键" class="headerlink" title="使用 WATCH 命令监视数据库键"></a>使用 WATCH 命令监视数据库键</h3><p>每个 Redis 数据库都保存着 watched_keys 字典，键是某个被 WATCHED 命令<strong>监视的键</strong>，值是一个链表，记录所有监视<strong>该键的客户端</strong>。</p><pre><code class="line-numbers language-c">typedef struct redisDb{    //正在被WATCHED命令监视的键    dict *watched_keys;    ...} redisDb；</code></pre><h3 id="监控机制的触发-amp-事务安全"><a href="#监控机制的触发-amp-事务安全" class="headerlink" title="监控机制的触发 &amp; 事务安全"></a>监控机制的触发 &amp; 事务安全</h3><p>在执行数据库修改命令时，都会调用<code>multi.c/touchWatchKey</code>函数对 watched_keys 字典进行检查，查看是否有客户端正在监视刚被命令修改过的键，如果有，将 watched_keys 该键对应的值，也就是监听的客户端都打开<code>REDIS_DIRTY_CAS</code>标识，表示事务的<strong>安全性已经被破坏</strong>。此时，服务器拒绝执行事务。</p><p><img src="/attachment/ce5b85e25e5c8c9c8b192f0adcc9e2b0.png"></p><h2 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h2><p>Redis 的事务有原子性、一致性和隔离性，当 Redis 运行在特定的持久化模式下时，才具有持久性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>Redis 事务队列中的命令，要么全部都执行，要么一个都不执行，因此，具有原子性。Redis 进行事务命令入队时，如果命令<strong>入队出错</strong>，会被<strong>拒绝执行</strong>。但是命令的<strong>语法错误</strong>（<strong>执行错误</strong>），不会导致整个命令不被执行，也就是说 <strong>Redis 不支持事务的回滚机制</strong>。</p><p>下面例子表示发生<strong>入队错误</strong>（一致性时将提到入队错误和执行错误）时，事务中的所有命令都不会被执行：</p><pre><code class="line-numbers language-shell">redis&gt; MULTIOKredis&gt; SET msg "he1lo"QUEUEDredis&gt; GET(error) ERR wrong number of arguments for 'get' commandredis&gt; GET msgQUEUED redis&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors.</code></pre><p>发生执行错误，不影响其他命令的执行：</p><pre><code class="line-numbers language-shell">redis&gt; SET msg "hello" # msg键是一个字符串OKredis&gt; MULTIOKredis&gt; SADD fruit "apple" "banana" "cherry"QUEUEDredis&gt; RPUSH msg "good bye" "bye bye" #错误地对字符串键msg执行列表键的命令QUEUEDredis&gt; SADD alphabet "a" "b" "c"QUEUEDredis&gt; EXEC 1) (integer) 32)(error) WRONGTYPE Operation against a key holding the wrong kind of value3)(integer) 3</code></pre><p>不支持事务回滚是考虑到了复杂性，与其<strong>简单高效的理念不符</strong>，并且 Redis 的设计者认为，Redis 事务的执行时错误通常都是<strong>编程错误</strong>产生的，在开发环境中会有，但生产环境不应该出现，因此，没有设计回滚机制。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性表示在事务的执行前后，成功与否，数据库<strong>都是一致的</strong>，也就是数据符合数据库本身定义和要求，<strong>没有非法或无效错误数据</strong>。</p><p>Redis 通过简单的错误检测来保证一致性。</p><ol><li>入队错误</li></ol><p>在 2.6.5 之后的版本，如果一个事务在入队时出现了命令不存在，Redis 则拒绝执行这个事务。</p><ol start="2"><li>执行错误</li></ol><p>对于命令执行期间发现的错误，<strong>不会影响其他命令</strong>的执行。服务器会识别出错的命令，并进行相应处理，这些命令不会对数据库做修改，不影响一致性。</p><ol start="3"><li>服务器停机</li></ol><p>如果 Redis 在执行过程中停机，数据也是一致的。如果没有开启持久化，重启后数据库是空白的。开启持久化后，重启后会还原到一致状态。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>Redis 是单线程的，并且服务器保证在执行事务期间<strong>不会对事务进行中断</strong>，因此是具有隔离性的。并且队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，因此<strong>没有隔离级别概念</strong>。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>持久性的意思是，事务执行的结果被<strong>永久性地保存</strong>，执行事务的结果不会丢失。因为 Redis 没有单独为事务队列提供持久化功能，所以<strong>取决于持久化模式</strong>，只有 AOF 方式持久化并且 appendsync 的值为 always，而且没有打开<code>no-appendfsync-on-rewrite</code>时，才具有持久性。因为其他方式并不能保证事务的执行结果被第一时间保存到硬盘里。</p><p>注：<code>no-appendfsync-on-rewrite</code>打开后，在执行<code>BGSAVE</code>和<code>BGREWRITEAOF</code>时会暂停对 AOF 文件的同步。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 重点功能</title>
      <link href="/database/redis/redis-chong-dian-gong-neng/redis-chong-dian-gong-neng/"/>
      <url>/database/redis/redis-chong-dian-gong-neng/redis-chong-dian-gong-neng/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-重点功能"><a href="#【Redis】-重点功能" class="headerlink" title="【Redis】 重点功能"></a>【Redis】 重点功能</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 重点功能date: 2023-07-09 13:03tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 重点功能</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>发布和订阅</li></ul><ul><li>事务（事务的实现，WATCH 命令的实现，ACID）</li><li>慢查询日志</li><li>监视器</li></ul><h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><p>undefined</p><p>undefined</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>undefined</p><p>undefined</p><h2 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h2><p>undefined</p><p>undefined</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>undefined</p><p>undefined</p><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>undefined</p><p>undefined</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 cluster 集群</title>
      <link href="/database/redis/redis-duo-ji-ku-de-shi-xian/redis-cluster-ji-qun/"/>
      <url>/database/redis/redis-duo-ji-ku-de-shi-xian/redis-cluster-ji-qun/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-cluster-集群"><a href="#【Redis】-cluster-集群" class="headerlink" title="【Redis】 cluster 集群"></a>【Redis】 cluster 集群</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 cluster 集群date: 2023-07-09 08:47tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 cluster 集群</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>集群是 Redis 提供的<strong>分布式数据库</strong>方案，通过<strong>分片</strong>来进行数据共享并提供复制和故障转移的功能。主要对集群的节点，槽指派，命令执行，重新分片，转向，故障转移，消息进行介绍。</p><ul><li>节点通过<strong>握手</strong>来将其他节点添加到自己所处的集群当中。</li><li>集群中的16384个<strong>槽</strong>可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点。</li><li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个<strong>MOVED错误</strong>，MOVED错误携带的信息可以<strong>指引客户端转向至正在负责相关槽的节点</strong>。</li><li>对Redis集群的重新分片工作是由<strong>redis-trib</strong>负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。</li><li>如果节点A正在<strong>迁移</strong>槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个<strong>ASK错误</strong>，指引客户端到节点B继续查找指定的数据库键。</li><li>MOVED错误表示槽的负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种<strong>临时措施</strong>。</li><li>集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</li><li>集群中的节点通过<strong>发送和接收消息</strong>来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL五种。</li></ul><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>集群由多个节点组成，通过<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>可以将节点连接起来。这个命令主要是将目标节点加入到当前 Redis 所在的集群中。下面从启动节点，集群相关数据结构，命令实现来介绍节点内容。</p><h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>Redis 服务器在启动时会根据 cluster-enable 配置是否为 yes 来决定是否开启集群模式。集群中的节点除了使用 redisServer 之外，还用<code>cluster.h/clusterNode</code>结构、<code>cluster.h/clusterLink</code>结构、<code>cluster.h/clusterState</code>结构来保存集群数据。</p><h3 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h3><p>集群的每个节点都会用 clusterNode 来保存：</p><pre><code class="line-numbers language-c">struct clusterNode {    //创建节点的时间    mstime_t ctime; .    //节点的名字，由40个十六进制字符组成    char name [REDIS_CLUSTER_NAMELEN] ;     //节点标识    //使用各种不同的标识值记录节点的角色(比如主节点或者从节点),    //以及节点目前所处的状态(比如在线或者下线)。    int flags;    //节点当前的配置纪元，用于实现故障转移    uint64_t configEpoch;    //节点的IP地址    char ip[REDIS_IP_STR_LEN] ;    //节点的端口号    int port;    //保存连接节点所需的有关信息    clusterLink *link;    ...};​</code></pre><p>link 属性保存了连接节点所需的有关信息：</p><pre><code class="line-numbers language-c">typedef struct clusterLink {    //连接的创建时间    mstime_t ctime ;    // TCP 套接字描述符    int fd;    //输出缓冲区，保存着等待发送给其他节点的消息( message )。    sds sndbuf;    //输入缓冲区，保存着从其他节点接收到的消息。    sds rcvbuf ;    //与这个连接相关联的节点，如果没有的话就为NULL    struct clusterNode node;} clusterLink;​</code></pre><p>每个节点都保存一个集群状态，记录在当前节点下：</p><pre><code class="line-numbers language-c">typedef struct clusterState {    //指向当前节点的指针    clusterNode *myself;    //集群当前的配置纪元，用于实现故障转移    uint64_t currentEpoch;    //集群当前的状态:是在线还是下线    int state;    //集群中至少处理着一个槽的节点的数量（下一节谈）    int size;    //集群节点名单(包括myself节点)    //键为节点名字，值为节点对应的clusterNode结构    dict *nodes;    ...} clusterState;​</code></pre><h3 id="CLUSTER-MEET-命令的实现"><a href="#CLUSTER-MEET-命令的实现" class="headerlink" title="CLUSTER MEET 命令的实现"></a>CLUSTER MEET 命令的实现</h3><p>通过向节点发送<code>CLUSTER MEET</code>命令，让目标节点加入集群，进行<strong>握手</strong>，执行过程如下：</p><ol><li>客户端发送该命令给节点 A，节点 A 会创建一个节点 B 的 clusterNode 结构，添加到 clusterState.nodes 中。</li><li>解析 IP 地址和端口号，向节点 B 发送 MEET 消息（最后一节会讲消息）。</li><li>同理，节点 B 收到后，会为 A 创建 clusterNode 结构并添加到 nodes。</li><li>节点 B 向 A 发送 PONG 消息。</li><li>节点 A 收到后向 B 发送一条 PING 消息。</li><li>节点 B 收到后直到 A 成功感知到 B，握手完成。</li></ol><p><img src="/attachment/964114e62dce24f3b70e4fb3e369a359.png"></p><p>之后，节点 A 将节点 B 的信息通过 <strong>Gossip 协议</strong>（最后一节消息中将提到）传播给集群中的其他节点。</p><h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p>Redis 通过分片方式保存键值对，集群的整个数据库被分为 <strong>16384</strong> 个槽（slot），数据库的每个键都属于某一个槽，每个节点可处理 0~16384 个槽。当集群中的<strong>每个槽都归某个节点</strong>管理，集群处于上线状态；但凡有一个没人管，集群处于下线状态。</p><p>发送<code>CLUSTER ADDSLOTS &lt;slot&gt; [slot...]</code>命令，可以将槽委派给某个节点负责。下面介绍槽的实现。</p><h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><p>clusterNode 有 slots 和 numslot 属性记录了节点负责处理的槽：</p><pre><code class="line-numbers language-c">struct clusterNode{    //二进制位数组，长度为16384/8=2048字节，    //每个索引8位，根据0和1判断槽是否被该节点负责    unsigned char slot[16384/8];    //负责处理的槽数量    int numslots;    ...}</code></pre><p>比如该节点负责 0~7 的槽，存储结构如下：</p><p><img src="/attachment/76a61c3456d2a35058db14623fa4f679.png"></p><p>通过这种设计，检查某节点<strong>是否负责处理某个槽</strong>或者<strong>让节点负责</strong>某个槽的操作的时间复杂度都为 **O(1)**。</p><h3 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h3><p>节点除了将自己负责的槽记录在<code>clusterNode.slots</code>中，还会将这个数组通过<strong>消息发送</strong>给其他节点，让他们都知道自己负责什么槽。其他节点接收消息后，会对<code>clusterStaste.nodes</code>字典中对应的<code>clusterNode.slots</code>数据进行更新。</p><h3 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h3><p>clusterState 会维护集群中每个节点管理槽的情况：</p><pre><code class="line-numbers language-c">typedef struct slusterState{    clusterNode *slots[16384];    ...}</code></pre><p>如果 slot[i] 指向空，说明该槽<strong>没有被节点管理</strong>；如果指向具体某个 clusterNode 的指针，说明由这个节点管理。</p><p>总结一下，<code>clusterState.slots</code>数组记录<strong>集群中所有槽的信息</strong>；<code>clusterNode.slots</code>数组记录当前节点<strong>负责槽的信息</strong>。前者方便知道某个槽指派给谁，后者方便知道某个槽是否指派给自己，或者发送自己槽的指派信息。（因为被指派后，还需要向其他节点发送消息告知）。</p><p><strong>CLUSTER ADDSLOTS 命令的实现</strong></p><p>这个命令的执行其实就是把上面讲的几小节知识给串起来。主要是用来指派槽给节点负责的，接收该命令后，首先会遍历所有传入的槽（命令入参）是否都是未指派，如果<strong>有一个被指派了就报错</strong>。如果都未指派，将这些槽委派给当前节点，更新<code>clusterState.slots</code>数组指向当前节点的 clusterNode；然后将<code>clusterNode.slots</code>数组中对应的索引<strong>二进制位设置为 1</strong>。最后，<strong>发送消息</strong>告诉集群中其他节点，自己负责这些槽。</p><h2 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h2><p>当客户端对节点发送与数据库键有关的命令时，接收命令的节点会计算属于哪个槽，检查这个槽是否指派给自己（根据 key 的 <strong>CRC-16 校验和 &amp; 16383</strong> 来确定槽号 i，再根据 clusterState.slots[i] 是否指向当前节点的 clusterNode 判断是否自己负责的）。如果不是指派给自己的，就（找负责该槽的 ip 和端口，指引客户端转向它）向客户端<strong>返回 MOVED 错误</strong>，引导客户端指向正确的节点并再次发送命令。</p><p>注：通过<code>CLUSTER KEYSLOT &lt;key&gt;</code>可查看某个 key 对应的槽号。</p><h3 id="MOVED-错误"><a href="#MOVED-错误" class="headerlink" title="MOVED 错误"></a>MOVED 错误</h3><p>MOVED 错误格式为：<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></p><p>在集群模式下，会被隐藏，客户端会进行自动转向并重发命令。节点的转向其实就是<strong>换对应套接字</strong>来发送命令。下面演示了对 7000 端口的节点操作键命令并被引导转向到真正存储该键的服务器（7001 端口）的过程：</p><pre><code class="line-numbers language-shell">127.0.0.1: 7000&gt; SET msg "hello"-&gt; Redirected to slot [6257] located at 127.0.0.1: 7001OK127.0.0.1:7001&gt; GET msg"hello"</code></pre><h3 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h3><p>节点对数据的存储和单机 Redis 的实现是一样的，只不过节点只能使用 0 号库。还需要维护一个<code>slots_to_keys</code>跳跃表关联槽号和键。<strong>分数是槽号，节点就是键</strong>。当节点往数据库添加新键时，节点就会在<code>slots_to_keys</code>中进行<strong>关联</strong>，反之则删除关联。</p><pre><code class="line-numbers language-c">typedef struct clusterState{    zskiplist *slots_to_keys;    ...} clusterState;</code></pre><h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>Redis 集群的重新分片操作可以将任意数量已经指派给某个节点 (源节点) 的槽改为指派给另一个节点(目标节点)，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><p>重新分片通过集群管理软件 redis-trib 执行，步骤如下：</p><ol><li>redis-trib 对目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让<strong>目标节点准备</strong>好，要导入键值对了。</li><li>redis-trib 对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让<strong>源节点准备好</strong>，要转移键值对了。</li><li>redis-trib 向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令， 获得最多 count 个属于槽 slot 的键值对的键名 (key name)，这实际上就是个<strong>批量分片</strong>的意思。</li><li>对于步骤 3 获得的每个键名，redis-trib 都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_ port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>命令，将被选中的键<strong>原子地</strong>从源节点迁移至目标节点。</li><li>重复执行步骤 3 和步骤 4，直到源节点保存的所有属于槽 slot 的键值对都被迁移至目标节点。</li><li>redis-trib 向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_ id&gt;</code>命令，将槽 slot 指派给目标节点，通过<strong>消息发送至整个集群</strong>，让所有节点感知。</li></ol><p>整体迁移的流程图：</p><p><img src="/attachment/1d1652e50cf5d0c46406121dade61a9c.png"></p><h2 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h2><p>当客户端向源节点发送与数据库键相关的命令，并且该键恰好属于<strong>被迁移的槽</strong>时，源节点会先查自己有没有，有就返回；<strong>没有则返回 ASK 错误</strong>，指引客户端向正在导入槽的目标节点发送命令。这个命令和 MOVED 类似，不会直接打印错误。比如端口 7000 是源节点，”love” 键的槽（16198 槽）正在被迁移到 7001 就会这样：</p><pre><code class="line-numbers language-shell">127.0.0.1: 7000&gt; GET "love"-&gt; Redirected to slot [16198] located at 127.0.0.1: 7001"you get the key 'love'"127.0.0.1: 7001&gt;</code></pre><h3 id="CLUSTER-SETSLOT-IMPORTING-的实现"><a href="#CLUSTER-SETSLOT-IMPORTING-的实现" class="headerlink" title="CLUSTER SETSLOT IMPORTING 的实现"></a>CLUSTER SETSLOT IMPORTING 的实现</h3><p>clusterState.importing_slots_from 数组记录当前节点正在从其他节点导入的槽：</p><pre><code class="line-numbers language-c">typedef struct clusterState{    clusterNode *importing_slots_from[16384];    ...}</code></pre><p>一般情况下指向空，当执行<code>CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</code>时，会将目标节点（当前节点）<code>clusterState.importing_slots_from[i]</code>设置为 source_id 所代表节点的 clusterNode。</p><h3 id="CLUSTER-SETSLOT-MIGRATING-的实现"><a href="#CLUSTER-SETSLOT-MIGRATING-的实现" class="headerlink" title="CLUSTER SETSLOT MIGRATING 的实现"></a>CLUSTER SETSLOT MIGRATING 的实现</h3><p>clusterState 结构的 migrating_slot_to 数组记录了当前节点正在迁移至其他节点的槽：</p><pre><code class="line-numbers language-c">typedef struct clusterState{    clusterNode *migrating_slots_to[16384];}</code></pre><p>一般情况下指向空，当执行<code>CLUSTER SERSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</code>时，会将源节点<code>clusterState.migrating_slots_to[i]</code>设置为 target_id 所代表节点的 clusterNode。</p><h3 id="ASK-错误-1"><a href="#ASK-错误-1" class="headerlink" title="ASK 错误"></a>ASK 错误</h3><p>如果收到 key 命令请求的节点所属 key 的槽正好指派给了该节点，找到则返回，如果没找到则检查<code>clusterState.migrating_slots_to[i]</code>，是否正在迁移，如果<strong>正在迁移</strong>，就向客户端返回 ASK 错误，引导其去<strong>导入槽的节点查询</strong>。</p><p>客户端接收到 ASK 错误后，根据 IP 和端口，转向目标节点，然后先向目标节点发送 <strong>ASKING</strong> 命令，再重新发送要执行的命令。</p><h3 id="ASKING-命令"><a href="#ASKING-命令" class="headerlink" title="ASKING 命令"></a>ASKING 命令</h3><p>这个命令的唯一作用就是打开发送该命令客户端的<code>REDIS_ASKING</code>标识。有了这个标识后，节点会<strong>为正在导入的键执行命令</strong>。这个标识是<strong>一次性</strong>的，如果再对刚才的 key 执行相关操作，该节点会返回 MOVED 错误（因为重分片未结束，它不是负责该槽的节点）。下面表示相关判断过程：</p><p><img src="/attachment/b44b0b2f8d1bee902716655139845398.png"></p><p><strong>ASK 错误与 MOVED 错误的区别</strong></p><p>这两个错误都会客户端转向：</p><ul><li>MOVED 错误代表槽的负责权<strong>已经从一个节点到了另一个节点</strong>。</li><li>ASK 错误只是两个节点再迁移槽过程中使用的<strong>临时措施</strong>。</li></ul><h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p>Redis 集群中的节点分主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点（相当于备份，不处理读请求），并在被复制节点下线时，代替下线主节点继续处理命令请求。</p><p>接下来介绍节点的复制方法，检测节点是否下线方法及对下线节点故障转移方法。</p><h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>向节点发送命令<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为指定节点的从节点并对主节点开始复制。主要过程是：</p><ol><li>接收命令节点在<code>lusterState.node</code>字典中找到 node_id 对应节点的 clusterNode，然后将<code>clusterState.myself.slaveof</code>指向这个节点。</li><li>修改<code>clusterState.myself.flags</code>属性，关闭<code>REDIS_NODE_MASTER</code>标识，<strong>打开<code>REDIS_NODE_SLAVE</code>标识</strong>，标识该节点成为从节点。</li><li>调用复制代码，对主节点复制。</li></ol><p>当节点成为从节点并开始复制时，这个信息会通过消息发送给集群中其他节点。</p><h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中每个节点都会定期向其他节点发送 PING 消息，如果没有在规定时间返回 PONG 消息，就会被标记位<strong>疑似下线</strong>。集群中各个节点会互相发送消息来交换各个节点的状态，当一个主节点 A 通过消息得知主节点 B 认为主节点 C 进入疑似下线状态，A 会将 B 的<strong>下线报告添加</strong>到<code>clusterNode.fail_reports</code>链表中。</p><p>链表中每个元素都由 clusterNodeFailReport 组成：</p><pre><code class="line-numbers language-c">struct clusterNodeFailReport{    //报告目标节点已经下线的节点    struct clusterNode *node;    //最后一次从node节点收到下线报告的时间    //程序使用这个时间戳来检查下线报告是否过期    // (与当前时间相差太久的下线报告会被删除)    mstime_t time;} typedef clusterNodeFailReport;</code></pre><p>在一个集群中，<strong>半数以上</strong>负责处理槽的主节点将某个主节点报告为疑似下线后，这个主节点将被<strong>标记为已下线</strong>。并向集群广播一条关于该主节点 FAIL 的消息，所有收到消息的节点都会将其标记为已下线。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>当一个从发现主节点下线后，开始故障转移。具体步骤：</p><ol><li>下线的主节点的所有从节点里面，会有一个从节点被选中。</li><li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点。</li><li>新的主节点会撤销并指派给自己对已下线主节点的槽指派。</li><li>新的主节点向集群广播一条 PONG 消息，让其他节点立即知道新的主节点。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ol><h3 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h3><p>集群选举新主节点的具体过程：</p><ol><li>通过集群的配置纪元确定是哪一次选举，它是一个<strong>自增计数器</strong>，初始值为 0。</li><li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被加一。</li><li>集群里每个负责处理槽的主节点都有<strong>一次投票的机会</strong>，第一个向主节点要求投票的从节点将获得主节点的投票。</li><li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群<strong>广播</strong>一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，要求所有收到这条消息并且具有投票权的主节点向这个从节点投票。</li><li>如果一个主节点具有投票权 (它正在负责处理槽)，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，表示这个主节点支持从节点成为新的主节点。</li><li>每个参与选举的从节点都会接收<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，并根据自己<strong>收到消息的条数</strong>来统计自己获得多少主节点的支持。</li><li>如果集群里有 N 个具有投票权的主节点，那么当一个从节点收集到大于等于 <strong>N/2+1</strong> 支持票时，这个从节点就会当选为新的主节点。</li><li>配置纪元确定每个具有投票权的主节点只能投一次，所以如果有 N 个主节点进行投票，那么具有大于等于 N/2+1 张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li><li>如果在一个配置纪元里没有从节点得到足够的票，那么集群进入一个新的配置纪元，并<strong>再次进行选举</strong>，直到选出新的主节点为止。</li></ol><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>集群中节点主要通过发送消息来传递信息，主要有 5 种：</p><ul><li>MEET 消息：发送者接收到客户端的 MEET 消息时，发送者向接收者发送 MEET 消息，<strong>请求加入</strong>发送者所在集群。</li><li>PING 消息：集群每个节点每隔一秒从已知节点<strong>随机选出 5 个</strong>节点，然后对<strong>最长时间没发</strong> PING 消息的节点进行发送。除此之外，还会将最后一次收到 PONG 消息的节点中，如果时间<strong>超过</strong>配置的<code>cluster-node-timeout</code>选项的<strong>一半</strong>时，也会发送 PING 消息。</li><li>PONG 消息：应答 MEET 或 PING 消息。还可以通过 PONG，告诉其他节点，刷新该节点的相关信息。</li><li>FAIL 消息：当某个主节点判断另一个主节点<strong>已经进入 FAIL 状态</strong>时，当前主节点会向集群<strong>广播</strong>一条关于已下线节点的 FAIL 消息。</li><li>PUBLISH 消息：当节点接收到 PUBLISH 命令时，执行这个命令，并向集群<strong>广播</strong>一条 PUBLISH 消息，所有接收到这条 PUBLISH 消息的节点都会执行相同的 PUBLISH 命令。</li></ul><p>一条消息由消息头和消息正文组成。</p><h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>记录信息发送者的一些信息。比如发送者的当前纪元，发送者名字，发送者的槽指派信息等。接收者可根据发送者的信息来更新发送者的状态。消息头是一个<code>cluster.h/clusterMsg</code>:</p><pre><code class="line-numbers language-c">typedef struct{    //消息的长度(包括这个消息头的长度和消息正文的长度)    uint32_ t totlen;    //消息的类型    uint16_ t type;    //消息正文包含的节点信息数量    //只在发送MEET. PING、PONG这三种Gossip协议消息时使用    uint16_ t count;    //发送者所处的配置纪元    uint64_ t currentEpoch;    //如果发送者是一个主节点，那么这里记录的是发送者的配置纪元    //如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元.    uint64_ t configEpoch;    //发送者的名字(ID)    char sender [REDIS_ CLUSTER_ NAMELEN] ;    //发送者目前的槽指派信息    unsigned char myslots [REDIS_ CLUSTER_ SLOTS/8];    //如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字    //如果发送者是一个主节点，那么这里记录的是REDIS_ NODE NULL NAME    // (一个40字节长，值全为0的字节数组)    char slaveof [REDIS_ CLUSTER_ NAMELEN] ;    //发送者的端口号    uint16_ t port;    //发送者的标识值    uint16_ t flags;    //发送者所处集群的状态    unsigned char state;    //消息的正文(或者说，内容)    union clusterMsgData data;} clusterMsg;</code></pre><p>其中消息正文是一个<code>cluster.h/clusterMsgData</code>结构：</p><pre><code class="line-numbers language-c">union clusterMsgData{    // MEET、 PING、PONG消息的正文    struct{        //每条MEET、PING、pONG消息都包含两个        //clusterMsgDataGossip结构        clusterMsgDataGossip[1];    } ping;        // FAIL消息的正文    struct {    clusterMsgDatafail about;    }fail;​    //PUBLISH消息的正文    struct{        clusterMsgDataPublish msg;    }publish;        //其他消息的正文...};​</code></pre><h3 id="MEET、PING、PONG-消息的实现"><a href="#MEET、PING、PONG-消息的实现" class="headerlink" title="MEET、PING、PONG 消息的实现"></a>MEET、PING、PONG 消息的实现</h3><p>集群中的各个节点通过 <strong>Gossip 协议</strong>来交换各自关于不同节点的状态信息，Gossip 协议由 MEET、PING、PONG 这三种消息实现，他们的的正文就是上面的 ping 结构体。</p><p>因为共用消息正文，所以需要消息头的 type 属性来区分。每次发送这类消息时，发送者都从已知节点中<strong>随机选择两个节点</strong>保存到 clusterMsgDataGossip，因此正文包含两个 clusterMsgDataGossip 结构：</p><pre><code class="line-numbers language-c">typedef struct (    //节点的名字    char nodename [REDIS_CLUSTER_NAMELEN]; .    //最后一次向该节点发送PING消息的时间戳    uint32_ t ping_sent;    //最后一次从该节点接收PONG消息的时间戳    uint32_t pong_received;    //节点的IP地址    char ip[16];    //节点的墙口号    uint16_t port;    //节点的标识值    uint16_t flags;}clusterMsgDataGossip;​</code></pre><p>消息接收者会根据 clusterMsgDataGossip 包含的节点，看是否为第一次接触，如果是的话，需要进行一次握手，记录节点信息；如果已经存在于已知节点中，则对相关节点信息更新。</p><h3 id="FAIL-消息的实现"><a href="#FAIL-消息的实现" class="headerlink" title="FAIL 消息的实现"></a>FAIL 消息的实现</h3><p>在集群节点较多的情况下，单纯使用 Gossip 会带来一些<strong>延迟</strong>，FAIL 消息需要所有节点立刻知道某个主节点下线了，从而尽快判断<strong>是否需要标记为下线或故障转移</strong>。消息正文是一个<code>cluster.h/clusterMsgDatafail</code>结构：</p><pre><code class="line-numbers language-c">typedef struct{    //记录下线节点的名字    char nodename[REDIS_CLUSTER_NAMELEN]}clusterMsgDataFail;</code></pre><p>因为名字都是集群内唯一的，所以可以这么保存。</p><h3 id="PUBLISH-消息的实现"><a href="#PUBLISH-消息的实现" class="headerlink" title="PUBLISH 消息的实现"></a>PUBLISH 消息的实现</h3><p>当集群的某个节点发送<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>时，会引发集群中所有节点都向 channel 发送消息。消息正文是一个<code>cluster.h/clusterMsgDataPublish</code>结构：</p><pre><code class="line-numbers language-c">typedef struct {    uint32_ t channel_len;    uint32_ t message_len;    //定义为8字节只是为了对齐其他消息结构    //实际的长度由保存的内容决定    unsigned char bulk_data[8] ;} clusterMsgDataPublish;​</code></pre><p>bulk_data 保存消息的 channel 和 message 参数。具体是根据对应参数长度识别的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 Sentinel 机制</title>
      <link href="/database/redis/redis-duo-ji-ku-de-shi-xian/redis-sentinel-ji-zhi/"/>
      <url>/database/redis/redis-duo-ji-ku-de-shi-xian/redis-sentinel-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-Sentinel-机制"><a href="#【Redis】-Sentinel-机制" class="headerlink" title="【Redis】 Sentinel 机制"></a>【Redis】 Sentinel 机制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 Sentinel 机制date: 2023-07-09 08:46tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 Sentinel 机制</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Sentinel（哨兵）是 Redis 的<strong>高可用性</strong>的解决方案，由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器以及属下的所有从服务器。当主服务器下线时，自动将下线的某个主服务器属下的某个从服务器<strong>升级</strong>为新的主服务器。从而实现<strong>故障转移</strong>，当原来的主服务器重新上线时，会被降级为从服务器。</p><p>下面展示了哨兵监视主从的状态：</p><p><img src="/attachment/d01e4544a8084f967936e061d0b2823d.png"></p><ul><li>Sentinel只是一个运行在<strong>特殊模式下的Redis服务器</strong>，它使用了和普通模式不同的命令表，所以Sentinel模式能够使用的命令和普通Redis服务器能够使用的命令不同。</li><li>Sentinel会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的<strong>命令连接</strong>和<strong>订阅连接</strong>，其中命令连接用于向主服务器<strong>发送命令请求</strong>，而订阅连接则用于<strong>接收指定频道的消息</strong>。</li><li>Sentinel通过向主服务器发送<strong>INFO命令</strong>来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。</li><li>在一般情况下，Sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送<strong>INFO命令</strong>，当主服务器处于下线状态，或者Sentinel正在对主服务器进行<strong>故障转移</strong>操作时，Sentinel向从服务器发送INFO命令的频率会改为每秒一次。</li><li>对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的__sentinel__:hello频道发送消息来向其他Sentinel宣告自己的存在。</li><li>每个Sentinel也会从__sentinel__:hello频道中接收其他Sentinel发来的信息，并根据这些信息为其他Sentinel创建相应的实例结构，以及命令连接。</li><li>Sentinel只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel与Sentinel之间则<strong>只创建命令连接</strong>。</li><li>Sentinel以每秒一次的频率向实例（包括主服务器、从服务器、其他Sentinel）发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向Sentinel发送无效回复时，Sentinel会将这个实例判断为主观下线。</li><li>当Sentinel将一个主服务器判断为<strong>主观下线</strong>时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意这个主服务器已经进入主观下线状态。</li><li>当Sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为<strong>客观下线</strong>，并发起一次针对主服务器的<strong>故障转移</strong>操作。</li></ul><p>下面主要讲解 Sentinel 系统对主服务器执行故障转移的整个过程。</p><h2 id="启动并初始化-Sentinel"><a href="#启动并初始化-Sentinel" class="headerlink" title="启动并初始化 Sentinel"></a>启动并初始化 Sentinel</h2><p>启动 Sentinel 有两种方式：</p><ul><li><code>redis-sentinel /path/to/your/sentinel.conf</code></li><li><code>redis-server /path/to/your/sentinel.conf --sentinel</code></li></ul><p>俩命令效果相同，启动时需要执行以下步骤：</p><ol><li>初始化服务器。</li><li>将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码。</li><li>初始化 Sentinel 状态。</li><li>根据配置文件，初始化 Sentinel 的监视主服务器列表。</li><li>创建连向主服务器的网络连接。</li></ol><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>Sentinel 实际上是一个特殊的 Redis 服务器，所以很多地方和 Redis 服务器的初始化有些类似。只不过少了 RDB 或 AOF 文件的载入等操作。</p><h3 id="使用-Sentinel-专用代码"><a href="#使用-Sentinel-专用代码" class="headerlink" title="使用 Sentinel 专用代码"></a>使用 Sentinel 专用代码</h3><p>将加载的常量，命令表（决定了 Sentinel 可以执行哪些命令）等替换为 Sentinel 专用的。</p><h3 id="初始化-Sentinel-状态"><a href="#初始化-Sentinel-状态" class="headerlink" title="初始化 Sentinel 状态"></a>初始化 Sentinel 状态</h3><p>初始化一个<code>sentinel.c/sentinelState</code>结构，记录 Sentinel 的状态，保存了服务器中所有与 Sentinel 相关的状态：</p><pre><code class="line-numbers language-c">struct sentinelState{    //当前纪元，选举计数器，用于实现故障转移    uint64_ t current_ epoch;    //（重点）保存了所有被这个sentinel监视的主服务器    //字典的键是主服务器的名字，值是一个指向sentine1RedisInstance结构的指针    dict masters;    //是否进入了TILT模式    int tilt;    //目前正在执行的脚本的数量    int running_ scripts;    //进入TILT模式的时间    mstime_ _t tilt_ start_ time;    //最后一次执行时间处理器的时间    mstime_ t previous_ time ;    //一个FIFO队列，包含了所有需要执行的用户脚本    list *scripts_ queue;}sentinel;</code></pre><h3 id="初始化-master-属性"><a href="#初始化-master-属性" class="headerlink" title="初始化 master 属性"></a>初始化 master 属性</h3><p>master 实例包括主服务器、从服务器或另一个 Sentinel。实例结构如下，了解一下，故障转移的可以先不关注：</p><pre><code class="line-numbers language-c">typedef struct sentinelRedisInstance {    //标识值，记录了实例的类型，以及该实例的当前状态.    int flags;    //实例的名字.    //主服务器的名字由用户在配置文件中设置    //从服务器以及Sentinel 的名字由Sentinel 自动设置    //格式为ip:port    char *name;    //实例的运行ID .    char *runid;    //配置纪元，用于实现故障转移    uint64_t config_epoch;    //实例的地址    sentinelAddr *addr;    // SENTINEL down-after-milliseconds 选项设定的值    //实例无响应多少毫秒之后才会被判断为主观下线    mstime_t down_after_period;    //判断这个实例为客观下线所需的支持投票数量    int quorum;    //在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量    int paral1el_syncs;    //刷新故障迁移状态的最大时限    mstime_t failover_timeout;    // ...} sentinelRedisInstance;​</code></pre><h3 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h3><p>Sentinel 会为监视的主服务器创建两个异步网络连接：</p><ul><li><strong>命令连接</strong>：专用于向主服务器发送命令，接收命令回复。</li><li><strong>订阅连接</strong>：专用于订阅主服务器<code>__sentinel__:hello</code>频道。（由于 Redis 的发布订阅消息不会保存，客户端断线就会丢失，为了不丢失，必须使用专门的频道连接）</li></ul><h2 id="获取主从服务器信息"><a href="#获取主从服务器信息" class="headerlink" title="获取主从服务器信息"></a>获取主从服务器信息</h2><p>Sentinel 默认 1<strong>0 秒一次</strong>通过命令连接被监视的主服务器并发送 <strong>INFO</strong> 命令，获取主服务器信息。主要获取主服务器本身信息（如服务器运行 ID），下属从服务器信息（如 ip，port，offset）。对应属性进行更新，如果没有某个从服务器新信息就会创建一个实例结构，放到主服务器的 slaves 字典中，键为 ip + 端口，值为 sentinelRedisInstance。除了创建新实例，还会创建连接到从服务器的<strong>命令连接</strong>和<strong>订阅连接</strong>。</p><h2 id="向主服务器和从服务器发送消息"><a href="#向主服务器和从服务器发送消息" class="headerlink" title="向主服务器和从服务器发送消息"></a>向主服务器和从服务器发送消息</h2><p>sentinel 默认以两秒一次，向服务器的<code>__sentinel__:hello</code>频道发送消息，命令：</p><p><code>PUBLISH __sentinel__:hello "&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;"</code></p><p>参数包含 sentinel 本身（s__…<em>）和主服务器（m</em>…）的运行 ID，ip，端口号，配置纪元等参数。</p><h2 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h2><p>Sentinel 与一个主服务器或从服务器建立订阅连接后，会发送<code>SUBSCRIBE _sentinel_:hello</code>命令。</p><p>也就是 Sentinel 通过命令连接发送信息到频道，又通过订阅连接接收频道中的信息。一个 Sentinel 发的信息也会被其他 Sentinel 接收，根据信息记录的 Sentinel 运行 id 和接收信息的 Sentinel <strong>运行 id 是否相同</strong>，来决定<strong>是否处理</strong>这条消息。通过这种透明的沟通机制，Sentinel 可以对各自监听的服务器信息进行更新。</p><h3 id="更新-sentinels-字典"><a href="#更新-sentinels-字典" class="headerlink" title="更新 sentinels 字典"></a>更新 sentinels 字典</h3><p>根据接收而来的消息，Sentinel 会更新实例结构中 sentinels 字典保存的所有 Sentinel 实例的信息。键为 Sentinel 的 ip + 端口，值为某个 Sentinel 的实例。消息接收者会检查发送消息的 Sentinel（源 sentinel）结构是否在 sentinels 字典存在则更新，没有则创建实例，和自己相同的 sentinel 不会被放入。</p><pre><code class="line-numbers language-c">typedef struct sentinelRedisInstance{    dict *sentinels;    ...}</code></pre><p>通过这种发布订阅的方式，Sentinel 不需要各自发信息告诉对方，而是监视同一个主服务器的多个 Sentinel 自动发现对方。</p><h3 id="创建连向其他-Sentinel-的命令连接"><a href="#创建连向其他-Sentinel-的命令连接" class="headerlink" title="创建连向其他 Sentinel 的命令连接"></a>创建连向其他 Sentinel 的命令连接</h3><p>sentinel 也会为对方互相创建命令连接，最终监视同一主服务器的多个 sentinel 会形成一个<strong>网络</strong>。但他们互相之间<strong>不会创建订阅连接</strong>，因为他们通过主或从服务器发来的频道来发现未知的 sentinel。</p><p><img src="/attachment/8b0415cc1263e38635f9df6dd08dbb8f.png"></p><h2 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h2><p>Sentinel 默认每秒与创建命令连接的实例（主服务器，从服务器，其他 sentinel）发送 PING 命令，通过回复判断是否在线。如果实例返回除了<code>+PONG</code>，<code>-LOADING</code>，<code>-MASTERRDOWN</code>之外的回复或未及时回复，就认为是<strong>无效回复</strong>。根据配置文件的<code>down-after-milliseconds</code>指定的<strong>主观下线所需时长内</strong>是否一直无效回复，来判断实例是否已经主观下线。下线了就将实例的的 flags 标识属性打开<code>SRI_S_DOWN</code>标识。由于每个 Sentinel 中的主观下线时间配置都可以不同，所有有可能<strong>某个 Sentinel 判断主观下线时，另一个 Sentinel 认为在线状态</strong>。</p><h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>当 Sentinel 判断主服务器为主观下线时，还会向其他 Sentinel 询问，得到足量数据已下线判断后，就会判定服务器为客观下线，并执行故障转移。</p><h3 id="发送-sentinel-is-master-down-by-addr-命令"><a href="#发送-sentinel-is-master-down-by-addr-命令" class="headerlink" title="发送 sentinel is-master-down-by-addr 命令"></a>发送 sentinel is-master-down-by-addr 命令</h3><p>Sentinel 使用：<code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current. epoch&gt; &lt;runid&gt;</code>命令询问其他 Sentinel 是否同意主服务器下线。这些参数分别是 Sentinel 的 ip，端口，配置纪元和运行 id。</p><h3 id="接收-sentinel-is-master-down-by-addr-命令"><a href="#接收-sentinel-is-master-down-by-addr-命令" class="headerlink" title="接收 sentinel is-master-down-by-addr 命令"></a>接收 sentinel is-master-down-by-addr 命令</h3><p>其他接收并返回三个参数的 Multi Bulk 回复：</p><ol><li><down_state>：是对主服务器的检查结果，1 表示已下线；0 表示未下线。</down_state></li><li><leader_runid>：如果是 *，表示该命令用于检测服务器状态；如果是 Sentinel 的运行 id 用于选举领头 Sentinel。</leader_runid></li><li><leader_epoch>：选举计数器，用于选举领头 sentinel。</leader_epoch></li></ol><h3 id="接收-sentinel-is-master-down-by-addr-命令的回复"><a href="#接收-sentinel-is-master-down-by-addr-命令的回复" class="headerlink" title="接收 sentinel is-master-down-by-addr 命令的回复"></a>接收 sentinel is-master-down-by-addr 命令的回复</h3><p>统计其他 Sentinel 同意主服务器已下线数量，当数量超过配置值（quorum 参数）时，sentinel 会将主服务器实例的 flags 属性的<code>SRI_O_DOWN</code>属性打开，表示已进入客观下线状态。</p><pre><code class="line-numbers language-c">typedef struct sentinelRedisInstance {    //判断这个实例为客观下线所需的支持投票数量    int quorum;    ...} sentinelRedisInstance;</code></pre><h2 id="选举领头-Sentinel"><a href="#选举领头-Sentinel" class="headerlink" title="选举领头 Sentinel"></a>选举领头 Sentinel</h2><p>当主服务器被判断为客观下线时，sentinel 会协商选举领头 sentinel，并由领头 sentinel 对下线主服务器执行故障转移操作。</p><p>当<code>SENTINEL is-master-down-by-addr</code>命令已经确认主服务器客观下线时，Sentinel 还会<strong>再发送</strong>带有选举性质的该命令，并且带上自己的运行 ID。如果接收命令的 Sentinel 还没设置局部领头时，就会将这个运行 ID 作为自己的 <strong>Multi Bulk 回复参数</strong>。根据回复参数来判断多少 sentinel 将自己设置为局部领头。可能根据网络延迟，有的 Sentinel 命令比其他 Sentinel 都先到达，并且胜出（必须有<strong>半数以上</strong>的票），那么就由它负责故障转移。一次选举没有产生，一段时间后再次选举，直到选出。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>故障转移包括 3 步：</p><ol><li>在已下线的主服务器属下从服务器里选出一个将其转为主服务器。</li><li>让其他从服务器都复制新主服务器。</li><li>当原来的主服务器再次上线时，让他成为新主服务器的从服务器。</li></ol><h3 id="选出新主服务器"><a href="#选出新主服务器" class="headerlink" title="选出新主服务器"></a>选出新主服务器</h3><p>如何选新的主服务器？Sentinel 会将所有从服务器放入列表，<strong>一项一项</strong>过滤：</p><ul><li>删除处于下线或断线状态的从服务器。</li><li>删除最近 5 秒没有回复过领头<code>sentinel INFO</code>命令的从服务器。</li><li>删除与已下线服务器段开时间超过<code>down-after-milliseconds*10</code>毫秒的从服务器。</li></ul><p>然后根据<strong>优先级排序</strong>，相同则选<strong>偏移量最大</strong>的，相同则选运行 ID 最小的。</p><p>选出来之后，对这个从服务器发送<code>SLAVEOF no one</code>命令，然后以<strong>每秒一次</strong>的频率向它发送<code>INFO</code>命令，观察返回的 role 属性如果变成 master，就表示顺利升级为主服务器了。</p><h3 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h3><p>向所有其他从服务器发送<code>SLAVEOF</code>命令，让他们都去复制新的主服务器。</p><h3 id="将旧的主服务器变为从服务器"><a href="#将旧的主服务器变为从服务器" class="headerlink" title="将旧的主服务器变为从服务器"></a>将旧的主服务器变为从服务器</h3><p>当原来的主服务器上线时，Sentinel 就会向它发送<code>SLAVEOF</code>命令，让他成为新主服务器的从服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 复制</title>
      <link href="/database/redis/redis-duo-ji-ku-de-shi-xian/redis-fu-zhi/"/>
      <url>/database/redis/redis-duo-ji-ku-de-shi-xian/redis-fu-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-复制"><a href="#【Redis】-复制" class="headerlink" title="【Redis】 复制"></a>【Redis】 复制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 复制date: 2023-07-09 08:44tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 复制</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Redis 中，可通过 SLAVEOF 命令或配置文件中设置 slaveof 选项，让一个服务器去复制另一个服务器，被复制的为主服务器，对其复制的称为从服务器。</p><ul><li>Redis 2.8以前的复制功能不能高效地处理断线后重复制情况，但Redis 2.8新添加的部分重同步功能可以解决这个问题。</li><li>部分重同步通过<strong>复制偏移量</strong>、<strong>复制积压缓冲区</strong>、<strong>服务器运行ID</strong>三个部分来实现。</li><li>在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。</li><li>主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器<strong>发送命令</strong>来进行<strong>心跳检测</strong>，以及命令丢失检测。</li></ul><h2 id="旧版本复制功能的实现"><a href="#旧版本复制功能的实现" class="headerlink" title="旧版本复制功能的实现"></a>旧版本复制功能的实现</h2><p>Redis 在 2.8 以前使用旧版本复制，在短线重连后的从服务器会遇上低效的情况。</p><p>Redis 的复制功能分为<strong>同步</strong>和<strong>命令传播</strong>俩操作：</p><ul><li>同步用于把从服务器的数据库状态<strong>更新至主服务器的数据库状态</strong>。</li><li>命令传播是在主服务器的<strong>数据库状态被修改</strong>时，导致主从数据库状态不一致时，让主从回到一致的过程。</li></ul><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>从服务器对主服务器的同步（下文以主从代替），需要向主服务器发送 SYNC 命令，具体步骤：</p><ol><li>从向主发送 SYNC 命令。</li><li>主接收并<strong>执行 BGSAVE</strong>，后台生成 RDB 文件，并用一个<strong>缓冲区记录</strong>现在开始执行的所有写命令。</li><li>BGSAVE 执行完毕时，主将 RDB 文件发给从，从接收并载入，更新数据库状态。</li><li>主将其记录在<strong>缓冲区的所有写命令</strong>发给从，从执行写命令。</li></ol><p><img src="/attachment/2bb57d5d270d7e17ac7a35fa1924a2e0.png"></p><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>当主发生写操作时，主从同步需要通过命令传播，具体步骤：</p><ol><li>主将写命令发送给从。</li><li>从接收并执行相同的写命令。</li></ol><h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>旧版复制的缺陷主要体现在断线重连上，主因为网络原因中断复制，但从通过自动重连连上主，并继续复制主的时候。此时，从发送 SYNC 命令，希望将<strong>断线期间</strong>由于写操作对主的数据库状态修改同步，但 SYNC 每次都会<strong>重新生成 RDB 文件</strong>，将<strong>所有的</strong>数据库状态都写到 RDB，这就造成了资源的<strong>大量浪费</strong>。SYNC 命令对性能的损耗比较高主要表现在：</p><ol><li>主执行 BGSAVE 生成 RDB 文件会消耗 <strong>CPU、内存和磁盘 I/O 资源</strong>。</li><li>主需要发送 RDB，消耗<strong>网络资源</strong>。</li><li>从接收并载入 RDB，载入期间是<strong>阻塞的无法处理命令</strong>。</li></ol><p>因此，必须是真正有必要才调用 SYNC 命令。</p><h2 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h2><p>Redis 从 2.8 开始使用 PSYNC 代替 SYNC 命令来执行同步操作。</p><p>PSYNC 有完整重同步和部分重同步的两种模式：</p><ul><li>完整重同步用于初次复制的情况，与 SYNC 命令一样。</li><li>部分重同步用于处理断线重连后的情况，重连后，主服务器将<strong>断线期间执行的写命令</strong>发送给从服务器，从只需接收并执行这些命令。</li></ul><p>部分重同步的执行过程：</p><ol><li>从向主发送 PSYNC 命令，请求同步数据。</li><li>主判断后，确认需要执行部分重同步时，返回给从 <strong>+COUNTINUE</strong>。</li><li>主将断线期间的写命令发送给从。</li></ol><p><img src="/attachment/c57a4d6a1035fee5e32c39ee2187c526.png"></p><h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><p>部分重同步基于三个部分实现：</p><ul><li>主从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区</li><li>服务器运行 ID</li></ul><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>主从都会维护一个复制偏移量，记录<strong>存储数据的字节数</strong>，当主服务器向从服务器传播 N 个字节数据时，主的复制偏移量会加 N，从接收到之后也会加 N。通过偏移量<strong>判断数据库状态是否一致</strong>。但有一个问题，就是从服务器重连后，需要执行部分还是完整重同步，这时候就需要复制积压缓冲区来帮忙判断。</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>复制积压缓冲区由主服务器维护，是固定长度的<strong>先进先出队列</strong>，默认 1M。当入队元素大于队列长度时，最先入队的元素会被弹出。主服务器在命令传播时，不仅将写命令发给从，还会将<strong>写命令入队至积压缓冲区</strong>。</p><p><img src="/attachment/becbcb51d25af6d8d15e01339dfe0337.png"></p><p>复制积压缓冲区会保存最近写的命令，并为队列中的<strong>每个字节记录复制偏移量</strong>。</p><p><img src="/attachment/9f9135e665a0ef4f512140b992649edf.png"></p><p>当从服务器重连后，发送 PSYNC 并将自己的复制偏移量也发送给主服务器，主服务器拿着复制偏移量去复制积压缓冲区找，如果<strong>存在</strong>则进行部分重同步并给从服务器<strong>发送 + CONTINUE</strong> 回复，否则进行完整重同步。</p><p>复制积压缓冲区大小应该根据实际场景的两个因素进行调整：</p><ul><li>断线重连平均时间</li><li>主服务器平均每秒产生写命令的数据量</li></ul><p>一般得将这两个指标相乘后再乘以 2，作为复制积压缓冲区的大小，应对大多数断线情况。</p><h4 id="服务器运行-ID"><a href="#服务器运行-ID" class="headerlink" title="服务器运行 ID"></a>服务器运行 ID</h4><p>服务器运行 ID 决定断线后执行哪种同步方式，主从都有运行 ID，是自动生成的 40 个随机十六进制字符。主从第一次复制时，从服务器会保存主服务器的 ID，断线后也会向主服务器发送这个 ID，如果<strong>不同则进行完整重同步</strong>（之前的主服务器由于某些原因连接断开，重新选举的情况）；相同则部分重同步。</p><h3 id="PSYNC-命令的实现"><a href="#PSYNC-命令的实现" class="headerlink" title="PSYNC 命令的实现"></a>PSYNC 命令的实现</h3><p>PSYNC 命令调用方法有两种：</p><ul><li>从服务器第一次复制时，会发送<code>**PSYNC ? -1**</code>命令，请求完整重同步。</li><li>已经复制过的情况，向主服务器发送<code>**PSYNC &lt;runid&gt; &lt;offset&gt;**</code>命令，一个是主服务器运行 ID，一个是积压缓冲区的偏移量。</li></ul><p>主服务器接收后有 3 种返回值：</p><ul><li><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>：表示执行<strong>完整重同步</strong>，从服务器会将这两个变量保存。</li><li><code>+CONTINUE</code>：执行<strong>部分重同步</strong>，从服务器等待缺失数据的发送。</li><li><code>-ERR</code>：主服务器版本低于 2.8，执行<strong>完整重同步</strong>操作。</li></ul><p><img src="/attachment/97e186a84ca1ce2df124c486b806b6d9.png"></p><h2 id="一次完整的主从复制过程"><a href="#一次完整的主从复制过程" class="headerlink" title="一次完整的主从复制过程"></a>一次完整的主从复制过程</h2><p>一次完整的复制过程可以分为设置主服务器的地址和端口、建立套接字连接、发送 PING 命令、身份验证、发送端口信息、同步、命令传播。</p><h3 id="设置主服务器的地址和端口"><a href="#设置主服务器的地址和端口" class="headerlink" title="设置主服务器的地址和端口"></a>设置主服务器的地址和端口</h3><p>当客户端向服务器发送 SLAVEOF 命令时，从服务器会将主服务器的 ip 和端口都保存后发送 OK。这是一个<strong>异步命令</strong>，所以复制工作在回复 OK 后再执行。</p><h3 id="建立套接字连接"><a href="#建立套接字连接" class="headerlink" title="建立套接字连接"></a>建立套接字连接</h3><p>从服务器此时创建连接主服务器的套接字，如果套接字能成功连接，从服务器会给它关联一个处理复制工作的<strong>文件事件处理器</strong>（负责接收 RDB，传播的命令等）。主从成功连接后，主服务器会创建从服务器的客户端状态。</p><h3 id="发送-PING-命令"><a href="#发送-PING-命令" class="headerlink" title="发送 PING 命令"></a>发送 PING 命令</h3><p>从服务器在套接字连接后做的第一个工作就是发送 PING 命令，检查套接字<strong>读写状态是否正常</strong>；主服务器<strong>能否正常处理命令请求</strong>。而主服务器会根据网络状态、能够处理给出对应回复。一旦回复超时或返回错误，从服务器就会断开并重连主服务器。</p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>检查从服务器是否设置 masterauth，如果设置则进行身份验证。</p><h3 id="发送端口信息"><a href="#发送端口信息" class="headerlink" title="发送端口信息"></a>发送端口信息</h3><p>身份验证后，从服务器向主服务器发送自己监听的端口号，主服务器保存这个端口号。</p><h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>从服务器发送 PSYNC 命令，主从互相成为对方的客户端，都能够执行命令并回复，执行同步操作，看是完整重同步还是部分重同步。</p><h3 id="命令传播-1"><a href="#命令传播-1" class="headerlink" title="命令传播"></a>命令传播</h3><p>完成同步后，进入该阶段，主服务器将写命令发送给从服务器，从服务器接收并执行。</p><h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>在命令传播阶段，从服务器默认 <strong>1 秒一次</strong>发送<code>REPLCONF ACK &lt;replication_offset&gt;</code>命令给主服务器，replication_offset 是复制偏移量。这么做有 3 个作用：</p><ul><li>检测主从网络状态</li><li>辅助实现 min-slave 选项</li><li>检测命令丢失</li></ul><h3 id="检测主从网络状态"><a href="#检测主从网络状态" class="headerlink" title="检测主从网络状态"></a>检测主从网络状态</h3><p>下面分别说这三个作用。检测网络连接很好理解，如果主服务器超过一秒没受到从服务器的<code>REPLCONF ACK</code>则表示连接有问题。</p><h3 id="辅助实现-min-slave-选项"><a href="#辅助实现-min-slave-选项" class="headerlink" title="辅助实现 min-slave 选项"></a>辅助实现 min-slave 选项</h3><p>Redis 的<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>可<strong>防止主服务器在不安全的情况下执行写命令</strong>。如果设置如下：</p><pre><code>min-slaves-to-write 3 min-slaves-max-lag 10</code></pre><p>表示从服务器数量少于 3 或 3 个从服务器延迟大于等于 10s 时，主服务器拒绝写命令。</p><h3 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h3><p>通过发送的偏移量，主服务器会判断命令是否有丢失，如果丢失，就从积压缓冲区里找到并<strong>补发</strong>。</p><p>注：Redis2.8 之前版本并<strong>不会注意</strong>到丢失数据，所以保持主从数据一致性最好使用以上版本。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 服务器</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-fu-wu-qi/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-服务器"><a href="#【Redis】-服务器" class="headerlink" title="【Redis】 服务器"></a>【Redis】 服务器</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 服务器date: 2023-07-09 08:42tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 服务器</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>简而言之，这章就是在解释客户端<strong>输入 Redis 指令到返回结果的执行过程</strong>。</p><ul><li>一个命令请求从发送到完成主要包括以下步骤：<ol><li>客户端将命令请求发送给服务器；</li><li>服务器读取命令请求，并分析出命令参数；</li><li>命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；</li><li>服务器将命令回复返回给客户端。</li></ol></li><li>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括<ol><li>更新服务器状态信息，</li><li>处理服务器接收的SIGTERM信号，</li><li>管理客户端资源和数据库状态，</li><li>检查并执行持久化操作等等。</li></ol></li><li>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：<ol><li>初始化服务器状态；</li><li>载入服务器配置；</li><li>初始化服务器数据结构；</li><li>还原数据库状态；</li><li>执行事件循环。</li></ol></li></ul><h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><p>首先是 Redis 服务器初始化操作，服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p><ol><li>初始化服务器状态。</li><li>载入服务器配置。</li><li>初始化服务器数据结构。</li><li>还原数据库状态。</li><li>执行事件循环。</li></ol><h3 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h3><p>主要是对 redisServer 结构体的初始化，包括设置服务器运行 ID，运行频率，设置配置文件路径，设置持久化条件，命令表创建等。</p><h3 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h3><p>根据用户设定的配置，对 redisServer 相关变量的值进行修改，比如端口号，数据库数量，RDB 的压缩是否开启等等。其他属性还是沿用默认值。</p><h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>服务器必须先载入用户配置，才能对其他数据结构进行准确初始化。其他数据结构包括客户端链表，db 数组，订阅信息，Lua 脚本执行环境，慢查询日志相关属性等等。</p><h3 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h3><p>载入 RDB 或 AOF 文件的数据恢复过程。</p><h3 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h3><p>至此，服务器可接收客户端请求并发送信息。</p><h2 id="命令执行过程"><a href="#命令执行过程" class="headerlink" title="命令执行过程"></a>命令执行过程</h2><p>以<code>SET key value</code>为例，命令的执行过程是：</p><ol><li>客户端发送命令。</li><li>服务器接收并处理请求，对数据库操作，回复 OK。</li><li>服务器将命令回复给客户端。</li><li>客户端接收命令并打印结果。</li></ol><p>下面将按照步骤拆解为发送，读取查找，执行预备操作，调用实现函数，执行后续工作，回复，打印操作讲解。</p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>客户端接收命令请求时，会将命令根据协议转为固定格式再发送给服务器。</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>当套接字因客户端的写入变得可读时，服务器会先读取协议格式内容并保存到输入缓冲区。命令分析，提取参数及个数，存入 argv 和 argc 属性。最后调用命令执行器。</p><h3 id="命令执行器-查找命令的实现"><a href="#命令执行器-查找命令的实现" class="headerlink" title="命令执行器 - 查找命令的实现"></a>命令执行器 - 查找命令的实现</h3><p>命令表是一个<strong>字典</strong>，键是命令名字，值是 redisCommand 结构。几个重要属性如下：</p><ul><li>name：命令名称。</li><li>proc：指向命令实现函数。</li><li>arity：命令参数个数，包括命令名称。</li><li>sflags：命令属性。</li></ul><p>查找命令表的过程就是找到 redisCommand，把指针指向它：</p><p><img src="/attachment/42f69c7f6daaba30ba8312e02846c4a4.png"></p><h3 id="命令执行器-执行预备操作"><a href="#命令执行器-执行预备操作" class="headerlink" title="命令执行器 - 执行预备操作"></a>命令执行器 - 执行预备操作</h3><p>在命令真正执行前需要有预备操作保证命令可以被正确，顺利地执行。这个环节相当于一层过滤，比如检查命令是否正确，参数是否正确，身份验证是否通过，内存是否够用等等。保证配置生效，准确执行。</p><h3 id="命令执行器-调用命令的实现函数"><a href="#命令执行器-调用命令的实现函数" class="headerlink" title="命令执行器 - 调用命令的实现函数"></a>命令执行器 - 调用命令的实现函数</h3><p>执行过程就是调用之前找到并指向的执行函数。通过 client-&gt;cmd-&gt;proc(client); 调用。然后将回复保存在客户端状态的输出缓冲区中，关联该套接字的命令回复处理器。</p><h3 id="命令执行器-执行后续工作"><a href="#命令执行器-执行后续工作" class="headerlink" title="命令执行器 - 执行后续工作"></a>命令执行器 - 执行后续工作</h3><p>有一些善后工作还将继续，比如慢查询日志记录，执行时长记录，AOF 持久化，主服务器将命令传给从服务器。当这些都处理完后，服务器就继续从文件时间处理器中取出并执行下一个命令请求。</p><h3 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h3><p>当客户端套接字变为可写状态，服务器执行命令回复处理器，将输出缓冲区的回复发送给客户端。</p><h3 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h3><p>将回复转为人类可读的格式，打印给用户看。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 客户端</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-ke-hu-duan/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-客户端"><a href="#【Redis】-客户端" class="headerlink" title="【Redis】 客户端"></a>【Redis】 客户端</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 客户端date: 2023-07-09 08:41tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 客户端</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 服务器的状态结构 clients 属性是<strong>链表</strong>，记录了所有与服务器相连的客户端结构，对客户端执行批量操作或查找操作，都可以通过 clients 链表完成：</p><pre><code class="line-numbers language-c">struct redisServer{    //一个链表，保存了所有客户端状态    list *clents    ...};</code></pre><p><img src="/attachment/920db7202bdda200313f8d5588a4bc22.png"></p><ul><li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li><li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li><li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li><li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li><li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li><li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li><li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li><li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li><li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li></ul><h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><p>客户端的属性主要分为通用和特定的，这里主要介绍通用的。简单来说有套接字描述符，标志，输入缓冲区，命令与参数，输出缓冲区，时间等。</p><pre><code class="line-numbers language-c">typedef struct redisClient{    //套接字描述符    int fd;    //标志    int flags;    //输入缓冲区    sds querybuf;    //单个命令拆分的数组    robj **argv;    //argv数组的长度    int argc;    //命令函数    struct redisCommand *cmd;    //固定大小输出缓冲区，默认16K    char buf[REDIS_REPLY_CHUNK_BYTES];    //buf已使用字节数    int bufpos;    //大小可变输出缓冲区    list *reply    //创建客户端的时间    time_t ctime;    //与服务器互动的最后时间    time_t lastinteraction;    //软性限制时间    time_t obuf_soft_limit_reached_time;    ...}redis client;</code></pre><h3 id="套接字描述符-fd"><a href="#套接字描述符-fd" class="headerlink" title="套接字描述符 fd"></a>套接字描述符 fd</h3><p>根据客户端类型不同：</p><ul><li>fd 为 - 1 表示伪客户端。</li><li>fd 为大于 - 1 的整数时表示普通客户端。</li></ul><p>伪客户端就是用于处理的命令请求来源于 AOF 或 Lua 脚本，不需要套接字连接，也就不需要套接字记录符。普通客户端就是所有来源于网络需要套接字连接的客户端。</p><h3 id="标志-flags"><a href="#标志-flags" class="headerlink" title="标志 flags"></a>标志 flags</h3><p>标志 flags 记录了客户端的角色。有主从标志，Lua 伪客户端标志，执行 MONITOR 标志… 标志可以以二进制来拼接：<code>flags:&lt;flag1&gt;|&lt;flag2&gt;|&lt;flag3&gt;...</code></p><h3 id="输入缓冲区-querybuf"><a href="#输入缓冲区-querybuf" class="headerlink" title="输入缓冲区 querybuf"></a>输入缓冲区 querybuf</h3><p>输入缓冲区存储客户端输入的指令，大小根据输入内容动态缩小扩大，最大不可超过 1G，否则导致服务器关闭该客户端。</p><h3 id="命令与参数-argv，argc）"><a href="#命令与参数-argv，argc）" class="headerlink" title="命令与参数 (argv，argc）"></a>命令与参数 (argv，argc）</h3><p>客户端输入的命令会先存放到数组 argv 中，其数据结构是这样的：</p><p><img src="/attachment/5a39935614975c0d34860507a262718a.png"></p><p>当客户端输入命令后，服务器根据 argv[0] 的值再命令表中查找（命令不区分大小写）对应命令的函数并给 cmd 赋值，cmd 就是对应的命令函数相关的操作信息。</p><h3 id="输出缓冲区（buf，bufpos，reply）"><a href="#输出缓冲区（buf，bufpos，reply）" class="headerlink" title="输出缓冲区（buf，bufpos，reply）"></a>输出缓冲区（buf，bufpos，reply）</h3><p>输出缓冲区有两个，一个大小固定，一个大小可变。大小固定的存储长度小的回复，比如 OK，错误返回等。大小可变缓冲区保存长度较大的回复，比如长列表，大集合。</p><p>大小可变缓冲区由 reply 链表实现，利用链表结构存储若干和字符串对象，使得长度不会受到限制。数据结构如下：</p><h3 id="时间（ctime，lastinteraction，obuf-soft-limit-reached-time）"><a href="#时间（ctime，lastinteraction，obuf-soft-limit-reached-time）" class="headerlink" title="时间（ctime，lastinteraction，obuf_soft_limit_reached_time）"></a>时间（ctime，lastinteraction，obuf_soft_limit_reached_time）</h3><p>服务器使用两种模式来限制客户端输出缓冲区的大小:</p><ul><li>硬性限制 (hard limit): 如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制 (softlimit): 软性限制比硬性限制小，服务器会根据输出缓冲区大小介于软硬性限制之间的时间决定是否关闭客户端 。</li></ul><h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><p>由于客户端有不同类型，所以创建和关闭的方式也不相同。</p><h3 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h3><p>客户端连接时调用 connect 函数，服务器就会调用连接事件处理器，为客户端创建状态，并创建新的客户端到 client 链表末尾。</p><h3 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h3><p>普通客户端可因其中一个原因关闭：</p><ul><li>客户端进程退出或者被杀死</li><li>客户端向服务器发送了带有不符合协议格式的命令请求</li><li>客户端成为了 CLIENT KILL 命令的目标</li><li>用户为服务器设置了 timeout 配置选项且当客户端的空转时间超过 timeout 时。不过 timeout 选项有客户端是主服务器，从服务器，正在被 BLPOP 等命令阻塞，正在执行 SUBSCRIBE、PSUBSCRIBE 等订阅命令，那么即使客户端的空转时间超过了 timeout 选项的值，客户端也不会被服务器关闭。</li><li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小 (默认为 1GB)</li><li>输出缓冲区的大小超过了硬性限制所设置的大小</li><li>输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制的时间超过指定时间。</li></ul><h3 id="Lua-脚本的伪客户端"><a href="#Lua-脚本的伪客户端" class="headerlink" title="Lua 脚本的伪客户端"></a>Lua 脚本的伪客户端</h3><p>服务器初始化时创建，随服务器结束关闭。</p><h3 id="AOF-文件的伪客户端"><a href="#AOF-文件的伪客户端" class="headerlink" title="AOF 文件的伪客户端"></a>AOF 文件的伪客户端</h3><p>载入 AOF 文件时创建，载入结束关闭。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 事件</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-shi-jian/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-事件"><a href="#【Redis】-事件" class="headerlink" title="【Redis】 事件"></a>【Redis】 事件</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 事件date: 2023-07-09 08:40tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 事件</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 服务器是一个<strong>事件驱动程序</strong>，主要有两种：</p><ul><li>文件事件：Redis 服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象。服务器与客户端通信会产生相应文件事件，服务器通过监听这些事件来完成一系列网络通信操作。</li><li>时间事件：Redis 服务器有一些需要在给定时间内执行的操作，而时间事件就是对这类定时操作的抽象。</li></ul><p>简单来说，文件事件就是<strong>套接字操作相关的事件</strong>；时间事件就是<strong>定时操作相关事件</strong>。</p><p><img src="/attachment/ac6460a0bd5d531922041e16fc619677.png"></p><p><img src="/attachment/66b550d03e4a8e2eeae8eedf70775185.png"></p><ul><li>Redis服务器是一个事件驱动程序，服务器处理的事件分为<strong>时间事件</strong>和<strong>文件事件</strong>两类。</li><li>文件事件处理器是<strong>基于Reactor模式</strong>实现的<strong>网络通信程序</strong>。</li><li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li><li>文件事件分为<strong>AE_READABLE事件（读事件）</strong>和<strong>AE_WRITABLE事件</strong>（写事件）两类。</li><li>时间事件分为<strong>定时事件</strong>和<strong>周期性事件</strong>：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li><li>服务器在一般情况下只执行<strong>serverCron函数</strong>一个时间事件，并且这个事件是周期性事件。</li><li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li><li>时间事件的实际处理时间通常会比设定的到达时间晚一些。</li></ul><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis 基于 Reactor 模式开发的网络事件处理器，就是文件事件处理器。大致是使用 I/O 多路复用程序<strong>同时监听多个套接字</strong>，根据套接字目前执行的任务为套接字<strong>关联不同的事件处理器</strong>；当被监听的套接字准备好<strong>应答，读取，写入，关闭</strong>等操作时。与之对应的文件事件就会产生，文件事件处理器就开始发挥作用了，调用事先关联好的事件处理器来处理事件。</p><p><img src="/attachment/2c4a583abe3309497b26cf6efba54179.png"></p><p>利用多路复用，虽然以单线程的方式运行，但文件事件处理器实现了高性能的网络通信模型，又能很好的与 Redis 服务器中其他模块对接，保持了设计的<strong>简单性</strong>。</p><h3 id="文件事件处理器的组成"><a href="#文件事件处理器的组成" class="headerlink" title="文件事件处理器的组成"></a>文件事件处理器的组成</h3><p>由套接字，I/O 多路复用程序，文件事件分派器，事件处理器组成。</p><p>I/O 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。I/O 多路复用程序总是将所有产生事件的<strong>套接字放入到一个队列</strong>中，以有序，同步，<strong>一次一个套接字</strong>向文件事件分派器传送的姿态来运行。只有当上一个套接字产生事件被事件处理器执行完了，才会继续传送下一个套接字。</p><p><img src="/attachment/3d386afeb9761489c690a472c9b354df.png"></p><h4 id="I-x2F-O-多路复用的实现"><a href="#I-x2F-O-多路复用的实现" class="headerlink" title="I/O 多路复用的实现"></a>I/O 多路复用的实现</h4><p>Redis 为所有多路复用的函数库进行包装，每个多路复用函数库在其中都对应一个单独文件：<code>ae_select.c</code>,<code>ae_epoll.c</code>,<code>ae_kqueue.c</code>。为每个多路复用函数都实现了相同的 API，所以多路复用程序的底层实现是可以互换的。Redis 在多路复用程序源码中用宏定义了相应规则，使得程序在编译时自动选择系统中性能最高的 I/O 多路复用函数库。</p><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><p>多路复用程序可监听的套接字事件可分为<code>ae.h/AE_READABLE</code>事件和<code>ae.h/AE_WRITABLE</code>事件。</p><ul><li>当套接字变得<strong>可读</strong>时（客户端对套接字执行 write，close，accept 后），套接字产生 AE_READABLE 事件。</li><li>当套接字变得<strong>可写</strong>时（客户端对套接字执行 read 操作后），套接字产生 AE_WRITABLE 事件。</li></ul><p>I/O 多路复用程序允许服务器同时监听者两个事件，如果某个套接字同时产生了两种事件，文件事件分派其会优先处理 AE_READABLE，再处理 AE_WRITABLE</p><h4 id="文件事件处理器的事件处理器"><a href="#文件事件处理器的事件处理器" class="headerlink" title="文件事件处理器的事件处理器"></a>文件事件处理器的事件处理器</h4><p>根据客户端的需要，事件处理器分为连接应答处理器，命令请求处理器，命令回复处理器，复制处理器。这里只介绍前三者。</p><ol><li>连接应答处理器</li></ol><p><code>networking.c/acceptTcpHandler</code>函数是 Redis 的连接应答处理器，用于连接服务器监听套接字的客户端进行应答。</p><p>Redis 服务器初始化时，程序就将连接应答处理器和服务器监听套接字的 <strong>AE_READABLE 事件关联</strong>，当客户端调用<code>sys/socket.h/connect</code>函数时连接服务器监听套接字时，套接字就会产生 AE_READABLE 事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p><p>简单来说就是客户端<strong>连接被监听的套接字</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>连接应答处理器就会执行</strong>。</p><ol start="2"><li>命令请求处理器</li></ol><p><code>networking.c/readQueryFromClient</code>函数是 Redis 命令请求处理器，主要负责从套接字中读入客户端发送的命令请求内容。</p><p>当客户端成功连接到服务器后，服务器会将 <strong>AE_READABLE 事件</strong>和命令请求处理器关联。当客户端向服务器发送命令请求时，套接字产生 AE_READABLE 事件，引发命令请求处理器执行，执行相应套接字的读入操作。</p><p>简单来说就是客户端<strong>发送命令请求</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>命令请求处理器就会执行</strong>。</p><ol start="3"><li>命令回复处理器</li></ol><p><code>networking.c/sendReplyToClient</code>函数是 Redis 的命令回复处理器，负责将服务器执行命令后得到的命令回复通过套接字返回给客户端。</p><p>当需要回复命令结果时，服务器会将客户端套接字的 <strong>AE_WRITEBLE 事件</strong>和命令回复处理器关联，当客户端准备好接收回复时就会产生 AE_WRITABLE 事件，引发命令回复处理器执行。执行结束，服务器会解除命令回复处理器与客户端的套接字 AE_WRITABLE 事件之间的关联。</p><p>简单来说就是服务器<strong>发送命令回复</strong>时，套接字<strong>产生并触发写事件</strong>，<strong>命令回复处理器就会执行</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一次完整的基于文件事件的服务器与客户端交互，相关处理器的处理过程：</p><ol><li>客户端发起连接，产生读事件，触发连接应答处理器执行。创建套接字，客户端状态并将该套接字的读事件与命令请求处理器关联。</li><li>客户端发送命令，产生读事件，触发命令请求处理器。读取执行命令，得到回复并将该套接字的写事件与命令回复处理器关联。</li><li>客户端读取命令回复，产生写事件，触发命令回复处理器。将回复写入套接字，解除读事件与命令回复处理器的关联。</li></ol><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>时间事件可分为<strong>定时事件</strong>和<strong>周期性事件</strong>：</p><ul><li>定时事件: 只在指定事件到达一次。如 xx 时间后执行一次。</li><li>周期性事件: 每隔一段时间执行一次。如每隔 xx 秒执行一次。</li></ul><p>注：Redis 一般只用周期性事件。</p><h3 id="时间事件的组成"><a href="#时间事件的组成" class="headerlink" title="时间事件的组成"></a>时间事件的组成</h3><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一 ID (标识号)。 ID 号按<strong>从小到大</strong>的顺序递增，新事件的 ID 号比旧事件大。</li><li>when：毫秒精度的 UNIX 时间戳，时间事件的到达 (arrive) 时间。</li><li>timeProc：时间事件处理器函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>事件处理器返回<code>ae.h/AE_NOMORE</code>, 为定时事件：该事件在达到一次之后被删除，之后不再到达。</li><li>事件处理器返回非<code>AE_NOMORE</code>的整数值，为周期性时间。当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的 when 属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，遍历整个链表，找到已到达的时间事件，调用相应的事件处理器。新的事件总是插入到链表的表头。</p><p><img src="/attachment/3cb8b55e4a5b27f9cddb7b200a0782ee.png"></p><p>因为事件 ID 只能增大，所以新插入的 id 总是最大的。</p><h3 id="serverCron-函数"><a href="#serverCron-函数" class="headerlink" title="serverCron 函数"></a>serverCron 函数</h3><p>很多情况下，Redis 需要定期进行资源检查，状态同步等操作，就需要定期操作，而定期操作都是由 serverCron 函数负责的，也是时间事件的应用实例。默认每隔 100ms 执行，具体工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。口清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行 AOF 或 RDB 持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>下面简单从几个方面出发，介绍 serverCron 的本职工作。</p><h4 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h4><p>Redis 不少功能依赖于系统当前时间，每次获取系统时间都会进行系统调用，为减少系统调用次数，服务器使用了 unixtime 和 mstime 作为当前时间的缓存。</p><pre><code class="line-numbers language-c">struct redisServer{    //保存了秒级精度的系统当前UNIX时间戳    time_t unixtime;    //保存了毫秒级的系统当前UNIC时间戳    long long mstime;    ...}</code></pre><p>由于 serverCron 默认 100 毫秒更新一次 unixtime 和 mstime，导致其精度不高，只使用于精度要求不高的场景：</p><ul><li>服务器打印日志，更新服务器的 LRU 时钟，决定执行持久化，计算上限时间等。</li><li>设置过期时间，添加慢查询日志需要高高进度，服务器还是会进行系统调用。</li></ul><h4 id="更新-LRU-时钟"><a href="#更新-LRU-时钟" class="headerlink" title="更新 LRU 时钟"></a>更新 LRU 时钟</h4><p>每个 Redis 对象也会有 lru 属性，记录上一次被命令访问的时间。如果要计算一个键的空转时长，就要通过 lrulock 记录的时间减去对象的 lru 属性记录时间。</p><pre><code class="line-numbers language-c">struct redisServer{    //默认每10秒更新一次的时钟缓存，    //用于计算键的空转时长    unsigned lrulock:22;    ...}typedef struct redisObject{    //对象最后一个被命令访问的时间    unsigned lru:22;    ...}</code></pre><h4 id="更新服务器每秒执行命令数"><a href="#更新服务器每秒执行命令数" class="headerlink" title="更新服务器每秒执行命令数"></a>更新服务器每秒执行命令数</h4><p>抽样计算函数以 100 毫秒一次，估算最近一秒钟的处理请求数。每次都会根据 4 个变量（上次抽样时间、当前时间、上次抽样已执行命令数、当前已执行命令数）来计算调用之间平均每毫秒处理几个命令，乘以 1000 就是 1 秒内处理命令的估计值。这个估计值会被放入 redisServer 的 ops_sec_samples 数组中。当我们需要知道秒内的指令数时，就会计算这个数组的平均数，因此结果是一个估算值。</p><h4 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h4><pre><code class="line-numbers language-c">struct redisServer{    //已使用内存峰值    size_t stat_peak_memory;    ...}</code></pre><p>stat_peak_memory 记录内存峰值，每次 serverCron 函数执行就会判断是否需要刷新内存峰值，如果当前使用的多就刷新。</p><h4 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h4><p>serverCron 每次执行都会调用 clientsCron 函数对客户端进行检查：如果已经超时则关闭；如果输入缓冲区大小超过一定长度则重新创建默认大小的输入缓冲区。</p><h4 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h4><p>serverCron 每次执行都会调用 databaseCron 函数，会对服务器的一部分数据库检查，删除过期键；对字典收缩。</p><p><strong>执行被延迟的 BGREWRITEAOF</strong></p><pre><code class="line-numbers language-c">struct redisServer{    //AOF延迟标志位，如果为1，则有AOF操作被延迟    int aof_rewrite_shceduled;    ...}</code></pre><p>由<code>aof_rewrite_shceduled</code>标志位决定，如果处于 BGSAVE 命令执行期间，BGREWRITEAOF 会被延迟到 BGSAVE 执行后执行。</p><h4 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h4><pre><code class="line-numbers language-c">struct redisServer{    //执行BGSAVE命令的子进程，没有为-1    pid_t rdb_child_pid;    //执行BGREWRITEAOF命令的子进程，没有为-1    pid_t aof_child_pid;    ...}</code></pre><p><code>rdb_child_pid</code>和<code>aof_child_pid</code>只要<strong>一个不为 - 1</strong>，则检查子进程是否有信号发来。如果有信号到达则进行后续操作，比如新 <strong>RDB 文件的替换，重写的 AOF 文件替换</strong>等。</p><p>如果<code>rdb_child_pid</code>和<code>aof_child_pid</code><strong>都为 - 1</strong>，则进行检查：</p><ul><li>是否有 BGREWRITEAOF 被延迟，有的话就进行 BGREWRITEAOF 操作。</li><li>自动保存条件是否满足，满足且未执行其他持久化操作则执行 BGSAVE。</li><li>AOF 重写条件是否满足，满足且未执行其他持久化操作则开始一次新的 BGREWRITEAOF 操作。</li></ul><p><img src="/attachment/98f02e914df90aa1426ac1c59bd447a4.png"></p><h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>当服务器同时存在时间事件和文件事件，调度时该如何选择，花费多久？</p><p>事件的调度由<code>ae.c/aeProcessEvents</code>函数负责。对于每一次事件循环，主要过程是：</p><ol><li>拿到最近的时间事件并计算还有多少毫秒。</li><li>创建时间任务结构；阻塞等待文件时间产生，最大阻塞时间<strong>由最近时间事件到达毫秒数决定</strong>。</li><li>先处理已产生的<strong>文件事件</strong>再处理到达的<strong>时间事件</strong>。</li></ol><p>执行原则 / 设计利弊：</p><ol><li>aeApiPoll 函数（redis 封装的多路复用函数）的最大阻塞时间由到达时间<strong>最接近当前时间的时间事件</strong>决定，这个方法既可以避免服务器对时间事件进行频繁的轮询 (忙等待)，也可以确保 aeApiPoll 函数<strong>不会阻塞过长时间</strong>。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。</li><li>对文件事件和时间事件的处理都是<strong>同步、有序、原子地执行</strong>的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器, 还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 AOF 持久化</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-aof-chi-jiu-hua/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-aof-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-AOF-持久化"><a href="#【Redis】-AOF-持久化" class="headerlink" title="【Redis】 AOF 持久化"></a>【Redis】 AOF 持久化</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 AOF 持久化date: 2023-07-09 08:39tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 AOF 持久化</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态。服务器启动时，可通过载入和执行 AOF 文件中保存的命令来还原服务器关闭前的数据库状态。</p><p><img src="/attachment/e07cc22d8e9bfa9cd0d5fce9b2a29b1c.png"></p><ul><li>AOF文件通过保存所有<strong>修改数据库的写命令</strong>请求来记录服务器的数据库状态。</li><li>AOF文件中的所有命令都以<strong>Redis命令请求协议</strong>的格式保存。</li><li>命令请求会先保存到<strong>AOF缓冲区</strong>里面，之后再定期写入并同步到AOF文件。</li><li>appendfsy nc选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。</li><li>服务器只要<strong>载入并重新执行保存在AOF文件中的命令</strong>，就可以还原数据库本来的状态。</li><li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库<strong>状态一样</strong>，但<strong>体积更小</strong>。</li><li>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</li><li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个<strong>AOF重写缓冲区</strong>，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF</li></ul><p>文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p><h2 id="AOF-持久化的实现"><a href="#AOF-持久化的实现" class="headerlink" title="AOF 持久化的实现"></a>AOF 持久化的实现</h2><p>AOF 持久化可分为命令追加，文件写入，文件同步三个步骤。</p><h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>开启 AOF 持久化后，服务器执行完一个写命令后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的 <strong>aof_buf 缓冲区末尾</strong>：</p><pre><code class="line-numbers language-c">struct redisServer{    //AOF缓冲区    sds aof_buf;    ...};</code></pre><h3 id="AOF-文件的写入与同步"><a href="#AOF-文件的写入与同步" class="headerlink" title="AOF 文件的写入与同步"></a>AOF 文件的写入与同步</h3><p>Redis 服务器进程就是一个<strong>事件循环</strong>，负责接收客户端命令请求及命令回复，时间事件负责执行向<code>serverCron</code>函数这样需要定时运行的函数。服务器每结束一个时间循环前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否有必要<strong>将 aof 缓冲区中的内容写入和保存至 AOF 文件</strong>里。这个判断的依据就是根据配置文件的 appendfsync 值决定：</p><ul><li>always：将 aof_buf 缓冲区的所有内容<strong>写入并同步</strong>到 AOF 文件。</li><li>everysec：将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间<strong>超过一秒</strong>，就再次对 AOF 文件进行同步，并由一个线程专门负责。</li><li>no：将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，但并<strong>不对 AOF 文件进行同步</strong>，何时同步<strong>由操作系统决定</strong>。</li></ul><p>为什么有写入和同步的区分？写入≠同步</p><p>为提高写效率，操作系统一般将写入数据<strong>暂时保存在内存缓冲区</strong>，等缓冲区<strong>填满或超过</strong>指定时间后才会真正地将<strong>数据同步到磁盘里</strong>。操作系统提供了 fsync 和 fdatasync 两同步函数，可<strong>强制操作系统同步数据</strong>，保证数据安全性。</p><p>也就是说，每一次的事件循环，aof_buf 中的指令<strong>都会被写入操作系统的缓冲区</strong>，根据 appendfsync 配置，当操作系统缓冲区满足一定条件后，就被<strong>真实地写入</strong>磁盘内。</p><h2 id="AOF-文件的载入与数据还原"><a href="#AOF-文件的载入与数据还原" class="headerlink" title="AOF 文件的载入与数据还原"></a>AOF 文件的载入与数据还原</h2><p>步骤如下：</p><ol><li>创建一个没有网络连接的伪客户端。由于 Redis 命令只能在客户端上下文中执行，并且 AOF 文件在本地而不是网络。</li><li>解析 AOF 文件并取出一条写命令。</li><li>使用伪客户端执行被读出的写命令</li><li>持续执行 2 和 3，直到所有写命令都已经执行完毕</li></ol><p><img src="/attachment/c50d73913c36b39f22d6dc108c5da992.png"></p><h3 id="AOF-创建和重写时对过期键的处理套路"><a href="#AOF-创建和重写时对过期键的处理套路" class="headerlink" title="AOF 创建和重写时对过期键的处理套路"></a>AOF 创建和重写时对过期键的处理套路</h3><p>如果数据库中的某个键已经过期且没有被删除，AOF 文件不会因为这个对过期键产生影响。当过期间被惰性删除或定期删除后，AOF 文件<strong>追加一条 DEL 命令</strong>来显式删除。</p><p>AOF 重写时，程序会对数据库的键检查，已过期的<strong>不会保存</strong>到 AOF 文件中。</p><h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>因为 AOF 持久化会将所有的写命令都记录，所以会有冗余情况，比如频繁地创建删除键值对，或者对同一个键的值频繁更新，都会导致文件的内容越来越多。所以需要一种<strong>瘦身的机制</strong>确保 AOF 里存的都是必不可少的精华。</p><p>Redis 提供 AOF 文件重写功能，让服务器创建一个新的 AOF 文件，替代现有的 AOF 文件，减少冗余命令。</p><h3 id="AOF-文件重写的实现"><a href="#AOF-文件重写的实现" class="headerlink" title="AOF 文件重写的实现"></a>AOF 文件重写的实现</h3><p>在新的 AOF 文件的重写过程中，不会读取旧 AOF 文件，而是通过<strong>读取数据库状态</strong>来实现的。首先从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前记录的多条命令。</p><p>注：在重写时会先检查键所包含的元素数量，因为多元素的键在命令转换时可能会导致客户端输入缓冲区溢出。因此读取配置中对应的常量，默认超过 64 个就用多条指令记录。</p><h3 id="AOF-后台重写过程"><a href="#AOF-后台重写过程" class="headerlink" title="AOF 后台重写过程"></a>AOF 后台重写过程</h3><p>AOF 重写的过程中会有大量的写入操作，为了避免 Redis 服务器长时间的阻塞，重写工作将被放到<strong>子进程中进行</strong>。这样的好处是：</p><ul><li>父进程仍然可继续处理请求。</li><li>子进程有自己的数据副本，而非子线程，可以避免一些线程安全性问题的出现。</li></ul><p>子进程在执行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，导致<strong>当前数据库状态与重写后的 AOF 文件保存状态不一致</strong>。为解决这个问题，设置了 <strong>AOF 重写缓冲区</strong>。</p><p>当重写子进程创建后，Redis 服务器执行完写命令就会将其写入 AOF 缓冲区和 AOF 重写缓冲区，子进程执行重写期间，服务器进程要执行 3 个工作：</p><ol><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到 AOF 缓冲区。</li><li>将执行后的写命令追加到 AOF 重写缓冲区。</li></ol><p><img src="/attachment/875dc96dab16f0743e27de35f672b65c.png"></p><p>当子进程完成重写后，会向父进程<strong>发送一个信号</strong>，父进程接收并调用信号处理函数，将重写缓冲区的所有内容写到新 AOF 文件中，原子地覆盖现有的 AOF 文件。因此整个 AOF 文件重写的过程中，只有<strong>信号处理函数执行时，才会阻塞</strong>，将性能损耗降到最低。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 RDB 持久化</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-rdb-chi-jiu-hua/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-rdb-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-RDB-持久化"><a href="#【Redis】-RDB-持久化" class="headerlink" title="【Redis】 RDB 持久化"></a>【Redis】 RDB 持久化</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 RDB 持久化date: 2023-07-09 08:38tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 RDB 持久化</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于 Redis 是内存数据库，数据状态都存储于内存，如果不想办法将存储在内存中的数据库状态保存到磁盘里，那么一旦服务器进程退出，服务器中的数据库状态也会消失。</p><p>为解决这个问题，Redis 提供了持久化的功能，可将内存中的数据库保存到磁盘，防止意外丢失。RDS 持久化（默认持久化策略）就是将某一时间点上的状态保存到一个 RDB 文件里。RDB 文件是经过<strong>压缩的二进制文件</strong>，可通过该文件还原成数据库状态。</p><p><img src="/attachment/397e2f468246a0464cd81462262cf7e2.png"></p><p><img src="/attachment/f8bdc604be32622fd208ac3ae22fcd1c.png"></p><ul><li>RDB文件用于保存和还原Redis服务器所有数据库中的<strong>所有键值对数据</strong>。</li><li><strong>SAVE命令</strong>由服务器进程直接执行保存操作，所以该命令会<strong>阻塞</strong>服务器。</li><li><strong>BGSAVE命令</strong>由子进程执行保存操作，所以该命令<strong>不会阻塞</strong>服务器。</li><li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li><li>RDB文件是一个经过<strong>压缩的二进制文件</strong>，由多个部分组成。</li><li>对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。</li></ul><h2 id="RDB-文件的创建与载入"><a href="#RDB-文件的创建与载入" class="headerlink" title="RDB 文件的创建与载入"></a>RDB 文件的创建与载入</h2><p>有两个命令可用于生成 RDB 文件（SAVE 和 BGSAVE）。他们之间的区别是：SAVE 会<strong>阻塞</strong> Redis 服务器进程，直到 RDB 文件创建完毕为止，阻塞期间，服务器不能处理任何命令请求。而 BGSAVE 会 <strong>fork 出一个子进程</strong>，由子进程负责创建 RDB 文件，<strong>父进程继续处理命令请求</strong>。当子进程完成之后，向父进程<strong>发送信号</strong>。</p><p>创建就是执行 SAVE/BGSAVE 底层调用 rdbSave 函数的过程，载入就是服务启动时读取 RDB 文件底层调用 rdbLoad 函数的过程。</p><h3 id="RDB-创建与载入时对过期键的处理套路"><a href="#RDB-创建与载入时对过期键的处理套路" class="headerlink" title="RDB 创建与载入时对过期键的处理套路"></a>RDB 创建与载入时对过期键的处理套路</h3><p>执行<code>SAVE</code>或<code>BGSAVE</code>时，创建一个新的 RDB 文件，程序回对数据库中键检查，已过期的就不会包含到 RDB 文件中。</p><p>在启动时，RDB 文件载入：</p><ul><li>如果服务器以主服务模式运行，程序对文件保存的键检查，未过期的载入到数据库，过期则<strong>忽略</strong>。</li><li>如果服务器以从服务模式运行，无论是否过期，<strong>都会载入</strong>到数据库。因为主服务器在数据同步时，会将从服务器的数据库清空，一般不会有影响。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>在一定间隔时间做一次备份，所以如果 redis 挂了，就会<strong>丢失最后一次快照后的所有修改</strong>。</li><li>fork 的时候，内存中的数据被克隆一份，大致 <strong>2 倍的膨胀性</strong>需要考虑内存空间。</li></ul><h3 id="BGSAVE-执行时的服务器状态"><a href="#BGSAVE-执行时的服务器状态" class="headerlink" title="BGSAVE 执行时的服务器状态"></a>BGSAVE 执行时的服务器状态</h3><p>BGSAVE 命令执行期间，对 SAVE，BGSAVE，BGREWRITEAOF（AOF 持久化命令）三个命令的处理方式如下：</p><p>由于 SAVE，BGSAVE 底层都是调用 rdbSave 来持久化文件的，而且父子进程同时执行两个 rdbSave 调用会<strong>产生竞态条件</strong>，所以这两个指令会被服务器拒绝。BGREWRITEAOF 会被延迟到 BGSAVE 执行结束后执行。<br>如果 BGREWRITEAOF 正在执行，服务器会拒绝 BGSAVE 命令。由于 BGREWRITEAOF 和 BGSAVE 都会产生子进程且有大量的磁盘写入，出于性能考虑不会同时执行。</p><p>简单来说，就是 BGSAVE 执行期间，<strong>拒绝 SAVE，BGSAVE</strong>；<strong>延迟执行 BGREWRITEAOF</strong>。BGREWRITEAOF 执行期间，<strong>拒绝 BGSAVE</strong>。</p><h3 id="RDB-与-AOF-共存的载入情况"><a href="#RDB-与-AOF-共存的载入情况" class="headerlink" title="RDB 与 AOF 共存的载入情况"></a>RDB 与 AOF 共存的载入情况</h3><p>RDB 文件的载入是在服务器启动时执行，Redis 并没有专门提供载入 Redis 的命令。由于 AOF 文件的更新频率更高，因此开启 AOF 持久化功能后，启动时<strong>优先加载 AOF</strong> 还原数据，只有在 AOF 处于关闭状态，才使用 RDB 文件恢复数据。</p><h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>服务器允许用户通过配置文件设置隔一定时间自动执行 BGSAVE。可通过 save 选项设多个保存条件，默认的配置如下：</p><pre><code class="line-numbers language-c">save 900 1save 300 10save 60 10000</code></pre><p>只要满足任意条件，900s 内对数据库进行 1 次修改或 300s 内…BGSAVE 就会被执行。</p><p>那么，服务器是如何根据 save 选项来自动执行 BGSAVE 的？<br>从实现角度考虑，我们需要<strong>记录配置</strong>、<strong>评判依据</strong>和<strong>依据更新驱动</strong>。记录配置由 saveparams 实现；评判依据是 dirty 计数器和 lastsave 属性；依据更新驱动就是 serverCron 对评判依据的动态更新。<br>save 配置都会在 redisServer 的 saveparam 数组中体现：</p><pre><code class="line-numbers language-c">struct redisServer{    //记录了保存条件的数组    struct saveparam *saveparams;    ...};struct saveparam{    //秒数    time_t seconds;    //修改数    int changes;};</code></pre><h3 id="dirty-计数器和-lastsave-属性"><a href="#dirty-计数器和-lastsave-属性" class="headerlink" title="dirty 计数器和 lastsave 属性"></a>dirty 计数器和 lastsave 属性</h3><p>这两个属性由 redisServer 持有：</p><ul><li>dirty 计数器记录距离上次成功执行 SAVE 或 BGSAVE 后数据库被修改了几次。</li><li>lastsave 是一个 UNIX 时间戳，记录上次成功执行 SAVE 或 BGSAVE 的时间。</li></ul><pre><code class="line-numbers language-c">struct redisServer{    //修改计数器    long long dirty;    //上一次执行保存的时间    time_t lastsave;    //...};</code></pre><h3 id="检查条件是否满足"><a href="#检查条件是否满足" class="headerlink" title="检查条件是否满足"></a>检查条件是否满足</h3><p>Redis 的周期性操作函数 serverCron 每隔 100 毫秒会执行一次，其中一项工作就是检查 save 选项设置的保存条件是否满足要求，满足则执行 BGSAVE。</p><h2 id="RDB-文件结构"><a href="#RDB-文件结构" class="headerlink" title="RDB 文件结构"></a>RDB 文件结构</h2><p><img src="/attachment/32420f4dff71b35fb14eaa0b1152e957.png"></p><p>REDIS：长度 5 字节，保存 “REDIS”5 个字符（为书写方便，其实是 5 个单独字符），通过这个判断该文件是否为 RDB 文件。</p><p>db_version：长度 4 字节，是字符串表示的整数记录 RDB 的版本号。</p><p>database：包含 0 个或多个数据库及各数据库中键值对数据。表示那些数据库是有数据的。</p><p>EOF：常量长度 1 字节，标志 RDB 文件正文的结束。读取时遇到该值，表示键值对的载入已经结束了。</p><p>check_sum：是一个 8 字节的无符号整数，保存一个同过前几位变量计算出来的校验和。每次加载都会进行计算校验，通过这个来判断文件是否损坏。</p><h3 id="database-部分"><a href="#database-部分" class="headerlink" title="database 部分"></a>database 部分</h3><p>每个非空数据库在 RDB 文件中都可表示为 SELECTDB，db_number，key_value_pairs 三部分</p><ul><li>selectdb：1 字节，标志位，标志着下一位存储的是数据库号码。</li><li>db_number：是一个数据库号码。</li><li>key_value_pairs：保存了数据库中所有键值对数据，如果有过期时间，则过期时间也会保存。</li></ul><h3 id="key-value-pairs-部分"><a href="#key-value-pairs-部分" class="headerlink" title="key_value_pairs 部分"></a>key_value_pairs 部分</h3><p>不带过期时间的键值对在 RDB 文件由 TYPE，key，value 组成，带过期时间则含有 EXPIRETIME_MS，ms：</p><p><img src="/attachment/114b672e75807c382972efb0754fc551.png"></p><p>EXPIRETIME_MS：标志位，长度为 1 字节，告知程序下一个读入的是以毫秒为单位的过期时间。<br>ms：是 8 字节长的带符号整数，记录 UNIX 时间戳，即过期时间。<br>type：记录 value 的类型，长度 1 字节，这个常量其实就是 Redis 对象类型和底层编码的组装：</p><ul><li>REDIS RDBTYPE_STRING</li><li>REDIS_ RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_HASH_ZIPLIST</li></ul><p>服务器会根据 TYPE 来决定如何读入和解释 value 的数据。</p><p>key 就不用做过多解释~</p><h3 id="value-的编码"><a href="#value-的编码" class="headerlink" title="value 的编码"></a>value 的编码</h3><p>根据 TYPE 的不同，value 的存储结构也大不相同。这里不详细展开，只需要知道，对于字符串对象，如果大于 20 字节，就会用 LZF 算法压缩。除字符串对象和整数集合，其他存储方式的开头都是节点数量，告诉程序应读入多少节点 / 键值对。</p><h2 id="分析-RDB-文件"><a href="#分析-RDB-文件" class="headerlink" title="分析 RDB 文件"></a>分析 RDB 文件</h2><p>Redis 自带 RDB 文件检查工具 redis-check-dump。可以帮助在系统故障后分析快照文件，也就是 RDB 文件。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 数据库</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-shu-ju-ku/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-数据库"><a href="#【Redis】-数据库" class="headerlink" title="【Redis】 数据库"></a>【Redis】 数据库</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 数据库date: 2023-07-09 08:37tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 数据库</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从 Redis 服务端的实现角度介绍，包括 db 存储，切换，键的存储及过期相关处理。</p><p><img src="/attachment/79a3ab862efb1ae17d0de6cb9b5cd3b0.png"></p><ul><li>Redis服务器的所有数据库都保存<strong>在redisServer.db数组</strong>中，而数据库的数量则由redisServer.dbnum属性保存。</li><li>客户端通过<strong>修改目标数据库指针</strong>，让它指向redisServer.db数组中的不同元素来<strong>切换不同的数据库</strong>。</li><li>数据库主要<strong>由dict和expires两个字典构成</strong>，其中<strong>dict字典</strong>负责保存<strong>键值对</strong>，而<strong>expires字典</strong>则负责<strong>保存键的过期时间</strong>。</li><li>因为数据库由字典构成，所以对数据库的操作都是建立在<strong>字典</strong>操作之上的。</li><li>数据库的<strong>键</strong>总是一个<strong>字符串对象</strong>，而<strong>值</strong>则可以是任意一种<strong>Redis对象类型</strong>，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。</li><li>expires字典的<strong>键</strong>指向<strong>数据库中的某个键</strong>，而<strong>值</strong>则记录了数据库键的<strong>过期时间</strong>，过期时间是一个以毫秒为单位的UNIX时间戳。</li><li>Redis使用<strong>惰性删除</strong>和<strong>定期删除</strong>两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li><li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li><li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li><li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li><li>当<strong>主服务器</strong>删除一个过期键之后，它会向所有从服务器发送一条<strong>DEL命令</strong>，显式地删除过期键。</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li><li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li></ul><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis 把所有库信息都保存在<code>redis.h/redisServer</code>结构的 db 数组中，数组类型是<code>redis.h/redisDB</code>，dbnum 决定着应该创建多少数据库中的 db，clients 维护着所有连接 Redis 的客户端：</p><pre><code class="line-numbers language-c">struct redisServer{    //服务器的数据库数量    int dbnum;    //一个数组，保存着服务器中的所有数据库    redisDb *db;    //客户端状态链表    list *clients;    //...}</code></pre><p>服务器数据库实例如图所示：</p><p><img src="/attachment/10b9c2751bf7753dacf1c337cd976540.png"></p><p>当切换库时，其实就是 redisClient.db 对 redisServer.db 数组的目标数据库指针的移动。下面展示了从 0 号库切为 1 号库的过程。通过<strong>指针的切换</strong>，实现对库的共享：</p><p><img src="/attachment/6a1916a768e8655f62460751cbf89d61.png"></p><h2 id="数据库的键空间"><a href="#数据库的键空间" class="headerlink" title="数据库的键空间"></a>数据库的键空间</h2><p>redis 将所有 key 进行统一管理，按照所属的库划分，放在 redisDb 的字典中（按照上面画的数据结构，redis 每一个库都对应一个 redisDb）。redisDb 结构的 dict 字典保存了该数据库中的所有键值对，也称为<strong>键空间</strong>。键空间的数据结构如下：</p><pre><code class="line-numbers language-c">typedef struct redisDb{    //数据库键空间，保存着数据库中的所有键值对    dict *dict;    ...}</code></pre><p>键空间的键就是数据库的键，每个键都是一个字符串对象，键空间的值就是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象</p><p><img src="/attachment/a1fe0204bfaf1c1acbbabb057e5e5237.png"></p><p>当执行一些插入指令时，就是对 dict 中 key 的新增；同理，删除键后，dict 中的键值对对象都会被删除。</p><h3 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h3><p>对键的读写时，服务器会做相应的善后操作，比如更新缓存的命中率，更新 LRU（最后一次使用）时间，对已过期的键先进行删除操作，修改时对客户端 watch 的键进行 dirty 标记，更新 dirty 键计数器的值，当开启通知功能后，键修改时需要按配置发送相应通知。</p><h2 id="键过期时间相关操作"><a href="#键过期时间相关操作" class="headerlink" title="键过期时间相关操作"></a>键过期时间相关操作</h2><p>通过<code>EXPIRE</code>或<code>PEXPIRE</code>，客户端可以以<strong>秒或毫秒</strong>为精度设置过期时间（Time To Live，TTL）。通过<code>EXPIREAT</code>或<code>PEXPIREAT</code>，客户端可以设置<strong>时间戳</strong>作为过期时间。</p><p>使用<code>TTL</code>或<code>PTTL</code>也可查看某个键的剩余生存时间，还有多久过期：</p><pre><code class="line-numbers language-shell">redis&gt; SET key valueOK redis&gt; EXPIRE key 500(integer) 1 redis&gt; TTL key(integer) 498</code></pre><p>Redis 是如何保存过期时间的，又是如何删除过期键的将在下面论述。</p><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>Redis 提供了 4 个命令设置过期时间：</p><ul><li><code>EXPIRE&lt;key&gt; &lt;ttl&gt;</code>：将 key 的生存时间设为 ttl 秒。</li><li><code>PEXPIRE&lt;key&gt; &lt;ttl&gt;</code>：将 key 的生存时间设为 ttl 毫秒。</li><li><code>EXPIREAT&lt;key&gt; &lt;timestamp&gt;</code>：将 key 的过期时间设置为 timestamp 秒数时间戳。</li><li><code>PEXPIREAT&lt;key&gt; &lt;timestamp&gt;</code>：将 key 的过期时间设置为 timestamp 毫秒数时间戳。</li></ul><p>其实几个命令底层都是经过换算后，用 <strong>PEXPIREAT</strong> 实现的。</p><p>实现转换关系图：</p><p><img src="/attachment/1fdeafced406a5ded853f062281ad621.png"></p><h3 id="存储过期时间"><a href="#存储过期时间" class="headerlink" title="存储过期时间"></a>存储过期时间</h3><p>redisDb 中有一个 expires 的字典数据结构保存所有键的过期时间，也称为过期字典。过期字典的值是一个 <strong>long long</strong> 类型的整数，保存了键所指向的数据库键的过期时间（毫秒精度的 Unix 时间戳）。</p><pre><code class="line-numbers language-c">typedef struct redisDb{    //过期字典，保存着键的过期时间    dict *expires;    ...} redisDb;</code></pre><p>图中键空间和过期的键其实复用了一个键对象，这里方便展示就拆开来，假设我们给键 alphabet 和 book 都设置了过期时间：</p><h3 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h3><p>PERSIST 命令可以<strong>移除一个键的过期时间</strong>，在过期字段中查找给定键，并<strong>解除</strong>键和值在过期字典中的关联。</p><pre><code class="line-numbers language-bash">redis&gt; SET key valueOK redis&gt; EXPIRE key 500(integer) 1 redis&gt; TTL key(integer) 498 redis&gt; PERSIST message(integer) 1 redis&gt; TTL key(integer) -1</code></pre><h3 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h3><p>TTL 以秒为单位返回剩余时间，PTTL 以毫秒返回键的剩余时间。二者的计算都是通过计算键的过期时间与当前时间之差来实现的。</p><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>如果一个键过期了，那么在什么时候被删除？列举几个常见淘汰策略：</p><ol><li>定时删除：设置键的过期时间时，创建定时器，过期时，以定时器立刻执行键的删除。</li><li>惰性删除：不着急删除过期键，每次获取时都会进行过期校验。</li><li>定期删除：隔一段时间，程序就对数据库检查，删除过期键。</li></ol><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>定时删除策略<strong>对内存友好</strong>，但<strong>对 CPU 不友好</strong>。过期键比较多时，删除会占用资源，特别是和删除当前任务无关的过期键，影响性能。Redis 定时器需要创建时间事件，时间事件底层由无需链表实现，查找复杂度为 O(N)，如果需要高效处理必然要创建大量的定时器，并不现实。</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除<strong>对 CPU 友好</strong>，但<strong>对内存不友好</strong>。不需要把时间浪费在非相关键的删除上。当键非常多时，会导致内存泄漏，因为只有用到时才会判断，删除。</p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>定期删除是一种折衷的方式，隔一段时间执行一次，并<strong>限制</strong>删除操作<strong>执行的时长和频率</strong>减少对 CPU 的占用；定期删除还能<strong>减少庞大的过期键对内存的占用</strong>。如何确定时长和频率是难点，过长或过少，会退变为定时删除和惰性删除。</p><h3 id="Redis-的过期键删除策略"><a href="#Redis-的过期键删除策略" class="headerlink" title="Redis 的过期键删除策略"></a>Redis 的过期键删除策略</h3><p>Redis 使用了<strong>惰性删除和定期删除</strong>两种策略配合，服务器可以合理地在使用 CPU 时间和避免内存浪费之间权衡。</p><ul><li>惰性删除策略的实现</li></ul><p>该策略由<code>db.c/expireIfNeeded</code>函数实现，如同指令过滤器，在执行读写键指令时都会调用该函数检查，如果过期则删除。</p><ul><li>定期删除策略的实现</li></ul><p>该策略由<code>redis.c/activeExpireCycle</code>函数实现，当服务器周期性调用<code>redis.c/serverCron</code>函数时，<code>activeExpireCycle</code>函数就会被调用，规定时间内，多次遍历服务器的各个数据库，从 expires 字典中随机检查一部分键的过期时间，并删除过期键。<code>activeExpireCycle</code>函数的主要工作可以拆分为：</p><ol><li>每次运行，都从一定数量的数据库中取出一定数量的<strong>随机键</strong>检查并删除过期键。</li><li>全局遍历记录检查进度，有<strong>记忆</strong>功能，全局变量存储的是几号库。</li><li>当所有数据库都被检查一遍后，<strong>重置</strong>全局变量，进行新一轮检查。</li></ol><h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>Redis 发布订阅功能可以让客户端获取数据库中键的变化及命令的执行情况。关注某个键执行了什么命令的通知称为键空间通知。关注某个命令被什么键执行的通知称为事件通知。</p><p>主要就是围绕通知功能，简单看下发送通知及其实现。</p><h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>该功能由<code>notify.c/notifyKeyspaceEvent</code>函数实现：</p><p>通过几个入参：要发送的通知类型，时间名称，产生时间的键，产生时间的数据库号。来构造事件通知内容和接收频道名，Redis 许多指令的执行函数都会调用这个函数，传递该命令引发的事件相关信息。</p><h4 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h4><ol><li>通过服务器配置的值判断，如果给定通知类型不是服务器允许的就直接返回。</li><li>如果是服务器允许发送的，检测是否允许发送键空间通知，允许则构建发送事件并通知。</li><li>检测是否允许发送键事件通知，如果允许则构建并发送通知。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 对象</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-dui-xiang/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-对象"><a href="#【Redis】-对象" class="headerlink" title="【Redis】 对象"></a>【Redis】 对象</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 对象date: 2023-07-09 08:35tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 对象</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis <strong>没有直接使用</strong>前文的数据结构来实现键值对数据库，而是基于这些数据结构构建了一个对象系统，通过对象组织数据结构，包括字<strong>符串对象，列表对象，哈希对象，集合对象</strong>和<strong>有序集合对象这</strong> 5 种对象。</p><p>使用对象的一个好处是可以针对不同的使用场景，为对象<strong>设置多种不同的数据结构实现</strong>，从而优化对象在不同场景下的使用效率。</p><p>Redis 使用对象来表示数据库的键和值。每个对象都是一个 redisObject 结构，是一个按照位段存储的结构，节约内存：</p><pre><code class="line-numbers language-c">typedef struct redisObject{    //类型    unsigned type :4;    //编码    unsigned encoding:4;    //指向底层实现数据结构的指针    void *ptr;    ...} robj;</code></pre><ul><li>Redis数据库中的每个键值对的键和值都是一个对象。</li><li>Redis共有<strong>字符串</strong>、<strong>列表</strong>、<strong>哈希</strong>、<strong>集合</strong>、<strong>有序集合</strong>五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li><li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</li><li>Redis的对象系统带有<strong>引用计数</strong>实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</li><li>Redis会共享值为0到9999的字符串对象。</li><li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的<strong>空转时间</strong>。</li></ul><h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><p>Redis 使用对象来表示数据库的键和值。每个对象都是一个 redisObject 结构，是一个按照位段存储的结构，节约内存：</p><pre><code class="line-numbers language-c">typedef struct redisObject{    //类型    unsigned type :4;    //编码    unsigned encoding:4;    //指向底层实现数据结构的指针    void *ptr;    ...} robj;</code></pre><p>其中，type 是类型常量，记录对象的类型：</p><table><thead><tr><th>类型常量</th><th>对象的名字</th></tr></thead><tbody><tr><td>REDIS_ String</td><td>字符串对象</td></tr><tr><td>REDIS_ List</td><td>列表对象</td></tr><tr><td>REDIS_ HASH</td><td>哈希对象</td></tr><tr><td>REDIS_ SET</td><td>集合对象</td></tr><tr><td>REDIS_ ZSET</td><td>有序集合对象</td></tr></tbody></table><p>encoding 记录对象使用的编码，即对象底层使用的具体数据结构：</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td>REDIS_ ENCODING_ INT</td><td>long类型的整数</td></tr><tr><td>REDIS ENCODING EMBSTR</td><td>embstr编码的简单动态字符串</td></tr><tr><td>REDIS_ ENCODING RAW</td><td>简单动态字符串</td></tr><tr><td>REDIS_ ENCODING_ HT</td><td>字典</td></tr><tr><td>REDIS_ ENCODING LINKEDLIST</td><td>双端链表</td></tr><tr><td>REDIS ENCODING ZIPLIST</td><td>压缩列表</td></tr><tr><td>REDIS_ ENCODING_ INTSET</td><td>整数集合</td></tr><tr><td>REDIS ENCODING SKIPLIST</td><td>一秒乎 跳跃表和字典</td></tr></tbody></table><p>Redis 对象采用 <strong>encoding 属性来设置编码</strong>，从而<strong>决定底层数据结构</strong>，而不是为特定类型的对象关联一种固定编码。这种方式极大地提高了灵活性和效率。</p><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串对象可以是 <strong>int，raw</strong> 或 <strong>embstr</strong>。</p><ul><li>如果字符串对象保存的是<strong>整数值</strong>，且这个数值<strong>可用 long</strong> 表示，底层就会以**<code>REDIS_ENCODING_INT</code>**编码来实现。</li><li>如果字符串对象是一个字符串值，且这个字符串长度 <strong>&gt;39 字节</strong>，字符串将使用一个 SDS 保存，底层编码为**<code>REDIS_ENCODING_RAW</code>**。</li><li>如果字符串对象保存的是字符串，且这个字符串长度 <strong>&lt;=39 字节</strong>，底层编码就是**<code>REDIS_ENCODING_EMBSTR</code>**，使用 embstr 编码的方式保存字符串。</li></ul><p><img src="/attachment/1501888fa3da916f257d8d3a1a0378f0.png"></p><h3 id="embstr-编码"><a href="#embstr-编码" class="headerlink" title="embstr 编码"></a>embstr 编码</h3><p>专门用于保存短字符串的一种优化编码方式，与 raw 的效果相同，都使用 redisObject 和 sdshdr 结构来表示字符串对象，但是 raw 会调用两次内存分配函数<strong>分别创建</strong> redisObject 和 sdshdr 结构。embstr 编码则通过调用<strong>一次内存分配</strong>函数来分配一块连续空间，空间依次包括 redisObject 和 sdshdr 俩结构。</p><p>使用 embstr 编码保存短字符串的<strong>优点</strong>：</p><ul><li>内存分配次数由两次降为 <strong>1 次</strong>。</li><li>释放 embstr 字符串对象只需调用 <strong>1 次</strong>内存释放函数。</li><li>embstr 字符串放在一块连续的内存中，能更好地<strong>利用缓存</strong>带来的优势.</li></ul><p>注：<strong>浮点数</strong>的存储，在 Redis 底层也会以<strong>字符串的形式</strong>保存。在有需要时，程序会将字符串对象中的字符串值<strong>转为浮点数值</strong>执行运算操作，然后再将结果<strong>转为字符串值</strong>保存。</p><h3 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h3><p><code>int-&gt;raw</code>：对 int 编码的字符串对象执行后，保存的不再是整数值，而是字符串值时。比如整数追加字符串。</p><p><code>embstr-&gt;raw</code>：Redis 没有为 embstr 编写修改程序，所以是<strong>只读的</strong>，当 embstr 编码的字符串修改后，就变成 raw 编码的字符串对象。</p><h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码是 ziplist 或 linkedlist。</p><p>当列表可以同时满足以下两个条件时，列表对象使用 ziplist 编码：</p><ul><li>列表对象保存的所有字符串元素的长度都 <strong>&lt;64 字节</strong></li><li>列表对象保存的元素数量 <strong>&lt;512 个</strong></li></ul><p>否则使用 linkedlist 编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用 ziplist 编码，执行<code>RPUSH elements "a" "b" 1</code>，后的数据结构：</p><p><img src="/attachment/dac49f238294e9fdd4ae2950a7b5a5a1.png"></p><p><img src="/attachment/b05e06b6cae83ee7373296c304cae12c.png"></p><p>注：SDS 对象都<strong>以 StringObject 代替</strong>。</p><h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是 ziplist 或 hashtable。</p><ul><li>ziplist 的数据结构：每当有新的键值对插入哈希对象时，Redis 会先将保存键的压缩列表节点推入表尾，再将保存值的压缩列表节点推入表尾。</li><li>hashtable 的数据结构：字典的每个键都是一个字符串对象，保存键；字典的每个值都是字符串对象，保存值</li></ul><p>当哈希对象可以同时满足下两个条件时，使用 <strong>ziplist 编码</strong>：</p><ul><li>哈希对象保存的所有键值对的值和键<strong>都 &lt; 64 字节</strong></li><li>哈希对象保存的键值对数量 <strong>&lt;512 个</strong></li></ul><p>否则使用 hashtable 编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用 ziplist 编码，执行<code>HSET student name "madongmei" age 25 career "pick up trash"</code>后的数据结构：</p><p><img src="/attachment/1fd09df94f60829def8f69bba77e198a.png"></p><p><img src="/attachment/fd033b73980ede2dca6483ef6d04610b.png"></p><p>使用 hashtable 编码，执行<code>HSET student name "madongmei" age 25 career "pick up trash"</code>后的数据结构：</p><p><img src="/attachment/2223ec3fe2fc79ba2f7f2757a0682b11.png"></p><h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是 intset 或 hashtable。</p><p>如果以 hashtable 编码作为<strong>集合对象</strong>底层实现，那么字典的每个键都是一个<strong>字符串对象</strong>，值都是 <strong>null</strong>。</p><p>当集合对象同时满足以下两个条件时，使用 intset 编码：</p><ul><li>集合对象保存的所有元素<strong>都是整数值</strong></li><li>集合对象保存的元素数量 <strong>&lt;=512 个</strong></li></ul><p>否则使用 hashtable 编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用 intset 编码，执行<code>SADDnumbers 1 3 5</code>后的数据结构：</p><p><img src="/attachment/3d79a1bd1ad2b7ee7c2fa9cbf2ebfbc0.png"></p><p><img src="/attachment/ca813997ce4625f4814eba4f7683c33a.png"></p><h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是 ziplist 或 skiplist。</p><p>使用 ziplist 编码时，每个元素使用<strong>两个紧挨在一起的压缩列表节点</strong>来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。</p><p><img src="/attachment/7bc280445e09c4a2545ddffece3505f9.png"></p><p><img src="/attachment/c288d2c4f0955eb4c8810448de6966dd.png"></p><p>如果是 skiplist 编码，使用 zset 结构：</p><pre><code class="line-numbers language-c">typedef struct zset{    zskiplist *zsl;    dict *dict;} zset;</code></pre><p>dict 字典为有序集合创建了一个从<strong>成员到分值的映射</strong>，字典中的每个键值对都保存了一个集合元素：键保存元素，值保存分值。通过字典以 <strong>O(1) 查找给定成员的分值</strong>。有序集合元素<strong>都是字符串对象</strong>，分值都是 <strong>double 类型浮点数</strong>。zset 的跳跃表和字典通过指针来<strong>共享相同元素</strong>的成员和分值，<strong>不会浪费</strong>额外内存。</p><p><img src="/attachment/73d576f6cd54160b9e8e4c125d84b776.png"></p><p>当有序集合对象同时满足以下两条件时，对象使用 ziplist 编码：</p><ul><li>有序集合保存的元素数量 <strong>&lt;128 个</strong></li><li>有序集合保存的所有元素成员的长度<strong>都 &lt; 64 字节</strong></li></ul><p>否则使用 skiplist 编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>Redis 中用于操作键的命令可分为两种类型。一种是可对<strong>任何类型执行</strong>的，如 del，expire，rename 等。另一种命令只能对<strong>特定类型的键执行</strong>，如 set，get，hdel，hset，rpush 等。如果对特定类型使用其他类型的命令，那么就会报错。</p><h3 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h3><p>为了确保只有制定类型的键可以执行某些特定命令，在执行前，Redis 会先通过 RedisObject 的 <strong>type 属性检查</strong>输入键的类型是否正确。</p><h3 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h3><p>Redis 除了根据值对象判断键是否能够执行制定命令外，还会根据<strong>值对象的编码方式</strong>，选择正确的命令实现代码来执行。比如基于编码的多态，列表对象的编码可能是 ziplist 或 linkedlist，所以需要<strong>多态命令执行</strong>对应编码的 API。基于类型的多态是<strong>一个命令可以同时处理多种不同类型的键</strong>。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>由于 C 语言没有内存回收机制，Redis 在对象系统中构建了<strong>引用计数器技术</strong>实现内存回收机制。每个对象的引用计数器信息由 redisObject 的 refcount 来记录。当对象的引用计数值<strong>为 0</strong> 时，所占用的内存<strong>会被释放</strong>。</p><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>引用计数器还有共享对象的作用。如果两个不同键的值都一样（必须是整数值的字符串对象），则将数据库键的值指针<strong>指向一个现有的值对象</strong>，然后将被共享对象的引用计数加一。如果不是整数值的对象，则需要耗费大量的时间<strong>验证共享对象和目标对象是否相同</strong>，复杂度较高，消耗 CPU 时间，所以 Redis <strong>不会共享包含字符串的对象</strong>。</p><p>Redis 在初始化服务时，会创建很多字符串对象，包含 0~9999 的整数（和 Integer 的常量池有点像），当需要时，就能直接复用。</p><p><img src="/attachment/9e8e46c883f3f61361adfaed3956397a.png"></p><h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>redisObject 还包含了 lru 属性，记录对象最后一个被命令程序访问的时间。<code>object idletime</code>命令可打印键的空转时长，就是<strong>当前时间减去 lru 时间</strong>计算得到的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 压缩列表</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-ya-suo-lie-biao/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-ya-suo-lie-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-压缩列表"><a href="#【Redis】-压缩列表" class="headerlink" title="【Redis】 压缩列表"></a>【Redis】 压缩列表</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 压缩列表date: 2023-07-09 08:34tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 压缩列表</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>压缩列表是<strong>列表键</strong>和<strong>哈希键</strong>底层实现之一。当一个列表键只包含少量列表项，且每个列表项要么是小整数，要么是长度比较短的字符串，Redis 就使用压缩列表来做列表键的底层实现。</p><p><strong>list</strong></p><p><img src="/attachment/3eea00ed5e6077b39e2e90392a72ddc6.png"></p><p><strong>entry</strong></p><p><img src="/attachment/580fba21935d385bf637c6f27d289871.png"></p><ul><li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li><li>压缩列表被用作列表键和哈希键的底层实现之一。</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</li></ul><h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p>为节约内存而开发的，由一系列<strong>特殊编码</strong>的<strong>连续内存块</strong>组成的<strong>顺序型</strong>数据结构。</p><p>结构比较简单，属性如下：</p><ul><li>zlbytes：记录整个压缩列表占用<strong>内存字节数</strong>，进行内存重分配或计算 zlend 时使用。</li><li>zltail：记录压缩列表尾节点<strong>距离压缩列表起始地址</strong>多少字节。</li><li>zllen：节点数量。小于 65535 时，表示<strong>节点数量</strong>；大于时，需要<strong>遍历</strong>才能计算得出。</li><li>entryx：列表节点。</li><li>zlend：特殊值 0xFF 用于<strong>标记压缩列表的末端</strong>。</li></ul><p><img src="/attachment/3eea00ed5e6077b39e2e90392a72ddc6.png"></p><h2 id="压缩列表节点的组成"><a href="#压缩列表节点的组成" class="headerlink" title="压缩列表节点的组成"></a>压缩列表节点的组成</h2><p><img src="/attachment/580fba21935d385bf637c6f27d289871.png"></p><p>每个压缩列表节点可以是一个<strong>字节数组</strong>，也可以是一个<strong>整数</strong>。由<code>previous_entry_length，encoding，content</code>组成。</p><p><strong>previous_entry_length</strong></p><p>单位是字节，记录压缩列表<strong>前一个节点的长度</strong>。该属性长度为 <strong>1 字节或 5 字节</strong>，前<strong>两位</strong>表示该属性长度为 2 位还是 10 位。</p><ul><li>前一个节点的长度 &lt; 254 字节时，该属性只有 <strong>2 位</strong>，且前一节点的长度就保存在这两位。如 0x05，表示前一个字节长度为 5 字节。</li><li>前一个节点的长度 &gt;=254 字节时，该属性有 <strong>10 位</strong>，且前两位表示这是一个 5 字节的长度，后 8 位表示前一个节点的长度。如 0xFE0000，表示前一个字节长度为 0x00002766，换算为 10 进制就是我们熟悉的数字。</li></ul><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>encoding 记录了节点的 content 属性所保存<strong>数据类型</strong>和<strong>长度</strong>。<strong>高两位</strong>表示存储的是字节数组还是整数。</p><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>存储节点的值。</p><h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>当<strong>多个连续</strong>的长度<strong>介于 250 字节到 253 字节</strong>之间的节点，插入新的头节点（长度大于等于 245 字节），后面节点的 previous_entry_length 就要新增 4 字节的空间（1 字节变成 5 字节），需要进行<strong>内存重分配</strong>，由于前一个节点的变更，每个节点的 previous_entry_length 属性<strong>也需要记录之前的长度而发生相应的变更</strong>，所以会出现连锁更新。除了新增节点，删除节点也可能会遇到这种情况。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行 <strong>N 次空间重分配操作</strong>，每次<strong>重分配的的最坏时间复杂度</strong>为 $O(N)$ ，所以连锁更新的<strong>最坏时间复杂度为</strong> $O(N^2)$</p><p>虽然代价很高，但是出现的<strong>几率比较低</strong>，而且只要更新节点的数量不多，就不会对性能产生影响。因此 ziplistPush 命令的<strong>平均复杂度为</strong> $O(N)$ 。</p><h2 id="压缩列表的时间复杂度"><a href="#压缩列表的时间复杂度" class="headerlink" title="压缩列表的时间复杂度"></a>压缩列表的时间复杂度</h2><table><thead><tr><th>操作 时间复杂度</th><th></th></tr></thead><tbody><tr><td>将新节点插入</td><td>“平均O(N),最坏O(N2)”</td></tr><tr><td>返回给定索引节点</td><td>O(N)</td></tr><tr><td>查找并返回合定值的节点</td><td>“如果是字节数组和整数,检查节点的复杂度为0(N),查找列表的复杂度为O(N2)”</td></tr><tr><td>删除给定节点</td><td>“平均O(N),最坏O(N2)”</td></tr><tr><td>返回节点数量</td><td>“节点数小于65535时为O(1),大于65535时为O(N)”</td></tr></tbody></table><h2 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h2><table><thead><tr><th>函数</th><th>作用</th><th>算法复杂度</th></tr></thead><tbody><tr><td>ziplistNew</td><td>创建一个新的压缩列表</td><td>O(1)</td></tr><tr><td>ziplistPush</td><td>“创建一个包含给定值的新节点,并将这 个新节点添加到压缩列表的表头或者表尾”</td><td>“平均0(N),最坏0(N)”</td></tr><tr><td>ziplistInsert</td><td>将包含给定值的新节点插人到给定节点 之后</td><td>“平均O(N),最坏O(v)”</td></tr><tr><td>ziplistIndex</td><td>返回压缩列表给定索引上的节点</td><td>O(N)</td></tr><tr><td>ziplistFind</td><td>在压缩列表中查找并返回包含了给定值 的节点</td><td>“因为节点的值可能是一个字节数组, 所以检查节点值和给定值是否相同的复 杂度为O(N,而查找整个列表的复杂度 则为0(N)”</td></tr><tr><td>ziplistNext</td><td>返回给定节点的下一个节点</td><td>O(1)</td></tr><tr><td>ziplistPrev</td><td>返回给定节点的前一个节点</td><td>O(1)</td></tr><tr><td>ziplistGet</td><td>获取给定节点所保存的值</td><td>O(1)</td></tr><tr><td>ziplistDelete</td><td>从压缩列表中删除给定的节点</td><td>“平均O(N),最坏O(N)”</td></tr><tr><td>ziplistDeleteRange</td><td>删除压缩列表在给定索引上的连续多个 节点</td><td>“平均O(N),最坏O(v)”</td></tr><tr><td>ziplistBlobLen</td><td>返回压缩列表目前占用的内存字节数</td><td>O(1)</td></tr><tr><td>ziplistLen</td><td>返回压缩列表目前包含的节点数量</td><td>“节点数量小于65535时为0(1),大于 65 535  时为O(N)”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 整数集合</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-zheng-shu-ji-he/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-zheng-shu-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-整数集合"><a href="#【Redis】-整数集合" class="headerlink" title="【Redis】 整数集合"></a>【Redis】 整数集合</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 整数集合date: 2023-07-09 08:33tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 整数集合</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当一个集合只包含整数元素，并且元素不多时，Redis 就会使用整数集合作为集合键的底层实现。</p><p><img src="/attachment/f45179f0b5157cc2a2793a276a7877b8.png"></p><ul><li>整数集合是集合键的底层实现之一。</li><li>整数集合的底层实现为<strong>数组</strong>，这个数组以<strong>有序</strong>、<strong>无重复</strong>的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。</li><li><strong>升级操作</strong>为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。</li><li>整数集合只支持升级操作，不支持降级操作。</li></ul><h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合是 Redis 中用于保存整数值的集合<strong>抽象数据结构</strong>，可以保证集合<strong>有序不重复</strong>。每个<code>intset.h/intset</code>结构来表示一个整数集合：</p><pre><code class="line-numbers language-c">typedef struct intset{    //编码方式    uint32_t encoding;    //集合包含的元素数量    uint32_t length;    //保存元素的数组    int8_t contents[];} intset;</code></pre><p>length 属性记录了整数集合包含的元素数量，contents 是整数集合的底层实现。contents 存储元素的真实类型<strong>取决于 encoding</strong>，比如<code>encoding==INT_ENC_INT16</code>时，contents 数组中每个向都是 int16_t 类型的整数。可以为<code>int16_t</code>,<code>int32_t</code>或<code>int64_t</code>。</p><p><img src="/attachment/f45179f0b5157cc2a2793a276a7877b8.png"></p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>当我们要将一个新元素添加至集合时，并且新元素的类型<strong>比现有集合类型都长</strong>时，整数集合就要升级。</p><p>步骤：</p><ol><li>根据新元素类型，<strong>扩展</strong>数组空间，为新元素分配空间。</li><li>将底层数组现有所有元素<strong>都转为新元素相同类型</strong>，并将类型转换后的元素放到正确位置。</li><li>将新元素<strong>添加</strong>到底层数组。</li></ol><p>由于每次向整数集合添加新元素都<strong>可能会引起升级</strong>，而每次升级都需要对底层数组中已有元素进行类型转换，所以添加的**时间复杂度为 O(N)**。</p><h3 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h3><p>有两个好处，可以提升整数集合的<strong>灵活性</strong>，也能尽可能地<strong>节约内存</strong>。<br>C 语言是静态类型语言，一般数组中的元素类型都相同，使用升级可以<strong>不用担心类型兼容</strong>问题，提升灵活性。元素统一以最大类型存储，而不是都用<code>int64_t</code>，可节约内存。</p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合<strong>不支持降低</strong>，一旦升级就不能降级。</p><h2 id="整数集合的时间复杂度"><a href="#整数集合的时间复杂度" class="headerlink" title="整数集合的时间复杂度"></a>整数集合的时间复杂度</h2><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>给定元素添加到/移出集合</td><td>O(N)</td></tr><tr><td>判断给定元素是否在集合</td><td>“由于有序,可用二分查找,复杂度为O(logN)”</td></tr><tr><td>取出给定索引元素</td><td>0(1)</td></tr></tbody></table><h2 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h2><table><thead><tr><th>函 数</th><th>作 用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>intsetNew</td><td>创建 一个新的压缩列表</td><td>O(1)</td></tr><tr><td>intsetAdd</td><td>将给定元素添加到整数集合里面</td><td>O(N)</td></tr><tr><td>intsetRemove</td><td>从整数集合中移除给定元素</td><td>O(N)</td></tr><tr><td>intsetFind</td><td>检查给定值是否存在于集合</td><td>“因为底层数组有序,查找可以通过二分查找 法来进行,所以复杂度为 0(logN)”</td></tr><tr><td>intsetRandom</td><td>从整数集合中随机返回一个元素</td><td>O(1)</td></tr><tr><td>intsetGet</td><td>取出底层数组在给定索引上的元素</td><td>O(1)</td></tr><tr><td>intsetLen</td><td>返回整数集合包含的元素个数</td><td>0(1)</td></tr><tr><td>intsetBlobLen</td><td>返回整数集合占用的内存字节数</td><td>O(1)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 跳跃表</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-tiao-yue-biao/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-tiao-yue-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-跳跃表"><a href="#【Redis】-跳跃表" class="headerlink" title="【Redis】 跳跃表"></a>【Redis】 跳跃表</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 跳跃表date: 2023-07-09 08:32tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 跳跃表</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>跳跃表是一种<strong>有序</strong>的数据结构，通过在每个节点<strong>维持多个指向其他节点的指针</strong>，达到快速访问节点的目的。</p><p>如果一个有序集合中包含的元素数量比较多，又或者有序集合中元素的成员是较长的字符串，Redis 就会使用跳跃表来作为有序集合键的底层实现。Redis 只有在两个地方用到了跳跃表，一个是实现<strong>有序集合键</strong>，另一个是在<strong>集群节点中</strong>作为内部数据结构。</p><p><img src="/attachment/23fabcfdd5dbe94a3432865cdd9f5c0a.png"></p><ul><li>跳跃表是有序集合的底层实现之一。</li><li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是1至32之间的随机数。</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li></ul><h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><p>Redis 的跳跃表由<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个数据结构定义。</p><pre><code class="line-numbers language-c">typedef struct zskiplist{    //表头节点和表尾节点    structz zskiplistNode *header,* tail;    //表中节点的数量    unsigned long length;    //表中层数最大的节点的层数    int level;} zskiplist;</code></pre><p>跳跃表由 zskiplist 组织，通过多个跳跃表节点 zskiplistNode 组成一个跳跃表。值得注意的是，记录 level 时，表头节点的层高不会记录在内。</p><p><img src="/attachment/23fabcfdd5dbe94a3432865cdd9f5c0a.png"></p><h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><pre><code class="line-numbers language-c">typedef strct zskiplistNode{    //后退指针    struct zskiplistNode *backward;    //分值    double score;    //成员对象    robj *obj;    //层    struct zskiplistlevel{        //前进指针        struct zskiplistNode *forward;        //跨度        unsigned int span;    }level[];} zskiplistNode;</code></pre><h2 id="跳跃表的时间复杂度"><a href="#跳跃表的时间复杂度" class="headerlink" title="跳跃表的时间复杂度"></a>跳跃表的时间复杂度</h2><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>插入新节点和分值</td><td>“平均O(logN),最坏O(N),N为跳跃表长度”</td></tr><tr><td>删除给定成员和分值</td><td>“平均O(logN), 最坏O(N),N为跳跃表长度”</td></tr><tr><td>返回给定成员和分值节点的排位</td><td>“平均O(logN), 最坏O(N),N为跳跃表长度”</td></tr><tr><td>释放给定跳跃表</td><td>“O(N),N为跳跃表的长度”</td></tr><tr><td>删除给定排位范围内节点</td><td>“O(N),N为被删除节点数”</td></tr><tr><td>“给定分值范围,返回是否有节点”</td><td>O(1)</td></tr><tr><td>“给定分值范围,返回第一个符合节点”</td><td>“平均O(logN), 最坏O(N),N为跳跃表长度”</td></tr></tbody></table><h2 id="跳跃表-API"><a href="#跳跃表-API" class="headerlink" title="跳跃表 API"></a>跳跃表 API</h2><table><thead><tr><th>函 数</th><th>作 用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>zslCreate</td><td>创建-一个新的跳跃表</td><td>O(1)</td></tr><tr><td>zslFree</td><td>“释放给定跳跃表,以及表中包含的所有节点”</td><td>“0(N),N为跳跃表的长度”</td></tr><tr><td>zslInsert</td><td>将包含给定成员和分值的新节点添加到跳跃表中</td><td>“平均O(logN),最坏o(M), N为跳跃表长度”</td></tr><tr><td>zslDelete</td><td>删除跳跃表中包含给定成员和分值的节点</td><td>“平均 O(logN),最坏o(N, N为跳跃表长度”</td></tr><tr><td>zslGetRank</td><td>返回包含给定成员和分值的节点在 跳跃表中的排位</td><td>“平均 O(logN),最坏O(N),N为跳跃表长度”</td></tr><tr><td>zslGetElementByRank</td><td>返回跳跃表在给定排位上的节点</td><td>“平均O(logM), 最坏O(N), N为跳跃表长度”</td></tr><tr><td>zslIsInRange</td><td>“给定一个分值范围(range), 比如0 到15, 20到28,诸如此类,如果跳跃表中有至少一个节点的分值在这个范围之内,那么返回1,否则返回0”</td><td>“通过跳跃表的表头节点和表尾节点, 这个检测可以用0(1)复杂度完成”</td></tr><tr><td>zslFirstInRange</td><td>“给定一个分值范围,返回跳跃表中第一个符合这个范围的节点”</td><td>“平均O(logN), 最坏O(M)。N为跳跃表长度”</td></tr><tr><td>zslLastInRange</td><td>“给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点”</td><td>“平均O(logN),最坏0(N)。N为跳跃表长度”</td></tr><tr><td>zslDeleteRangeByScore</td><td>“给定一个分值范围,删除跳跃表中 所有在这个范围之内的节点”</td><td>“O(N),N为被删除节点数量”</td></tr><tr><td>zslDeleteRangeByRank</td><td>“给定一个排位范围,删除跳跃表中 所有在这个范围之内的节点”</td><td>“O(N),N为被删除节点数量”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 字典</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-zi-dian/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-zi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-字典"><a href="#【Redis】-字典" class="headerlink" title="【Redis】 字典"></a>【Redis】 字典</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 字典date: 2023-07-09 08:31tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 字典</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>字典又称<strong>符号表</strong>，<strong>关联数组</strong>或<strong>映射</strong>，用于保存键值对的抽象数据结构。当一个哈希键包含的键值对比较多时，或者键值对中的元素都是比较长的字符串时，Redis 就会使用字典作为哈希键的底层实现。</p><p><img src="/attachment/1586b7cef27e4e6d8d296f5c2e0991b4.png"></p><p>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</p><ul><li>Redis中的字典使用<strong>哈希表</strong>作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</li><li>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</li><li>哈希表使用<strong>链地址法</strong>来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</li><li>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。</li></ul><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis 的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有<strong>多个哈希表节点</strong>，每个哈希表节点保存了字典中的<strong>一个键值对</strong>。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>使用<code>dict.h/dictht</code>结构定义：</p><pre><code class="line-numbers language-c">typedef struct dictht{    //哈希表数组    dictEntry **table;    //哈希表大小    unsigned long size;    //哈希表大小掩码，用于计算索引值    //总是等于size-1    unsigned long sizemask;    //该哈希表已有节点的数量    unsigned long used;}dictht;</code></pre><p>数组中的每个元素都是指向<code>dict.h/dictht</code>的结构，dictEntry 就是一个键值对。</p><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><p>哈希表节点使用 dictEntry 实现，每个 dictEntry 都存储着一个键值对：</p><pre><code class="line-numbers language-c">typedef struct dictEntry{    //键    void *key;    //值    union{        void *val;        uint64_t u64;        int64_t s64;    } v;    //指向下个哈希表节点，形成链表    struct dictEntry *next;} dictEntry;</code></pre><p>键值对的值可以是一个指针，或一个<code>uint64_t</code>整数，或一个<code>int64_t</code>整数。next 是<strong>指向另一个哈希节点的指针</strong>，可将多个<strong>哈希值相同的键值对连接在一起</strong>，以此来解决冲突。</p><p><img src="/attachment/7cb821b75c9e66e619910c5b95838a00.png"></p><p>如图，表示的是两个哈希值相同的节点，通过指针连接在一起。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Redis 中的字典由<code>dict.h/dict</code>实现，由这个数据结构将字典组织在一起。</p><pre><code class="line-numbers language-c">typedef struct dict{    //类型特定函数    dictType *type;    //私有数据    void *privdata;    //哈希表    dictht ht[2];    //rehash索引    //当rehash不在进行时，值为-1    int rehashidx;} dict;</code></pre><p>type 和 privdata 属性是<strong>针对不同类型</strong>的键值对，为丰富键值对的使用场景而设置的。</p><ul><li>type 属性是一个指向 dictType 的结构指针，每个 dictType 结构保存了一簇用于<strong>操作特定类型键值对的函数</strong>，Redis 为用途不同的字典设置不同类型特定函数。</li></ul><pre><code class="line-numbers language-c">typedef struct dictType{    //计算哈希值的函数    unsigned int (*hashFunction)(const void *key);    //复制键的函数    void *(*keyDup)(void *privdata,const void *key)    ...}</code></pre><ul><li>privdata 属性保存了需要传给那些类型特定函数的可选参数。</li><li>ht 属性是包含<strong>两个项</strong>的数组，每项都是一个哈希表，ht[0] 平时使用，而 ht[1] 仅在 rehash 时使用。</li><li>rehashidx 记录了 rehash 的进度，初始为 - 1。</li></ul><p><img src="/attachment/1586b7cef27e4e6d8d296f5c2e0991b4.png"></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>Redis 计算哈希值方法： <code>hash=dict-&gt;type-&gt;hashFunction(key);</code><br>计算索引值的方法：<code>index=hash &amp; dict-&gt;ht[x].sizemask;</code></p><p>当字典被用作数据库的底层实现或哈希键的底层实现时，Redis 使用 <strong>MurmurHash2 算法</strong>来计算键的哈希值。优点在于即使输入的键是有规律的，算法仍然能给出<strong>很好的随机分布性</strong>，并且计算<strong>速度飞快</strong>。</p><h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>当有两个或以上的键被分配到哈希表的<strong>同个索引</strong>，那么就发生了冲突。Redis 使用链地址法来解决冲突，被分配到索引的多个节点<strong>使用链表连接</strong>。为了提高速度，每次都是将新节点添加到链表的<strong>表头</strong>位置。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>为了让哈希表的负载因子维持在一个<strong>合理的范围内</strong>，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行响应的扩容或缩容。扩容和缩容通过执行 rehash 来完成，Redis 中<strong>重新散列的步骤</strong>如下：</p><ol><li>为字典 ht[1] 哈希表<strong>分配空间</strong>，大小取决于要执行的操作与 ht[0] <strong>当前键值对的数量</strong>。</li><li>将保存在 ht[0] 中的所有键值对存放到 ht[1] 指定的位置</li><li>当 ht[0] 的所有键值对都迁移完毕后，<strong>释放 ht[0]<strong>，并</strong>指向</strong> ht[1]，并在 ht[1] 上创建一个空的哈希表，为下次 rehash 准备。</li></ol><h3 id="扩容与缩容场景"><a href="#扩容与缩容场景" class="headerlink" title="扩容与缩容场景"></a>扩容与缩容场景</h3><p>扩容操作场景：</p><ul><li>服务器目前没有在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子 &gt;=1</strong>。</li><li>服务器正在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子 &gt;=5</strong>。</li></ul><p>负载因子 = 哈希表已存储节点数 / 哈希表大小<br><code>load_factor=ht[0].used/ht[0].size</code></p><p>为什么根据**<code>BGSAVE</code><strong>命令或</strong><code>BGREWRITEAOF</code><strong>命令来判断是否扩展？<br>因为执行这些命令时，Redis 需要创建当前服务器进程的</strong>子进程<strong>，大多数操作系统采用</strong>写时复制技术**来优化子进程使用效率，此时提高负载因子，可以尽量避免子进程对哈希表扩展，避免不必要的内存写入操作，节约内存。</p><p>缩容操作场景：<strong>负载因子 &lt; 0.1</strong> 时，<strong>自动</strong>对哈希表执行收缩操作。</p><h2 id="渐进式-rehash-的过程"><a href="#渐进式-rehash-的过程" class="headerlink" title="渐进式 rehash 的过程"></a>渐进式 rehash 的过程</h2><p>rehash 时会将 ht[0] 中所有的键值对 rehash 到 ht[1]，如果键值对很多并且一次性操作的话，容易导致服务器在<strong>一段时间内停止服务</strong>。为避免这种情况，Redis 采用渐进式 rehash，将 ht[0] 中的键值对分多次，<strong>慢慢的 rehash</strong> 到 ht[1] 之中。</p><p>步骤：</p><ol><li>为 ht[1] 分配空间，让字典同时持有两个哈希表。</li><li>在字典中维持一个<strong>索引计数器变量 rehashidx</strong>，将其设置为 0，表示 rehash 正式开始。</li><li>在 rehash 进行期间，每次对字典进行<strong>添加，删除，查找或更新</strong>操作时，程序除了执行指定的操作外，还会将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 **rehash 到 ht[1]**，当 rehash 工作完成后，将 rehashidx++。</li><li>某个时刻，ht[0] 中的所有键值对都被 rehash 至 ht[1]，此时设置 rehashidx=-1 时，表示 rehash 操作已经完成。</li></ol><p>这种方式的 rehash 的好处在于采用了分而治之的方式，将 rehash 键值对所需的<strong>计算工作均摊到对字典的每个操作中</strong>，从而避免集中式 rehash 带来庞大计算量。</p><p>在 rehash 的期间，字典<strong>同时使用</strong> ht[0]，ht[1] 两个哈希表。对哈希表的操作会在两个表上进行，比如查找键时，<strong>先在 ht[0] 里面查找</strong>，如果为空，就<strong>继续到 ht[1] 里查找</strong>。在此期间，新增的键值对<strong>都会被添加到 ht[1]</strong> 中，ht[0] <strong>不承担任何添加</strong>操作，保证 ht[0] 中的键值对只能是<strong>越来越少</strong>。</p><h2 id="字典时间复杂度"><a href="#字典时间复杂度" class="headerlink" title="字典时间复杂度"></a>字典时间复杂度</h2><p>字典相关操作及时间复杂度：</p><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>添加键值对</td><td>O(1)</td></tr><tr><td>返回给定键的值</td><td>O(1)</td></tr><tr><td>删除给定键的值</td><td>“O(N),N为链表长度”</td></tr><tr><td>释放字典</td><td>“O(N),N为字典包含的键值对数”</td></tr></tbody></table><h2 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h2><table><thead><tr><th>函 数</th><th>作 用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>dictCreate</td><td>创建一个新的字典</td><td>O(1)</td></tr><tr><td>dictAdd</td><td>将给定的键值对添加到字典里面</td><td>O(1)</td></tr><tr><td>dictReplace</td><td>“将给定的键值对添加到字典里面,如果键已经 存在于字典,那么用新值取代原有的值”</td><td>0(1)</td></tr><tr><td>dictFetchValue</td><td>返回给定键的值</td><td>O(1)</td></tr><tr><td>dictGetRandomKey</td><td>从字典中随机返回一个键值对</td><td>0(1)</td></tr><tr><td>dictDelete</td><td>从字典中删除给定键所对应的键值对</td><td>0(1)</td></tr><tr><td>dictRelease</td><td>“释放给定字典,以及字典中包含的所有键值对”</td><td>“O(N), N为字典包含的键值对数量”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 链表</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-lian-biao/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-链表"><a href="#【Redis】-链表" class="headerlink" title="【Redis】 链表"></a>【Redis】 链表</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 链表date: 2023-07-09 08:30tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 链表</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当一个列表键包含了数量比较多的元素，或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。</p><p><img src="/attachment/79eb0908ba542e2b75dfdde93b6d7a14.png"></p><ul><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ul><h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><pre><code class="line-numbers language-c">typedef struct listNode{    //前置节点    struct listNode *prev;    //后置节点    struct listNode *next;    //节点的值    void *value;}listNode;</code></pre><p>节点由前驱后继组成，多个节点组成的链表为双端链表。</p><p>使用<code>adlist.h/list</code>来持有，操作链表：</p><pre><code class="line-numbers language-c">typedef struct list{    //表头节点    listNode *head;    //表尾节点    listNode *tail;    //链表所包含的节点数量    unsigned long len;    //节点值复制函数    void *(*dup)(void *ptr);    //节点值释放函数    void (*free)(void *ptr);    //节点值对比函数    int (*match)(void *ptr,void *key);}list;</code></pre><p>整个链表串起来后，如下图：</p><p><img src="/attachment/79eb0908ba542e2b75dfdde93b6d7a14.png"></p><p>Redis 的链表特性可以总结如下：</p><p><strong>双端</strong>：链表节点带有 prev 和 next 指针，获取前置和后置节点的复杂度都是 O(1)。<br><strong>无环</strong>：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点。 带表头指针和表尾指针 带链表长度计数器 。<br><strong>头尾指针</strong>：将程序获取头尾节点的复杂度降为 O(1)。<br><strong>长度计数器</strong>：将程序获取表长的复杂度降为 O(1)。<br><strong>多态</strong>：链表节点使用 void * 指针来保存节点值，并且可以通过 list 结构的<code>dup、free、match</code>为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</p><h2 id="链表时间复杂度"><a href="#链表时间复杂度" class="headerlink" title="链表时间复杂度"></a>链表时间复杂度</h2><p>链表相关操作及时间复杂度：</p><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>返回链表长度/头尾节点/给定节点的前驱后继</td><td>O(1)</td></tr><tr><td>插入新节点到表尾/表头</td><td>O(1)</td></tr><tr><td>删除/查找给定节点</td><td>“0(N),N为链表长度”</td></tr><tr><td>拷贝/释放一个链表</td><td>“0(N),N为链表长度”</td></tr></tbody></table><h2 id="链表-API"><a href="#链表-API" class="headerlink" title="链表 API"></a>链表 API</h2><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>listSetDupMethod</td><td>“将给定的函数设置为链表的节点值复制函数,复制函数可以通过链表的dup 属性直接获得”</td><td>0(1)</td></tr><tr><td>listGetDupMethod</td><td>“返回链表当前正在使用的节点值复制函数”</td><td>0(1)</td></tr><tr><td>listSetFreeMethod</td><td>“将给定的函数设置为链表的节点值释放函数,释放函数可以通过链表的 free 属性直接获得”</td><td>0(1)</td></tr><tr><td>listGetFree</td><td>“返回链表当前正在使用的节点值释放函数”</td><td>0(1)</td></tr><tr><td>listSetMatchMethod</td><td>“将给定的函数设置为链表的节点值对比函数,对比函数可以通过链表的match 属性直接获得”</td><td>O(1)</td></tr><tr><td>listGetMatchMethod</td><td>“返回链表当前正在使用的节点值对比函数”</td><td>0(1)</td></tr><tr><td>listLength</td><td>“返回链表的长度(包含了多少个节点),链表长度可以通过链表的 len 属性直接获得”</td><td>0(1)</td></tr><tr><td>listFirst</td><td>“返回链表的表头节点,表头节点可以通过链表的 head 属性直接获得”</td><td>O(1)</td></tr><tr><td>listLast</td><td>“返回链表的表尾节点,表尾节点可以通过链表的 tail 属性直接获得”</td><td>O(1)</td></tr><tr><td>listPrevNode</td><td>“返回给定节点的前置节点,前置节点可以通过节点的prev 属性直接获得”</td><td>0(1)</td></tr><tr><td>listNextNode</td><td>“返回给定节点的后置节点,后置节点可以通过节点的next 属性直接获得”</td><td>0(1)</td></tr><tr><td>listNodeValue</td><td>“返回给定节点目前正在保存的值,节点值可以通过节点的value 属性直接获得”</td><td>O(1)</td></tr><tr><td>listCreate</td><td>“创建一个不包含任何节点的新链表”</td><td>O(1)</td></tr><tr><td>listAddNodeHead</td><td>将一个包含给定值的新节点添加到给定链表 的表头</td><td>O(1)</td></tr><tr><td>listAddNodeTail</td><td>将一个包含给定值的新节点添加到给定链表 的表尾</td><td>0(1)</td></tr><tr><td>listInsertNode</td><td>将一个包含给定值的新节点添加到给定节点 的之前或者之后</td><td>0(1)</td></tr><tr><td>listSearchKey</td><td>查找并返回链表中包含给定值的节点</td><td>“O(N),N为链表长度”</td></tr><tr><td>listIndex</td><td>返回链表在给定索引上的节点</td><td>“O(M),N为链表长度”</td></tr><tr><td>listDelNode</td><td>从链表中删除给定节点</td><td>“O(M),N为链表长度”</td></tr><tr><td>listRotate</td><td>“将链表的表尾节点弹出,然后将被弹出的节 点插人到链表的表头,成为新的表头节点”</td><td>O(1)</td></tr><tr><td>listDup</td><td>复制一个给定链表的副本</td><td>“O(N),N为链表长度”</td></tr><tr><td>listRelease</td><td>“释放给定链表,以及链表中的所有节点”</td><td>“O(M),N为链表长度”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 简单动态字符串</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-jian-dan-dong-tai-zi-fu-chuan/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-jian-dan-dong-tai-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-简单动态字符串"><a href="#【Redis】-简单动态字符串" class="headerlink" title="【Redis】 简单动态字符串"></a>【Redis】 简单动态字符串</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 简单动态字符串date: 2023-07-09 08:28tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 简单动态字符串</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 中，涉及可以被修改的字符串值时，都用<strong>简单动态字符串</strong>（simple dynamic string，SDS）来实现。比如包含字符串值的键值对在底层的实现。C 字符串（C 语言中传统字符串，以空字符串结尾的字符数组）则用于<strong>无须对字符串进行修改</strong>的地方，比如日志打印。</p><p>SDS 还被用作缓冲区，比如 AOF 模块中的 AOF 缓冲区，客户端状态中的输入缓冲区。</p><p><img src="/attachment/48f6554b6d64116a146df63a9cd88017.png"></p><p>Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。</p><p>比起C字符串，SDS具有以下<strong>优点</strong>：</p><ol><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出。</li><li>减少修改字符串长度时所需的内存重分配次数。</li><li>二进制安全。</li><li>兼容部分C字符串函数。</li></ol><h2 id="SDS-定义"><a href="#SDS-定义" class="headerlink" title="SDS 定义"></a>SDS 定义</h2><pre><code class="line-numbers language-c">struct sdshdr{    //buf已使用的字节数    int len;    //buf未使用的字节数    int free;    //字节数组，用于保存字符串    char buf[];}</code></pre><p>buf 遵循 C 字符串以空字符串结尾的惯例，保存空字符串的 1 字节空间不计算在 SDS 的 len 属性里面，并为空字符分配<strong>额外 1 字节</strong>空间，对用户来说是透明的。</p><p><img src="/attachment/48f6554b6d64116a146df63a9cd88017.png"></p><p>如中展示了 SDS 的数据结构，5 字节未使用空间，已使用 5 字节，buf 存储了字符串值，最后一个字节保存了空字符<code>'\0'</code>。这里要注意的是，free 和 len 的计算不涉及空字符。</p><h2 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h2><ol><li>SDS 有<strong>常数级的时间复杂度</strong>获取字符串长度。<br> 由于 C 字符串不会记录自身长度，因此只能遍历，直到遇到结尾的空字符为止, 时间复杂度为 O(N)。而 SDS 对于字符串长度的记录都是在其 API 中执行的，所以时间复杂度为 **O(1)**。</li><li>SDS <strong>杜绝缓冲区溢出。</strong><br> 由于 C 字符串未记录自身长度，容易导致缓冲区溢出。在执行字符串拼接时，如果没有足够的空间，并且相邻内存地址被其他字符串占用时，字符串的<strong>数据将溢出</strong>，且容易<strong>意外修改相邻的字符串内容</strong>。相比而言，SDS 会将这种情况扼杀在摇篮之中，SDS API 先判断<strong>空间是否满足</strong>，如果不满足则将空间<strong>扩展至执行修改所需的大小</strong>。</li><li>SDS 拥有<strong>内存分配策略</strong>，详见 1.3。</li><li>SDS API 都是<strong>二进制安全</strong>的。<br>C 字符串的字符<strong>必须符合某种编码</strong>，并且中间<strong>不能</strong>有空字符，否则读取时会被误以为是字符串结尾。种种局限使得 C 字符串只能存文本，不能存图片，音频，视频，压缩文件等二进制数据。 为确保 Redis 对不同使用场景的支持，SDS API 都是二进制安全的，也就是所有 SDS API 都会以<strong>二进制的方式</strong>存取 buf 中的数据，数据的写入和读出都是一个样的。由于 SDS 读取时并不是依靠空字符来判断结束的，而是 <strong>len 属性</strong>，所以是二进制安全的。</li><li><strong>兼容部分 C 字符串函数</strong>。<br> SDS 虽然都是二进制安全的，但也<strong>遵循以空字符结尾</strong>的习惯。SDS API 总会在 buf 数组分配空间时多分配一个字节用于容纳空字符，这是为了保存文本的 SDS <strong>重用一部分</strong> &lt;string.h&gt; 库函数，避免代码重复。</li></ol><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>由于 C 字符并<strong>不记录</strong>自身长度，并且需要一个字符空间保存空字符串，因此每次增长或缩短字符串时，就要对其进行一次<strong>内存重分配</strong>操作。增长字符串时要看空间是否够用，否则会有<strong>缓冲区溢出</strong>；缩短字符串要释放不用的空间，否则会有<strong>内存泄漏</strong>。</p><p>Redis 经常被用于速度要求严苛，数据被频繁修改的场合，每次修改字符串都要重新分配内存，就会占用很多时间。为避免这个问题，redis 采用了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略。</p><h3 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h3><p>空间预分配用于优化 SDS 字符串<strong>增长操作</strong>。在扩展 SDS 空间前，SDS API 会先检查未使用空间够不够，如果不够，则进行空间预分配。此时，程序不仅会为 SDS 分配修改所必须要的空间，还为其分配额外未使用的空间。</p><ul><li>修改后的 SDS&lt;1MB，程序分配和 len 属性<strong>同样大小</strong>的未使用空间，此时 SDS 的 len 与 free 大小相等。比如修改后实际存储字符串的空间变为 13 字节，那么 len=13，free=13，buf 数组整体的长度 = 13+13+1（额外 1 字节保存空字符）。</li><li>修改后 SDS&gt;=1MB。程序会分配 <strong>1MB</strong> 的未使用空间。比如修改后实际存储字符串的空间变为 2MB，那么 len=2M，free=1MB，buf 数组整体的长度 = 2MB+1MB+1byte。</li></ul><p>通过空间的预分配，将<strong>连续增长 N 次字符串需要的内存分配次数</strong>从一定需要 N 次变为<strong>最多 N 次</strong>。因而可以减少连续执行字符串增长操作所需的内存重分配的次数。</p><h3 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h3><p>惰性空间的释放用于优化 SDS 字符串<strong>缩短操作</strong>。当 SDS API 需要缩短保存的字符串时，程序并不立即回收这部分内存，而是使用 free 属性将字节的数量记录，等待使用。与此同时，SDS 提供了相关 API，在有需要时，<strong>真正释放</strong>未使用空间，不需要担心惰性空间造成的内存浪费。</p><p>C 字符串与 SDS 的区别简单来说：</p><table><thead><tr><th>C字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>“API是不安全的,可能会造成缓冲区溢出”</td><td>API是安全的,不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度N次必然需要执行N次重分配</td><td>修改字符串长度N次最多需要执行N次重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本或二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h2 id="SDS-时间复杂度"><a href="#SDS-时间复杂度" class="headerlink" title="SDS 时间复杂度"></a>SDS 时间复杂度</h2><p>SDS 相关操作及时间复杂度：</p><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>创建/释放/拷贝一个的SDS</td><td>“O(N),N为C字符串长度”</td></tr><tr><td>清空SDS内容</td><td>“情性空闫释放,O(1)”</td></tr><tr><td>给定C字符率拼接到SDS尾部</td><td>“O(N),N为被拼接字符串长度”</td></tr></tbody></table><h2 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h2><table><thead><tr><th>函 数</th><th>作 用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>sdsnew</td><td>创建一个包含给定C字符串的 SDS</td><td>“O(N),N为给定C字符串的长度”</td></tr><tr><td>sdsempty</td><td>创建一个不包含任何内容的空 SDS</td><td>O(1)</td></tr><tr><td>sdsfree</td><td>释放给定的 SDS</td><td>“O(M),N为被释放SDS的长度”</td></tr><tr><td>sdslen</td><td>返回SDS的已使用空间字节数</td><td>“这个值可以通过读取 SDS 的len属性来 直接获得,复杂度为 0(1)”</td></tr><tr><td>sdsavail</td><td>返回SDS 的未使用空间字节数</td><td>“这个值可以通过读取 SDS 的free属性 来直接获得,复杂度为 0(1)”</td></tr><tr><td>sdsdup</td><td>创建一个给定 SDS的副本( copy )</td><td>“O(M),N为给定 SDS的长度”</td></tr><tr><td>sdsclear</td><td>清空SDS保存的字符串内容</td><td>“因为惰性空间释放策略,复杂度为O(1)”</td></tr><tr><td>sdscat</td><td>将给定C字符串拼接到SDS字符串的末尾</td><td>“O(M),N为被拼接C字符串的长度”</td></tr><tr><td>sdscatsds</td><td>将给定SDS字符串拼接到另一个SDS字符串 的末尾</td><td>“O(N),N为被拼接SDS字符串的长度”</td></tr><tr><td>sdscpy</td><td>“将给定的C字符串复制到 SDS里面,覆盖 SDS原有的字符串”</td><td>“O(M),N为被复制C字符串的长度”</td></tr><tr><td>sdsgrowzero</td><td>用空字符将SDS扩展至给定长度</td><td>“O(N),N为扩展新增的字节数”</td></tr><tr><td>sdsrange</td><td>“保留SDS给定区间内的数据,不在区间内的 数据会被覆盖或清除”</td><td>“O(N),N为被保留数据的字节数”</td></tr><tr><td>sdstrim</td><td>“接受一个SDS和一个C字符串作为参数,从 SDS中移除所有在C字符串中出现过的字符”</td><td>“O(N),N为给定C字符串的长度”</td></tr><tr><td>sdscmp</td><td>对比两个SDS字符串是否相同</td><td>“O(M),N为两个SDS 中较短的那个 SDS 的长度”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 多机库的实现</title>
      <link href="/database/redis/redis-duo-ji-ku-de-shi-xian/redis-duo-ji-ku-de-shi-xian/"/>
      <url>/database/redis/redis-duo-ji-ku-de-shi-xian/redis-duo-ji-ku-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-多机库的实现"><a href="#【Redis】-多机库的实现" class="headerlink" title="【Redis】 多机库的实现"></a>【Redis】 多机库的实现</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 多机库的实现date: 2023-07-09 07:59tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 多机库的实现</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/850d61c882123d73b0f6f251e3ef9025.png"></p><ul><li>复制（同步，命令传播，SYNC，PSYNC 实现，心跳检测）</li><li>Sentinel 机制（启动并初始化，获取主从信息，发送 / 接收频道消息，下线检测，故障转移）</li><li>cluster 集群（节点数据结构，槽指派，命令执行，重新分片，ASK 错误，故障转移，消息）</li></ul><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>undefined</p><p>undefined</p><h2 id="Sentinel-机制"><a href="#Sentinel-机制" class="headerlink" title="Sentinel 机制"></a>Sentinel 机制</h2><p>undefined</p><p>undefined</p><h2 id="cluster-集群"><a href="#cluster-集群" class="headerlink" title="cluster 集群"></a>cluster 集群</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 单机库的实现</title>
      <link href="/database/redis/redis-dan-ji-ku-de-shi-xian/redis-dan-ji-ku-de-shi-xian/"/>
      <url>/database/redis/redis-dan-ji-ku-de-shi-xian/redis-dan-ji-ku-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-单机库的实现"><a href="#【Redis】-单机库的实现" class="headerlink" title="【Redis】 单机库的实现"></a>【Redis】 单机库的实现</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 单机库的实现date: 2023-07-08 23:28tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 单机库的实现</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/0f7624ac6815ad0d822a4e791f52731e.png"></p><ul><li>数据库（数据库实现，键空间实现，过期键操作，删除策略，通知）</li><li>RDB 持久化（载入与创建，间隔性保存原理，文件结构）</li><li>AOF 持久化（实现，载入与数据还原，AOF 重写）</li><li>事件（文件事件，I/O 多路复用的实现，时间事件，serverCron 函数，调度与执行）</li><li>客户端（属性，创建与关闭）</li><li>服务器（初始化过程，命令执行过程）</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>undefined</p><p>undefined</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>undefined</p><p>undefined</p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>undefined</p><p>undefined</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>undefined</p><p>undefined</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>undefined</p><p>undefined</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】 Redis 数据结构与对象</title>
      <link href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-shu-ju-jie-gou-yu-dui-xiang/"/>
      <url>/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-shu-ju-jie-gou-yu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="【Redis】-Redis-数据结构与对象"><a href="#【Redis】-Redis-数据结构与对象" class="headerlink" title="【Redis】 Redis 数据结构与对象"></a>【Redis】 Redis 数据结构与对象</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Redis】 Redis 数据结构与对象date: 2023-07-08 20:57tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: 【Redis】 Redis 数据结构与对象</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/attachment/b6b17135ab87241a042e726ff6ea516d.png"></p><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>undefined</p><p>undefined</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>undefined</p><p>undefined</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>undefined</p><p>undefined</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>undefined</p><p>undefined</p><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>undefined</p><p>undefined</p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>undefined</p><p>undefined</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 锁</title>
      <link href="/database/mysql/mysql-suo/"/>
      <url>/database/mysql/mysql-suo/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 锁</h1><h2 id="Metadata-23">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 锁date: 2023-06-25 22:16tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 锁</code></pre><h2 id="概述-18">概述</h2><p><strong>并发事务的情况</strong></p><ul><li>写-写情况：即并发事务相继对相同的记录做出改动。 – 脏写</li><li>读-写或写-读情况：即一个事务进行读取操作，另一个进行改动操作。  – 脏读、不可重复读、幻读</li></ul><p><strong>锁结构</strong></p><ul><li>trx信息：代表这个锁结构是哪个事务生成的。</li><li>is_waiting ：代表当前事务是否在等待。</li></ul><p><img src="/attachment/161ec1961aef73abc354f82b621b4f7c.png" alt=""></p><p><strong>解决并发事务带来问题的两种基本方式</strong></p><ul><li>读操作利用多版本并发控制（ MVCC ），写操作进行加锁。</li><li>读、写操作都采用加锁的方式。</li></ul><p><strong>读操作</strong></p><ul><li>一致性读（Consistent Reads） 事务利用MVCC 进行的读取操作</li><li>锁定读（Locking Reads）  共享锁和独占锁</li></ul><p><strong>写操作</strong></p><ul><li>DELETE<ol><li>先在B+ 树中定位到这条记录的位置，</li><li>然后获取一下这条记录的X锁，</li><li>然后再执行delete mark 操作。</li></ol></li><li>UPDATE<ul><li>未修改键值且未改变存储空间：<ol><li>在B+树中定位到待修改记录的位置。</li><li>获取记录的X锁（锁定读）。</li><li>在原记录位置进行修改操作。</li></ol></li><li>未修改键值但改变了存储空间：<ol><li>在B+树中定位到待修改记录的位置。</li><li>获取记录的X锁（锁定读）。</li><li>彻底删除该记录（移入垃圾链表）。</li><li>插入一条新记录。</li><li>新插入的记录由INSERT操作提供的隐式锁进行保护。</li></ol></li><li>修改了键值：<ol><li>相当于先执行DELETE操作再执行INSERT操作。</li><li>加锁操作遵循DELETE和INSERT的规则。</li></ol></li></ul></li><li>INSERT<ul><li>隐式锁 保护</li></ul></li></ul><p><strong>多粒度锁</strong></p><ul><li><p>共享锁，英文名： Shared Locks，简称S锁。 在事务要读取一条记录时，需要先获取该记录的S锁。</p></li><li><p>独占锁，也常称排他锁，英文名： Exclusive Locks ，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。</p></li><li><p>行锁  DML 语句 DQL 语句</p><ul><li>行S锁</li><li>行X锁</li></ul></li><li><p>表锁  DDL 语句</p><ul><li>表S锁</li><li>表X锁</li></ul></li><li><p>意向锁 为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁</p><ul><li>意向共享锁，英文名： Intention Shared Lock ，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。</li><li>意向独占锁，英文名： Intention Exclusive Lock ，简称IX锁。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。</li></ul></li></ul><p><img src="/attachment/2ed86ba8130e63a3194c27bd2ec8052f.png" alt=""></p><p><strong>InnoDB 存储引擎相关锁</strong></p><p>表级锁</p><ul><li>AUTO-INC锁<ul><li>id 字段声明了AUTO_INCREMENT</li><li>轻量级的锁</li></ul></li></ul><p>行级锁</p><ul><li>Record Locks 记录锁<ul><li>仅仅把一条记录锁上</li><li>分 X锁 S锁</li><li><img src="/attachment/ece8f03d4b6e3eb6703eba7f14860179.png" alt=""></li></ul></li><li>Gap Locks 间隔锁<ul><li>记录前边的间隙插入新记录</li><li>解决幻读</li><li><img src="/attachment/9b396b346bb2541cfc2bf9cf71aafade.png" alt=""></li></ul></li><li>Next-Key Locks 邻键锁<ul><li>既锁住某条记录，又阻止其他事务在该记录前边的间隙插入新记录</li><li><img src="/attachment/e90eee308ee767cf1b2394ad7bb494d8.png" alt=""></li></ul></li><li>Insert Intention Locks 插入意向锁<ul><li>有事务想在某个间隙中插入新记录，但是现在在等待。</li><li><img src="/attachment/38332344b5963095d1b246349b494971.png" alt=""></li></ul></li><li>隐式锁<ul><li>一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id 的存在，相当于加了一个隐式锁。</li></ul></li></ul><p><strong>InnoDB锁的内存结构</strong></p><p><img src="/attachment/85002faeead4df3acc3ca0fe807dab1d.png" alt=""></p><h2 id="前言-3">前言</h2><h3 id="并发事务的情况">并发事务的情况</h3><ul><li>读-读情况：即并发事务相继读取相同的记录。<br>读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。</li><li>写-写情况：即并发事务相继对相同的记录做出改动。<br>在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。<br>读-写或写-读情况：也就是一个事务进行读取操作，另一个进行改动操作。<br>这种情况下可能发生脏读、不可重复读、幻读的问题。</li></ul><p>在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。</p><h3 id="锁结构">锁结构</h3><p>这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的</p><p><img src="/attachment/830e40aa7b2a310a14441c6c27df6a3c.png" alt=""></p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。</p><p>比方说事务T1 要对这条记录做改动，就需要生成一个锁结构与之关联：</p><p><img src="/attachment/fb84dcdd9da6e3b4ab6d8228e2994005.png" alt=""></p><p>其实在锁结构里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：</p><ul><li>trx信息：代表这个锁结构是哪个事务生成的。</li><li>is_waiting ：代表当前事务是否在等待。</li></ul><p>如图所示，当事务T1 改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting 属性就是false ，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。</p><p>在事务T1 提交之前，另一个事务T2 也想对该记录做改动，那么先去看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting 属性值为true ，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁，画个图表示就是这样：</p><p><img src="/attachment/161ec1961aef73abc354f82b621b4f7c.png" alt=""></p><p>在事务T1 提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2 还在等待获取锁，所以把事务T2 对应的锁结构的is_waiting 属性设置为false ，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2 就算获取到锁了。效果图就是这样：</p><p><img src="/attachment/cc45bd5f6c7036e7b59d01065b627937.png" alt=""></p><p>我们总结一下后续内容中可能用到的几种说法，以免大家混淆：</p><ul><li>不加锁<br>意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。</li><li>获取锁成功，或者加锁成功<br>意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting 属性为false ，也就是事务可以继续执行操作。</li><li>获取锁失败，或者加锁失败，或者没有获取到锁<br>意思就是在内存中生成了对应的锁结构，不过锁结构的is_waiting 属性为true ，也就是事务需要等待，不可以继续执行操作。</li></ul><h2 id="解决并发事务带来问题的两种基本方式">解决并发事务带来问题的两种基本方式</h2><h3 id="方案一：读操作利用多版本并发控制（-MVCC-），写操作进行加锁。">方案一：读操作利用多版本并发控制（ MVCC ），写操作进行加锁。</h3><p>读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC 时， 读-写操作并不冲突。</p><h3 id="方案二：读、写操作都采用加锁的方式。">方案二：读、写操作都采用加锁的方式。</h3><p>这样在读取记录的时候也就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p><h2 id="读操作">读操作</h2><h3 id="一致性读（Consistent-Reads）">一致性读（Consistent Reads）</h3><p>事务利用MVCC 进行的读取操作称之为<strong>一致性读</strong>，或者<strong>一致性无锁读</strong>，有的地方也称之为<strong>快照读</strong></p><h3 id="锁定读（Locking-Reads）">锁定读（Locking Reads）</h3><h4 id="共享锁和独占锁">共享锁和独占锁</h4><p>由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以设计MySQL 的大叔给锁分了个类：</p><ul><li>共享锁，英文名： Shared Locks ，简称S锁。在事务要读取一条记录时，需要先获取该记录的S锁。</li><li>独占锁，也常称排他锁，英文名： Exclusive Locks ，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。</li></ul><p><img src="/attachment/374c86eaca4bde2a35b9123cb75cfa2c.png" alt=""></p><h4 id="锁定读的语句">锁定读的语句</h4><p>对读取的记录加S锁：</p><pre><code class="language-sql">SELECT ... LOCK IN SHARE MODE;</code></pre><p>对读取的记录加X锁：</p><pre><code class="language-sql">SELECT ... FOR UPDATE;</code></pre><h2 id="写操作">写操作</h2><p>写操作无非是DELETE 、UPDATE 、INSERT 这三种</p><ul><li>DELETE ：</li></ul><p>对一条记录做DELETE 操作的过程其实是</p><ol><li>先在B+ 树中定位到这条记录的位置，</li><li>然后获取一下这条记录的X锁，</li><li>然后再执行delete mark 操作。</li></ol><p>我们也可以把这个<strong>定位待删除记录在B+ 树中位置</strong>的过程看成是一个获取X锁的锁定读。</p><ul><li>UPDATE ：</li></ul><ol><li>如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在B+ 树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。其实我们也可以把这个<strong>定位待修改记录在B+ 树中位置</strong>的过程看成是一个获取X锁的锁定读。</li><li>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+ 树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个<strong>定位待修改记录在B+ 树中位置</strong>的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT 操作提供的隐式锁进行保护。</li><li>如果修改了该记录的键值，则相当于在原记录上做DELETE 操作之后再来一次INSERT 操作，加锁操作就需要按照DELETE 和INSERT 的规则进行了。</li></ol><ul><li>INSERT ：</li></ul><p>新插入一条记录的操作并不加锁，设计InnoDB 的大叔通过一种称之为<strong>隐式锁</strong>的东东来保护这条新插入的记录在本事务提交前不被别的事务访问</p><h2 id="多粒度锁">多粒度锁</h2><p>之前提到的锁都是针对记录的，也可以被称之为<strong>行级锁</strong>或者<strong>行锁</strong>，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细</p><p>其实一个事务也可以在表级别进行加锁，自然就被称之为<strong>表级锁</strong>或者<strong>表锁</strong>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。</p><p>给表加的锁也可以分为共享锁（ S锁）和独占锁（ X锁）：</p><h3 id="给表加S锁：">给表加S锁：</h3><p>如果一个事务给表加了S锁，那么：</p><ul><li>别的事务可以继续获得该表的S锁</li><li>别的事务可以继续获得该表中的某些记录的S锁</li><li>别的事务不可以继续获得该表的X锁</li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul><h3 id="给表加X锁：">给表加X锁：</h3><p>如果一个事务给表加了X锁（意味着该事务要独占这个表），那么：</p><ul><li>别的事务不可以继续获得该表的S锁</li><li>别的事务不可以继续获得该表中的某些记录的S锁</li><li>别的事务不可以继续获得该表的X锁</li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul><h3 id="意向锁">意向锁</h3><p>我们在对教学楼整体上锁（ 表锁）时，怎么知道教学楼中有没有教室已经被上锁（ 行锁）了呢？</p><p><strong>总结</strong></p><p>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。</p><p><img src="/attachment/2ed86ba8130e63a3194c27bd2ec8052f.png" alt=""></p><h2 id="MySQL中的行锁和表锁">MySQL中的行锁和表锁</h2><p>InnoDB 存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。下边我们详细看一下。</p><h3 id="InnoDB中的表级锁">InnoDB中的表级锁</h3><h4 id="表级别的S锁、X锁">表级别的S锁、X锁</h4><p>在对某个表执行SELECT 、INSERT 、DELETE 、UPDATE 语句时， InnoDB 存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p><p>在对某个表执行一些诸如ALTER TABLE 、DROP TABLE 这类的DDL 语句时，其他事务对这个表并发执行诸如SELECT 、INSERT 、DELETE 、UPDATE 的语句会发生阻塞，同理，某个事务中对某个表执行SELECT 、INSERT 、DELETE 、UPDATE 语句时，在其他会话中对这个表执行DDL 语句也会发生阻塞</p><p>这个过程其实是通过在<strong>server层</strong>使用一种称之为<strong>元数据锁</strong>（英文名： Metadata Locks ，简称MDL ）东东来实现的，一般情况下也不会使用InnoDB 存储引擎自己提供的表级别的S锁和X锁。</p><p>其实这个InnoDB 存储引擎提供的表级S锁或者X锁是相当鸡肋，只会在一些特殊情况下，比方说<strong>崩溃恢复</strong>过程中用到。</p><p>不过我们还是可以手动获取一下的，比方说在系统变量autocommit=0，innodb_table_locks =1 时，手动获取InnoDB 存储引擎提供的表t 的S锁或者X锁可以这么写：</p><ul><li>LOCK TABLES t READ ： InnoDB 存储引擎会对表t 加表级别的S锁。</li><li>LOCK TABLES t WRITE ： InnoDB 存储引擎会对表t 加表级别的X锁。</li></ul><h4 id="表级别的IS锁、IX锁">表级别的IS锁、IX锁</h4><p>当我们在对使用InnoDB 存储引擎的表的某些记录加S锁之前，那就需要先在表级别加一个IS锁，当我们在对使用InnoDB 存储引擎的表的某些记录加X锁之前，那就需要先在表级别加一个IX锁。</p><p>S锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。</p><h4 id="表级别的AUTO-INC锁">表级别的AUTO-INC锁</h4><p>在使用MySQL 过程中，我们可以为表的某个列添加AUTO_INCREMENT 属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值</p><p>比方说我们有一个表：</p><pre><code class="language-sql">CREATE TABLE t (id INT NOT NULL AUTO_INCREMENT,c VARCHAR(100),PRIMARY KEY (id)) Engine=InnoDB CHARSET=utf8;</code></pre><p>由于这个表的id 字段声明了AUTO_INCREMENT ，也就意味着在书写插入语句时不需要为其赋值.</p><p>系统实现这种自动给AUTO_INCREMENT 修饰的列递增赋值的原理主要是两个：</p><ul><li>采用AUTO-INC 锁，也就是在执行插入语句时就在表级别加一个AUTO-INC 锁，然后为每条待插入记录的<strong>AUTO_INCREMENT</strong> 修饰的列分配<strong>递增</strong>的值，在该语句执行结束后，再把AUTO-INC 锁释放掉。这样一个事务在持有AUTO-INC 锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</li><li>采用一个轻量级的锁，在为插入语句生成AUTO_INCREMENT 修饰的列的值时获取一下这个<strong>轻量级锁</strong>，然后生成本次插入语句需要用到的AUTO_INCREMENT 列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。</li></ul><h3 id="InnoDB中的行级锁">InnoDB中的行级锁</h3><p>行锁，也称为记录锁，顾名思义就是在记录上加的锁。</p><p>使对同一条记录加行锁，如果类型不同，起到的功效也是不同的。</p><h4 id="示例-2">示例</h4><pre><code class="language-sql">CREATE TABLE hero (number INT,name VARCHAR(100),country varchar(100),PRIMARY KEY (number),KEY idx_name (name)) Engine=InnoDB CHARSET=utf8;</code></pre><p>我们主要是想用这个表存储三国时的英雄，然后向这个表里插入几条记录：</p><pre><code class="language-sql">INSERT INTO hero VALUES(1, 'l刘备', '蜀'),(3, 'z诸葛亮', '蜀'),(8, 'c曹操', '魏'),(15, 'x荀彧', '魏'),(20, 's孙权', '吴');</code></pre><p>现在表里的数据就是这样的：</p><p><img src="/attachment/d2449908ad089564eaa35f943a597b26.png" alt=""></p><pre><code class="language-ad-tip">采用utf8字符集，该字符集并没有对应的按照汉语拼音进行排序的比较规则</code></pre><p>我们把hero 表中的聚簇索引的示意图画一下：</p><p><img src="/attachment/26e8bb3d7af0b8def3361644af2eef81.png" alt=""></p><h4 id="常用的行锁类型">常用的行锁类型</h4><h5 id="Record-Locks-：">Record Locks ：</h5><p>LOCK_REC_NOT_GAP (正经记录锁) 仅仅把一条记录锁上</p><p>比方说我们把number 值为8 的那条记录加一个正经记录锁的示意图如下：</p><p><img src="/attachment/ece8f03d4b6e3eb6703eba7f14860179.png" alt=""></p><p>正经记录锁是有S锁和X锁之分的，让我们分别称之为S型正经记录锁和X型正经记录锁吧</p><h5 id="Gap-Locks-：">Gap Locks ：</h5><p>使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上正经记录锁。</p><p>提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP 简称为gap锁。</p><p><img src="/attachment/9b396b346bb2541cfc2bf9cf71aafade.png" alt=""></p><p>不允许别的事务在number 值为8 的记录前边的间隙插入新记录</p><p>这个gap锁的提出仅仅是为了防止插入幻影记录而提出的</p><p>给哪条记录加gap锁才能阻止其他事务插入number 值在(20, +∞) 这个区间的新记录呢?</p><p>参考数据页时介绍的两条伪记录了：</p><ul><li>Infimum 记录，表示该页面中最小的记录。</li><li>Supremum 记录，表示该页面中最大的记录。</li></ul><p>为了实现阻止其他事务插入number 值在(20, +∞) 这个区间的新记录，我们可以给索引中的最后一条记录，也就是number 值为20 的那条记录所在页面的Supremum 记录加上一个gap锁</p><p><img src="/attachment/8e2b8dfb65a52fb31b0429976d42e168.png" alt=""></p><p>这样就可以阻止其他事务插入number 值在(20, +∞) 这个区间的新记录。为了大家理解方便，之后的索引示意图中都会把这个Supremum 记录画出来。</p><h5 id="Next-Key-Locks-：">Next-Key Locks ：</h5><p>既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录</p><p>Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY 简称为next-key锁。</p><p><img src="/attachment/e90eee308ee767cf1b2394ad7bb494d8.png" alt=""></p><p>next-key锁的本质就是一个正经记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p><h5 id="Insert-Intention-Locks-：">Insert Intention Locks ：</h5><p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁<br>如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。<br>设计InnoDB 的大叔规定事务在等待的时候也需要在内存中生成一个锁结构, 表明有事务想在某个间隙中插入新记录，但是现在在等待。</p><p>把这种类型的锁命名为Insert Intention Locks ，官方的类型名称为： LOCK_INSERT_INTENTION ，我们也可以称为插入意向锁。</p><p><img src="/attachment/38332344b5963095d1b246349b494971.png" alt=""></p><p>比方说现在T1 为number 值为8 的记录加了一个gap锁，然后T2 和T3 分别想向hero 表中插入number 值分别为4 、5 的两条记录，所以现在为number 值为8 的记录加的锁的示意图就如下所示：</p><p><img src="/attachment/4d049c35d004eaa8be62091cfc3c75e3.png" alt=""></p><p>从图中可以看到，由于T1 持有gap锁，所以T2 和T3 需要生成一个插入意向锁的锁结构并且处于等待状态。当T1 提交后会把它获取到的锁都释放掉，这样T2 和T3 就能获取到对应的插入意向锁了（本质上就是把插入意向锁对应锁结构的is_waiting 属性改为false ）， T2 和T3 之间也并不会相互阻塞，它们可以同时获取到number 值为8的插入意向锁，然后执行插入操作。</p><h5 id="隐式锁">隐式锁</h5><p>一个事务在执行INSERT 操作时，如果即将插入的间隙已经被其他事务加了gap锁，那么本次INSERT 操作会阻塞，并且当前事务会在该间隙上加一个插入意向锁，否则一般情况下INSERT 操作是不加锁的。</p><p>那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），没提交，然后另一个事务：</p><ul><li>立即使用SELECT … LOCK IN SHARE MODE 语句读取这条事务，也就是在要获取这条记录的S锁，或者使用SELECT … FOR UPDATE 语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的X锁<br>如果允许这种情况的发生，那么可能产生脏读问题。</li><li>立即修改这条记录，也就是要获取这条记录的X锁，该咋办？<br>如果允许这种情况的发生，那么可能产生脏写问题。</li></ul><p><strong>我们把聚簇索引和二级索引中的记录分开看一下：</strong></p><ul><li>情景一：</li></ul><p>对于聚簇索引记录来说，有一个trx_id 隐藏列，该隐藏列记录着最后改动该记录的事务id 。<br>那么如果在当前事务中新插入一条聚簇索引记录后，该记录的trx_id 隐藏列代表的就是当前事务的事务id ，<br>如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id 隐藏列代表的事务是否是当前的活跃事务，<br>如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构， is_waiting 属性是false ），<br>然后自己进入等待状态（也就是为自己也创建一个锁结构， is_waiting 属性是true ）。</p><ul><li>情景二：</li></ul><p>对于二级索引记录来说，本身并没有trx_id 隐藏列，但是在二级索引页面的Page Header 部分有一个PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的事务id ，<br>如果PAGE_MAX_TRX_ID 属性值小于当前最小的活跃事务id ，那么说明对该页面做修改的事务都已经提交了，<br>否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。</p><p>一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id 这个牛逼的东东的存在，相当于加了一个隐式锁。</p><h2 id="InnoDB锁的内存结构">InnoDB锁的内存结构</h2><p>决定在对不同记录加锁时，如果符合下边这些条件：</p><p>如果符合下边这些条件：</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的<br>那么这些记录的锁就可以被放到一个锁结构中</li></ul><p>InnoDB 存储引擎中的锁结构：</p><p><img src="/attachment/85002faeead4df3acc3ca0fe807dab1d.png" alt=""></p><h3 id="锁所在的事务信息：">锁所在的事务信息：</h3><p>不论是表锁还是行锁，都是在事务执行过程中生成的，<strong>哪个事务生成了这个锁结构</strong>，这里就记载着这个事务的信息。</p><h3 id="索引信息：">索引信息：</h3><p>对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。</p><h3 id="表锁／行锁信息：">表锁／行锁信息：</h3><p>表锁结构和行锁结构在这个位置的内容是不同的：</p><ul><li>表锁：<ul><li>记载着这是对哪个表加的锁，还有其他的一些信息。</li></ul></li><li>行锁：<ul><li>记载了三个重要的信息：<ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，<strong>一条记录就对应着一个比特位</strong>，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li></ul></li></ul></li></ul><h3 id="type-mode-：">type_mode ：</h3><p>这是一个32位的数，被分成了lock_mode 、lock_type 和rec_lock_type 三个部分，如图所示：</p><p><img src="/attachment/78c76fd0161343d3226a2ec4a9dce15f.png" alt=""></p><ul><li><p>锁的模式（ lock_mode ），占用低4位，可选的值如下：</p><ul><li>LOCK_IS （十进制的0 ）：表示共享意向锁，也就是IS锁。</li><li>LOCK_IX （十进制的1 ）：表示独占意向锁，也就是IX锁。</li><li>LOCK_S （十进制的2 ）：表示共享锁，也就是S锁。</li><li>LOCK_X （十进制的3 ）：表示独占锁，也就是X锁。</li><li>LOCK_AUTO_INC （十进制的4 ）：表示AUTO-INC锁。</li></ul></li><li><p>锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p><ul><li>LOCK_TABLE （十进制的16 ），也就是当第5个比特位置为1时，表示表级锁。</li><li>LOCK_REC （十进制的32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li><p>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在lock_type 的值为LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</p><ul><li>LOCK_ORDINARY （十进制的0 ）：表示next-key锁。</li><li>LOCK_GAP （十进制的512 ）：也就是当第10个比特位置为1时，表示gap锁。</li><li>LOCK_REC_NOT_GAP （十进制的1024 ）：也就是当第11个比特位置为1时，表示正经记录锁。</li><li>LOCK_INSERT_INTENTION （十进制的2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。<br><strong>is_waiting 属性也放到了type_mode 这个32位的数字中</strong></li><li>LOCK_WAIT （十进制的256 ） ：也就是当第9个比特位置为1 时，表示is_waiting 为true ，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为0 时，表示is_waiting 为false ，也就是当前事务获取锁成功。</li></ul></li></ul><h4 id="一堆比特位">一堆比特位</h4><p>对应着一个页面中的记录，一个比特位映射一个heap_no</p><p><img src="/attachment/dbd7d8cbbc1f954c4d21c18f051888cb.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 事务的隔离级别与 MVCC</title>
      <link href="/database/mysql/mysql-shi-wu-de-ge-chi-ji-bie-yu-mvcc/"/>
      <url>/database/mysql/mysql-shi-wu-de-ge-chi-ji-bie-yu-mvcc/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 事务的隔离级别与 MVCC</h1><h2 id="Metadata-16">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 事务的隔离级别与 MVCCdate: 2023-06-25 21:00tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 事务的隔离级别与 MVCC</code></pre><h2 id="概述-11">概述</h2><p><strong>并发事务问题</strong></p><ul><li>脏写（ Dirty Write ） 如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写</li><li>脏读（ Dirty Read ）一个事务读到了另一个未提交事务修改过的数据</li><li>不可重复读（Non-Repeatable Read） 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</li><li>幻读（Phantom）一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</li></ul><p><strong>事务隔离级别</strong></p><ul><li>READ UNCOMMITTED ：未提交读。</li><li>READ COMMITTED ：已提交读。</li><li>REPEATABLE READ ：可重复读。</li><li>SERIALIZABLE ：可串行化。</li></ul><p><strong>MVCC</strong></p><p>MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD 、REPEATABLE READ 这两种隔离级别的事务在执行普通的SEELCT 操作时访问记录的版本链的过程</p><p>版本链</p><ul><li>trx_id ：事务的事务id</li><li>roll_pointer 通过它来找到该记录修改前的信息</li></ul><p><img src="/attachment/36756f24ac5454d6bdf4625a79b63021.png" alt=""></p><p><strong>ReadView</strong></p><ul><li>m_ids ：表示在生成ReadView 时当前系统中活跃的读写事务的事务id 列表。</li><li>min_trx_id ：表示在生成ReadView 时当前系统中活跃的读写事务中最小的事务id ，也就是m_ids 中的最小值。</li><li>max_trx_id ：表示生成ReadView 时系统中应该分配给下一个事务的id 值。</li><li>creator_trx_id ：表示生成该ReadView 的事务的事务id 。</li></ul><p>READ COMMITTED —— 每次读取数据前都生成一个ReadView<br>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</p><h2 id="事前准备">事前准备</h2><pre><code class="language-sql">CREATE TABLE hero (number INT,name VARCHAR(100),country varchar(100),PRIMARY KEY (number)) Engine=InnoDB CHARSET=utf8;</code></pre><p>然后向这个表里插入一条数据：</p><pre><code class="language-sql">INSERT INTO hero VALUES(1, '刘备', '蜀');</code></pre><h2 id="事务隔离级别">事务隔离级别</h2><p>MySQL 是一个客户端／服务器架构的软件</p><p>对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（ Session ）</p><h3 id="事务并发执行遇到的问题">事务并发执行遇到的问题</h3><h4 id="脏写（-Dirty-Write-）">脏写（ Dirty Write ）</h4><p>如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写</p><p><img src="/attachment/33d4b1e593f31ee6473d80a30557b4c7.png" alt=""></p><h4 id="脏读（-Dirty-Read-）">脏读（ Dirty Read ）</h4><p>一个事务读到了另一个未提交事务修改过的数据</p><p><img src="/attachment/5466605563e108d2623de1678bbedd39.png" alt=""></p><h4 id="不可重复读（Non-Repeatable-Read）">不可重复读（Non-Repeatable Read）</h4><p>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</p><p><img src="/attachment/da2541ea1621f71c378e7fa04afdb962.png" alt=""></p><h4 id="幻读（Phantom）">幻读（Phantom）</h4><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</p><p><img src="/attachment/31a5f163a9ce74f0ceeaa76fa75924a2.png" alt=""></p><h3 id="SQL标准中的四种隔离级别">SQL标准中的四种隔离级别</h3><p>给这些问题按照严重性来排一下序：</p><p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p><p>设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生</p><p>制定了一个所谓的SQL标准，在标准中设立了4个隔离级别：</p><ul><li>READ UNCOMMITTED ：未提交读。</li><li>READ COMMITTED ：已提交读。</li><li>REPEATABLE READ ：可重复读。</li><li>SERIALIZABLE ：可串行化。</li></ul><p><img src="/attachment/bf6978fc8a103b03d278aed2748f433e.png" alt=""></p><p><strong>脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</strong></p><h3 id="MySQL中支持的四种隔离级别">MySQL中支持的四种隔离级别</h3><p>与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</p><h4 id="如何设置事务的隔离级别">如何设置事务的隔离级别</h4><pre><code class="language-sql">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</code></pre><p>其中的level 可选值有4个:</p><pre><code>level: {REPEATABLE READ| READ COMMITTED| READ UNCOMMITTED| SERIALIZABLE}</code></pre><p>设置事务的隔离级别的语句中，在SET 关键字后可以放置GLOBAL 关键字、SESSION 关键字或者什么都不放，这样会对不同范围的事务产生不同的影响，具体如下：</p><ul><li>使用GLOBAL 关键字（在全局范围影响）：<ul><li>只对执行完该语句之后产生的会话起作用。</li><li>当前已经存在的会话无效。</li></ul></li><li>使用SESSION 关键字（在会话范围影响）：<ul><li>对当前会话的所有后续的事务有效</li><li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。</li><li>如果在事务之间执行，则对后续的事务有效。</li></ul></li><li>上述两个关键字都不用（只对执行语句后的下一个事务产生影响）：<ul><li>只对当前会话中下一个即将开启的事务有效。</li><li>下一个事务执行完后，后续事务将恢复到之前的隔离级别。</li><li>该语句不能在已经开启的事务中间执行，会报错的。</li></ul></li></ul><h2 id="MVCC原理">MVCC原理</h2><h3 id="版本链">版本链</h3><p>聚簇索引记录中都包含两个必要的隐藏列</p><ul><li>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id 赋值给trx_id 隐藏列。</li><li>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表</p><p><img src="/attachment/36756f24ac5454d6bdf4625a79b63021.png" alt=""></p><p>所有的版本都会被roll_pointer 属性连接成一个链表，我们把这个链表称之为版本链</p><p>每个版本中还包含生成该版本时对应的事务id</p><h3 id="ReadView">ReadView</h3><p>对于使用READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了</p><p>对于使用SERIALIZABLE 隔离级别的事务来说，设计InnoDB 的大叔规定使用加锁的方式来访问记录（加锁是啥我们后续文章中说哈）</p><p>对于使用READ COMMITTED 和REPEATABLE READ 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的</p><p><strong>核心问题</strong></p><p>需要判断一下版本链中的哪个版本是当前事务可见的</p><p>提出了一个<strong>ReadView</strong> 的概念，这个ReadView 中主要包含4个比较重要的内容：</p><ul><li>m_ids ：表示在生成ReadView 时当前系统中活跃的读写事务的事务id 列表。</li><li>min_trx_id ：表示在生成ReadView 时当前系统中活跃的读写事务中最小的事务id ，也就是m_ids 中的最小值。</li><li>max_trx_id ：表示生成ReadView 时系统中应该分配给下一个事务的id 值。</li><li>creator_trx_id ：表示生成该ReadView 的事务的事务id 。</li></ul><p>有了这个ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的trx_id 属性值<strong>等于</strong>ReadView 中的creator_trx_id 值，意味着当前事务在访问它自己修改过的记录，所以该版本可以被<strong>当前事务访问</strong>。</li><li>如果被访问版本的trx_id 属性值<strong>小于</strong>ReadView 中的min_trx_id 值，表明生成该版本的事务在当前事务生成ReadView 前<strong>已经提交</strong>，所以该版本<strong>可以</strong>被当前事务访问。</li><li>如果被访问版本的trx_id 属性值<strong>大于</strong>ReadView 中的max_trx_id 值，表明生成该版本的事务在当前事务生成ReadView 后才开启，所以该版本<strong>不可以</strong>被当前事务访问。</li><li>如果被访问版本的trx_id 属性值<strong>介于</strong>ReadView 的min_trx_id 和max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在m_ids 列表中，如果在，说明创建ReadView 时生成该版本的事务还是活跃的，该版本<strong>不可以</strong>被访问；如果不在，说明创建ReadView 时生成该版本的事务已经被提交，该版本<strong>可以</strong>被访问。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性</p><h4 id="示例">示例</h4><p><img src="/attachment/637fb8acc43e6383704d22877b86d666.png" alt=""></p><p>接下来看一下READ COMMITTED 和REPEATABLE READ 所谓的生成ReadView的时机不同到底不同在哪里。</p><h5 id="READ-COMMITTED-——-每次读取数据前都生成一个ReadView">READ COMMITTED —— 每次读取数据前都生成一个ReadView</h5><pre><code class="language-sql"># Transaction 100BEGIN;UPDATE hero SET name = '关羽' WHERE number = 1;UPDATE hero SET name = '张飞' WHERE number = 1;# Transaction 200BEGIN;# 更新了一些别的表的记录...</code></pre><p><img src="/attachment/2171c85e333c55b04530231cd7d53a4e.png" alt=""></p><p>假设现在有一个使用READ COMMITTED 隔离级别的事务开始执行：</p><pre><code class="language-sql"># 使用READ COMMITTED隔离级别的事务BEGIN;# SELECT1：Transaction 100、200未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'</code></pre><p>这个SELECT1 的执行过程如下：</p><ul><li>在执行 SELECT 语句时会先生成一个<strong>ReadView</strong> ， ReadView 的m_ids 列表的内容就是[100, 200] ，min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’张飞’ ，该版本的trx_id 值为100 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li><li>下一个版本的列name 的内容是’关羽’ ，该版本的trx_id 值也为100 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’刘备’ ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为’刘备’ 的记录。</li></ul><p>之后，我们把事务id 为100 的事务提交一下，就像这样：</p><pre><code class="language-sql"># Transaction 100BEGIN;UPDATE hero SET name = '关羽' WHERE number = 1;UPDATE hero SET name = '张飞' WHERE number = 1;COMMIT;</code></pre><p>然后再到事务id 为200 的事务中更新一下表hero 中number 为1 的记录：</p><pre><code class="language-sql"># Transaction 200BEGIN;# 更新了一些别的表的记录...UPDATE hero SET name = '赵云' WHERE number = 1;UPDATE hero SET name = '诸葛亮' WHERE number = 1;</code></pre><p>此刻，表hero 中number 为1 的记录的版本链就长这样：</p><p><img src="/attachment/ec61e30d9e71825c622557bc39c68924.png" alt=""></p><p>然后再到刚才使用READ COMMITTED 隔离级别的事务中继续查找这个number 为1 的记录，如下：</p><pre><code class="language-sql"># 使用READ COMMITTED隔离级别的事务BEGIN;# SELECT1：Transaction 100、200均未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'# SELECT2：Transaction 100提交，Transaction 200未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'张飞'</code></pre><p>这个SELECT2 的执行过程如下：</p><ul><li>在执行SELECT 语句时会又会单独生成一个ReadView ，该ReadView 的m_ids 列表的内容就是[200] （ 事务id 为100 的那个事务已经提交了，所以再次生成快照时就没有它了）， min_trx_id 为200 ，max_trx_id 为201 ， creator_trx_id 为0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’诸葛亮’ ，该版本的trx_id 值为200 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li><li>下一个版本的列name 的内容是’赵云’ ，该版本的trx_id 值为200 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’张飞’ ，该版本的trx_id 值为100 ，小于ReadView 中的min_trx_id 值200 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为’张飞’ 的记录。</li></ul><p><strong>总结</strong></p><p>使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h5 id="REPEATABLE-READ-——-在第一次读取数据时生成一个ReadView">REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</h5><p>只会在第一次执行查询语句时生成一个ReadView ，之后的查询就不会重复生成了。</p><p>比方说现在系统里有两个事务id 分别为100 、200 的事务在执行：</p><pre><code class="language-sql"># Transaction 100BEGIN;UPDATE hero SET name = '关羽' WHERE number = 1;UPDATE hero SET name = '张飞' WHERE number = 1;# Transaction 200BEGIN;# 更新了一些别的表的记录...</code></pre><p>此刻，表hero 中number 为1 的记录得到的版本链表如下所示：</p><p><img src="/attachment/231a456a5254a23ea1f26f00a85667dd.png" alt=""></p><p>假设现在有一个使用REPEATABLE READ 隔离级别的事务开始执行：</p><pre><code class="language-sql"># 使用REPEATABLE READ隔离级别的事务BEGIN;# SELECT1：Transaction 100、200未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'</code></pre><p>这个SELECT1 的执行过程如下：</p><ul><li>在执行SELECT 语句时会先生成一个ReadView ， ReadView 的m_ids 列表的内容就是[100, 200] ，min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’张飞’ ，该版本的trx_id 值为100 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li><li>下一个版本的列name 的内容是’关羽’ ，该版本的trx_id 值也为100 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’刘备’ ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为’刘备’ 的记录。</li></ul><p>之后，我们把事务id 为100 的事务提交一下，就像这样：</p><pre><code class="language-sql"># Transaction 100BEGIN;UPDATE hero SET name = '关羽' WHERE number = 1;UPDATE hero SET name = '张飞' WHERE number = 1;COMMIT;</code></pre><p>然后再到事务id 为200 的事务中更新一下表hero 中number 为1 的记录：</p><pre><code class="language-sql"># Transaction 200BEGIN;# 更新了一些别的表的记录...UPDATE hero SET name = '赵云' WHERE number = 1;UPDATE hero SET name = '诸葛亮' WHERE number = 1;</code></pre><p>此刻，表hero 中number 为1 的记录的版本链就长这样：</p><p><img src="/attachment/cee859da72faeb6e3b31c814e8f10bdc.png" alt=""></p><p>然后再到刚才使用REPEATABLE READ 隔离级别的事务中继续查找这个number 为1 的记录，如下：</p><pre><code class="language-sql"># 使用REPEATABLE READ隔离级别的事务BEGIN;# SELECT1：Transaction 100、200均未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'# SELECT2：Transaction 100提交，Transaction 200未提交SELECT * FROM hero WHERE number = 1; # 得到的列name的值仍为'刘备'</code></pre><p>这个SELECT2 的执行过程如下：</p><ul><li>因为当前事务的隔离级别为REPEATABLE READ ，而之前在执行SELECT1 时已经生成过ReadView 了，所以此时直接复用之前的ReadView ，之前的ReadView 的m_ids 列表的内容就是[100, 200] ， min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’诸葛亮’ ，该版本的trx_id 值为200 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li><li>下一个版本的列name 的内容是’赵云’ ，该版本的trx_id 值为200 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’张飞’ ，该版本的trx_id 值为100 ，而m_ids 列表中是包含值为100 的事务id 的，所以该版本也不符合要求，同理下一个列name 的内容是’关羽’ 的版本也不符合要求。继续跳到下一个版本。</li><li>下一个版本的列name 的内容是’刘备’ ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值 100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c 为’刘备’ 的记录。</li></ul><p>也就是说两次SELECT 查询得到的结果是重复的，记录的列c 值都是’刘备’ ，这就是可重复读的含义。如果我们之后再把事务id 为200 的记录提交了，然后再到刚才使用REPEATABLE READ 隔离级别的事务中继续查找这个number 为1 的记录，得到的结果还是’刘备’ ，具体执行过程大家可以自己分析一下。</p><h3 id="MVCC小结">MVCC小结</h3><p>所谓的MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD 、REPEATABLE READ 这两种隔离级别的事务在执行普通的SEELCT 操作时访问记录的版本链的过程</p><p>这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同就是：</p><p><strong>生成ReadView的时机不同</strong>，</p><ul><li>READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，</li><li>而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul><h3 id="关于purge">关于purge</h3><p>我们说insert undo 在事务提交之后就可以被释放掉了，而update undo 由于还需要支持MVCC ，不能立即删除掉。<br>为了支持MVCC ，对于delete mark 操作来说，仅仅是在记录上打一个删除标记，并没有真正将它删除掉。</p><p>随着系统的运行，在确定系统中包含最早产生的那个ReadView 的事务不会再访问某些update undo日志以及被打了删除标记的记录后，有一个后台运行的<strong>purge线程</strong>会把它们真正的删除掉。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 日志 - undo</title>
      <link href="/database/mysql/mysql-ri-zhi-undo/"/>
      <url>/database/mysql/mysql-ri-zhi-undo/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 日志 - undo</h1><h2 id="Metadata-22">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 日志 - undodate: 2023-06-25 16:14tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 日志 - undo</code></pre><h2 id="概述-17">概述</h2><p><strong>回滚</strong>是指将已经提交的事务撤销，恢复到事务开始之前的状态。保证数据的一致性和完整性。<br><strong>把回滚时所需的东西都给记下来</strong><br>把这些为了回滚而记录的这些东东称之为撤销日志，英文名为undo log</p><p><strong>事务id</strong><br>如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB 存储引擎就会给它分配一个独一无二的事务id<br>在内存中维护一个全局变量，每当需要为某个事务分配一个事务id 时，就会把该变量的值当作事务id 分配给该事务，并且把该变量自增1。<br><strong>trx_id隐藏列</strong></p><p><strong>roll pointer隐藏列的含义</strong></p><p>本质上就是一个指向记录对应的undo日志的一个指针。</p><p><img src="/attachment/dca520e076cde66ce47fe2ae73824f33.png" alt=""></p><p><strong>undo日志的格式</strong></p><ul><li>INSERT操作对应的undo日志<ul><li>写对应的undo 日志时，主要是把这条记录的主键信息记上。<br><img src="/attachment/1ada3449637039388de5c57e0fa1644b.png" alt=""></li></ul></li><li>DELETE操作对应的undo日志<ul><li>被删除的记录其实也会根据记录头信息中的next_record 属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为垃圾链表。<br><img src="/attachment/06169958235dfb6a4b4ac6c00cbc8507.png" alt=""></li></ul></li><li>UPDATE操作对应的undo日志<ul><li>不更新主键的情况   — 更新后的列和更新前的列占用的存储空间<ul><li>就地更新（in-place update）</li><li>先删除掉旧记录，再插入新记录</li></ul></li><li>更新主键的情况<ul><li>将旧记录进行delete mark 操作</li><li>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。</li></ul></li></ul></li></ul><p><strong>FIL_PAGE_UNDO_LOG页面</strong></p><p><img src="/attachment/dbddb08e41e8e92e4a7f98f1bb2f3a8f.png" alt=""></p><p><strong>Undo页面链表</strong></p><p><img src="/attachment/4e06859c7c633b8ed617fd3e56517015.png" alt=""></p><p><strong>undo日志具体写入过程</strong></p><p>每一个Undo页面链表都对应着一个段，称之为Undo Log Segment 。<br><img src="/attachment/fc15ca718a01e53181cd23b1cdcd6c6f.png" alt=""></p><p><strong>为事务分配Undo页面链表详细过程</strong></p><ol><li>回滚段分配：</li></ol><ul><li>在事务对普通表的记录进行改动之前，会先从系统表空间的第5号页面中分配一个回滚段。</li><li>一旦某个回滚段被分配给了事务，后续对普通表的记录改动不会重复分配。</li></ul><ol start="2"><li>回滚段分配方式：</li></ol><ul><li>使用循环方式（round-robin）分配回滚段，依次分配给不同的事务。</li></ul><ol start="3"><li>缓存的undo slot：</li></ol><ul><li>分配到回滚段后，会检查回滚段的缓存链表中是否有已经缓存的undo slot。</li><li>根据操作类型（如INSERT或DELETE）选择相应的缓存链表进行查找。</li><li>如果存在缓存的undo slot，则将其分配给当前事务。</li><li>如果没有可用的缓存undo slot，则在Rollback Segment Header页面中查找可用的undo slot。</li></ul><ol start="4"><li>分配可用的undo slot：</li></ol><ul><li>从Rollback Segment Header页面中开始查找可用的undo slot。</li><li>从第0个undo slot开始，如果其值为FIL_NULL，则表示该undo slot为空闲，将其分配给当前事务。</li><li>如果第0个undo slot不满足条件，则继续查找下一个undo slot，直到找到可用的undo slot。</li><li>如果所有的1024个undo slot都不为空闲，则报错。</li></ul><ol start="5"><li>Undo Log Segment和Undo页面链表：</li></ol><ul><li>如果分配到的undo slot是从缓存链表中获取的，那么对应的Undo Log Segment已经分配。</li><li>否则，需要重新分配一个Undo Log Segment，并从该Undo Log Segment中申请一个页面作为Undo页面链表的第一个页面。</li></ul><ol start="6"><li>写入Undo日志：</li></ol><ul><li>事务可以将undo日志写入先前申请的Undo页面链表中。</li></ul><h2 id="事务回滚的需求">事务回滚的需求</h2><p>出现问题</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入ROLLBACK 语句结束当前的事务的执行。</li></ul><p><strong>回滚</strong>是指将已经提交的事务撤销，恢复到事务开始之前的状态。保证数据的一致性和完整性。</p><p><strong>把回滚时所需的东西都给记下来</strong></p><p>把这些为了回滚而记录的这些东东称之为撤销日志，英文名为undo log</p><p>由于查询操作（ SELECT ）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</p><h2 id="事务id">事务id</h2><h3 id="给事务分配id的时机">给事务分配id的时机</h3><p>如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB 存储引擎就会给它分配一个独一无二的事务id</p><p>分配方式如下</p><ul><li>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id ，否则的话是不分配事务id 的。</li><li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id ，否则的话也是不分配事务id 的。</li></ul><h3 id="事务id是怎么生成的">事务id是怎么生成的</h3><p>这个事务id 本质上就是一个数字，它的分配策略和我们前边提到的对隐藏列row_id （当用户没有为表创建主键 和UNIQUE 键时InnoDB 自动创建的列）的分配策略大抵相同，具体策略如下：</p><ul><li>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务id 时，就会把该变量的值当作事务id 分配给该事务，并且把该变量自增1。</li><li>每当这个变量的值为256 的倍数时，就会将该变量的值刷新到系统表空间的页号为5 的页面中一个称之为Max Trx ID 的属性处，这个属性占用8 个字节的存储空间。</li><li>当系统下一次重新启动时，会将上边提到的Max Trx ID 属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于Max Trx ID 属性值）。</li></ul><p>这样就可以保证整个系统中分配的事务id 值是一个递增的数字。先被分配id 的事务得到的是较小的事务id ，后被分配id 的事务得到的是较大的事务id 。</p><h3 id="trx-id隐藏列">trx_id隐藏列</h3><p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列。</p><p><img src="/attachment/30cfac561c89751ffeed249c4ac4bad3.png" alt=""></p><h2 id="undo日志的格式">undo日志的格式</h2><p>为了实现事务的原子性，<br>InnoDB 存储引擎在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。<br>一般每对一条记录做一次改动，就对应着一条undo日志，但在某些更新记录的操作中，也可能会对应着2 条undo日志</p><h3 id="INSERT操作对应的undo日志">INSERT操作对应的undo日志</h3><p>插入的结果就是这条记录被放到了一个数据页中。<br>如果希望回滚这个插入操作，那么把这条记录删除就好了，也就是说在写对应的undo 日志时，主要是把这条记录的主键信息记上。</p><p>设计了一个类型为 TRX_UNDO_INSERT_REC 的undo日志</p><p><img src="/attachment/1ada3449637039388de5c57e0fa1644b.png" alt=""></p><ul><li>undo no 在一个事务中是从0 开始递增的，也就是说只要事务没提交，每生成一条undo日志，那么该条日志的undo no 就增1。</li><li>如果记录中的主键只包含一个列，那么在类型为TRX_UNDO_INSERT_REC 的undo日志中只需要把该列占用的存储空间大小和真实值记录下来，如果记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的len 就代表列占用的存储空间大小， value 就代表列的真实值）。</li></ul><pre><code class="language-ad-tip">当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。不过记录undo日志时，我们只需要考虑向**聚簇索引**插入记录时的情况就好了，因为其实聚簇索引记录和二级索引记录是一一对应的，我们在回滚插入操作时，只需要知道这条记录的主键信息，然后**根据主键信息做对应的删除操作**，做删除操作时就会顺带着把所有二级索引中相应的记录也删除掉。后边说到的DELETE操作和UPDATE操作对应的undo日志也都是针对聚簇索引记录而言的，我们之后就不强调了。</code></pre><pre><code class="language-ad-tip">为了最大限度的节省undo日志占用的存储空间，和我们前边说过的redo日志类似，设计InnoDB的大叔会给undo日志中的某些属性进行压缩处理，具体的压缩细节我们就不唠叨了。</code></pre><pre><code class="language-ad-example">title: 示例```sql# 插入两条记录INSERT INTO undo_demo(id, key1, col)VALUES (1, 'AWM', '狙击枪'), (2, 'M416', '步枪');```第一条undo日志的undo no 为0 ，记录主键占用的存储空间长度为4 ，真实值为1 。画一个示意图就是这样：![](attachment/4474a5bc4274ae85d9515a24d16f5ee3.png)第二条undo日志的undo no 为1 ，记录主键占用的存储空间长度为4 ，真实值为2 。画一个示意图就是这样（与第一条undo日志对比， undo no 和主键各列信息有不同）：![](attachment/7d2d541d16f1ebdfd7310249c8d70fa7.png)</code></pre><h4 id="roll-pointer隐藏列的含义">roll pointer隐藏列的含义</h4><p>本质上就是一个指向记录对应的undo日志的一个指针。</p><p><img src="/attachment/dca520e076cde66ce47fe2ae73824f33.png" alt=""></p><p>roll_pointer 本质就是一个指针，指向记录对应的undo日志。</p><h3 id="DELETE操作对应的undo日志">DELETE操作对应的undo日志</h3><p>插入到页面中的记录会根据记录头信息中的next_record 属性组成一个单向链表，我们把这个链表称之为正常记录链表</p><p>被删除的记录其实也会根据记录头信息中的next_record 属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为垃圾链表。</p><p><strong>假设此刻某个页面中的记录分布情况是这样的</strong></p><p><img src="/attachment/8447c9f1e11276338034c8f58b777e16.png" alt=""></p><p>页面的Page Header 部分的PAGE_FREE 属性的值代表指向垃圾链表头节点的指针。</p><p>假设现在我们准备使用DELETE 语句把正常记录链表中的最后一条记录给删除掉，其实这个删除的过程需要经历两个阶段：</p><p>阶段一：仅仅将记录的delete_mask 标识位设置为1 ，其他的不做修改（其实会修改记录的trx_id 、roll_pointer 这些隐藏列的值）。设计InnoDB 的大叔把这个阶段称之为delete mark 。</p><p><img src="/attachment/1482eea1a3c45b7dc02bffc72502aab3.png" alt=""></p><p>正常记录链表中的最后一条记录的delete_mask值被设置为1，但是并没有被加入到垃圾链表。也就是此时记录处于一个中间状态</p><p>阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。</p><p>所谓真正的删除就是<strong>把该记录从正常记录链表中移除，并且加入到垃圾链表中，然后还要调整一些页面的其他信息</strong>，比如页面中的用户记录数量PAGE_N_RECS 、上次插入记录的位置PAGE_LAST_INSERT 、垃圾链表头节点的指针PAGE_FREE 、页面中可重用的字节数量PAGE_GARBAGE 、还有页目录的一些信息等等。设计InnoDB 的大叔把这个阶段称之为<strong>purge</strong> 。</p><p><img src="/attachment/72485d4f6abd41a83f5a19aa460e454d.png" alt=""></p><p><img src="/attachment/06169958235dfb6a4b4ac6c00cbc8507.png" alt=""></p><p>在删除语句所在的事务提交之前，只会经历阶段一，也就是delete mark 阶段（提交之后我们就不用回滚了，所以只需考虑对删除操作的阶段一做的影响进行回滚）。</p><p>注意一下这几点：</p><ul><li>在对一条记录进行delete mark 操作前，需要把该记录的旧的trx_id 和roll_pointer 隐藏列的值都给记到对应的undo日志中来，就是我们图中显示的old trx_id 和old roll_pointer 属性。<br>这样有一个好处，那就是可以通过undo日志的old roll_pointer 找到记录在修改之前对应的undo 日志。比方说在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作，这个过程的示意图就是这样：</li></ul><p><img src="/attachment/75cb3575b78b1274b8f7588af08d3c61.png" alt=""></p><p>undo 日志串成了一个链表。这个链表就称之为<strong>版本链</strong></p><ul><li>与类型为TRX_UNDO_INSERT_REC 的undo日志不同，类型为TRX_UNDO_DEL_MARK_REC 的undo 日志还多了一个索引列各列信息的内容<br>如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到这个索引列各列信息部分<br>所谓的相关信息包括该列在记录中的位置（用pos 表示），该列占用的存储空间大小（用len 表示），该列实际值（用value 表示）。</li></ul><pre><code class="language-ad-example">title: 示例```sqlBEGIN; # 显式开启一个事务，假设该事务的id为100# 插入两条记录INSERT INTO undo_demo(id, key1, col)VALUES (1, 'AWM', '狙击枪'), (2, 'M416', '步枪');# 删除一条记录DELETE FROM undo_demo WHERE id = 1;```![](attachment/6a23f0b932bd9d7a43cc8261dae304f3.png)</code></pre><h3 id="UPDATE操作对应的undo日志">UPDATE操作对应的undo日志</h3><p>在执行UPDATE 语句时， InnoDB 对更新主键和不更新主键这两种情况有截然不同的处理方案。</p><h4 id="不更新主键的情况">不更新主键的情况</h4><ul><li>就地更新（in-place update）</li></ul><p>更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行就地更新： 直接在原记录的基础上修改对应列的值</p><ul><li>先删除掉旧记录，再插入新记录</li></ul><p>如果有<strong>任何</strong>一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。</p><p>删除并不是delete mark 操作，而是<strong>真正</strong>的删除掉，也就是把这条记录从正常记录链表中移除并加入到垃圾链表中，并且修改页面中相应的统计信息（比如PAGE_FREE 、PAGE_GARBAGE 等这些信息）</p><p>设计了一种类型为TRX_UNDO_UPD_EXIST_REC 的undo日志</p><p>它的完整结构如下：</p><p><img src="/attachment/697ff0ee0dc43b8dc4102d3066b362e1.png" alt=""></p><p>注意这么几点：</p><ul><li>n_updated 属性表示本条UPDATE 语句执行后将有几个列被更新，后边跟着的&lt;pos, old_len, old_value&gt; 分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。</li><li>如果在UPDATE 语句中更新的列包含索引列，那么也会添加索引列各列信息这个部分，否则的话是不会添加这个部分的。</li></ul><pre><code class="language-ad-example">title: 示例```sqlBEGIN; # 显式开启一个事务，假设该事务的id为100# 插入两条记录INSERT INTO undo_demo(id, key1, col)VALUES (1, 'AWM', '狙击枪'), (2, 'M416', '步枪');# 删除一条记录DELETE FROM undo_demo WHERE id = 1;# 更新一条记录UPDATE undo_demoSET key1 = 'M249', col = '机枪'WHERE id = 2;```![](attachment/a8c6721ce95c69c055ec30a6ff22878d.png)</code></pre><h4 id="更新主键的情况">更新主键的情况</h4><ul><li>将旧记录进行delete mark 操作</li></ul><p>在UPDATE 语句所在的事务提交前，对旧记录只做一个delete mark 操作<br>在事务提交后才由专门的线程做purge操作，把它加入到垃圾链表中。</p><ul><li>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。<br>由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。</li></ul><h2 id="通用链表结构">通用链表结构</h2><p>在写入undo日志的过程中会使用到多个链表，很多链表都有同样的节点结构<br><img src="/attachment/1d51ddc012e93d621b948614da9e0e84.png" alt=""></p><ul><li>Pre Node Page Number 和Pre Node Offset 的组合就是指向前一个节点的指针</li><li>Next Node Page Number 和Next Node Offset 的组合就是指向后一个节点的指针。</li></ul><p>整个List Node 占用12 个字节的存储空间。</p><p>为了更好的管理链表，设计InnoDB 的大叔还提出了一个<strong>基节点</strong>的结构，里边存储了这个链表的头节点、尾节点以及链表长度信息，基节点的结构示意图如下：</p><p><img src="/attachment/bd6c7c3185930138b1a278c90e1b4623.png" alt=""></p><p>其中：</p><ul><li>List Length 表明该链表一共有多少节点。</li><li>First Node Page Number 和First Node Offset 的组合就是指向链表头节点的指针。</li><li>Last Node Page Number 和Last Node Offset 的组合就是指向链表尾节点的指针。</li></ul><p>整个List Base Node 占用16 个字节的存储空间。</p><p>undefined</p><h2 id="FIL-PAGE-UNDO-LOG页面">FIL_PAGE_UNDO_LOG页面</h2><p>表空间其实是由许许多多的页面构成的. 专门用来存储undo日志的, 称之为FIL_PAGE_UNDO_LOG 类型的</p><p><img src="/attachment/dbddb08e41e8e92e4a7f98f1bb2f3a8f.png" alt=""></p><p>Undo Page Header 是Undo页面所特有的</p><p><img src="/attachment/a1b1085573cca29947e1caab8380b967.png" alt=""></p><ul><li>TRX_UNDO_PAGE_TYPE ：本页面准备存储什么种类的undo日志。<ul><li>TRX_UNDO_INSERT （使用十进制1 表示）：类型为TRX_UNDO_INSERT_REC 的undo日志属于此大类，一般由INSERT 语句产生，或者在UPDATE 语句中有更新主键的情况也会产生此类型的undo日志。</li><li>TRX_UNDO_UPDATE （使用十进制2 表示）：除了类型为TRX_UNDO_INSERT_REC 的undo日志，其他类型的undo日志都属于这个大类，比如我们前边说的TRX_UNDO_DEL_MARK_REC 、TRX_UNDO_UPD_EXIST_REC 啥的，一般由DELETE 、UPDATE 语句产生的undo日志属于这个大类。</li></ul></li><li>TRX_UNDO_PAGE_START ：表示在当前页面中是从什么位置开始存储undo日志的，或者说表示第一条undo日志在本页面中的起始偏移量。</li><li>TRX_UNDO_PAGE_FREE ：与上边的TRX_UNDO_PAGE_START 对应，表示当前页面中存储的最后一条undo 日志结束时的偏移量，或者说从这个位置开始，可以继续写入新的undo日志。</li><li>TRX_UNDO_PAGE_NODE： 代表一个List Node 结构</li></ul><h2 id="Undo页面链表">Undo页面链表</h2><h3 id="单个事务中的Undo页面链表">单个事务中的Undo页面链表</h3><p>每条记录进行改动前，都需要记录1条或2条的undo日志，所以在一个事务执行过程中可能产生很多undo日志，这些日志可能一个页面放不下，需要放到多个页面中，这些页面就通过我们上边介绍的TRX_UNDO_PAGE_NODE 属性连成了链表：</p><p><img src="/attachment/7d2fffea050cebeec50bb194f5224f74.png" alt=""></p><p>大家往上再瞅一瞅上边的图，我们特意把链表中的第一个Undo页面给标了出来，称它为first undo page ，其余的Undo页面称之为normal undo page ，这是因为在first undo page 中除了记录Undo Page Header 之外，还会记录其他的一些管理信息，这个我们稍后再说哈。</p><p>在一个事务执行过程中，可能混着执行INSERT 、DELETE 、UPDATE 语句，也就意味着会产生不同类型的undo日志。<br>同一个Undo页面要么只存储TRX_UNDO_INSERT 大类的undo日志，要么只存储 TRX_UNDO_UPDATE 大类的undo日志<br>在一个事务执行过程中就可能需要2个Undo页面的链表，一个称之为insert undo链表，另一个称之为update undo链表，</p><p><img src="/attachment/a6ba0236eed051a8a857f1455daaa207.png" alt=""></p><p>另外，设计InnoDB 的大叔规定对普通表和临时表的记录改动时产生的undo日志要分别记录，所以在一个事务中最多有4个以Undo页面为节点组成的链表：</p><p><img src="/attachment/4e06859c7c633b8ed617fd3e56517015.png" alt=""></p><p>并不是在事务一开始就会为这个事务分配这4个链表，具体分配策略如下：</p><ul><li>刚刚开启事务时，一个Undo页面链表也不分配。</li><li>当事务执行过程中向普通表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个普通表的insert undo链表。</li><li>当事务执行过程中删除或者更新了普通表中的记录之后，就会为其分配一个普通表的update undo链表。</li><li>当事务执行过程中向临时表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个临时表的insert undo链表。</li><li>当事务执行过程中删除或者更新了临时表中的记录之后，就会为其分配一个临时表的update undo链表。</li></ul><p>总结: <strong>按需分配，啥时候需要啥时候再分配，不需要就不分配。</strong></p><h3 id="多个事务中的Undo页面链表">多个事务中的Undo页面链表</h3><p>不同事务执行过程中产生的undo日志需要被写入到不同的Undo页面链表中</p><h2 id="undo日志具体写入过程">undo日志具体写入过程</h2><h3 id="段（Segment）的概念">段（Segment）的概念</h3><p><img src="/attachment/9b951adb2a230815bbb6335b622dbf36.png" alt=""></p><p>整个Segment Header 占用10个字节大小，各个属性的意思如下：</p><ul><li>Space ID of the INODE Entry ： INODE Entry 结构所在的表空间ID。</li><li>Page Number of the INODE Entry ： INODE Entry 结构所在的页面页号。</li><li>Byte Offset of the INODE Ent ： INODE Entry 结构在该页面中的偏移量</li></ul><h3 id="Undo-Log-Segment-Header">Undo Log Segment Header</h3><p>每一个Undo页面链表都对应着一个段，称之为Undo Log Segment 。</p><p><img src="/attachment/50f58981009c4f5d0f1c5e115800e148.png" alt=""></p><p>可以看到这个Undo 链表的第一个页面比普通页面多了个Undo Log Segment Header</p><p><img src="/attachment/0f60c1bad451360ffc1d5c08857a0109.png" alt=""></p><ul><li>TRX_UNDO_STATE ：本Undo页面链表处在什么状态。<ul><li>一个Undo Log Segment 可能处在的状态包括：</li><li>TRX_UNDO_ACTIVE ：活跃状态，也就是一个活跃的事务正在往这个段里边写入undo日志。</li><li>TRX_UNDO_CACHED ：被缓存的状态。处在该状态的Undo页面链表等待着之后被其他事务重用。</li><li>TRX_UNDO_TO_FREE ：对于insert undo 链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li><li>TRX_UNDO_TO_PURGE ：对于update undo 链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li><li>TRX_UNDO_PREPARED ：包含处于PREPARE 阶段的事务产生的undo日志。</li></ul></li><li>TRX_UNDO_LAST_LOG ：本Undo页面链表中最后一个Undo Log Header 的位置。</li><li>TRX_UNDO_FSEG_HEADER ：本Undo页面链表对应的段的Segment Header 信息（就是我们上一节介绍的那个10字节结构，通过这个信息可以找到该段对应的INODE Entry ）。</li><li>TRX_UNDO_PAGE_LIST ： Undo页面链表的基节点。</li></ul><h3 id="Undo-Log-Header">Undo Log Header</h3><p>同一个事务向一个Undo页面链表中写入的undo日志算是一个组</p><p>设计InnoDB 的大叔把存储这些属性的地方称之为Undo Log Header</p><p>所以Undo页面链表的第一个页面在真正写入undo日志前，其实都会被填充Undo Page Header 、Undo Log Segment Header 、Undo Log Header 这3个部分</p><p><img src="/attachment/78ae7b294f300af8914dfd9612bd9793.png" alt=""></p><p>Undo Log Header 具体的结构如下：</p><p><img src="/attachment/548a5d90c71252a091facf45c0f764e0.png" alt=""></p><ul><li>TRX_UNDO_TRX_ID ：生成本组undo日志的事务id 。</li><li>TRX_UNDO_TRX_NO ：事务提交后生成的一个需要序号，使用此序号来标记事务的提交顺序（先提交的此序号小，后提交的此序号大）。</li><li>TRX_UNDO_DEL_MARKS ：标记本组undo 日志中是否包含由于Delete mark 操作产生的undo日志。</li><li>TRX_UNDO_LOG_START ：表示本组undo 日志中第一条undo日志的在页面中的偏移量。</li><li>TRX_UNDO_XID_EXISTS ：本组undo日志是否包含XID信息。</li><li>TRX_UNDO_DICT_TRANS ：标记本组undo日志是不是由DDL语句产生的。</li><li>TRX_UNDO_TABLE_ID ：如果TRX_UNDO_DICT_TRANS 为真，那么本属性表示DDL语句操作的表的table id 。</li><li>TRX_UNDO_NEXT_LOG ：下一组的undo日志在页面中开始的偏移量。</li><li>TRX_UNDO_PREV_LOG ：上一组的undo日志在页面中开始的偏移量。</li><li>TRX_UNDO_HISTORY_NODE ：一个12字节的List Node 结构，代表一个称之为History 链表的节点。</li></ul><h3 id="小结">小结</h3><p>对于没有被重用的Undo页面链表来说，链表的第一个页面，也就是first undo page 在真正写入undo日志前，会填充Undo Page Header 、Undo Log Segment Header 、Undo Log Header 这3个部分，之后才开始正式写入undo日志。</p><p>normal undo page 在真正写入undo日志前，只会填充Undo Page Header 。</p><p>链表的List Base Node 存放到first undo page 的Undo Log Segment Header 部分， List Node 信息存放到每一个Undo页面的undo Page Header 部分</p><p><img src="/attachment/fc15ca718a01e53181cd23b1cdcd6c6f.png" alt=""></p><h2 id="重用Undo页面">重用Undo页面</h2><p>为每个事务单独分配相应的Undo页面链表（最多可能单独分配4个链表）</p><p>在事务提交后在某些情况下重用该事务的Undo页面链表。一个Undo页面链表是否可以被重用的条件很简单：</p><ul><li>该链表中只包含一个Undo页面。</li></ul><p>只有在Undo页面链表中只包含一个Undo 页面时，该链表才可以被下一个事务所重用。</p><ul><li>该Undo页面已经使用的空间小于整个页面空间的3/4。</li></ul><h2 id="回滚段">回滚段</h2><h3 id="回滚段的概念">回滚段的概念</h3><p>在这个页面中存放了各个Undo页面链表的frist undo page 的页号，他们把这些页号称之为undo slot 。</p><pre><code class="language-ad-tip">title: 理解每个Undo页面链表都相当于是一个班，这个链表的first undo page 就相当于这个班的班长，找到了这个班的班长，就可以找到班里的其他同学（其他同学相当于normal undo page ）。有时候学校需要向这些班级传达一下精神，就需要把班长都召集在会议室，这个Rollback Segment Header 就相当于是一个会议室。</code></pre><p><img src="/attachment/a6a8df0602a2be0d8f1f149bd715ca13.png" alt=""></p><p>每一个Rollback Segment Header 页面都对应着一个段，这个段就称为Rollback Segment ，翻译过来就是回滚段。</p><p>Rollback Segment Header 的页面的各个部分的含义都是啥意思：</p><ul><li>TRX_RSEG_MAX_SIZE ：本Rollback Segment 中管理的所有Undo页面链表中的Undo页面数量之和的最大值。</li><li>TRX_RSEG_HISTORY_SIZE ： History 链表占用的页面数量。</li><li>TRX_RSEG_HISTORY ： History 链表的基节点。</li><li>TRX_RSEG_FSEG_HEADER ：本Rollback Segment 对应的10字节大小的Segment Header 结构，通过它可以找到本段对应的INODE Entry 。</li><li>TRX_RSEG_UNDO_SLOTS ：各个Undo页面链表的first undo page 的页号集合，也就是undo slot 集合。</li></ul><h3 id="从回滚段中申请Undo页面链表">从回滚段中申请Undo页面链表</h3><h3 id="多个回滚段">多个回滚段</h3><p>不同的回滚段可能分布在不同的表空间中</p><p><img src="/attachment/510d1aa73ece25d1f2766fa5a840bf0c.png" alt=""></p><h3 id="回滚段的分类">回滚段的分类</h3><p>针对普通表和临时表划分不同种类的回滚段的原因：在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。</p><h3 id="为事务分配Undo页面链表详细过程">为事务分配Undo页面链表详细过程</h3><ul><li>事务在执行过程中对普通表的记录首次做改动之前，首先会到系统表空间的第5 号页面中<strong>分配一个回滚段</strong>（其实就是获取一个Rollback Segment Header 页面的地址）。一旦<strong>某个回滚段被分配给了这个事务</strong>，那么之后该事务中再对普通表的记录做改动时，就<strong>不会重复分配</strong>了。</li><li>使用传说中的<strong>round-robin （循环使用）方式来分配回滚段</strong>。比如当前事务分配了第0 号回滚段，那么下一个事务就要分配第33 号回滚段，下下个事务就要分配第34 号回滚段，简单一点的说就是<strong>这些回滚段被轮着分配给不同的事务</strong>（就是这么简单粗暴，没啥好说的）。</li><li>在分配到回滚段后，首先看一下这个回滚段的两个cached链表<strong>有没有已经缓存了的undo slot</strong> ，比如如果事务做的是INSERT 操作，就去回滚段对应的insert undo cached链表中看看有没有缓存的undo slot ；如果事务做的是DELETE 操作，就去回滚段对应的update undo cached链表中看看有没有缓存的undo slot 。如果<strong>有缓存</strong>的undo slot ，那么就把<strong>这个缓存的undo slot 分配给该事务</strong>。如果<strong>没有缓存</strong>的undo slot 可供分配，那么就要到<strong>Rollback Segment Header</strong> 页面中<strong>找一个可用的undo slot 分配给当前事务</strong>。<ul><li>从Rollback Segment Header 页面中分配可用的undo slot 的方式我们上边也说过了，就是从第0 个undoslot 开始，如果该undo slot 的值为FIL_NULL ，意味着这个undo slot 是空闲的，就把这个undo slot分配给当前事务，否则查看第1 个undo slot 是否满足条件，依次类推，直到最后一个undo slot 。如果这1024 个undo slot 都没有值为FIL_NULL 的情况，就直接报错喽（一般不会出现这种情况）～</li></ul></li><li>找到可用的undo slot 后，如果该undo slot 是<strong>从cached链表中获取</strong>的，那么它对应的Undo LogSegment 已经分配了，否则的话需要重新分配一个<strong>Undo Log Segment</strong> ，然后从该Undo Log Segment 中<strong>申请一个页面</strong>作为Undo页面链表的<strong>first undo page</strong> 。</li><li>然后事务就可以把undo日志写入到上边申请的Undo页面链表了！</li></ul><p>对临时表的记录做改动的步骤和上述的一样，就不赘述了。</p><p>不错需要再次强调一次，如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配<strong>2个回滚段</strong>。并发执行的不同事务其实也可以被分配相同的回滚段，只要<strong>分配不同的undoslot</strong>就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 日志 - redo</title>
      <link href="/database/mysql/mysql-ri-zhi-redo/"/>
      <url>/database/mysql/mysql-ri-zhi-redo/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 日志 - redo</h1><h2 id="Metadata-20">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 日志 - redodate: 2023-06-25 10:13tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。</code></pre><h2 id="概述-15">概述</h2><ul><li>redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。</li><li>redo日志的主要功能是<strong>保证数据库的持久性和恢复能力</strong>。</li><li>redo 日志本质上只是记录了一下<strong>事务对数据库做了哪些修改</strong>, 在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。<ul><li>type ：该条redo 日志的类型。</li><li>space ID ：表空间ID。</li><li>page number ：页号。</li><li>data ：该条redo 日志的具体内容。</li></ul></li></ul><p><img src="/attachment/95d39a797c7e8abe375c63e8bf4c9052.png" alt=""></p><ul><li>Mini-Transaction<ul><li>对底层页面中的一次原子访问的过程称之为一个Mini-Transaction ，简称mtr。</li><li>以组的形式写入redo日志 —  <strong>原子</strong></li><li>修改一次Max Row ID 的值算是一个Mini-Transaction</li><li>向某个索引对应的B+ 树中插入一条记录的过程也算是一个Mini-Transaction</li></ul></li></ul><p><img src="/attachment/9dc564aab6d3f1055f5b09bf9a4eebac.png" alt=""></p><ul><li><p>redo日志的写入过程</p><ul><li>redo log block<br><img src="/attachment/1d05f86aacee59136739ffecdf347977.png" alt=""></li><li>redo日志缓冲区<ul><li>redo日志写入log buffer<ul><li><strong>buf_free</strong> 的全局变量，该变量指明后续写入的redo 日志应该写入到log buffer 中的哪个位置</li></ul></li></ul></li></ul></li><li><p>redo日志文件</p><ul><li>redo日志刷盘时机<ul><li>log buffer 空间不足时</li><li>事务提交时</li><li>后台线程不停的刷刷刷<ul><li>后台有一个线程，大约每秒都会刷新一次log buffer 中的redo 日志到磁盘。</li></ul></li><li>正常关闭服务器时</li><li>做所谓的checkpoint 时（我们现在没介绍过checkpoint 的概念，稍后会仔细唠叨，稍安勿躁）</li><li>其他的一些情况…</li></ul></li><li>redo日志文件格式<br><img src="/attachment/8e93c10b72701ec5752a42211bd479d4.png" alt=""></li></ul></li><li><p>Log Sequeue Number</p><ul><li>为记录已经写入的redo 日志量，设计了一个称之为Log Sequeue Number 的全局变量，日志序列号, 简称LSN</li><li>buf_next_to_write 标记当前log buffer 中已经有哪些日志被刷新到磁盘中了</li><li>flushed_to_disk_lsn   刷新到磁盘中的redo 日志量的全局变量</li><li>flush链表按照oldest_modification代表的LSN值进行排序</li><li>flush链表中的LSN<br><img src="/attachment/57704071c7325804ba415757ddcb41f6.png" alt=""></li></ul></li><li><p>checkpoint</p><ul><li><strong>判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。</strong></li><li>做一次checkpoint其实可以分为两个步骤：<ul><li>步骤一：计算一下当前系统中可以被覆盖的redo 日志对应的lsn 值最大是多少。<ul><li>凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的</li><li>把该脏页的oldest_modification 赋值给checkpoint_lsn 。</li></ul></li><li>步骤二：将checkpoint_lsn 和对应的redo 日志文件组偏移量以及此次checkpint 的编号写到日志文件的管理信息（就是checkpoint1 或者checkpoint2 ）中。</li></ul></li></ul></li><li><p>崩溃恢复</p><ul><li>确定恢复的起点</li><li>确定恢复的终点</li></ul></li></ul><h2 id="redo日志">redo日志</h2><p>redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。</p><p>redo日志的主要功能是<strong>保证数据库的持久性和恢复能力</strong>。当事务进行修改数据库的操作时，redo日志会记录这些操作的详细信息，包括修改的数据、修改前后的值等。通过redo日志，可以将事务的操作重新应用到数据库中，以实现事务的持久性。</p><h3 id="redo日志的特点如下：">redo日志的特点如下：</h3><ul><li><strong>占用空间小</strong>: 存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间</li><li><strong>顺序记录</strong>：redo日志以顺序的方式记录事务的操作，而不是随机记录。这样可以提高日志的写入效率。</li><li><strong>非持久性</strong>：redo日志不需要永久保存在磁盘上，只需要在事务执行过程中保持在内存中和写入磁盘的缓冲区中。只有当事务提交后，才会将redo日志写入磁盘进行持久化保存。</li><li><strong>循环利用</strong>：当redo日志写满时，可以将最旧的日志覆盖掉，从而实现循环利用。这样可以节省存储空间，并保证日志文件的大小不会无限增长。</li></ul><h2 id="redo日志格式">redo日志格式</h2><p>redo 日志本质上只是记录了一下<strong>事务对数据库做了哪些修改</strong></p><p><img src="/attachment/95d39a797c7e8abe375c63e8bf4c9052.png" alt=""></p><p>各个部分的详细释义如下：</p><ul><li>type ：该条redo 日志的类型。</li><li>space ID ：表空间ID。</li><li>page number ：页号。</li><li>data ：该条redo 日志的具体内容。</li></ul><h3 id="简单的redo日志类型">简单的redo日志类型</h3><p>对页面的修改是极其简单的， redo 日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了，设计InnoDB 的大叔把这种极其简单的redo 日志称之为<strong>物理日志</strong></p><p>根据在页面中写入数据的多少划分了几种不同的redo 日志类型：</p><ul><li>MLOG_1BYTE （ type 字段对应的十进制数字为1 ）：表示在页面的某个偏移量处写入1个字节的redo 日志类型。</li><li>MLOG_2BYTE （ type 字段对应的十进制数字为2 ）：表示在页面的某个偏移量处写入2个字节的redo 日志类型。</li><li>MLOG_4BYTE （ type 字段对应的十进制数字为4 ）：表示在页面的某个偏移量处写入4个字节的redo 日志类型。</li><li>MLOG_8BYTE （ type 字段对应的十进制数字为8 ）：表示在页面的某个偏移量处写入8个字节的redo 日志类型。</li><li>MLOG_WRITE_STRING （ type 字段对应的十进制数字为30 ）：表示在页面的某个偏移量处写入一串数据。</li></ul><p><img src="/attachment/69cf44d08da23ebe909980205fd09e2e.png" alt=""></p><p>MLOG_WRITE_STRING 类型的redo 日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个len 字段：</p><p><img src="/attachment/8fe8edd4fa5ed6340e0cdc70f8e87812.png" alt=""></p><h3 id="复杂一些的redo日志类型">复杂一些的redo日志类型</h3><p>语句对B+ 树所做更新：</p><ul><li><p>表中包含多少个索引，一条INSERT 语句就可能更新多少棵B+ 树。</p></li><li><p>针对某一棵B+ 树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在内节点页面中添加目录项记录）。</p></li><li><p>可能更新Page Directory 中的槽信息。</p></li><li><p>Page Header 中的各种页面统计信息，比如PAGE_N_DIR_SLOTS 表示的槽数量可能会更改， PAGE_HEAP_TOP代表的还未使用的空间最小地址可能会更改， PAGE_N_HEAP 代表的本页面中的记录数量可能会更改，吧啦吧啦，各种信息都可能会被修改。</p></li><li><p>我们知道在数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的next_record 属性来维护这个单向链表。</p></li><li><p>还有别的吧啦吧啦的更新的地方，就不一一唠叨了…</p></li></ul><p><img src="/attachment/353da489b21aa85f4bc415e560dba28c.png" alt=""></p><p>新的redo 日志类型:</p><ul><li>MLOG_REC_INSERT （对应的十进制数字为9 ）：表示插入一条使用非紧凑行格式的记录时的redo 日志类型。</li><li>MLOG_COMP_REC_INSERT （对应的十进制数字为38 ）：表示插入一条使用紧凑行格式的记录时的redo 日志类型。</li><li>MLOG_COMP_PAGE_CREATE （ type 字段对应的十进制数字为58 ）：表示创建一个存储紧凑行格式记录的页面的redo 日志类型。</li><li>MLOG_COMP_REC_DELETE （ type 字段对应的十进制数字为42 ）：表示删除一条使用紧凑行格式记录的redo 日志类型。</li><li>MLOG_COMP_LIST_START_DELETE （ type 字段对应的十进制数字为44 ）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的redo 日志类型。</li><li>MLOG_COMP_LIST_END_DELETE （ type 字段对应的十进制数字为43 ）：与MLOG_COMP_LIST_START_DELETE类型的redo 日志呼应，表示删除一系列记录直到MLOG_COMP_LIST_END_DELETE 类型的redo 日志对应的记录为止。</li></ul><pre><code class="language-ad-tip">Redundant是一种比较原始的行格式，它就是非紧凑的。而Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。</code></pre><p>这些类型的redo 日志既包含物理层面的意思，也包含逻辑层面的意思，具体指：</p><p>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。<br>逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。</p><p><img src="/attachment/3f5b621b58bec69fe578eb9bc1fbeb5b.png" alt=""></p><p>这个类型为MLOG_COMP_REC_INSERT 的redo 日志结构有几个地方需要大家注意：</p><ul><li>field1_len ~ fieldn_len 代表着该记录若干个字段占用存储空间的大小</li><li>offset 代表的是该记录的前一条记录在页面中的地址。</li><li>通过end_seg_len 的值可以间接的计算出一条记录占用存储空间的总大小</li><li>mismatch_index 的值也是为了节省redo 日志的大小而设立的，大家可以忽略。</li></ul><h3 id="redo日志格式小结">redo日志格式小结</h3><p>redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。</p><h2 id="Mini-Transaction">Mini-Transaction</h2><h3 id="以组的形式写入redo日志">以组的形式写入redo日志</h3><p>在执行语句的过程中产生的redo 日志被设计InnoDB 的大叔人为的划分成了若干个不可分割的组，比如：</p><ul><li>更新Max Row ID 属性时产生的redo 日志是不可分割的。</li><li>向聚簇索引对应B+ 树的页面中插入一条记录时产生的redo 日志是不可分割的。</li><li>向某个二级索引对应B+ 树的页面中插入一条记录时产生的redo 日志是不可分割的。</li><li>还有其他的一些对页面的访问操作时产生的redo 日志是不可分割的。。。</li></ul><p><strong>不可分割的含义</strong></p><ul><li><p>我们以向某个索引对应的B+ 树插入一条记录为例，在向B+ 树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p></li><li><p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为MLOG_COMP_REC_INSERT 的redo 日志就好了，我们把这种情况称之为乐观插入。</p></li><li><p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的页分裂操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条目录项记录指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条redo 日志，我们把这种情况称之为悲观插入。</p></li></ul><p><img src="/attachment/71287f939b738feec0b12a85ffd153dc.png" alt=""></p><p>向某个索引对应的B+ 树中插入一条记录的这个过程必须是<strong>原子</strong>的</p><p>规定在执行这些需要保证原子性的操作时必须以组的形式来记录的redo 日志，在进行系统奔溃重启恢复时，针对某个组中的redo 日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？</p><ul><li>有的需要保证原子性的操作会生成多条redo 日志，比如向某个索引对应的B+ 树中进行一次悲观插入就需要生成许多条redo 日志。</li></ul><p>该组中的最后一条redo 日志后边加上一条特殊类型的redo 日志，该类型名称为MLOG_MULTI_REC_END ， type 字段对应的十进制数字为31 ，该类型的redo 日志结构很简单，只有一个type 字段：</p><p><img src="/attachment/3855e8a74e6878458e3752e1c9087c43.png" alt=""></p><p>所以某个需要保证原子性的操作产生的一系列redo 日志必须要以一个类型为MLOG_MULTI_REC_END 结尾，就像这样：<br><img src="/attachment/d61609ebe74a8f9dbb9f8934e231bbdf.png" alt=""></p><p>这样在系统奔溃重启进行恢复时，只有当解析到类型为MLOG_MULTI_REC_END 的redo 日志，才认为解析到了一组完整的redo 日志，才会进行恢复。否则的话直接放弃前边解析到的redo 日志。</p><ul><li>有的需要保证原子性的操作只生成一条redo 日志，比如更新Max Row ID 属性的操作就只会生成一条redo日志。</li></ul><p>用7个比特位就足以包括所有的redo 日志类型，而type 字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条redo 日志，<br><img src="/attachment/9734a9b9fbeff14ce4e3e19643c39999.png" alt=""></p><p>如果type 字段的第一个比特位为1 ，代表该需要保证原子性的操作只产生了单一的一条redo 日志，否则表示该需要保证原子性的操作产生了一系列的redo 日志。</p><h3 id="Mini-Transaction的概念">Mini-Transaction的概念</h3><p>对底层页面中的一次原子访问的过程称之为一个Mini-Transaction ，简称mtr。</p><ul><li>修改一次Max Row ID 的值算是一个Mini-Transaction</li><li>向某个索引对应的B+ 树中插入一条记录的过程也算是一个Mini-Transaction</li></ul><p>一个所谓的mtr 可以包含一组redo 日志，在进行奔溃恢复时这一组redo 日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr 组成，每一个mtr 又可以包含若干条redo 日志，画个图表示它们的关系就是这样：</p><p><img src="/attachment/9dc564aab6d3f1055f5b09bf9a4eebac.png" alt=""></p><h2 id="redo日志的写入过程">redo日志的写入过程</h2><h3 id="redo-log-block">redo log block</h3><p>为了更好的进行系统奔溃恢复，他们把通过mtr 生成的redo 日志都放在了大小为512字节的页中。</p><p>log buffer 本质上是一片连续的内存空间，被划分成了若干个512 字节大小的block 。</p><p>用来存储redo 日志的页称为block</p><p><strong>redo log block 的示意图如下：</strong></p><p><img src="/attachment/1d05f86aacee59136739ffecdf347977.png" alt=""></p><p>真正的redo 日志都是存储到占用496 字节大小的log block body 中，图中的log block header 和log block trailer 存储的是一些管理信息。</p><p><strong>管理信息示意图:</strong></p><p><img src="/attachment/f8cb74a8b560c202a167d8ef4b88bbc7.png" alt=""></p><p>其中log block header 的几个属性的意思分别如下：</p><ul><li>LOG_BLOCK_HDR_NO ：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li><li>LOG_BLOCK_HDR_DATA_LEN ：表示block中已经使用了多少字节，初始值为12 （因为log block body 从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果log block body已经被全部写满，那么本属性的值被设置为512 。</li><li>LOG_BLOCK_FIRST_REC_GROUP ：一条redo 日志也可以称之为一条redo 日志记录（ redo log record ），</li><li>一个mtr 会生产多条redo 日志记录，这些redo 日志记录被称之为一个redo 日志记录组（ redo logrecord group ）。LOG_BLOCK_FIRST_REC_GROUP 就代表该block中第一个mtr 生成的redo 日志记录组的偏移量（其实也就是这个block里第一个mtr 生成的第一条redo 日志的偏移量）。</li><li>LOG_BLOCK_CHECKPOINT_NO ：表示所谓的checkpoint 的序号， checkpoint 是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</li></ul><p>log block trailer 中属性的意思如下：</p><ul><li>LOG_BLOCK_CHECKSUM ：表示block的校验值，用于正确性校验，我们暂时不关心它。</li></ul><h3 id="redo日志缓冲区">redo日志缓冲区</h3><p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer 的连续内存空间，翻译成中文就是redo日志缓冲区，我们也可以简称为log buffer 。</p><p>这片内存空间被划分成若干个连续的redo log block</p><p><img src="/attachment/8d197b0dcbbb096473c844ae946009d9.png" alt=""></p><p>默认值为16MB</p><h4 id="redo日志写入log-buffer">redo日志写入log buffer</h4><p>向log buffer 中写入redo 日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写</p><p>当我们想往log buffer 中写入redo 日志时，第一个遇到的问题就是应该写在哪个 block 的哪个偏移量处，所以设计InnoDB 的大叔特意提供了一个称之为<strong>buf_free</strong> 的全局变量，该变量指明后续写入的redo 日志应该写入到log buffer 中的哪个位置</p><p><img src="/attachment/7b62e9267e29b45a0d2259da7c5d96dc.png" alt=""></p><p>mtr 执行过程中可能产生若干条redo 日志，这些redo 日志是一个不可分割的组，<br>所以其实并不是每生成一条redo 日志，就将其插入到log buffer 中，<br>而是每个mtr 运行过程中产生的日志先暂时存到一个地方，<br>当该mtr 结束的时候，将过程中产生的一组redo 日志再全部复制到log buffer 中</p><p>假设<br>有两个名为T1 、T2 的事务，每个事务都包含2个mtr ，我们给这几个mtr 命名一下：</p><ul><li>事务T1 的两个mtr 分别称为mtr_T1_1 和mtr_T1_2 。</li><li>事务T2 的两个mtr 分别称为mtr_T2_1 和mtr_T2_2 。</li></ul><p>用示意图来描述一下这些mtr 产生的日志情况：</p><p><img src="/attachment/86ea507cc9ab069492f0ecea0409e987.png" alt=""></p><p>不同的事务可能是并发执行的，所以T1 、T2 之间的mtr 可能是交替执行的。</p><p>每当一个mtr 执行完成时，伴随该mtr 生成的一组redo 日志就需要被复制到log buffer 中，也就是说不同事务的mtr 可能是交替写入log buffer 的</p><p><img src="/attachment/3936f656aa6e353e47a4f05234d68999.png" alt=""></p><h2 id="redo日志文件">redo日志文件</h2><h3 id="redo日志刷盘时机">redo日志刷盘时机</h3><p>在一些情况下它们会被刷新到磁盘里</p><ul><li>log buffer 空间不足时</li><li>事务提交时</li><li>后台线程不停的刷刷刷<ul><li>后台有一个线程，大约每秒都会刷新一次log buffer 中的redo 日志到磁盘。</li></ul></li><li>正常关闭服务器时</li><li>做所谓的checkpoint 时（我们现在没介绍过checkpoint 的概念，稍后会仔细唠叨，稍安勿躁）</li><li>其他的一些情况…</li></ul><h3 id="redo日志文件组">redo日志文件组</h3><p>MySQL 的数据目录（使用SHOW VARIABLES LIKE ‘datadir’ 查看）下默认有两个名为<code>ib_logfile0</code> 和<code>ib_logfile1</code> 的文件， log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中。</p><p>磁盘上的redo 日志文件是以一个日志文件组的形式出现的。</p><p>这些文件以ib_logfile[数字] （ 数字可以是0 、1 、2 …）的形式进行命名。</p><p><img src="/attachment/841ce5d38af1aa4690e5a8b8fb7cf4bf.png" alt=""></p><p>总共的redo 日志文件大小其实就是：<br>innodb_log_file_size × innodb_log_files_in_group 。</p><h3 id="redo日志文件格式">redo日志文件格式</h3><p>将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中</p><p>redo 日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储log buffer 中的block镜像的。</li></ul><p><img src="/attachment/8e93c10b72701ec5752a42211bd479d4.png" alt=""></p><p><strong>介绍一下每个redo 日志文件前2048个字节，也就是前4个特殊block的格式</strong></p><p><img src="/attachment/d7615b3b42ba54071280404008bb7f6b.png" alt=""></p><p>这4个block分别是：</p><ul><li>log file header ：描述该redo 日志文件的一些整体属性，看一下它的结构：<br><img src="/attachment/d3d42b092271e9fafc2b2525865d7a34.png" alt=""></li></ul><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">长度（单位：字节）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">LOG_HEADER_FORMAT</td><td style="text-align:center">4</td><td style="text-align:left">redo 日志的版本，在MySQL5.7.21 中该值永远为1</td></tr><tr><td style="text-align:center">LOG_HEADER_PAD1</td><td style="text-align:center">4</td><td style="text-align:left">做字节填充用的，没什么实际意义，忽略～</td></tr><tr><td style="text-align:center">LOG_HEADER_START_LSN</td><td style="text-align:center">8</td><td style="text-align:left">标记本redo 日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值（关于什么是LSN我们稍后再看哈，看不懂的先忽略）。</td></tr><tr><td style="text-align:center">LOG_HEADER_CREATOR</td><td style="text-align:center">32</td><td style="text-align:left">一个字符串，标记本redo 日志文件的创建者是谁。正常运行时该值为MySQL 的版本号，比如： “MySQL 5.7.21” ，使用mysqlbackup 命令创建的redo 日志文件的该值为"ibbackup" 和创建时间。</td></tr><tr><td style="text-align:center">LOG_BLOCK_CHECKSUM</td><td style="text-align:center">4</td><td style="text-align:left">本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><ul><li>checkpoint1 ：记录关于checkpoint 的一些属性，看一下它的结构：<br><img src="/attachment/bb48c1b7b81b2c67d98200f113755e4b.png" alt=""></li></ul><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">长度（单位：字节）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">LOG_CHECKPOINT_NO</td><td style="text-align:center">8</td><td style="text-align:left">服务器做checkpoint 的编号，每做一次checkpoint ，该值就加1。</td></tr><tr><td style="text-align:center">LOG_CHECKPOINT_LSN</td><td style="text-align:center">8</td><td style="text-align:left">服务器做checkpoint 结束时对应的LSN 值，系统奔溃恢复时将从该值开始。</td></tr><tr><td style="text-align:center">LOG_CHECKPOINT_OFFSET</td><td style="text-align:center">8</td><td style="text-align:left">上个属性中的LSN 值在redo 日志文件组中的偏移量</td></tr><tr><td style="text-align:center">LOG_CHECKPOINT_LOG_BUF_SIZE</td><td style="text-align:center">8</td><td style="text-align:left">服务器在做checkpoint 操作时对应的log buffer 的大小</td></tr><tr><td style="text-align:center">LOG_BLOCK_CHECKSUM</td><td style="text-align:center">4</td><td style="text-align:left">本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><ul><li>第三个block未使用，忽略～</li><li>checkpoint2 ：结构和checkpoint1 一样。</li></ul><h2 id="Log-Sequeue-Number">Log Sequeue Number</h2><p>为记录已经写入的redo 日志量，设计了一个称之为Log Sequeue Number 的全局变量，日志序列号，简称LSN</p><p>规定初始的lsn 值为8704</p><p>在统计lsn 的增长量时，是按照实际写入的日志量加上占用的log block header 和log block trailer 来计算的</p><p>每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p><h3 id="flushed-to-disk-lsn">flushed_to_disk_lsn</h3><p>redo 日志是首先写到log buffer 中，之后才会被刷新到磁盘上的redo 日志文件。所以设计InnoDB 的大叔提出了一个称之为 buf_next_to_write 的全局变量，标记当前log buffer 中已经有哪些日志被刷新到磁盘中了。</p><p><img src="/attachment/3b8a42e699920fe0a42680ac68939a94.png" alt=""></p><p>刷新到磁盘中的redo 日志量的全局变量，称之为 flushed_to_disk_lsn 。</p><p>系统第一次启动时，该变量的值和初始的lsn 值是相同的，都是8704</p><p>如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p><h3 id="lsn值和redo日志文件偏移量的对应关系">lsn值和redo日志文件偏移量的对应关系</h3><p>lsn 的值是代表系统写入的redo 日志量的一个总和，一个mtr 中产生多少日志， lsn 的值就增加多少（当然有时候要加上log block header 和log block trailer 的大小），这样mtr 产生的日志写到磁盘中时，很容易计算某一个lsn 值在redo 日志文件组中的偏移量</p><h3 id="flush链表中的LSN">flush链表中的LSN</h3><p>在mtr 结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表。</p><p><img src="/attachment/59448f56db4c485c66d2a1cdb0c8a789.png" alt=""></p><p>说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的</p><p>在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p><ul><li>oldest_modification ：如果某个页面被加载到Buffer Pool 后进行第一次修改，那么就将修改该页面的 mtr 开始时对应的lsn 值写入这个属性。</li><li>newest_modification ：每修改一次页面，都会将修改该页面的mtr 结束时对应的lsn 值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统lsn 值。</li></ul><p><strong>举例</strong></p><ul><li>假设mtr_1 执行过程中修改了页a ，那么在mtr_1 执行结束时，就会将页a 对应的控制块加入到flush链表的头部。并且将mtr_1 开始时对应的lsn ，也就是8716 写入页a 对应的控制块的oldest_modification 属性中，把mtr_1 结束时对应的lsn ，也就是8916写入页a 对应的控制块的newest_modification 属性中。画个图表示一下（为了让图片美观一些，我们把oldest_modification 缩写成了o_m ，把newest_modification 缩写成了n_m ）：</li></ul><p><img src="/attachment/67c7c0593ef4be8ecd71c88590fe4ad9.png" alt=""></p><ul><li>接着假设mtr_2 执行过程中又修改了页b 和页c 两个页面，那么在mtr_2 执行结束时，就会将页b 和页c对应的控制块都加入到flush链表的头部。并且将mtr_2 开始时对应的lsn ，也就是8916写入页b 和页c对应的控制块的oldest_modification 属性中，把mtr_2 结束时对应的lsn ，也就是9948写入页b 和页c对应的控制块的newest_modification 属性中。画个图表示一下：</li></ul><p><img src="/attachment/f94d1f76d0363cd140144eb40c3218e3.png" alt=""></p><p>每次新插入到flush链表中的节点都是被放在了头部，也就是说<strong>flush链表中前边的脏页修改的时间比较晚，后边的脏页修改时间比较早</strong>。</p><ul><li>接着假设mtr_3 执行过程中修改了页b 和页d ，不过页b 之前已经被修改过了，所以它对应的控制块已经被插入到了flush 链表，所以在mtr_3 执行结束时，只需要将页d 对应的控制块都加入到flush链表的头部即可。</li></ul><p><img src="/attachment/57704071c7325804ba415757ddcb41f6.png" alt=""></p><p>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</p><h2 id="checkpoint">checkpoint</h2><p>redo日志只是为了系统奔溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统奔溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。</p><p><strong>判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。</strong></p><p><img src="/attachment/0da7360001348c19f9108658047c0fd1.png" alt=""></p><p>如果页a被刷新到了磁盘，那么它对应的控制块就会从flush链表中移除</p><p><img src="/attachment/e6e162cae4b971e6a2627708e262ea22.png" alt=""></p><p>这样mtr_1 生成的redo 日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。</p><p>提出了一个全局变量 <strong>checkpoint_lsn</strong> 来代表当前系统中可以被覆盖的redo 日志总量是多少，这个变量初始值也是8704 。</p><p>比方说现在页a被刷新到了磁盘，mtr_1生成的redo日志就可以被覆盖了，所以我们可以进行一个增加checkpoint_lsn的操作，我们把这个过程称之为做一次checkpoint。</p><p>做一次checkpoint其实可以分为两个步骤：</p><p>步骤一：计算一下当前系统中可以被覆盖的redo 日志对应的lsn 值最大是多少。</p><ul><li>凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的</li><li>把该脏页的oldest_modification 赋值给checkpoint_lsn 。</li></ul><p>步骤二：将checkpoint_lsn 和对应的redo 日志文件组偏移量以及此次checkpint 的编号写到日志文件的管理信息（就是checkpoint1 或者checkpoint2 ）中。</p><p>维护了一个目前系统做了多少次checkpoint 的变量checkpoint_no ，每做一次checkpoint ，该变量的值就加1。<br>上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。</p><p>undefined</p><h3 id="批量从flush链表中刷出脏页">批量从flush链表中刷出脏页</h3><p>如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做checkpoint ，可能就需要用户线程同步的从flush链表中把那些最早修改的脏页（ oldest_modification 最小的脏页）刷新到磁盘，这样这些脏页对应的redo 日志就没用了，然后就可以去做checkpoint 了。</p><h3 id="查看系统中的各种LSN值">查看系统中的各种LSN值</h3><pre><code class="language-sql">SHOW ENGINE INNODB STATUS</code></pre><ul><li>Log sequence number ：代表系统中的lsn 值，也就是当前系统已经写入的redo 日志量，包括写入logbuffer 中的日志。</li><li>Log flushed up to ：代表flushed_to_disk_lsn 的值，也就是当前系统已经写入磁盘的redo 日志量。</li><li>Pages flushed up to ：代表flush链表中被最早修改的那个页面对应的oldest_modification 属性值。</li><li>Last checkpoint at ：当前系统的checkpoint_lsn 值。</li></ul><h3 id="innodb-flush-log-at-trx-commit的用法">innodb_flush_log_at_trx_commit的用法</h3><p>为了保证事务的持久性，用户线程在事务提交时需要将该事务执行过程中产生的所有redo 日志都刷新到磁盘上。</p><p><strong>innodb_flush_log_at_trx_commit</strong> 的系统变量</p><ul><li>0 ：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步redo 日志，这个任务是交给后台线程做的。这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将redo 日志刷新到磁盘，那么该事务对页面的修改会丢失。</li><li>1 ：当该系统变量值为1时，表示在事务提交时需要将redo 日志同步到磁盘，可以保证事务的持久性。1也是innodb_flush_log_at_trx_commit 的默认值。</li><li>2 ：当该系统变量值为2时，表示在事务提交时需要将redo 日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是操作系统也挂了的话，那就不能保证持久性了。</li></ul><h2 id="崩溃恢复">崩溃恢复</h2><h3 id="确定恢复的起点">确定恢复的起点</h3><p>redo 日志文件组的第一个文件的管理信息中有两个block都存储了checkpoint_lsn 的信息，我们当然是要选取最近发生的那次checkpoint的信息。</p><h3 id="确定恢复的终点">确定恢复的终点</h3><p><img src="/attachment/cd81fa87dd718fed10415acc55ac175e.png" alt=""></p><p>普通block的log block header 部分有一个称之为LOG_BLOCK_HDR_DATA_LEN 的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为512 。如果该属性的值不为512 ，那么就是它了，它就是此次奔溃恢复中需要扫描的最后一个block。</p><h3 id="怎么恢复">怎么恢复</h3><p>确定了需要扫描哪些redo 日志进行奔溃恢复之后，接下来就是怎么进行恢复了。</p><p>假设现在的redo 日志文件中有5条redo 日志，如图：</p><p><img src="/attachment/99f809bbdc1359a32f7be7d187f5efa3.png" alt=""></p><p>由于redo 0 在checkpoint_lsn 后边，恢复时可以不管它。我们现在可以按照redo 日志的顺序依次扫描checkpoint_lsn 之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。</p><ul><li>使用哈希表</li></ul><p>根据redo 日志的space ID 和page number 属性计算出散列值，把space ID 和page number 相同的redo日志放到哈希表的同一个槽里，如果有多个space ID 和page number 都相同的redo 日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，</p><p><img src="/attachment/37f0ae78d9f018981aa767d5c3700f6d.png" alt=""></p><ul><li>跳过已经刷新到磁盘的页面</li></ul><h2 id="LOG-BLOCK-HDR-NO是如何计算的">LOG_BLOCK_HDR_NO是如何计算的</h2><p>对于实际存储redo 日志的普通的log block 来说，在log block header 处有一个称之为 LOG_BLOCK_HDR_NO 的属性</p><p>使用下边的公式计算该block的LOG_BLOCK_HDR_NO 值：</p><pre><code class="language-sql">((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</code></pre><p><img src="/attachment/df91a46b5d15f3eec07ea9d95c5b1df2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 事务</title>
      <link href="/database/mysql/mysql-shi-wu/"/>
      <url>/database/mysql/mysql-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 事务</h1><h2 id="Metadata-15">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 事务date: 2023-06-25 09:25tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 事务</code></pre><h2 id="事务的起源">事务的起源</h2><p><strong>举例</strong></p><p>银行为了存储人们的账户信息会建立一个account 表：</p><pre><code class="language-sql">CREATE TABLE account (id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',name VARCHAR(100) COMMENT '客户名称',balance INT COMMENT '余额',PRIMARY KEY (id)) Engine=InnoDB CHARSET=utf8;</code></pre><p>每一个操作都相当于现实世界中账户的一次状态转换</p><pre><code class="language-sql">UPDATE account SET balance = balance - 10 WHERE id = 1;UPDATE account SET balance = balance + 10 WHERE id = 2;</code></pre><p>让某些数据库操作符合现实世界中状态转换的规则</p><h3 id="原子性（Atomicity）">原子性（Atomicity）</h3><p>事务是一个不可分割的操作单元，要么全部执行成功，要么全部失败回滚。如果事务中的任何一步操作失败，则整个事务都会被回滚到最初的状态，保证数据的一致性。</p><h3 id="隔离性（Isolation）">隔离性（Isolation）</h3><p>多个事务并发执行时，每个事务的操作应该与其他事务的操作相互隔离，互不干扰。每个事务在执行期间所做的修改对其他事务是不可见的，直到事务提交。</p><p><strong>示例</strong></p><p>步骤一：读取狗哥账户的余额到变量A中，这一步骤简写为read(A) 。<br>步骤二：将狗哥账户的余额减去转账金额，这一步骤简写为A = A - 5 。<br>步骤三：将狗哥账户修改过的余额写到磁盘里，这一步骤简写为write(A) 。<br>步骤四：读取猫爷账户的余额到变量B，这一步骤简写为read(B) 。<br>步骤五：将猫爷账户的余额加上转账金额，这一步骤简写为B = B + 5 。<br>步骤六：将猫爷账户修改过的余额写到磁盘里，这一步骤简写为write(B) 。</p><p><img src="/attachment/b5f78daf4692c06f126ef8133bc049e2.png" alt=""></p><p><strong>实际</strong></p><p><img src="/attachment/d84bf87925b105c7ace16d15d8e6a101.png" alt=""></p><h3 id="一致性（Consistency）">一致性（Consistency）</h3><p>事务执行前后，数据库的完整性约束必须保持一致。</p><p>每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。</p><p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果。</p><h3 id="持久性（Durability）">持久性（Durability）</h3><p>一旦事务提交，其所做的修改将永久保存在数据库中，即使系统发生故障也不会丢失。系统保证已提交的事务对数据库的修改是永久性的。</p><h2 id="事务的概念">事务的概念</h2><p>把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称之为一个事务（英文名是： transaction ）</p><p>叔根据这些操作所执行的不同阶段把事务大致上划分成了这么几个状态：</p><ul><li>活动的（active）</li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。</p><ul><li>部分提交的（partially committed）</li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p><ul><li>失败的（failed）</li></ul><p>当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p><ul><li>中止的（aborted）</li></ul><p>。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p><ul><li>提交的（committed）</li></ul><p>当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。</p><p><img src="/attachment/bf07be398a246489bbc88fe730befae7.png" alt=""></p><p>只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。</p><h2 id="MySQL中事务的语法">MySQL中事务的语法</h2><h3 id="开启事务">开启事务</h3><h4 id="BEGIN-WORK">BEGIN [WORK];</h4><p>BEGIN 语句代表开启一个事务，后边的单词WORK 可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。</p><h4 id="START-TRANSACTION">START TRANSACTION;</h4><p>START TRANSACTION 语句和BEGIN 语句有着相同的功效，都标志着开启一个事务</p><p>可以在START TRANSACTION 语句后边跟随几个修饰符</p><ul><li><p>READ ONLY<br>标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p></li><li><p>READ WRITE<br>标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p></li><li><p>WITH CONSISTENT SNAPSHOT<br>启动一致性读</p></li></ul><h3 id="提交事务">提交事务</h3><p>COMMIT [WORK]</p><h3 id="手动中止事务">手动中止事务</h3><p>ROLLBACK [WORK]</p><h3 id="支持事务的存储引擎">支持事务的存储引擎</h3><p>目前只有InnoDB 和NDB 存储引擎支持</p><h3 id="自动提交">自动提交</h3><p>MySQL 中有一个系统变量autocommit</p><h3 id="隐式提交">隐式提交</h3><p>导致事务隐式提交的语句包括：</p><ul><li>定义或修改数据库对象的数据定义语言（Data definition language，缩写为： DDL ）。</li><li>隐式使用或修改mysql 数据库中的表</li><li>事务控制或关于锁定的语句</li><li>加载数据的语句</li><li>关于MySQL 复制的一些语句</li><li>其它的一些语句</li></ul><h3 id="保存点">保存点</h3><p>保存点（英文： savepoint ）的概念</p><p>在事务对应的数据库语句中打几个点，我们在调用ROLLBACK 语句时可以指定会滚到哪个点，而不是回到最初的原点</p><p>定义保存点的语法如下：</p><pre><code class="language-sql">SAVEPOINT 保存点名称;</code></pre><p>当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词WORK 和SAVEPOINT 是可有可无的）：</p><pre><code class="language-sql">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</code></pre><p>如果我们想删除某个保存点，可以使用这个语句：</p><pre><code class="language-sql">RELEASE SAVEPOINT 保存点名称;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB的Buffer Pool</title>
      <link href="/database/mysql/mysql-innodb-de-buffer-pool/"/>
      <url>/database/mysql/mysql-innodb-de-buffer-pool/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 InnoDB的Buffer Pool</h1><h2 id="Metadata-10">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 InnoDB的Buffer Pooldate: 2023-06-24 14:49tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 InnoDB的Buffer Pool</code></pre><h2 id="概述-8">概述</h2><ol><li>磁盘太慢，用内存作为缓存很有必要。</li><li>Buffer Pool 本质上是InnoDB 向操作系统申请的一段<strong>连续的内存空间</strong>，可以通过 innodb_buffer_pool_size 来调整它的大小。</li><li>Buffer Pool 向操作系统申请的连续内存由<strong>控制块</strong>和<strong>缓存页</strong>组成，每个控制块和缓存页都是一一对应的，在填充足够多的控制块和缓存页的组合后， Buffer Pool 剩余的空间可能产生不够填充一组控制块和缓存页，这部分空间不能被使用，也被称为碎片。</li><li>InnoDB 使用了许多<strong>链表</strong>来管理Buffer Pool 。</li><li>free链表中每一个<strong>节点</strong>都代表一个<strong>空闲的缓存页</strong>，在将磁盘中的页加载到Buffer Pool 时，会从free链表中寻找空闲的缓存页。</li><li>为了快速定位某个页是否被加载到Buffer Pool ，使用<strong>表空间号 + 页号</strong>作为key ，<strong>缓存页</strong>作为value ，建立<strong>哈希表</strong>。</li><li>在Buffer Pool 中<strong>被修改的页</strong>称为<strong>脏页</strong>，脏页并不是立即刷新，而是被加入到<strong>flush链表</strong>中，待之后的某个时刻同步到磁盘上。</li><li>LRU链表分为<strong>young</strong> 和<strong>old</strong> 两个区域，可以通过innodb_old_blocks_pct 来调节old 区域所占的比例。首次从磁盘上加载到Buffer Pool 的页会被放到old 区域的头部，在innodb_old_blocks_time 间隔时间内访问该页不会把它移动到young 区域头部。在Buffer Pool 没有可用的空闲缓存页时，会首先<strong>淘汰掉</strong>old 区域的一些页。</li><li>我们可以通过指定innodb_buffer_pool_instances 来控制Buffer Pool 实例的个数，每个Buffer Pool 实例中都有各自独立的链表，互不干扰。</li><li>自MySQL 5.7.5 版本之后，可以在服务器运行过程中调整Buffer Pool 大小。每个Buffer Pool 实例由若干个chunk 组成，每个chunk 的大小可以在服务器启动时通过启动参数调整。</li></ol><p><img src="/attachment/29ea829b7b4ac4c2406b67567c247b48.png" alt=""></p><p><img src="/attachment/67abbef1a879e0fa04c8fb83cd658680.png" alt=""></p><p><img src="/attachment/de8451072ba42c2df458bd4fe2425abc.png" alt=""></p><h2 id="缓存的重要性">缓存的重要性</h2><p>即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。</p><p>将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO 的开销了。</p><h2 id="InnoDB的Buffer-Pool">InnoDB的Buffer Pool</h2><h3 id="什么个Buffer-Pool">什么个Buffer Pool</h3><p>为了缓存磁盘中的页，在MySQL 服务器启动的时候就向操作系统申请了一片连续的内存，他们给这片内存起了个名，叫做Buffer Pool （中文名是缓冲池）</p><p>默认情况下Buffer Pool 只有128M 大小</p><h3 id="Buffer-Pool内部组成">Buffer Pool内部组成</h3><p>控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边</p><p><img src="/attachment/29ea829b7b4ac4c2406b67567c247b48.png" alt=""></p><h3 id="free链表的管理">free链表的管理</h3><p>最好在某个地方记录一下Buffer Pool中哪些缓存页是可用的</p><p>把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中</p><h3 id="缓存页的哈希处理">缓存页的哈希处理</h3><p><strong>创建一个哈希表</strong></p><ul><li>用表空间号 + 页号作为key</li><li>缓存页作为value</li></ul><p>先从哈希表中根据表空间号 + 页号看看有没有对应的缓存页，如果有，直接使用该缓存页就好，<br>如果没有，那就从free链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</p><h3 id="flush链表的管理">flush链表的管理</h3><p>如果我们修改了Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为<strong>脏页</strong>（英文名： dirty page ）</p><p>最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能</p><p>凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫<strong>flush链表</strong></p><p><img src="/attachment/67abbef1a879e0fa04c8fb83cd658680.png" alt=""></p><h3 id="LRU链表的管理">LRU链表的管理</h3><h4 id="缓存不够的窘境">缓存不够的窘境</h4><p>如果需要缓存的页占用的内存大小超过了Buffer Pool 大小</p><p>假设我们一共访问了n 次页，那么被访问的页已经在缓存中的次数除以n 就是所谓的缓存命中率，我们的期望就是让缓存命中率越高越好</p><h4 id="简单的LRU链表">简单的LRU链表</h4><p>我们可以再创建一个链表，由于这个链表是为了按照最近最少使用的原则去淘汰缓存页的，所以这个链表可以被称为LRU链表（LRU的英文全称：Least Recently Used）</p><h4 id="划分区域的LRU链表">划分区域的LRU链表</h4><p><strong>两种比较尴尬的情况</strong></p><ul><li><p>情况一: InnoDB 提供了一个看起来比较贴心的服务—— 预读（英文名： read ahead ）</p><ul><li>InnoDB 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到Buffer Pool 中。</li><li>预读又可以细分为下边两种<ul><li>线性预读<ul><li>提供了一个系统变量innodb_read_ahead_threshold</li><li>如果顺序访问了某个区（ extent ）的页面超过这个系统变量的值，就会触发一次异步读取下一个区中全部的页面到BufferPool 的请求</li></ul></li><li>随机预读<ul><li>如果Buffer Pool 中已经缓存了某个区的13个连续的页面，不论这些页面是不是顺序读取的，都会触发一次异步读取本区中所有其的页面到Buffer Pool 的请求。<br>如果此时Buffer Pool 的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在LRU链表尾部的一些缓存页会很快的被淘汰掉，会大大降低缓存命中率。</li></ul></li></ul></li></ul></li><li><p>情况二: 可能会写一些需要扫描全表的查询语句</p></li><li><p>当需要访问这些页时，会把它们统统都加载到Buffer Pool 中，Buffer Pool 中的所有页都被换了一次血，其他查询语句在执行时又得执行一次从磁盘加载到Buffer Pool的操作。</p></li><li><p>而这种全表扫描的语句执行的频率也不高，每次执行都要把Buffer Pool 中的缓存页换一次血，这严重的影响到其他查询对 Buffer Pool 的使用，从而大大降低了缓存命中率。</p></li></ul><p><strong>总结</strong>一下上边说的可能降低Buffer Pool 的两种情况：</p><ul><li>加载到Buffer Pool 中的页不一定被用到。</li><li>如果非常多的使用频率偏低的页被同时加载到Buffer Pool 时，可能会把那些使用频率非常高的页从Buffer Pool 中淘汰掉。</li></ul><p>因为有这两种情况的存在，所以设计InnoDB 的大叔把这个LRU链表按照一定比例分成两截，分别是：</p><ul><li>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做热数据，或者称young区域。</li><li>另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做冷数据，或者称old区域。</li></ul><p><img src="/attachment/de8451072ba42c2df458bd4fe2425abc.png" alt=""></p><p>我们是按照<strong>某个比例</strong>将LRU链表分成两半的，不是某些节点固定是young区域的，某些节点固定是old区域的，随着程序的运行，某个节点所属的区域也可能发生变化。</p><p>有了这个被划分成young 和old 区域的LRU 链表之后，设计InnoDB 的大叔就可以针对我们上边提到的两种可能降低缓存命中率的情况进行优化了：</p><ul><li><p>针对预读的页面可能不进行后续访情况的优化<br>当磁盘上的某个页面在<strong>初次加载</strong>到Buffer Pool中的某个缓存页时，该缓存页对应的控制块会被放到old区域的头部。<br>这样针对预读到Buffer Pool 却不进行后续访问的页面就会被逐渐从old 区域逐出，而不会影响young 区域中被使用比较频繁的缓存页。</p></li><li><p>针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化</p><ul><li>首次被加载到Buffer Pool 的页被放到了old 区域的头部，但是后续会被马上访问到，每次进行访问的时候又会把该页放到young 区域的头部，这样仍然会把那些使用频率比较高的页面给顶下去</li><li>规定：<ul><li>在对某个处在old 区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部</li></ul></li></ul></li></ul><h4 id="更进一步优化LRU链表">更进一步优化LRU链表</h4><p>只有被访问的缓存页位于young 区域的1/4 的后边，才会被移动到LRU链表头部，这样就可以降低调整LRU链表的频率，从而提升性能（也就是说如果某个缓存页对应的节点在young 区域的1/4 中，再次访问该缓存页时也不会将其移动到LRU 链表头部）。</p><p>尽量高效的提高 Buffer Pool 的缓存命中率</p><h3 id="其他的一些链表">其他的一些链表</h3><ul><li>unzip LRU链表用于管理解压页</li><li>zip clean链表用于管理没有被解压的压缩页</li><li>zip free数组中每一个元素都代表一个链表</li><li>它们组成所谓的伙伴系统来为压缩页提供内存空间等等</li></ul><h3 id="刷新脏页到磁盘">刷新脏页到磁盘</h3><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。<br>主要有两种刷新路径：</p><ul><li><p>从LRU链表的冷数据中刷新一部分页面到磁盘。<br>后台线程会定时从LRU链表尾部开始扫描一些页面，扫描的页面数量可以通过系统变量innodb_lru_scan_depth 来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为 <strong>BUF_FLUSH_LRU</strong> 。</p></li><li><p>从flush链表中刷新一部分页面到磁盘。<br>后台线程也会定时从flush链表中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为<strong>BUF_FLUSH_LIST</strong> 。</p></li></ul><p>有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到Buffer Pool 时没有可用的缓存页，这时就会尝试看看<strong>LRU链表尾部有没有可以直接释放掉的未修改页面</strong>，<br><strong>如果没有的话会不得不将LRU链表尾部的一个脏页同步刷新到磁盘</strong>（和磁盘交互是很慢的，这会降低处理用户请求的速度）。这种刷新单个页面到磁盘中的刷新方式被称之为<strong>BUF_FLUSH_SINGLE_PAGE</strong> 。</p><h3 id="多个Buffer-Pool实例">多个Buffer Pool实例</h3><p>当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances 的值修改为1。</p><h3 id="innodb-buffer-pool-chunk-size">innodb_buffer_pool_chunk_size</h3><p>Pool 的大小通过配置innodb_buffer_pool_size 启动参数来调整大小</p><p>innodb_buffer_pool_chunk_size的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的。</p><h3 id="配置Buffer-Pool时的注意事项">配置Buffer Pool时的注意事项</h3><ul><li>innodb_buffer_pool_size 必须是innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances 的倍数</li><li>如果在服务器启动时， innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances 的值已经大于innodb_buffer_pool_size 的值，那么innodb_buffer_pool_chunk_size 的值会被服务器自动设置为innodb_buffer_pool_size/innodb_buffer_pool_instances 的值。</li></ul><h3 id="Buffer-Pool中存储的其它信息">Buffer Pool中存储的其它信息</h3><p>存储锁信息、自适应哈希索引等信息</p><h3 id="查看Buffer-Pool的状态信息">查看Buffer Pool的状态信息</h3><pre><code class="language-sql">SHOW ENGINE INNODB STATUS\G</code></pre><ul><li>Total memory allocated ：代表Buffer Pool 向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。</li><li>Dictionary memory allocated ：为数据字典信息分配的内存空间大小，注意这个内存空间和Buffer Pool没啥关系，不包括在Total memory allocated 中。</li><li>Buffer pool size ：代表该Buffer Pool 可以容纳多少缓存页，注意，单位是页！</li><li>Free buffers ：代表当前Buffer Pool 还有多少空闲缓存页，也就是free链表中还有多少个节点。</li><li>Database pages ：代表LRU 链表中的页的数量，包含young 和old 两个区域的节点数量。</li><li>Old database pages ：代表LRU 链表old 区域的节点数量。</li><li>Modified db pages ：代表脏页数量，也就是flush链表中节点的数量。</li><li>Pending reads ：正在等待从磁盘上加载到Buffer Pool 中的页面数量。</li><li>Pending writes LRU ：即将从LRU 链表中刷新到磁盘中的页面数量。</li><li>Pending writes flush list ：即将从flush 链表中刷新到磁盘中的页面数量。</li><li>Pending writes single page ：即将以单个页面的形式刷新到磁盘中的页面数量。</li><li>Pages made young ：代表LRU 链表中曾经从old 区域移动到young 区域头部的节点数量。</li><li>Page made not young ：在将innodb_old_blocks_time 设置的值大于0时，首次访问或者后续访问某个处在old 区域的节点时由于不符合时间间隔的限制而不能将其移动到young 区域头部时， Page made not young 的值会加1。</li><li>youngs/s ：代表每秒从old 区域被移动到young 区域头部的节点数量。</li><li>non-youngs/s ：代表每秒由于不满足时间限制而不能从old 区域移动到young 区域头部的节点数量。</li><li>Pages read 、created 、written ：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速率。</li><li>Buffer pool hit rate ：表示在过去某段时间，平均访问1000次页面，有多少次该页面已经被缓存到Buffer Pool 了。</li><li>young-making rate ：表示在过去某段时间，平均访问1000次页面，有多少次访问使页面移动到young 区域的头部了。</li><li>not (young-making rate) ：表示在过去某段时间，平均访问1000次页面，有多少次访问没有使页面移动到young 区域的头部。</li><li>LRU len ：代表LRU链表中节点的数量。</li><li>unzip_LRU ：代表unzip_LRU链表中节点的数量（由于我们没有具体唠叨过这个链表，现在可以忽略它的值）。</li><li>I/O sum ：最近50s读取磁盘页的总数。</li><li>I/O cur ：现在正在读取的磁盘页数量。</li><li>I/O unzip sum ：最近50s解压的页面数量。</li><li>I/O unzip cur ：正在解压的页面数量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 optimizer trace表</title>
      <link href="/database/mysql/mysql-optimizer-trace-biao/"/>
      <url>/database/mysql/mysql-optimizer-trace-biao/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 optimizer trace表</h1><h2 id="Metadata-14">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 optimizer trace表date: 2023-06-24 14:40tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 optimizer trace表</code></pre><h2 id="【MySQL】-optimizer-trace表-2">【MySQL】 optimizer trace表</h2><p>查看优化器生成执行计划的整个过程</p><p>这个OPTIMIZER_TRACE 表有4个列，分别是：</p><ul><li>QUERY ：表示我们的查询语句。</li><li>TRACE ：表示优化过程的JSON格式文本。</li><li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE ：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li><li>INSUFFICIENT_PRIVILEGES ：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是1 ，我们暂时不关心这个字段的值。</li></ul><p>优化过程大致分为了三个阶段：</p><ul><li>prepare 阶段</li><li>optimize 阶段</li><li>execute 阶段</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 Explain详解</title>
      <link href="/database/mysql/mysql-explain-xiang-jie/"/>
      <url>/database/mysql/mysql-explain-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 Explain详解</h1><h2 id="Metadata-11">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 Explain详解date: 2023-06-24 12:50tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 Explain详解</code></pre><h2 id="概述-9">概述</h2><p>EXPLAIN 语句帮助理解 MySQL 如何执行 SQL 查询。每个输出列都有特定的含义。<br><strong>主要列：</strong></p><ul><li>table: 显示访问的表名。</li><li>id: 对于每个 SELECT 关键字，都会分配一个唯一的 id 值。</li><li>select_type: 描述了查询中各部分的类型（例如，SIMPLE, PRIMARY, UNION等）。</li><li>partitions: 显示涉及到的分区信息。</li><li>type：显示了 MySQL 使用哪种内部机制来查找行。可能是全索引扫描、范围扫描、全表扫描等方式之一。</li><li>possible_keys 和 key：显示 MySQL 可能和实际使用什么索引进行查询优化。</li><li>key_len：显示所选择的键长度，在某些条件下可能不使用全部长度来获取数据结果集</li><li>ref：表示参考什么信息寻找索引值 (如果可能) 在给定表上匹配一个行操作，这可以是常量或者函数等值对比结果</li><li>rows: 预计需要读取多少行以获得最终结果集.</li><li>filtered : 表示返回结果集百分比(通过where过滤后), 是估算值.</li><li>Extra: 提供MySQL如何处理查询以及检索表中行额外信息.<br><strong>Json格式：</strong><br>Json 格式提供了更详细且直观地查看执行计划花费成本与评价性能。</li><li>read_cost: IO 成本 + 检测 rows × (1 - filter) 条记录 CPU 成本</li><li>eval_cost: 检测 rows × filter 条记录成本</li><li>prefix_cost: 单独查询 s1 表成本 = read_cost + eval_cost</li><li>data_read_per_join :在此次查询中需要读取数据量</li></ul><p>总体而言，使用 EXPLAIN 可以帮助开发人员诊断低效率或潜在问题的 SQL 查询，并为优化提供依据。</p><h2 id="【MySQL】-Explain详解-2">【MySQL】 Explain详解</h2><h3 id="EXPLAIN-语句输出的各个列的作用">EXPLAIN 语句输出的各个列的作用:</h3><pre><code class="language-sql">EXPLAIN SELECT 1;</code></pre><p><img src="/attachment/3b588558bc6309016c37debba719dde2.png" alt=""></p><h2 id="执行计划输出中各列详解">执行计划输出中各列详解</h2><h3 id="table">table</h3><p><strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名</strong></p><h3 id="id">id</h3><p>每出现一个SELECT 关键字，会为它分配一个唯一的id 值。</p><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表。</p><p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。</p><h3 id="select-type">select_type</h3><p>为每一个SELECT 关键字代表的小查询都定义了一个称之为select_type 的属性，意思是我们只要知道了某个小查询的select_type 属性，就知道了这个小查询在整个大查询中扮演了一个什么角色</p><p><strong>select_type 取值</strong></p><p><img src="/attachment/1b63c5033aeef5ddc5e715da92f0d3e0.png" alt=""></p><ul><li>SIMPLE<br>查询语句中不包含UNION 或者子查询的查询都算作是SIMPLE 类型</li><li>PRIMARY<br>对于包含UNION 、UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type 值就是PRIMARY</li><li>UNION<br>对于包含UNION 或者UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type 值就是UNION</li><li>UNION RESULT<br>MySQL 选择使用临时表来完成UNION 查询的去重工作，针对该临时表的查询的select_type 就是UNIONRESULT</li><li>SUBQUERY<br>如果包含子查询的查询语句不能够转为对应的semi-join 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个SELECT 关键字代表的那个查询的select_type 就是SUBQUERY<br><strong>由于select_type为SUBQUERY的子查询由于会被物化，所以只需要执行一遍</strong></li><li>DEPENDENT SUBQUERY<br>如果包含子查询的查询语句不能够转为对应的semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个SELECT 关键字代表的那个查询的select_type 就是DEPENDENT SUBQUERY<br><strong>select_type为DEPENDENT SUBQUERY的查询可能会被执行多次</strong></li><li>DEPENDENT UNION<br>在包含UNION 或者UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的select_type 的值就是DEPENDENT UNION 。</li><li>DERIVED<br>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的select_type 就是DERIVED ，比方说下边这个查询</li><li>MATERIALIZED<br>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的select_type 属性就是MATERIALIZED</li><li>UNCACHEABLE SUBQUERY</li><li>UNCACHEABLE UNION</li></ul><h3 id="partitions">partitions</h3><h3 id="type">type</h3><p>MySQL 对某个表的执行查询时的访问方法</p><p>其中的type 列就表明了这个访问方法是个啥</p><p>完整的访问方法如下： system ， const ，eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ，range ， index ， ALL 。</p><ul><li><p>system<br>该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system 。</p></li><li><p>const</p></li></ul><p>根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</p><ul><li>eq_ref</li></ul><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref</p><ul><li>ref</li></ul><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表</p><ul><li>fulltext</li></ul><p>全文索引</p><ul><li>ref_or_null</li></ul><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL 值时，那么对该表的访问方法就可能是ref_or_null</p><ul><li>index_merge</li></ul><p>一般情况下对于某个表的查询只能使用到一个索引，但我们唠叨单表访问方法时特意强调了在某些场景下可以使用Intersection 、Union 、Sort-Union 这三种索引合并的方式来执行查询</p><ul><li>unique_subquery</li></ul><p>类似于两表连接中被驱动表的eq_ref 访问方法， unique_subquery 是针对在一些包含IN 子查询的查询语句中，如果查询优化器决定将IN 子查询转换为EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的type 列的值就是unique_subquery</p><ul><li>index_subquery</li></ul><p>index_subquery 与unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引</p><ul><li>range</li></ul><p>如果使用索引获取某些范围区间的记录，那么就可能使用到range 访问方法</p><ul><li>index</li></ul><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index</p><ul><li>ALL</li></ul><p>全表扫描</p><h3 id="possible-keys和key">possible_keys和key</h3><p>possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些， key 列表示实际用到的索引有哪些</p><p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p><h3 id="key-len">key_len</h3><p>key_len 列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度, 由这三个部分构成的</p><ul><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100) ，使用的字符集是utf8 ，那么该列实际占用的最大存储空间就是100 × 3 = 300 个字节。</li><li>如果该索引列可以存储NULL 值，则key_len 比不可以存储NULL 值时多1个字节。</li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ul><p>由于id 列的类型是INT ，并且不可以存储NULL 值，所以在使用该列的索引时key_len 大小就是4 。</p><h3 id="ref">ref</h3><p>在访问方法是const 、eq_ref 、ref 、ref_or_null 、unique_subquery 、index_subquery 其中之一时， ref 列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</p><h3 id="rows">rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows 列就代表预计扫描的索引记录行数。</p><h3 id="filtered">filtered</h3><p>condition filtering 的概念, MySQL 在计算驱动表扇出时采用的一个策略</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><h3 id="Extra">Extra</h3><p>Extra 列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL 到底将如何执行给定的查询语句。</p><ul><li>No tables used</li></ul><p>当查询语句的没有FROM 子句时将会提示该额外信息</p><ul><li>Impossible WHERE</li></ul><p>查询语句的WHERE 子句永远为FALSE 时将会提示该额外信息</p><ul><li>No matching min/max row</li></ul><p>当查询列表处有MIN 或者MAX 聚集函数，但是并没有符合WHERE 子句中的搜索条件的记录时，将会提示该额外信息</p><ul><li>Using index</li></ul><p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra 列将会提示该额外信息</p><ul><li>Using index condition</li></ul><p>有些搜索条件中虽然出现了索引列，但却不能使用到索引</p><ul><li>Using where</li></ul><p>当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE 子句中有针对该表的搜索条件时，在 Extra 列中会提示上述额外信息。</p><ul><li>Using join buffer (Block Nested Loop)</li></ul><p>当被驱动表不能有效的利用索引加快访问速度， MySQL 一般会为其分配一块名叫join buffer 的内存块来加快查询速度，也就是我们所讲的基于块的嵌套循环算法</p><ul><li>Not exists</li></ul><p>当我们使用左（外）连接时，如果WHERE 子句中包含要求被驱动表的某个列等于NULL 值的搜索条件，而且那个列又是不允许存储NULL 值的，那么在该表的执行计划的Extra 列就会提示Not exists 额外信息</p><p><strong>没有必要到被驱动表中找到全部符合ON子句条件的记录</strong></p><ul><li>Using intersect(…) 、Using union(…) 和Using sort_union(…)</li></ul><p>如果执行计划的Extra 列出现了Using intersect(…) 提示，说明准备使用Intersect 索引合并的方式执行查询，括号中的… 表示需要进行索引合并的索引名称；如果出现了Using union(…) 提示，说明准备使用Union 索引合并的方式执行查询；出现了Using sort_union(…) 提示，说明准备使用Sort-Union 索引合并的方式执行查询。</p><ul><li>Zero limit</li></ul><p>当我们的LIMIT 子句的参数为0 时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息</p><ul><li>Using filesort</li></ul><p>很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序</p><p>把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：filesort ）。</p><ul><li>Using temporary</li></ul><p>如果查询中使用到了内部的临时表，在执行计划的Extra 列将会显示Using temporary 提示</p><ul><li>Start temporary, End temporary</li></ul><p>查询优化器会优先尝试将IN 子查询转换成semi-join ，而semi-join 又有好多种执行策略</p><p>当执行策略为DuplicateWeedout 时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，<br>驱动表查询执行计划的Extra 列将显示Start temporary 提示<br>被驱动表查询执行计划的 Extra 列将显示End temporary 提示</p><ul><li>LooseScan</li></ul><p>在将In 子查询转为semi-join 时，如果采用的是LooseScan 执行策略，则在驱动表执行计划的Extra 列就是显示LooseScan 提示</p><ul><li>FirstMatch(tbl_name)</li></ul><p>在将In 子查询转为semi-join 时，如果采用的是FirstMatch 执行策略，则在被驱动表执行计划的Extra列就是显示FirstMatch(tbl_name)</p><h2 id="Json格式的执行计划">Json格式的执行计划</h2><p>提供了一种查看某个执行计划花费的成本的方式</p><ul><li>read_cost 是由下边这两部分组成的<ul><li>IO 成本</li><li>检测rows × (1 - filter) 条记录的CPU 成本</li></ul></li><li>eval_cost 是这样计算的：<ul><li>检测 rows × filter 条记录的成本。</li></ul></li><li>prefix_cost 就是单独查询s1 表的成本<ul><li>read_cost + eval_cost</li></ul></li><li>data_read_per_join 表示在此次查询中需要读取的数据量</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 MySQL基于规则的优化</title>
      <link href="/database/mysql/mysql-mysql-ji-yu-gui-ze-de-you-hua/"/>
      <url>/database/mysql/mysql-mysql-ji-yu-gui-ze-de-you-hua/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 MySQL基于规则的优化</h1><h2 id="Metadata-13">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 MySQL基于规则的优化date: 2023-06-23 16:19tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 MySQL基于规则的优化</code></pre><h2 id="概述-10">概述</h2><p>把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<strong>查询重写</strong></p><ul><li>条件化简<ul><li>移除不必要的括号</li><li>常量传递（constant_propagation）</li><li>等值传递（equality_propagation）</li><li>移除没用的条件（trivial_condition_removal）</li><li>表达式计算</li><li>HAVING子句和WHERE子句的合并</li><li>常量表检测</li></ul></li><li>外连接消除<ul><li>在外连接查询中，指定的WHERE 子句中包含被驱动表中的列不为NULL 值的条件称之为空值拒绝</li><li>符合空值拒绝的条件后，外连接和内连接可以相互转换。</li><li>选出成本最低的那种连接顺序来执行查询</li></ul></li><li>子查询优化<ul><li>按返回的结果集区分子查询<ul><li>标量子查询</li><li>行子查询</li><li>列子查询</li><li>表子查询</li></ul></li><li>按与外层查询关系来区分子查询<ul><li>不相关子查询</li><li>相关子查询</li></ul></li><li>标量子查询、行子查询的执行方式<ul><li>包含不相关的标量子查询或者行子查询的查询语句<ul><li>分别独立的执行外层查询和子查询</li></ul></li><li>相关的标量子查询或者行子查询<ul><li>先从外层查询中获取一条记录，本例中也就是先从s1 表中获取一条记录。</li><li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从s1 表中获取的那条记录中找出s1.key3 列的值，然后执行子查询。</li><li>最后根据子查询的查询结果来检测外层查询WHERE 子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li><li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li></ul></li></ul></li><li>IN子查询优化<ul><li>物化表的提出<ul><li>将子查询结果集中的记录保存到临时表</li></ul></li><li>物化表转连接</li><li>将子查询转换为semi-join<ul><li>只关心在s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配</li><li>如果IN 子查询符合转换为semi-join 的条件，查询优化器会优先把该子查询为semi-join ，然后再考虑下边5种执行半连接的策略中哪个成本最低：</li><li>Table pullout （子查询中的表上拉）<ul><li>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表上拉到外层查询的FROM 子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中</li></ul></li><li>DuplicateWeedout execution strategy （重复值消除）<ul><li>可以建立一个临时表</li></ul></li><li>LooseScan execution strategy （松散索引扫描）<ul><li>只取值相同的记录的第一条去做匹配操作的方式</li></ul></li><li>FirstMatch execution strategy （首次匹配）<ul><li>先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录</li></ul></li><li>semi-join的适用条件<ul><li>该子查询必须是和IN 语句组成的布尔表达式，并且在外层查询的WHERE 或者ON 子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和IN 子查询的搜索条件必须使用AND 连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由UNION 连接起来的形式。</li><li>该子查询不能包含GROUP BY 或者HAVING 语句或者聚集函数。</li><li>… 还有一些条件比较少见，就不唠叨啦～</li></ul></li><li>不符合转换为semi-join 的条件<ul><li>先将子查询物化之后再执行查询</li><li>执行IN to EXISTS 转换。</li></ul></li></ul></li></ul></li></ul></li><li>ANY/ALL子查询优化<br><img src="/attachment/3b96bdbc57b41498b8685f778d9785a7.png" alt=""></li><li>[NOT] EXISTS子查询的执行<ul><li>可以先执行子查询，得出该[NOT] EXISTS 子查询的结果是TRUE 还是FALSE ，并重写原先的查询语句</li></ul></li><li>对于派生表的优化<ul><li>对于含有派生表的查询， MySQL 提供了两种执行策略：<ul><li>最容易想到的就是把派生表物化。</li><li>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</li></ul></li></ul></li><li>当派生表中有这些语句就不可以和外层查询合并：<ul><li>聚集函数，比如MAX()、MIN()、SUM()啥的</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>LIMIT</li><li>UNION 或者 UNION ALL</li><li>派生表对应的子查询的SELECT 子句中含有另一个子查询</li><li>… 还有些不常用的情况就不多说了哈～</li></ul></li></ul><h2 id="前言-2">前言</h2><p>设计MySQL 的大叔还是依据一些规则,竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<strong>查询重写</strong></p><h2 id="条件化简">条件化简</h2><h3 id="移除不必要的括号">移除不必要的括号</h3><p>优化器会把那些用不到的括号给干掉</p><pre><code class="language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;((a = 5 AND b = c) OR ((a &amp;gt; c) AND (c &amp;lt; 5)))&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;(a = 5 and b = c) OR (a &amp;gt; c AND c &amp;lt; 5)&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="常量传递（constant-propagation）">常量传递（constant_propagation）</h3><p>有时候某个表达式是某个列和某个常量做等值匹配. 当这个表达式和其他涉及列a 的表达式使用AND 连接起来时，可以将其他表达式中的a 的值替换为5</p><pre><code class="language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;a = 5 AND b &amp;gt; a&lt;/p&gt;&lt;/div&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;a = 5 AND b &amp;gt; 5&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="等值传递（equality-propagation）">等值传递（equality_propagation）</h3><pre><code class="language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;a = b and b = c and c = 5&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;a = 5 and b = 5 and c = 5&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="移除没用的条件（trivial-condition-removal）">移除没用的条件（trivial_condition_removal）</h3><p>对于一些明显永远为TRUE 或者FALSE 的表达式，优化器会移除掉它们</p><pre><code class="language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;(a &amp;lt; 1 and b = b) OR (a = 6 OR 5 != 5)&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;a &amp;lt; 1 OR a = 6&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="表达式计算">表达式计算</h3><pre><code class="language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;a = 5 + 1&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;a = 6&lt;/p&gt;&lt;/div&gt;</code></pre><p><strong>最好让索引列以单独的形式出现在表达式中</strong></p><h3 id="HAVING子句和WHERE子句的合并">HAVING子句和WHERE子句的合并</h3><p>如果查询语句中没有出现诸如SUM 、MAX 等等的聚集函数以及GROUP BY 子句，优化器就把HAVING 子句和WHERE 子句合并起来。</p><h3 id="常量表检测">常量表检测</h3><p>设计MySQL 的大叔觉得下边这两种查询运行的特别快：</p><ul><li>查询的表中一条记录没有，或者只有一条记录。</li><li>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</li></ul><p>把通过主键等值匹配或者唯一二级索引列等值匹配这两种方式查询的表称之为常量表（英文名： constant tables ）</p><p>优化器在分析一个查询语句时，</p><ul><li>先首先执行常量表查询</li><li>然后把查询中涉及到该表的条件全部替换成常数</li><li>最后再分析其余表的查询成本</li></ul><pre><code class="language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;SELECT * FROM table1 INNER JOIN table2ON table1.column1 = table2.column2WHERE table1.primary_key = 1;&lt;/p&gt;&lt;/div&gt;==&gt;&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2ON table1表column1列的常量值 = table2.column2;&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="外连接消除">外连接消除</h2><p>外连接和内连接的本质区别就是：<br>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃</p><p>凡是不符合WHERE子句中条件的记录都不会参与连接<br>只要我们在搜索条件中指定关于被驱动表相关列的值不为NULL ，那么外连接中在被驱动表中找不到符合ON 子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了！</p><p>我们把这种在外连接查询中，指定的WHERE 子句中包含被驱动表中的列不为NULL 值的条件称之为空值拒绝（英文名： reject-NULL ）。</p><p>在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。</p><h2 id="子查询优化">子查询优化</h2><h3 id="按返回的结果集区分子查询">按返回的结果集区分子查询</h3><p>因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型</p><ul><li><p>标量子查询<br><strong>只返回一个单一值的子查询</strong>称之为标量子查询</p></li><li><p>行子查询<br>返回一条记录的子查询，不过这条记录需要包含多个列</p></li><li><p>列子查询<br>列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录</p></li><li><p>表子查询<br>子查询的结果既包含很多条记录，又包含很多个列</p></li></ul><h3 id="按与外层查询关系来区分子查询">按与外层查询关系来区分子查询</h3><ul><li><p>不相关子查询<br>如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为不相关子查询</p></li><li><p>相关子查询<br>如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为相关子查询</p></li></ul><h3 id="子查询在布尔表达式中的使用">子查询在布尔表达式中的使用</h3><ul><li><p>使用= 、&gt; 、&lt; 、&gt;= 、&lt;= 、&lt;&gt; 、!= 、&lt;=&gt; 作为布尔表达式的操作符<br>这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录</p></li><li><p>[NOT] IN/ANY/SOME/ALL子查询</p><ul><li>IN 或者NOT IN<ul><li>操作数 [NOT] IN (子查询)</li><li>判断某个操作数在不在由子查询结果集组成的集合中</li></ul></li><li>ANY/SOME （ ANY 和SOME 是同义词）<ul><li>操作数 comparison_operator ANY/SOME(子查询)</li><li>ANY相当于判断子查询结果集中是否存在某个值和给定的操作数相等，它的含义和IN是相同的。</li></ul></li><li>ALL<ul><li>操作数 comparison_operator ALL(子查询)</li></ul></li></ul></li><li><p>EXISTS子查询</p><ul><li>仅仅需要判断子查询的结果集中是否有记录</li><li>[NOT] EXISTS (子查询)</li></ul></li></ul><h3 id="子查询语法注意事项">子查询语法注意事项</h3><ul><li>子查询必须用小括号扩起来。不扩起来的子查询是非法的</li><li>在SELECT 子句中的子查询必须是标量子查询。</li><li>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用LIMIT 1 语句来限制记录数量。</li><li>对于[NOT] IN/ANY/SOME/ALL 子查询来说，子查询中不允许有LIMIT 语句。</li><li>ORDER BY 子句 子查询的结果其实就相当于一个集合，集合里的值排不排序一点儿都不重要</li><li>DISTINCT 语句 集合里的值去不去重也没啥意义</li><li>没有聚集函数以及HAVING 子句的GROUP BY 子句。</li><li>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</li></ul><h3 id="子查询在MySQL中是怎么执行的">子查询在MySQL中是怎么执行的</h3><h4 id="前期准备">前期准备</h4><pre><code class="language-sql">CREATE TABLE single_table (id INT NOT NULL AUTO_INCREMENT,key1 VARCHAR(100),key2 INT,key3 VARCHAR(100),key_part1 VARCHAR(100),key_part2 VARCHAR(100),key_part3 VARCHAR(100),common_field VARCHAR(100),PRIMARY KEY (id),KEY idx_key1 (key1),UNIQUE KEY idx_key2 (key2),KEY idx_key3 (key3),KEY idx_key_part(key_part1, key_part2, key_part3)) Engine=InnoDB CHARSET=utf8;</code></pre><h4 id="标量子查询、行子查询的执行方式">标量子查询、行子查询的执行方式</h4><p>对于<strong>包含不相关的标量子查询或者行子查询的查询语句</strong>来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。</p><p>对于相关的标量子查询或者行子查询来说</p><ul><li>先从外层查询中获取一条记录，本例中也就是先从s1 表中获取一条记录。</li><li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从s1 表中获取的那条记录中找出s1.key3 列的值，然后执行子查询。</li><li>最后根据子查询的查询结果来检测外层查询WHERE 子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li><li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li></ul><h3 id="IN子查询优化">IN子查询优化</h3><h4 id="物化表的提出">物化表的提出</h4><p>为了优化IN 子查询倾注了太多心血</p><p>不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里</p><p><strong>写入临时表的过程</strong></p><ul><li>该临时表的列就是子查询结果集中的列。</li><li>写入临时表的记录会被去重。</li><li>一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用Memory 存储引擎的临时表，而且会为该表建立哈希索引。</li></ul><p>把这个将子查询结果集中的记录保存到临时表的过程称之为物化（英文名：Materialize ）</p><h4 id="物化表转连接">物化表转连接</h4><pre><code class="language-sql">SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');</code></pre><p>当我们把子查询进行物化之后，假设子查询物化表的名称为materialized_table ，该物化表存储的子查询结果集的列为m_val ，那么这个查询其实可以从下边两种角度来看待</p><ul><li><p>从表s1 的角度来看待，整个查询的意思其实是：对于s1 表中的每条记录来说，如果该记录的key1 列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：<br><img src="/attachment/a373317ab7e8083dfda2ee519833cf69.png" alt=""></p></li><li><p>从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在s1 表中找到对应的key1 列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：</p></li></ul><p><img src="/attachment/1fd4cf961ac0155cdf6a4591fc0f8066.png" alt=""></p><p>也就是说其实上边的查询就相当于表s1 和子查询物化表materialized_table 进行内连接</p><p>分析一下上述查询中使用外层查询的表s1 和物化表materialized_table 进行内连接的成本都是由哪几部分组成的：</p><ul><li>如果使用s1 表作为驱动表的话，总查询成本由下边几个部分组成：<ul><li>物化子查询时需要的成本</li><li>扫描s1 表时的成本</li><li>s1表中的记录数量 × 通过m_val = xxx 对materialized_table 表进行单表访问的成本（我们前边说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。</li></ul></li><li>如果使用materialized_table 表作为驱动表的话，总查询成本由下边几个部分组成：<ul><li>物化子查询时需要的成本</li><li>扫描物化表时的成本</li><li>物化表中的记录数量 × 通过key1 = xxx 对s1 表进行单表访问的成本（非常庆幸key1 列上建立了索引，所以这个步骤是非常快的）。</li></ul></li></ul><h3 id="将子查询转换为semi-join">将子查询转换为semi-join</h3><p>虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用</p><p>能不能不进行物化操作直接把子查询转换为连接呢？</p><p>我们可以分三种情况讨论：</p><ul><li>情况一：对于s1 表的某条记录来说， s2 表中没有任何记录满足s1.key1 = s2.common_field 这个条件，那么该记录自然也不会加入到最后的结果集。</li><li>情况二：对于s1 表的某条记录来说， s2 表中有且只有记录满足s1.key1 = s2.common_field 这个条件，那么该记录会被加入最终的结果集。</li><li>情况三：对于s1 表的某条记录来说， s2 表中至少有2条记录满足s1.key1 = s2.common_field 这个条件，那么该记录会被多次加入最终的结果集。</li></ul><p>由于我们只关心s2 表中是否存在记录满足s1.key1 = s2.common_field 这个条件，而不关心具体有多少条记录与之匹配，又因为有情况三的存在，我们上边所说的IN 子查询和两表连接之间并不完全等价。</p><p>提出了一个新概念 — 半连接（英文名： semi-join ）。将s1 表和s2 表进行半连接的意思就是</p><p>对于s1 表的某条记录来说，我们只关心在s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留s1 表的记录。</p><h4 id="怎么实现这种所谓的半连接呢？">怎么实现这种所谓的半连接呢？</h4><p><strong>Table pullout （子查询中的表上拉）</strong></p><p>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表上拉到外层查询的FROM 子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中</p><pre><code class="language-ad-example">&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;原始&lt;/p&gt;&lt;p&gt;SELECT * FROM s1WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = 'a');&lt;/p&gt;&lt;/div&gt;由于key2 列是s2 表的唯一二级索引列，所以我们可以直接把s2 表上拉到外层查询的FROM 子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，上拉之后的查询就是这样的：&lt;style&gt;.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info&gt;.admonition-title, .todo&gt;.admonition-title {  background-color: rgba(0,184,212,.1);}.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {  background-color: rgba(255,145,0,.1);}.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition&gt;:last-child {  margin-bottom: 0 !important;}&lt;/style&gt;&lt;div class="admonition note"&gt;&lt;p class="admonition-title"&gt;优化&lt;/p&gt;&lt;p&gt;SELECT s1.* FROM s1 INNER JOIN s2ON s1.key2 = s2.key2WHERE s2.key3 = 'a';&lt;/p&gt;&lt;/div&gt;</code></pre><p><strong>主键或者唯一索引列中的数据本身就是不重复</strong></p><p><strong>DuplicateWeedout execution strategy （重复值消除）</strong></p><p>s1 表中的某条记录可能在s2 表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表</p><p><strong>LooseScan execution strategy （松散索引扫描）</strong></p><p>在子查询中，对于s2 表的访问可以使用到key1 列的索引，而恰好子查询的查询列表处就是key1 列，这样在将该查询转换为半连接查询后，如果将s2 作为驱动表执行查询的话，那么执行过程就是这样</p><p><img src="/attachment/1dce000b49353f37f1c133ac69533d4e.png" alt=""></p><p>虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为<strong>松散索引扫描</strong>。</p><p><strong>Semi-join Materialization execution strategy</strong></p><p>先把外层查询的IN 子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种semi-join ，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。</p><p><strong>FirstMatch execution strategy （首次匹配）</strong></p><p>先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。</p><h4 id="semi-join的适用条件">semi-join的适用条件</h4><p>只有形如这样的查询才可以被转换为semi-join ：</p><pre><code class="language-sql">SELECT ... FROM outer_tablesWHERE expr IN (SELECT ... FROM inner_tables ...) AND ...</code></pre><p>或者这样的形式也可以：</p><pre><code class="language-sql">SELECT ... FROM outer_tablesWHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...</code></pre><p>用文字总结一下，只有符合下边这些条件的子查询才可以被转换为semi-join ：</p><ul><li>该子查询必须是和IN 语句组成的布尔表达式，并且在外层查询的WHERE 或者ON 子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和IN 子查询的搜索条件必须使用AND 连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由UNION 连接起来的形式。</li><li>该子查询不能包含GROUP BY 或者HAVING 语句或者聚集函数。</li><li>… 还有一些条件比较少见，就不唠叨啦～</li></ul><h4 id="不适用于semi-join的情况">不适用于semi-join的情况</h4><ul><li>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用OR 连接起来</li></ul><pre><code class="language-ad-example">```sqlSELECT * FROM s1WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a')OR key2 &gt; 100;```</code></pre><ul><li>使用NOT IN 而不是IN 的情况</li></ul><pre><code class="language-ad-example">```sqlSELECT * FROM s1WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = 'a')```</code></pre><ul><li>在SELECT 子句中的IN子查询的情况</li></ul><pre><code class="language-ad-example">```sqlSELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a') FROM s1 ;```</code></pre><ul><li>子查询中包含GROUP BY 、HAVING 或者聚集函数的情况</li></ul><pre><code class="language-ad-example">```sqlSELECT * FROM s1WHERE key2 IN (SELECT COUNT(*) FROM s2 GROUP BY key1);```</code></pre><ul><li>子查询中包含UNION 的情况</li></ul><pre><code class="language-ad-example">```sqlSELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a'UNIONSELECT common_field FROM s2 WHERE key3 = 'b');```</code></pre><h4 id="MySQL-仍然留了两手绝活来优化不能转为semi-join-查询的子查询">MySQL 仍然留了两手绝活来优化不能转为semi-join 查询的子查询</h4><ul><li><p>对于不相关子查询来说，可以尝试把它们物化之后再参与查询</p></li><li><p>不管子查询是相关的还是不相关的，都可以把IN 子查询尝试转为EXISTS 子查询</p></li></ul><h4 id="小结一下">小结一下</h4><p>如果IN 子查询符合转换为semi-join 的条件，查询优化器会优先把该子查询为semi-join ，然后再考虑下边5种执行半连接的策略中哪个成本最低：</p><ul><li>Table pullout</li><li>DuplicateWeedout</li><li>LooseScan</li><li>Materialization</li><li>FirstMatch<br>选择成本最低的那种执行策略来执行子查询。</li></ul><p>如果IN 子查询不符合转换为semi-join 的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：</p><ul><li>先将子查询物化之后再执行查询</li><li>执行IN to EXISTS 转换。</li></ul><h3 id="ANY-ALL子查询优化">ANY/ALL子查询优化</h3><p><img src="/attachment/3b96bdbc57b41498b8685f778d9785a7.png" alt=""></p><h3 id="NOT-EXISTS子查询的执行">[NOT] EXISTS子查询的执行</h3><p>如果[NOT] EXISTS 子查询是不相关子查询，可以先执行子查询，得出该[NOT] EXISTS 子查询的结果是TRUE 还是FALSE ，并重写原先的查询语句</p><h3 id="对于派生表的优化">对于派生表的优化</h3><p>我们前边说过把子查询放在外层查询的FROM 子句后，那么这个子查询的结果相当于一个派生表</p><p>对于含有派生表的查询， MySQL 提供了两种执行策略：</p><ul><li>最容易想到的就是把派生表物化。</li><li>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</li></ul><p>当派生表中有这些语句就不可以和外层查询合并：</p><ul><li>聚集函数，比如MAX()、MIN()、SUM()啥的</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>LIMIT</li><li>UNION 或者 UNION ALL</li><li>派生表对应的子查询的SELECT 子句中含有另一个子查询</li><li>… 还有些不常用的情况就不多说了哈～</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB 的统计数据收集</title>
      <link href="/database/mysql/mysql-innodb-de-tong-ji-shu-ju-shou-ji/"/>
      <url>/database/mysql/mysql-innodb-de-tong-ji-shu-ju-shou-ji/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 InnoDB 的统计数据收集</h1><h2 id="Metadata-7">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 InnoDB 的统计数据收集date: 2023-06-23 15:44tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 InnoDB 的统计数据收集</code></pre><h2 id="概述-5">概述</h2><ul><li>InnoDB 以<strong>表</strong>为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</li><li><strong>innodb_stats_persistent</strong> 控制着<strong>是否使用永久性统计数据</strong>；</li><li><strong>innodb_stats_persistent_sample_pages</strong> 控制着<strong>永久性统计数据</strong>的<strong>采样页面数量</strong>；</li><li><strong>innodb_stats_transient_sample_pages</strong> 控制着<strong>非永久性统计数据</strong>的<strong>采样页面数量</strong>；</li><li><strong>innodb_stats_auto_recalc</strong> 控制着<strong>是否自动重新计算统计数据</strong>。</li><li>我们可以针对某个具体的表，在创建和修改表时通过指定STATS_PERSISTENT 、STATS_AUTO_RECALC 、STATS_SAMPLE_PAGES 的值来控制相关统计数据属性。</li><li><strong>innodb_stats_method</strong> 决定着在<strong>统计某个索引列不重复值的数量时如何对待NULL 值</strong>。</li></ul><h2 id="前言">前言</h2><p>通过SHOW TABLE STATUS 可以看到关于表的统计数据<br>通过SHOW INDEX 可以看到关于索引的统计数据</p><h2 id="两种不同的统计数据存储方式">两种不同的统计数据存储方式</h2><ul><li><p>永久性的统计数据<br>这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</p></li><li><p>非永久性的统计数据<br>这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了</p></li></ul><p>提供了系统变量innodb_stats_persistent 来控制到底采用哪种方式去存储统计数据</p><p><strong>InnoDB 默认是以表为单位来收集和存储统计数据的</strong></p><p>也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。</p><p>在创建和修改表的时候通过指定STATS_PERSISTENT 属性来指明该表的统计数据存储方式</p><pre><code class="language-sql">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);</code></pre><h2 id="基于磁盘的永久性统计数据">基于磁盘的永久性统计数据</h2><p>当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里</p><p><img src="/attachment/0ca6e36a8dad1f0eae419e6308dcca56.png" alt=""></p><p>这两个表都位于mysql 系统数据库下边</p><ul><li>innodb_table_stats 存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li>innodb_index_stats 存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><h3 id="innodb-table-stats">innodb_table_stats</h3><p><img src="/attachment/4502734aa98c041b96d32642ce726350.png" alt=""><br>注意这个表的主键是(database_name,table_name)</p><p><strong>innodb_table_stats表的每条记录代表着一个表的统计信息</strong></p><p>几个重要统计信息项的值如下：</p><ul><li>n_rows 的值是9693 ，表明single_table 表中大约有9693 条记录，注意这个数据是估计值。</li><li>clustered_index_size 的值是97 ，表明single_table 表的聚簇索引占用97个页面，这个值是也是一个估计值。</li><li>sum_of_other_index_sizes 的值是175 ，表明single_table 表的其他索引一共占用175个页面，这个值是也是一个估计值。</li></ul><h4 id="n-rows统计项的收集">n_rows统计项的收集</h4><p>n_rows 这个统计项的值是估计值</p><p>InnoDB 统计一个表中有多少行记录的套路:</p><ul><li>按照一定算法（并不是纯粹随机的）选取几个叶子节点页面</li><li>计算每个页面中主键值记录数量</li><li>然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的n_rows 值。</li></ul><p>n_rows 值精确与否取决于统计时采样的页面数量</p><p>准备了一个名为innodb_stats_persistent_sample_pages 的系统变量来<strong>控制使用永久性的统计数据时，计算统计数据时采样的页面数量</strong>。<br>该系统变量的默认值是20</p><h4 id="clustered-index-size和sum-of-other-index-sizes统计项的收集">clustered_index_size和sum_of_other_index_sizes统计项的收集</h4><p>这两个统计项的收集过程如下：</p><ul><li>从数据字典里找到表的各个索引对应的根页面位置。<br>系统表SYS_INDEXES 里存储了各个索引对应的根页面信息。</li><li>从根页面的Page Header 里找到叶子节点段和非叶子节点段对应的Segment Header 。<br>在每个索引的根页面的Page Header 部分都有两个字段：<ul><li>PAGE_BTR_SEG_LEAF ：表示B+树叶子段的Segment Header 信息。</li><li>PAGE_BTR_SEG_TOP ：表示B+树非叶子段的Segment Header 信息。</li></ul></li><li>从叶子节点段和非叶子节点段的Segment Header 中找到这两个段对应的INODE Entry 结构。</li><li>从对应的INODE Entry 结构中可以找到该段对应所有零散的页面地址以及FREE 、NOT_FULL 、FULL 链表的基节点。</li><li>直接统计零散的页面有多少个，然后从那三个链表的List Length 字段中读出该段占用的区的大小，每个区占用64 个页，所以就可以统计出整个段占用的页面。</li><li>分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数,<ul><li>它们的和就是clustered_index_size 的值</li><li>按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是sum_of_other_index_sizes 的值。</li></ul></li></ul><p>以<strong>区为单位申请空间中有一些页可能并没有使用</strong>，但是在统计clustered_index_size 和 sum_of_other_index_sizes 时都把它们算进去了，所以说聚簇索引和其他的索引占用的页面数可能比这两个值要小一些。</p><h3 id="innodb-index-stats">innodb_index_stats</h3><p><img src="/attachment/6008aa7dab16d26450bebd56b1559528.png" alt=""></p><p>注意这个表的主键是(database_name,table_name,index_name,stat_name)</p><p>其中的stat_name 是指统计项的名称，也就是说innodb_index_stats表的每条记录代表着一个索引的一个统计项。</p><p>正确查看这个结果的方式是这样的：</p><ul><li>先查看index_name 列，这个列说明该记录是哪个索引的统计信息</li><li>针对index_name 列相同的记录， stat_name 表示针对该索引的统计项名称， stat_value 展示的是该索引在该统计项上的值， stat_description 指的是来描述该统计项的含义的。<ul><li>n_leaf_pages 该索引的叶子节点占用多少页面</li><li>size 表示该索引共占用多少页面。</li><li>n_diff_pfxNN 表示对应的索引列不重复的值有多少</li></ul></li><li>在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样， size 列就表明了采样的页面数量是多少。</li></ul><h3 id="定期更新统计数据">定期更新统计数据</h3><p>提供了如下两种更新统计数据的方式：</p><ul><li>开启innodb_stats_auto_recalc 。<br>系统变量innodb_stats_auto_recalc 决定着服务器是否自动重新计算统计数据，它的默认值是ON ，也就是该功能默认是开启的。<br>过自动重新计算统计数据的过程是异步发生的</li><li>手动调用ANALYZE TABLE 语句来更新统计信息</li><li>ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的</li></ul><h3 id="手动更新innodb-table-stats-和innodb-index-stats-表">手动更新innodb_table_stats 和innodb_index_stats 表</h3><p>手动更新某个表或者索引的统计数据</p><p>步骤一：更新innodb_table_stats 表。<br>步骤二：让MySQL 查询优化器重新加载我们更改过的数据。</p><h2 id="基于内存的非永久性统计数据">基于内存的非永久性统计数据</h2><p>系统变量innodb_stats_persistent 的值设置为OFF<br>直接在创建表或修改表时设置STATS_PERSISTENT 属性的值为0</p><p>由于非永久性的统计数据经常更新，所以导致MySQL 查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会生成<strong>经常变化的执行计划</strong></p><h2 id="innodb-stats-method的使用">innodb_stats_method的使用</h2><p>索引列不重复的值的数量这个统计数据对于MySQL 查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行</p><p>它的应用场景主要有两个</p><ul><li>单表查询中单点区间太多<br>直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量</li><li>连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用ref 访问方法来对被驱动表进行查询</li></ul><p>他们提供了一个名为innodb_stats_method 的系统变量，相当于在计算某个索引列不重复值的数量时如何对待NULL 值这个锅甩给了用户，这个系统变量有三个候选值：</p><ul><li>nulls_equal ：认为所有NULL 值都是相等的。</li><li>nulls_unequal ：认为所有NULL 值都是不相等的。</li><li>nulls_ignored ：直接把NULL 值忽略掉。</li></ul><p>最好不在索引列中存放NULL值才是正解</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 MySQL基于成本的优化</title>
      <link href="/database/mysql/mysql-mysql-ji-yu-cheng-ben-de-you-hua/"/>
      <url>/database/mysql/mysql-mysql-ji-yu-cheng-ben-de-you-hua/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 MySQL基于成本的优化</h1><h2 id="Metadata-12">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 MySQL基于成本的优化date: 2023-06-23 13:57tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 MySQL基于成本的优化</code></pre><h2 id="什么是成本">什么是成本</h2><h3 id="I-O-成本">I/O 成本</h3><p>从磁盘到内存这个加载的过程损耗的时间</p><h3 id="CPU-成本">CPU 成本</h3><p>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间</p><p>规定读取一个页面花费的成本默认是1.0 ，读取以及检测一条记录是否符合搜索条件的成本默认是0.2 。</p><h2 id="单表查询的成本">单表查询的成本</h2><h3 id="准备工作">准备工作</h3><pre><code class="language-sql">CREATE TABLE single_table (id INT NOT NULL AUTO_INCREMENT,key1 VARCHAR(100),key2 INT,key3 VARCHAR(100),key_part1 VARCHAR(100),key_part2 VARCHAR(100),key_part3 VARCHAR(100),common_field VARCHAR(100),PRIMARY KEY (id),KEY idx_key1 (key1),UNIQUE KEY idx_key2 (key2),KEY idx_key3 (key3),KEY idx_key_part(key_part1, key_part2, key_part3)) Engine=InnoDB CHARSET=utf8;</code></pre><h3 id="基于成本的优化步骤">基于成本的优化步骤</h3><p>MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<strong>执行计划</strong>，之后才会调用存储引擎提供的接口真正的执行查询</p><h4 id="1-根据搜索条件，找出所有可能使用的索引">1. 根据搜索条件，找出所有可能使用的索引</h4><p>把一个查询中可能使用到的索引称之为possible keys</p><h4 id="2-计算全表扫描的代价">2. 计算全表扫描的代价</h4><p>全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集</p><p>由于查询成本= I/O 成本+ CPU 成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><p>提供了SHOW TABLE STATUS 语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的LIKE 语句就好</p><pre><code class="language-sql">SHOW TABLE STATUS LIKE 'single_table'</code></pre><ul><li>Rows 本选项表示表中的记录条数。</li><li>Data_length 本选项表示表占用的存储空间字节数。<ul><li>Data_length = 聚簇索引的页面数量 x 每个页面的大小</li><li>页数 = Data_length / 页占用空间字节数</li></ul></li></ul><p>对于single_table 的全表扫描所需的总成本 = I/O 成本 + CPU 成本 = 页数 * 1.0 (加载一个页面的成本常数) + 1.1(偏移值) + ROW * 0.2 (读取一条记录的成本常数) + 1.0(微调值)</p><h4 id="3-计算使用不同索引执行查询的代价">3. 计算使用不同索引执行查询的代价</h4><p>下边我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p><pre><code class="language-sql">SELECT * FROM single_table WHEREkey1 IN ('a', 'b', 'c') ANDkey2 &gt; 10 AND key2 &lt; 1000 ANDkey3 &gt; key2 ANDkey_part1 LIKE '%hello%' ANDcommon_field = '123';</code></pre><h5 id="range">range</h5><ul><li>使用idx_key2执行查询的成本分析</li></ul><p><img src="/attachment/6f54658c205985ac9ef486424ce0fdd9.png" alt=""></p><ul><li>范围数量<br>查询优化器粗暴的认为读取索引的一个范围区间的I/O成本和读取一个页面是相同的</li></ul><p><img src="/attachment/86e2a448589112c2f07e8f3d50b86c5f.png" alt=""></p><ul><li><p>需要回表的记录数</p></li><li><p>步骤1：访问一下idx_key2 对应的B+ 树索引</p><ul><li>区间最左记录</li><li>区间最右记录<ul><li>每次最多跨10页</li><li>计算页b 和页c 之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录</li></ul></li><li>读取二级索引记录需要付出的CPU 成本= 需要读取的二级索引记录条数 * 0.2 (读取记录的成本)  + 0.01 (微调值)</li></ul></li><li><p>步骤2: 根据这些记录里的主键值到聚簇索引中做回表操作</p><ul><li>粗略计算： 每次回表操作都相当于访问一个页面<ul><li>需要读取的二级索引记录条数 * 1 (读取一个页面所需时间成本) + 0.1 (微调值)</li></ul></li><li>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立</li></ul></li></ul><h5 id="In">In</h5><ul><li>使用idx_key1执行查询的成本分析</li></ul><p><img src="/attachment/7e0ed677f04e40adc1f6fcd65c8c19a9.png" alt=""></p><ul><li>范围区间数量</li></ul><p>使用idx_key1 执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I/O成本就是：<br>3 x 1.0 = 3.0</p><ul><li>需要回表的记录数</li></ul><h5 id="是否有可能使用索引合并（Index-Merge）">是否有可能使用索引合并（Index Merge）</h5><h4 id="4-对比各种执行方案的代价，找出成本最低的那一个">4. 对比各种执行方案的代价，找出成本最低的那一个</h4><p>下边把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p><ul><li>全表扫描的成本： 2037.7</li><li>使用idx_key2 的成本： 134.01</li><li>使用idx_key1 的成本： 168.21<br>很显然，使用idx_key2 的成本最低，所以当然选择idx_key2 来执行查询喽。</li></ul><h3 id="基于索引统计数据的成本计算">基于索引统计数据的成本计算</h3><p>这种通过直接访问索引对应的B+ 树来计算某个范围区间对应的索引记录条数的方式称之为index dive 。</p><p>系统变量  eq_range_index_dive_limit</p><p>小于该值将使用index dive 的方式计算各个单点区间对应的记录条数</p><p>查看一下single_table 的各个索引的统计数据</p><pre><code class="language-sql">SHOW INDEX FROM single_table;</code></pre><p><img src="/attachment/e1da7a29877c93da11c456c2b657a456.png" alt=""></p><h2 id="连接查询的成本">连接查询的成本</h2><h3 id="准备工作-2">准备工作</h3><p>连接查询至少是要有两个表的，只有一个single_table 表是不够的，所以为了故事的顺利发展，我们直接构造一个和single_table 表一模一样的single_table2 表。为了简便起见，我们把single_table 表称为s1 表，把single_table2 表称为s2 表。</p><h3 id="Condition-filtering介绍">Condition filtering介绍</h3><p>MySQL 中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次</p><p>所以对于两表连接查询来说，它的查询成本由下边两个部分构成</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本 (具体查询多少次取决于对驱动表查询的结果集中有多少条记录)</li></ul><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的扇出（英文名： fanout ）</p><h3 id="两表连接的成本分析">两表连接的成本分析</h3><p>连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</p><pre><code class="language-sql">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2ON s1.key1 = s2.common_fieldWHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 ANDs2.key2 &gt; 1000 AND s2.key2 &lt; 2000;</code></pre><p>对于内连接来说，可以选择的连接顺序有两种：</p><ul><li>s1 连接s2 ，也就是s1 作为驱动表， s2 作为被驱动表。</li><li>s2 连接s1 ，也就是s2 作为驱动表， s1 作为被驱动表。</li></ul><p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。</p><p>定性的分析一下</p><ul><li>使用single_table 作为驱动表时的总成本, 使用s1 作为驱动表的情况<ul><li>分析对于驱动表的成本最低的执行方案<ul><li>看一下涉及s1 表单表的搜索条件有哪些</li></ul></li><li>然后分析对于被驱动表的成本最低的执行方案</li><li>使用idx_key2访问s1的成本 + s1的扇出 × 使用idx_key2访问s2的成本</li></ul></li><li>使用s2 作为驱动表的情况<ul><li>分析对于驱动表的成本最低的执行方案<ul><li>看一下涉及s2 表单表的搜索条件有哪些</li></ul></li><li>然后分析对于被驱动表的成本最低的执行方案</li><li>使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本</li></ul></li><li>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。</li><li>优化重点其实是下边这两个部分<ul><li>尽量减少驱动表的扇出</li><li>对被驱动表的访问成本尽量低</li></ul></li></ul><p><strong>尽量在被驱动表的连接列上建立索引</strong></p><h2 id="多表连接的成本分析">多表连接的成本分析</h2><p>对于n 表连接的话，则有 n × (n-1) × (n-2) × ··· × 1 种连接顺序，就是n的阶乘种连接顺序，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> 。</p><p>有n 个表进行连接， MySQL 查询优化器要每一种连接顺序的成本都计算一遍,  减少计算非常多种连接顺序的成本的方法</p><h3 id="提前结束某种顺序的成本评估">提前结束某种顺序的成本评估</h3><p>在计算各种链接顺序的成本之前，会维护一个全局的变量, 这个变量表示当前最小的连接查询成本。</p><p>MySQL 在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。<br>如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本</p><h3 id="系统变量optimizer-search-depth">系统变量optimizer_search_depth</h3><p>如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与 optimizer_search_depth 值相同数量的表进行穷举分析</p><h3 id="根据某些规则压根儿就不考虑某些连接顺序">根据某些规则压根儿就不考虑某些连接顺序</h3><p>启发式规则  就是根据以往经验指定的一些规则</p><p>凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划</p><p>提供了一个系统变量optimizer_prune_level 来控制到底是不是用这些启发式规则。</p><h2 id="调节成本常数">调节成本常数</h2><p>两个成本常数：</p><ul><li>读取一个页面花费的成本默认是1.0</li><li>检测一条记录是否符合搜索条件的成本默认是0.2</li></ul><p>其实除了这两个成本常数， MySQL 还支持好多呢，它们被存储到了mysql 数据库</p><p>一条语句的执行其实是分为两层的：</p><ul><li>server 层</li><li>存储引擎层</li></ul><p>在server 层进行连接管理、查询缓存、语法解析、查询优化等操作，<br>在存储引擎层执行具体的数据存取操作。</p><p>关于这些操作对应的成本常数就存储在了server_cost 表中<br>而依赖于存储引擎的一些操作对应的成本常数就存储在了 engine_cost 表中。</p><h3 id="mysql-server-cost表">mysql.server_cost表</h3><p>server_cost 表中在server 层进行的一些操作对应的<strong>成本常数</strong></p><p><img src="/attachment/edd07cf61391169590ec85d5b73bcdd7.png" alt=""></p><ul><li>cost_name<br>表示成本常数的名称。</li><li>cost_value<br>表示成本常数对应的值。如果该列的值为NULL 的话，意味着对应的成本常数会采用默认值。</li><li>last_update<br>表示最后更新记录的时间。</li><li>comment<br>注释。</li></ul><p>从server_cost 中的内容可以看出来，目前在server 层的一些操作对应的成本常数有以下几种</p><p><img src="/attachment/9003480538d207d6f71c5cf562b83054.png" alt=""></p><p>MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。</p><p>在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，<br>在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。</p><p>这些成本常数在server_cost 中的初始值都是NULL ，意味着优化器会使用它们的默认值来计算某个操作的成本</p><p>如果我们想修改某个成本常数的值的话，需要做两个步骤：</p><ul><li>对我们感兴趣的成本常数做更新操作</li><li>让系统重新加载这个表的值。</li></ul><pre><code class="language-sql">FLUSH OPTIMIZER_COSTS;</code></pre><h3 id="mysql-engine-cost表">mysql.engine_cost表</h3><p>engine_cost表表中在存储引擎层进行的一些操作对应的成本常数</p><p><img src="/attachment/f33176d14ac03c55626dac3402e9008f.png" alt=""></p><p>与server_cost 相比， engine_cost 多了两个列：</p><ul><li>engine_name 列  指成本常数适用的存储引擎名称。</li><li>device_type 列  指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在MySQL 5.7.21 这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是0 。</li></ul><p>我们从engine_cost 表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p><p><img src="/attachment/03f6727e70a9aa4c47a0eb0946dc6922.png" alt=""></p><p>通过为engine_cost 表插入新记录的方式来添加只针对某种存储引擎的成本常数</p><ul><li>插入针对某个存储引擎的成本常数</li><li>让系统重新加载这个表的值。</li></ul><pre><code class="language-sql">FLUSH OPTIMIZER_COSTS;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 连接的原理</title>
      <link href="/database/mysql/mysql-lian-jie-de-yuan-li/"/>
      <url>/database/mysql/mysql-lian-jie-de-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 连接的原理</h1><h2 id="Metadata-21">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 连接的原理date: 2023-06-23 13:26tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 连接的原理</code></pre><h2 id="概述-16">概述</h2><h3 id="连接简介：">连接简介：</h3><ul><li>连接的本质是通过<strong>笛卡尔积</strong>将两个表中的记录相互匹配组合。</li><li>连接过程涉及<strong>单表条件</strong>和<strong>涉及两表条件</strong>。</li><li>连接查询的执行过程包括<strong>确定驱动表</strong>和<strong>在驱动表和被驱动表之间查找匹配记录</strong>。</li><li>连接分为<strong>内连接</strong>和<strong>外连接</strong>，内连接<strong>只返回匹配的记录</strong>，而外连接会<strong>包括未匹配的记录</strong>。</li><li>外连接可以进一步细分为<strong>左外连接</strong>和<strong>右外连接</strong>。</li></ul><h3 id="连接的原理总结：">连接的原理总结：</h3><ul><li><strong>嵌套循环连接</strong>是一种连接算法，驱动表<strong>只访问一次</strong>，而被驱动表可能<strong>被多次访问</strong>。</li><li>使用<strong>索引</strong>可以<strong>加快连接速度</strong>。</li><li><strong>基于块的嵌套循环连接</strong>是优化的方法，通过减少被驱动表的访问次数来提高性能。</li><li>基于块的嵌套循环连接使用<strong>join buffer来加载驱动表的记录</strong>，然后一次性和被驱动表的多条记录进行匹配，减少了磁盘访问的开销。<ul><li>执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer 中</li><li>然后开始扫描被驱动表</li><li>每一条<strong>被驱动表</strong>的记录<strong>一次性</strong>和join buffer 中的<strong>多条驱动表记录</strong>做匹配</li><li>因为匹配的过程都是在内存中完成的</li></ul></li><li>基于块的嵌套循环连接也被称为Block Nested-Loop Join算法。</li></ul><p><img src="/attachment/d93fa06115d169691620716bb78a1bfb.png" alt=""></p><p><img src="/attachment/39872bfec9f8904fd7b28497b0ae04c1.png" alt=""></p><h2 id="连接简介">连接简介</h2><h3 id="连接的本质">连接的本质</h3><p><strong>笛卡尔积</strong></p><p>连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合</p><h3 id="连接过程简介">连接过程简介</h3><ul><li>涉及单表的条件</li><li>涉及两表的条件</li></ul><h4 id="这个连接查询的大致执行过程">这个连接查询的大致执行过程</h4><ol><li>首先确定第一个需要查询的表，这个表称之为驱动表</li><li>针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到t2 表中查找匹配的记录，所谓匹配的记录，指的是符合过滤条件的记录。</li></ol><h3 id="内连接和外连接">内连接和外连接</h3><ul><li>对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。</li><li>对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。<br>在MySQL 中，根据选取驱动表的不同，外连接仍然可以细分为2种：</li><li>左外连接<ul><li>选取左侧的表为驱动表。</li></ul></li><li>右外连接<ul><li>选取右侧的表为驱动表。</li></ul></li></ul><h4 id="外连接的语法">外连接的语法</h4><p>对于左（外）连接和右（外）连接来说，必须使用ON 子句来指出连接条件。</p><h4 id="内连接的语法">内连接的语法</h4><p><strong>内连接和外连接的根本区别</strong></p><p>内连接和外连接的根本区别就是<strong>在驱动表中的记录不符合ON 子句中的连接条件时不会把该记录加入到最后的结果集</strong></p><p>由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句</p><p>对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。</p><p>左外连接和右外连接的驱动表和被驱动表不能轻易互换</p><h2 id="连接的原理">连接的原理</h2><h3 id="嵌套循环连接（Nested-Loop-Join）">嵌套循环连接（Nested-Loop Join）</h3><p>驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数</p><p><img src="/attachment/d93fa06115d169691620716bb78a1bfb.png" alt=""></p><h3 id="使用索引加快连接速度">使用索引加快连接速度</h3><h3 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）">基于块的嵌套循环连接（Block Nested-Loop Join）</h3><pre><code class="language-ad-question">采用嵌套循环连接算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访</code></pre><p>尽量减少访问被驱动表的次数</p><p>在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了</p><h4 id="join-buffer-的概念">join buffer 的概念</h4><ul><li>执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer 中</li><li>然后开始扫描被驱动表</li><li>每一条被驱动表的记录一次性和join buffer 中的多条驱动表记录做匹配</li><li>因为匹配的过程都是在内存中完成的</li></ul><p><img src="/attachment/39872bfec9f8904fd7b28497b0ae04c1.png" alt=""></p><p>这种加入了join buffer 的嵌套循环连接算法称之为基于块的嵌套连接（Block Nested-Loop Join）算法。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 单表访问方法</title>
      <link href="/database/mysql/mysql-dan-biao-fang-wen-fang-fa/"/>
      <url>/database/mysql/mysql-dan-biao-fang-wen-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 单表访问方法</h1><h2 id="Metadata-17">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 单表访问方法date: 2023-06-22 23:07tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 单表访问方法</code></pre><h2 id="概述-12">概述</h2><ul><li>MySQL Server使用<strong>查询优化器</strong>对查询语句进行优化，生成执行计划。</li><li>单表查询的访问方法主要有两种：<strong>全表扫描</strong>和<strong>使用索引</strong>。<ul><li>全表扫描通过<strong>逐行扫描表中的记录</strong>来找到符合搜索条件的记录。</li><li>使用索引可以细分为多种类型，如针对主键或唯一二级索引的等值查询、普通二级索引的等值查询、索引列的范围查询和直接扫描整个索引等。<ul><li><strong>const</strong>访问方法是通过<strong>主键</strong>或<strong>唯一二级索引</strong>来定位一条记录，具有<strong>常数级别</strong>的访问代价。</li><li><strong>ref</strong>访问方法适用于<strong>普通二级索引</strong>，其访问代价取决于<strong>等值匹配到的二级索引记录条数</strong>。</li><li><strong>ref_or_null</strong>访问方法是针对<strong>二级索引列值为NULL的情况</strong>。</li><li><strong>range</strong>访问方法用于处理使用<strong>IN操作符</strong>或<strong>范围查询</strong>的情况。</li><li><strong>index</strong>访问方法是直接通过<strong>遍历索引</strong>的叶子节点来执行查询，适用于查询列表只涉及<strong>索引列</strong>且搜索条件<strong>只包含索引中的列</strong>的情况。</li><li><strong>all</strong>访问方法是<strong>全表扫描</strong>的方式执行查询。</li></ul></li></ul></li><li>在使用二级索引进行查询时，需要注意二级索引+回表的操作，回表操作是在找到索引记录后再根据<strong>主键</strong>获取<strong>完整的用户记录</strong>进行进一步过滤。</li><li>对于range访问方法，需要<strong>明确定义范围区间</strong>，利用索引列和常数的比较操作符来构建区间。</li><li>索引合并有<strong>Intersection合并</strong>和<strong>Union合并</strong>两种方式，Intersection合并适用于多个<strong>二级索引的等值匹配</strong>，Union合并适用于<strong>多个二级索引的并集操作</strong>，<strong>Sort-Union合并</strong>用于<strong>多个二级索引查询结果的排序和合并</strong>。</li><li><strong>联合索引</strong>可以替代<strong>Intersection索引合并</strong>的方式。</li></ul><h2 id="【MySQL】-单表访问方法-2">【MySQL】 单表访问方法</h2><p>MySQL Server 有一个称为查询优化器的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的执行计划</p><h2 id="访问方法（access-method）的概念">访问方法（access method）的概念</h2><p>对于单个表的查询来说，设计MySQL的大叔把查询的执行方式大致分为下边两种：</p><h3 id="使用全表扫描进行查询">使用全表扫描进行查询</h3><p>把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。</p><h3 id="使用索引进行查询">使用索引进行查询</h3><p>使用索引来执行查询的方式五花八门，又可以细分为许多种类：</p><ul><li>针对主键或唯一二级索引的等值查询</li><li>针对普通二级索引的等值查询</li><li>针对索引列的范围查询</li><li>直接扫描整个索引</li></ul><p>MySQL 执行查询语句的方式称之为访问方法或者访问类型</p><h2 id="const">const</h2><pre><code class="language-sql">SELECT * FROM single_table WHERE id = 1438;</code></pre><pre><code class="language-sql">SELECT * FROM single_table WHERE key2 = 3841;</code></pre><pre><code class="language-sql">SELECT * FROM single_table WHERE key2 IS NULL;</code></pre><ul><li><strong>聚簇索引</strong></li><li><strong>唯一二级索引</strong></li></ul><p><img src="/attachment/a3fefae543a2f483ea40fe628cebc6cb.png" alt=""></p><p>B+ 树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的B+ 树叶子节点中的记录就是按照id 列排序的。</p><p>把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为： const ，意思是常数级别的，代价是可以忽略不计的</p><h2 id="ref-2">ref</h2><pre><code class="language-sql">SELECT * FROM single_table WHERE key1 = 'abc';</code></pre><p><strong>普通的二级索引</strong></p><p><img src="/attachment/effbdcf15338511e7ba11bae78d0fd45.png" alt=""></p><p>使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数</p><ul><li>二级索引列值为NULL 的情况</li></ul><p>采用key IS NULL 这种形式的搜索条件最多只能使用ref 的访问方法，而不是const 的访问方法。</p><p>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用ref的访问方法</p><h2 id="ref-or-null">ref_or_null</h2><pre><code class="language-sql">SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;</code></pre><p><img src="/attachment/5b912954932cdcdd69aaba1da5ef1eca.png" alt=""></p><h2 id="range-2">range</h2><pre><code class="language-sql">SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79);</code></pre><h2 id="index">index</h2><pre><code class="language-sql">SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';</code></pre><p>这个查询符合下边这两个条件：</p><ul><li>它的查询列表只有3个列： key_part1 , key_part2 , key_part3 ，而索引idx_key_part 又包含这三个列。</li><li>搜索条件中只有key_part2 列。这个列也包含在索引idx_key_part 中。</li></ul><p>可以直接通过遍历idx_key_part 索引的叶子节点的记录来比较key_part2 = ‘abc’ 这个条件是否成立</p><p>把匹配成功的二级索引记录的key_part1 , key_part2 , key_part3 列的值直接加到结果集中就行了。</p><h2 id="all">all</h2><p>全表扫描执行查询的方式称之为： all 。</p><h2 id="注意事项">注意事项</h2><h3 id="重温-二级索引-回表">重温 二级索引 + 回表</h3><p>因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用idx_key1 索引进行查询时只会用到与key1 列有关的搜索条件，其余条件，比如key2 &gt; 1000 这个条件在步骤1中是用不到的，只有在步骤2完成<strong>回表操作后</strong>才能继续针对完整的用户记录中继续过滤。</p><h3 id="明确range访问方法使用的范围区间">明确range访问方法使用的范围区间</h3><p>其实对于B+ 树索引来说，只要索引列和常数使用= 、&lt;=&gt; 、IN 、NOT IN 、IS NULL 、IS NOT NULL 、&gt; 、&lt; 、&gt;= 、&lt;= 、BETWEEN 、!= （不等于也可以写成&lt;&gt; ）或者LIKE 操作符连接起来，就可以产生一个所谓的区间。</p><h3 id="索引合并">索引合并</h3><h4 id="Intersection合并">Intersection合并</h4><p>在二级索引列都是等值匹配的情况下才可能使用Intersection 索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。</p><p><strong>读取多个二级索引后取交集</strong></p><h4 id="Union合并">Union合并</h4><p><strong>读取多个二级索引后取集</strong></p><p>采用Union 索引合并的方式把 Or 连接的两个主键集合取并集，然后进行回表操作，将结果返回给用户。</p><pre><code class="language-sql">SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');</code></pre><ul><li>先按照搜索条件key1 = ‘a’ AND key3 = ‘b’ 从索引idx_key1 和idx_key3 中使用Intersection 索引合并的方式得到一个主键集合。</li><li>再按照搜索条件key_part1 = ‘a’ AND key_part2 = ‘b’ AND key_part3 = ‘c’ 从联合索引idx_key_part 中得到另一个主键集合。</li><li>采用Union 索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li></ul><h4 id="Sort-Union合并">Sort-Union合并</h4><p><strong>读取多个二级索引后对结果按主键排序并返回合并</strong></p><pre><code class="language-sql">SELECT * FROM single_table WHERE key1 &lt; 'a' OR key3 &gt; 'z'</code></pre><ul><li>先根据key1 &lt; ‘a’ 条件从idx_key1 二级索引总获取记录，并按照记录的主键值进行排序</li><li>再根据key3 &gt; ‘z’ 条件从idx_key3 二级索引总获取记录，并按照记录的主键值进行排序</li><li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和Union 索引合并方式就一样了。</li></ul><h4 id="联合索引替代Intersection索引合并">联合索引替代Intersection索引合并</h4>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB的表空间</title>
      <link href="/database/mysql/mysql-innodb-de-biao-kong-jian/"/>
      <url>/database/mysql/mysql-innodb-de-biao-kong-jian/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 InnoDB的表空间</h1><h2 id="Metadata-9">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 InnoDB的表空间date: 2023-06-22 05:36tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 InnoDB的表空间</code></pre><h2 id="概述-7">概述</h2><p><img src="/attachment/58b87e5bda10eaf0599a9f58b8bf8ba3.png" alt=""></p><h3 id="独立表空间">独立表空间</h3><ol><li><strong>区</strong>: 连续的<strong>64</strong>个页就是一个区，也就是说一个区默认占用1MB空间大小。每<strong>256</strong>个区被划分成一组。<ul><li>第一个组最开始的3个页面的类型是固定的，也就是说extent 0 这个区最开始的3个页面的类型是固定的，分别是：<ul><li><strong>FSP_HDR</strong> 类型: 这个类型的页面是用来登记<strong>整个表空间的一些整体属性以及本组所有的区</strong>，也就是extent 0 ~ extent 255 这256个区的属性</li><li><strong>IBUF_BITMAP</strong> 类型: 这个类型的页面是存储本组所有的区的所有页面关于<strong>INSERT BUFFER 的信息</strong>。</li><li><strong>INODE</strong> 类型: 这个类型的页面存储了许多称为INODE 的数据结构</li></ul></li><li>其余各组最开始的2个页面的类型是固定的，也就是说extent 256 、extent 512 这些区最开始的2个页面的类型是固定的，分别是：<ul><li><strong>XDES 类型</strong>: 全称是extent descriptor ，用来登记<strong>本组256个区的属性</strong>，对于在extent 256区中的该类型页面存储的就是extent 256 ~ extent 511 这些区的属性</li><li><strong>IBUF_BITMAP</strong> 类型： 这个类型的页面是存储本组所有的区的所有页面关于<strong>INSERT BUFFER 的信息</strong>。</li></ul></li></ul></li><li><strong>段</strong>: 一个索引会生成<strong>2</strong>个段，一个叶子节点段，一个非叶子节点段。 定义了一个INODE Entry 结构来记录一下段中的属性<ul><li><strong>Segment ID</strong>  这个INODE Entry 结构对应的<strong>段的编号</strong>（ID）</li><li><strong>NOT_FULL_N_USED</strong> 是在<strong>NOT_FULL 链表中已经使用了多少个页面</strong>。下次从NOT_FULL 链表分配空闲页面时可以直接根据这个字段的值定位到。</li><li><strong>3个List Base Node</strong> 分别为段的<strong>FREE 链表</strong>、<strong>NOT_FULL 链表</strong>、<strong>FULL 链表定义了List Base Node</strong></li><li><strong>Magic Number</strong> 用来标记这个INODE Entry <strong>是否已经被初始化</strong>了</li><li><strong>Fragment Array Entry</strong> 每个Fragment Array Entry 结构都对应着一个零散的页面，这个结构一共4个字节，<strong>表示一个零散页面的页号</strong>。</li></ul></li><li><strong>碎片（fragment）区</strong> 有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于</li><li>区的分类<ul><li><strong>FREE</strong> <strong>空闲的区</strong></li><li><strong>FREE_FRAG</strong> **有剩余空间的碎片区</li><li><strong>FULL_FRAG</strong> <strong>没有剩余空间的碎片区</strong></li><li><strong>FSEG</strong> <strong>附属于某个段的区</strong></li></ul></li><li>XDES Entry  是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：<ul><li>Segment ID （8字节） 每一个段都有一个唯一的编号，用ID表示，此处的Segment ID 字段表示就是该区所在的段。</li><li>List Node （12字节） 这个部分可以将若干个XDES Entry 结构串联成一个链表</li><li>State （4字节）这个字段表明区的状态。</li><li>Page State Bitmap （16字节） 一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。</li></ul></li><li>链表基节点  每个链表都对应这么一个List Base Node 结构<ul><li>List Length 表明该链表一共有多少节点，</li><li>First Node Page Number 和First Node Offset 表明该链表的头节点在表空间中的位置。</li><li>Last Node Page Number 和Last Node Offset 表明该链表的尾节点在表空间中的位置。</li></ul></li></ol><h3 id="系统表空间">系统表空间</h3><ol><li>系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面<ul><li>某个表属于哪个表空间，表里边有多少列</li><li>表对应的每一个列的类型是什么</li><li>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li><li>该表有哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li><li>balabala … 还有好多，不一一列举了</li></ul></li><li>SYS_TABLES表</li><li>SYS_COLUMNS表</li><li>SYS_FIELDS表</li><li>Data Dictionary Header页面<ol><li>Max Row ID: 我们生成一个名为row_id 的列作为主键，这个Max Row ID 是全局共享的</li><li>Max Table ID: InnoDB存储引擎中的所有的索引都对应一个唯一的ID</li><li>Max Space ID: InnoDB存储引擎中的所有的表空间都对应一个唯一的ID</li><li>Root of SYS_TABLES clust index ：本字段代表SYS_TABLES 表聚簇索引的根页面的页号。</li><li>Root of SYS_TABLE_IDS sec index ：本字段代表SYS_TABLES 表为ID 列建立的二级索引的根页面的页号。</li><li>Root of SYS_COLUMNS clust index ：本字段代表SYS_COLUMNS 表聚簇索引的根页面的页号。</li><li>Root of SYS_INDEXES clust index： 本字段代表SYS_INDEXES 表聚簇索引的根页面的页号。</li><li>Root of SYS_FIELDS clust index ： 本字段代表SYS_FIELDS 表聚簇索引的根页面的页号。</li></ol></li></ol><h2 id="独立表空间结构">独立表空间结构</h2><h3 id="区（extent）的概念">区（extent）的概念</h3><p>对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小。</p><p>每256个区被划分成一组。</p><p><img src="/attachment/7826e02e37b4826849c68183be4516f3.png" alt=""></p><p>第一个组最开始的3个页面的类型是固定的，也就是说extent 0 这个区最开始的3个页面的类型是固定的，分别是：</p><ul><li>FSP_HDR 类型: 这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区，也就是extent 0 ~ extent 255 这256个区的属性</li><li>IBUF_BITMAP 类型: 这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER 的信息。</li><li>INODE 类型: 这个类型的页面存储了许多称为INODE 的数据结构</li></ul><p>其余各组最开始的2个页面的类型是固定的，也就是说extent 256 、extent 512 这些区最开始的2个页面的类型是固定的，分别是：</p><ul><li>XDES 类型: 全称是extent descriptor ，用来登记本组256个区的属性，对于在extent 256区中的该类型页面存储的就是extent 256 ~ extent 511 这些区的属性</li><li>IBUF_BITMAP 类型： 这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER 的信息。</li></ul><h3 id="段（segment）的概念">段（segment）的概念</h3><p>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。</p><p>叶子节点有自己独有的区，非叶子节点也有自己独有的区。</p><p>存放叶子节点的区的集合就算是一个段（ segment ），存放非叶子节点的区的集合也算是一个段。</p><p>说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><p>为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况</p><p>设计InnoDB 的大叔们提出了一个碎片（fragment）区的概念</p><p>在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于</p><p>碎片区直属于表空间，并不属于任何一个段。</p><p>此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。</li></ul><h3 id="区的分类">区的分类</h3><ul><li>FREE 空闲的区: 现在还没有用到这个区中的任何页面。</li><li>FREE_FRAG 有剩余空间的碎片区: 表示碎片区中还有可用的页面。</li><li>FULL_FRAG 没有剩余空间的碎片区: 表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>FSEG 附属于某个段的区: 每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li></ul><p>这4种类型的区也可以被称为区的4种状态（ State ）</p><p>处于FREE 、FREE_FRAG 以及FULL_FRAG 这三种状态的区都是独立的，算是直属于表空间；而处于FSEG 状态的区是附属于某个段的。</p><p>为了方便管理这些区，设计InnoDB 的大叔设计了一个称为XDES Entry 的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个XDES Entry 结构</p><p><img src="/attachment/7adf50f3da76f6069a9c7045ea3d4f70.png" alt=""></p><p>XDES Entry 是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：</p><ul><li>Segment ID （8字节）<br>每一个段都有一个唯一的编号，用ID表示，此处的Segment ID 字段表示就是该区所在的段。</li><li>List Node （12字节）<br>这个部分可以将若干个XDES Entry 结构串联成一个链表</li><li>State （4字节）<br>这个字段表明区的状态。</li><li>Page State Bitmap （16字节）<br>一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。</li></ul><h4 id="XDES-Entry链表">XDES Entry链表</h4><ul><li>当段中数据较少的时候，会进行以下操作：<ul><li>首先查看表空间中是否有状态为FREE_FRAG的区；</li><li>如果找到了FREE_FRAG的区，从该区中取一些零碎的页，将数据插入其中；</li><li>如果没有找到FREE_FRAG的区，则在表空间下申请一个状态为FREE的区；</li><li>将新申请的区的状态变为FREE_FRAG，并从该区中取一些零碎的页，将数据插入其中。</li></ul></li><li>不同的段在使用零碎页的时候，都会从上述区中取；</li><li>直到该区中没有空闲空间，该区的状态变为FULL_FRAG。</li></ul><p><strong>ListNode 的作用</strong></p><ul><li>把状态为FREE的区对应的XDESEntry结构通过ListNode来连接成一个链表，这个链表我们就称之为FREE链表。</li><li>把状态为FREE_FRAG的区对应的XDESEntry结构通过ListNode来连接成一个链表，这个链表我们就称之为FREE_FRAG链表。</li><li>把状态为FULL_FRAG的区对应的XDESEntry结构通过ListNode来连接成一个链表，这个链表我们就称之为FULL_FRAG链表。</li></ul><p>为每个段中的区对应的XDES Entry 结构建立了三个链表：</p><ul><li>FREE 链表：同一个段中，所有页面都是空闲的区对应的XDES Entry 结构会被加入到这个链表。注意和直属于表空间的FREE 链表区别开了，此处的FREE 链表是附属于某个段的。</li><li>NOT_FULL 链表：同一个段中，仍有空闲空间的区对应的XDES Entry 结构会被加入到这个链表。</li><li>FULL 链表：同一个段中，已经没有空闲空间的区对应的XDES Entry 结构会被加入到这个链表。</li></ul><p><strong>每一个索引都对应两个段，每个段都会维护上述的3个链表</strong></p><p><strong>链表基节点</strong></p><p>这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息</p><p><img src="/attachment/c31d0bbe7b1eccc674b804560f2bca85.png" alt=""></p><p>每个链表都对应这么一个List Base Node 结构</p><ul><li>List Length 表明该链表一共有多少节点，</li><li>First Node Page Number 和First Node Offset 表明该链表的头节点在表空间中的位置。</li><li>Last Node Page Number 和Last Node Offset 表明该链表的尾节点在表空间中的位置。</li></ul><h3 id="段的结构">段的结构</h3><p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念</p><p>定义了一个INODE Entry 结构来记录一下段中的属性</p><p><img src="/attachment/6c02f38231695f30338aa4ba235bce89.png" alt=""></p><ul><li>Segment ID<br>这个INODE Entry 结构对应的段的编号（ID）</li><li>NOT_FULL_N_USED<br>是在NOT_FULL 链表中已经使用了多少个页面。<br>下次从NOT_FULL 链表分配空闲页面时可以直接根据这个字段的值定位到。</li><li>3个List Base Node<br>分别为段的FREE 链表、NOT_FULL 链表、FULL 链表定义了List Base Node</li><li>Magic Number<br>用来标记这个INODE Entry 是否已经被初始化了</li><li>Fragment Array Entry<br>每个Fragment Array Entry 结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号。</li></ul><h3 id="各类型页面详细情况">各类型页面详细情况</h3><h4 id="FSP-HDR-类型">FSP_HDR 类型</h4><p>表空间的第一个页面，页号为0 。这个页面的类型是FSP_HDR</p><p>存储了表空间的一些整体属性以及第一个组内256个区的对应的XDES Entry 结构</p><p><img src="/attachment/ec35f4f158da1a180071733a659d37cd.png" alt=""></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38 字节</td><td>页的一些通用信息</td></tr><tr><td>File Space Header</td><td>表空间头部</td><td>112字节</td><td>表空间的一些整体属性信息</td></tr><tr><td>XDES Entry</td><td>区描述信息</td><td>10240字节</td><td>存储本组256个区对应的属性信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>5986字节</td><td>“用于页结构的填充,没啥实际意义”</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><h5 id="File-Space-Header部分">File Space Header部分</h5><p>用来存储表空间的一些整体属性的</p><p><img src="/attachment/88af70ee1666e4a9704abb4445e38d34.png" alt=""></p><table><thead><tr><th>占用空间大小</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Space ID</td><td>4 字节</td><td>表空间的ID</td></tr><tr><td>Not Used</td><td>4字节</td><td>“这4个字节未被使用,可以忽略”</td></tr><tr><td>Size</td><td>4字节</td><td>当前表空间占有的页面数</td></tr><tr><td>FREE Limit</td><td>4字节</td><td>“尚未被初始化的最小页号,大于或等于这个页号的区对应的XDES Entry结构都 没有被加入FREE链表”</td></tr><tr><td>Space Flags</td><td>4字节</td><td>表空间的一些占用存储空间比较小的属性</td></tr><tr><td>FRAG_N_USED</td><td>4字节</td><td>FREE_FRAG链表中已使用的页面数量</td></tr><tr><td>List Base Node for FREE List</td><td>16字节</td><td>FREE链表的基节点</td></tr><tr><td>List Base Node for FREE_FRAG List</td><td>16 字节</td><td>FREE_FREG链表的基节点</td></tr><tr><td>List Base Node for FULL_FRAG List</td><td>16 字节</td><td>FULL_FREG链表的基节点</td></tr><tr><td>Next Unused Segment ID</td><td>8字节</td><td>当前表空间中下一个未使用的 Segment ID</td></tr><tr><td>List Base Node for SEG_INODES_FULL List</td><td>16 字节</td><td>SEG_INODES_FULL链表的基节点</td></tr><tr><td>List Base Node for SEG_INODES_FREE List</td><td>16 字节</td><td>SEG_INODES_FREE链表的基节点</td></tr></tbody></table><h4 id="XDES-Entry部分">XDES Entry部分</h4><p>每一个XDES Entry 结构对应表空间的一个区</p><p>每组开头的一个页面记录着本组内所有的区对应的XDES Entry 结构。</p><p>整个表空间的第一个页面，记录本组中的所有区对应的XDES Entry 结构以外，还记录着表空间的一些整体属性，这个页面的类型就是我们刚刚说完的FSP_HDR 类型，整个表空间里只有一个这个类型的页面</p><p>除去第一个分组以外，之后的每个分组的第一个页面只需要记录本组内所有的区对应的XDES Entry 结构即可</p><p><img src="/attachment/4d0015af51df048b598e73f8a207ef35.png" alt=""></p><h4 id="IBUF-BITMAP-类型">IBUF_BITMAP 类型</h4><p>每个分组的第二个页面的类型都是IBUF_BITMAP</p><p>这种类型的页里边记录了一些有关Change Buffer 的东东</p><h4 id="INODE-类型">INODE 类型</h4><p>第一个分组的第三个页面的类型是INODE</p><p>为了方便管理，他们又为每个段设计了一个INODE Entry 结构，这个结构中记录了关于这个段的相关属性。</p><p>undefined</p><p>从图中可以看出，一个INODE 类型的页面是由这几部分构成的：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38 字节</td><td>页的一些通用信息</td></tr><tr><td>List Node for INODE Page List</td><td>通用链表节点</td><td>12字节</td><td>存储上一个INODE页面和下一个INODE页面的指针</td></tr><tr><td>INODE Entry</td><td>段描述信息</td><td>16128 字节</td><td></td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>6字节</td><td>“用于页结构的填充,没啥实际意义”</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><ul><li>SEG_INODES_FULL 链表<br>该链表中的INODE 类型的页面中已经没有空闲空间来存储额外的INODE Entry 结构了。</li><li>SEG_INODES_FREE 链表<br>该链表中的INODE 类型的页面中还有空闲空间来存储额外的INODE Entry 结构了。</li></ul><p>每当我们新创建一个段（创建索引时就会创建段）时，都会创建一个INODE Entry 结构与之对应，存储INODE Entry 的大致过程就是这样的：</p><ul><li>先看看SEG_INODES_FREE 链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的INODE 类型的页面，然后把该INODE Entry 结构防到该页面中。当该页面中无剩余空间时，就把该页放到SEG_INODES_FULL 链表中。</li><li>如果SEG_INODES_FREE 链表为空，则需要从表空间的FREE_FRAG 链表中申请一个页面，修改该页面的类型为INODE ，把该页面放到SEG_INODES_FREE 链表中，与此同时把该INODE Entry 结构放入该页面。</li></ul><h3 id="Segment-Header-结构的运用">Segment Header 结构的运用</h3><p><img src="/attachment/cf2886d6e955e46601662f5555432d0a.png" alt=""></p><p>其中的PAGE_BTR_SEG_LEAF 和PAGE_BTR_SEG_TOP 都占用10个字节，它们其实对应一个叫Segment Header 的结构，该结构图示如下：</p><p><img src="/attachment/cad75f83be354bc4960254cc7d86585e.png" alt=""></p><p><img src="/attachment/f0b5af1dd75ed98ca0a9dd7b267c8de5.png" alt=""></p><h2 id="系统表空间-2">系统表空间</h2><h3 id="系统表空间的整体结构">系统表空间的整体结构</h3><p>系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面</p><p><img src="/attachment/2306403ee0ed146539c0dbe329a92ada.png" alt=""></p><p><img src="/attachment/d175479644e7e8e81d3803c9154c1f74.png" alt=""></p><h4 id="InnoDB数据字典">InnoDB数据字典</h4><p>MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息</p><ul><li>某个表属于哪个表空间，表里边有多少列</li><li>表对应的每一个列的类型是什么</li><li>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li><li>该表有哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li><li>balabala … 还有好多，不一一列举了</li></ul><p>为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为元数据</p><p>InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些元数据：</p><p><img src="/attachment/445f3431f591b892d0cf687c5bd94bcd.png" alt=""></p><p>这些系统表也被称为数据字典，它们都是以B+ 树的形式保存在系统表空间的某些页面</p><h5 id="SYS-TABLES表">SYS_TABLES表</h5><p><img src="/attachment/bf7a562b1d38b08e9fbca21758846d39.png" alt=""></p><p>这个SYS_TABLES 表有两个索引</p><ul><li>以NAME 列为主键的聚簇索引</li><li>以ID 列建立的二级索引</li></ul><h5 id="SYS-COLUMNS表">SYS_COLUMNS表</h5><p><img src="/attachment/bd4d295084678e8102e2d823577771fa.png" alt=""><br><img src="/attachment/c253da09781dc1ef2563f29cdd421265.png" alt=""></p><h5 id="SYS-FIELDS表">SYS_FIELDS表</h5><p><img src="/attachment/145baea6638cb72ba441953fe55f639c.png" alt=""></p><h5 id="Data-Dictionary-Header页面">Data Dictionary Header页面</h5><p><img src="/attachment/6c85e8f3959cfbf84213dfa84a6e5323.png" alt=""></p><ul><li>Max Row ID:</li></ul><p>如果我们不显式的为表定义主键，而且表中也没有UNIQUE 索引<br>InnoDB 存储引擎会默认为我们生成一个名为row_id 的列作为主键。</p><p>不论哪个拥有row_id 列的表插入一条记录时，该记录的row_id 列的值就是Max Row ID 对应的值，然后再把Max Row ID 对应的值加1，也就是说这个Max Row ID 是全局共享的。</p><ul><li>Max Table ID</li></ul><p>InnoDB存储引擎中的所有的表都对应一个唯一的ID<br>每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。</p><ul><li>Max Index ID</li></ul><p>InnoDB存储引擎中的所有的索引都对应一个唯一的ID<br>每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。</p><ul><li>Max Space ID</li></ul><p>InnoDB存储引擎中的所有的表空间都对应一个唯一的ID<br>每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。</p><ul><li>Root of SYS_TABLES clust index ：</li></ul><p>本字段代表SYS_TABLES 表聚簇索引的根页面的页号。</p><ul><li>Root of SYS_TABLE_IDS sec index ：</li></ul><p>本字段代表SYS_TABLES 表为ID 列建立的二级索引的根页面的页号。</p><ul><li>Root of SYS_COLUMNS clust index ：</li></ul><p>本字段代表SYS_COLUMNS 表聚簇索引的根页面的页号。</p><ul><li>Root of SYS_INDEXES clust index</li></ul><p>本字段代表SYS_INDEXES 表聚簇索引的根页面的页号。</p><ul><li>Root of SYS_FIELDS clust index</li></ul><p>本字段代表SYS_FIELDS 表聚簇索引的根页面的页号。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/database/db-sql/db-sql/"/>
      <url>/database/db-sql/db-sql/</url>
      
        <content type="html"><![CDATA[<h1>DB SQL Overview</h1><pre><code class="language-ccard">type: folder_brief_livestyle: stripnoteOnly: true</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/database/mongodb/mongodb/"/>
      <url>/database/mongodb/mongodb/</url>
      
        <content type="html"><![CDATA[<h1>MongoDB Overview</h1><pre><code class="language-ccard">type: folder_brief_livestyle: stripnoteOnly: true</code></pre><h2 id="知识体系">知识体系</h2><p><img src="/attachment%5Ce07d7cf8dddf07f87d2c3eb506345ef8.png" alt></p><h2 id="MongoDB生态">MongoDB生态</h2><p><img src="/attachment%5C0face0d5be5fc99622615abfaaa99120.png" alt></p><p><img src="/attachment%5Cf93af37338bd72e59606ca5b525c75c8.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数接口 Function</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-function/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-function/</url>
      
        <content type="html"><![CDATA[<h1>函数接口 Function</h1><h2 id="Metadata-57">Metadata</h2><pre><code class="language-yml">title: 函数接口 Functiondate: 2023-02-21 10:52tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: java.util.function.Function  接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</code></pre><h2 id="函数接口-Function">函数接口 Function</h2><p><code>java.util.function.Function&lt;T,R&gt;</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p><pre><code class="language-java">package java.util.function;import java.util.Objects;/** * Represents a function that accepts one argument and produces a result. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is {@link #apply(Object)}. * * @param &lt;T&gt; the type of the input to the function * @param &lt;R&gt; the type of the result of the function * * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; {    /**     * Applies this function to the given argument.     *     * @param t the function argument     * @return the function result     */    R apply(T t);    /**     * Returns a composed function that first applies the {@code before}     * function to its input, and then applies this function to the result.     * If evaluation of either function throws an exception, it is relayed to     * the caller of the composed function.     *     * @param &lt;V&gt; the type of input to the {@code before} function, and to the     *           composed function     * @param before the function to apply before this function is applied     * @return a composed function that first applies the {@code before}     * function and then applies this function     * @throws NullPointerException if before is null     *     * @see #andThen(Function)     */    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {        Objects.requireNonNull(before);        return (V v) -&gt; apply(before.apply(v));    }    /**     * Returns a composed function that first applies this function to     * its input, and then applies the {@code after} function to the result.     * If evaluation of either function throws an exception, it is relayed to     * the caller of the composed function.     *     * @param &lt;V&gt; the type of output of the {@code after} function, and of the     *           composed function     * @param after the function to apply after this function is applied     * @return a composed function that first applies this function and then     * applies the {@code after} function     * @throws NullPointerException if after is null     *     * @see #compose(Function)     */    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; after.apply(apply(t));    }    /**     * Returns a function that always returns its input argument.     *     * @param &lt;T&gt; the type of the input and output objects to the function     * @return a function that always returns its input argument     */    static &lt;T&gt; Function&lt;T, T&gt; identity() {        return t -&gt; t;    }}</code></pre><h3 id="抽象方法-apply">抽象方法:apply</h3><p>Function 接口中最主要的抽象方法为: <code>R apply(T t) </code>，根据类型T的参数获取类型R的结果。 使用的场景例如:将 String 类型转换为 Integer 类型。</p><pre><code class="language-java">public class Demo {    private static void method(Function&lt;String, Integer&gt; function) {        int num = function.apply("10");        System.out.println(num + 20);    }    public static void main(String[] args) {        method(s -&gt; Integer.parseInt(s));    }}</code></pre><p>当然，最好是通过方法引用的写法。</p><h3 id="默认方法-andThen-2">默认方法:andThen</h3><p>Function 接口中有一个默认的 andThen 方法，用来进行组合操作。</p><p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多:</p><pre><code class="language-java">public class Demo {    private static void method(Function&lt;String, Integer&gt; one,                               Function&lt;Integer, Integer&gt; two) {        int num = one.andThen(two).apply("10");        System.out.println(num + 20);    }    public static void main(String[] args) {        method(str -&gt; Integer.parseInt(str) + 10, i -&gt; i *= 10);    }}</code></pre><p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。</p><p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p><h2 id="自定义函数模型拼接">自定义函数模型拼接</h2><p>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为:</p><ul><li>String str = “张二三,20”</li><li>将字符串截取数字年龄部分，得到字符串;</li><li>将上一步的字符串转换成为int类型的数字;</li><li>将上一步的int数字累加10，得到结果int数字。</li></ul><pre><code class="language-java">public class Demo {    public static void main(String[] args) {        String str = "张二三,20";        int age = getAgeNum(str, s -&gt; s.split(",")[1],                s -&gt; Integer.parseInt(s),                n -&gt; n += 100);        System.out.println(age);    }    private static int getAgeNum(String str, Function&lt;String, String&gt; one,                                 Function&lt;String, Integer&gt; two,                                 Function&lt;Integer, Integer&gt; three) {        return one.andThen(two).andThen(three).apply(str);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数接口 Predicate</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-predicate/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-predicate/</url>
      
        <content type="html"><![CDATA[<h1>函数接口 Predicate</h1><h2 id="Metadata-59">Metadata</h2><pre><code class="language-yml">title: 函数接口 Predicatedate: 2023-02-21 10:47tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: 有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 java.util.function.Predicate  接口。</code></pre><h2 id="函数接口-Predicate-2">函数接口 Predicate</h2><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code> 接口。接口定义如下：</p><pre><code class="language-java">package java.util.function;import java.util.Objects;/** * Represents a predicate (boolean-valued function) of one argument. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is {@link #test(Object)}. * * @param &lt;T&gt; the type of the input to the predicate * * @since 1.8 */@FunctionalInterfacepublic interface Predicate&lt;T&gt; {    /**     * Evaluates this predicate on the given argument.     *     * @param t the input argument     * @return {@code true} if the input argument matches the predicate,     * otherwise {@code false}     */    boolean test(T t);    /**     * Returns a composed predicate that represents a short-circuiting logical     * AND of this predicate and another.  When evaluating the composed     * predicate, if this predicate is {@code false}, then the {@code other}     * predicate is not evaluated.     *     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed     * to the caller; if evaluation of this predicate throws an exception, the     * {@code other} predicate will not be evaluated.     *     * @param other a predicate that will be logically-ANDed with this     *              predicate     * @return a composed predicate that represents the short-circuiting logical     * AND of this predicate and the {@code other} predicate     * @throws NullPointerException if other is null     */    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {        Objects.requireNonNull(other);        return (t) -&gt; test(t) &amp;&amp; other.test(t);    }    /**     * Returns a predicate that represents the logical negation of this     * predicate.     *     * @return a predicate that represents the logical negation of this     * predicate     */    default Predicate&lt;T&gt; negate() {        return (t) -&gt; !test(t);    }    /**     * Returns a composed predicate that represents a short-circuiting logical     * OR of this predicate and another.  When evaluating the composed     * predicate, if this predicate is {@code true}, then the {@code other}     * predicate is not evaluated.     *     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed     * to the caller; if evaluation of this predicate throws an exception, the     * {@code other} predicate will not be evaluated.     *     * @param other a predicate that will be logically-ORed with this     *              predicate     * @return a composed predicate that represents the short-circuiting logical     * OR of this predicate and the {@code other} predicate     * @throws NullPointerException if other is null     */    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {        Objects.requireNonNull(other);        return (t) -&gt; test(t) || other.test(t);    }    /**     * Returns a predicate that tests if two arguments are equal according     * to {@link Objects#equals(Object, Object)}.     *     * @param &lt;T&gt; the type of arguments to the predicate     * @param targetRef the object reference with which to compare for equality,     *               which may be {@code null}     * @return a predicate that tests if two arguments are equal according     * to {@link Objects#equals(Object, Object)}     */    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) {        return (null == targetRef)                ? Objects::isNull                : object -&gt; targetRef.equals(object);    }}</code></pre><h3 id="抽象方法-test">抽象方法:test</h3><p>Predicate 接口中包含一个抽象方法: boolean test(T t) 。用于条件判断的场景:</p><pre><code class="language-java">public class Demo {    private static void method(Predicate&lt;String&gt; predicate) {        boolean veryLong = predicate.test("HelloWorld");        System.out.println("字符串很长吗:" + veryLong);    }    public static void main(String[] args) {        method(s -&gt; s.length() &gt; 5);    }}</code></pre><p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。</p><h3 id="默认方法-and">默认方法:and</h3><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实 现“并且”的效果时，可以使用default方法 and 。</p><p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么:</p><pre><code class="language-java">public class Demo {    private static void method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) {        boolean isValid = one.and(two).test("Helloworld");        System.out.println("字符串符合要求吗:" + isValid);    }    public static void main(String[] args) {        method(s -&gt; s.contains("H"), s -&gt; s.contains("W"));    }}</code></pre><h3 id="默认方法-or">默认方法:or</h3><p>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。</p><p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变:</p><pre><code class="language-java">public class Demo {    private static void method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) {        boolean isValid = one.or(two).test("Helloworld");        System.out.println("字符串符合要求吗:" + isValid);    }    public static void main(String[] args) {        method(s -&gt; s.contains("H"), s -&gt; s.contains("W"));    }}</code></pre><h3 id="默认方法-negate">默认方法:negate</h3><p>“与”、“或”已经了解了，剩下的“非”(取反)也会简单。</p><p>从上面的实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前调用 negate 方法，正如 and 和 or 方法一样:</p><pre><code class="language-java">public class Demo {    private static void method(Predicate&lt;String&gt; predicate) {        boolean veryLong = predicate.negate().test("HelloWorld");        System.out.println("字符串很长吗:" + veryLong);    }    public static void main(String[] args) {        method(s -&gt; s.length() &lt; 5);    }}</code></pre><h2 id="作用-4">作用</h2><h3 id="集合信息筛选测试">集合信息筛选测试</h3><p>数组当中有多条“姓名+性别”的信息如下，通过 Predicate 接口的拼装将符合要求的字符串筛选到集合 ArrayList 中，需要同时满足两个条件:</p><ul><li>性别必须为女</li><li>姓名为3个字</li></ul><pre><code class="language-java">public class Demo {    public static void main(String[] args) {        String[] array = {"张三,女", "李四五,女", "李四六,男", "张二三,女"};        List&lt;String&gt; list = filter(array,                s -&gt; "女".equals(s.split(",")[1]),                s -&gt; s.split(",")[0].length() == 3);        System.out.println(list);    }    private static List&lt;String&gt; filter(String[] array, Predicate&lt;String&gt; one,                                       Predicate&lt;String&gt; two) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        for (String info : array) {            if (one.and(two).test(info)) {                list.add(info);            }        }        return list;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数接口 Consumer</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-consumer/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-consumer/</url>
      
        <content type="html"><![CDATA[<h1>函数接口 Consumer</h1><h2 id="Metadata-56">Metadata</h2><pre><code class="language-yml">title: 函数接口 Consumerdate: 2023-02-21 10:34tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: java.util.function.Consumer 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据， 其数据类型由泛型决定。</code></pre><h2 id="函数接口-Consumer-2">函数接口 Consumer</h2><p><strong>consumer</strong><br>英 [kənˈsjuːmə®] 美 [kənˈsuːmər]</p><p>n. 消费者；用户，顾客</p><p><code>java.util.function.Consumer&lt;T&gt;</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据， 其数据类型由泛型决定。</p><pre><code class="language-java">package java.util.function;import java.util.Objects;/** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, {@code Consumer} is expected * to operate via side-effects. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is {@link #accept(Object)}. * * @param &lt;T&gt; the type of the input to the operation * * @since 1.8 */@FunctionalInterfacepublic interface Consumer&lt;T&gt; {    /**     * Performs this operation on the given argument.     *     * @param t the input argument     */    void accept(T t);    /**     * Returns a composed {@code Consumer} that performs, in sequence, this     * operation followed by the {@code after} operation. If performing either     * operation throws an exception, it is relayed to the caller of the     * composed operation.  If performing this operation throws an exception,     * the {@code after} operation will not be performed.     *     * @param after the operation to perform after this operation     * @return a composed {@code Consumer} that performs in sequence this     * operation followed by the {@code after} operation     * @throws NullPointerException if {@code after} is null     */    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; { accept(t); after.accept(t); };    }}</code></pre><h3 id="抽象方法-accept">抽象方法:accept</h3><p>Consumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。基本使用如下:</p><pre><code class="language-java">public class Demo {    private static void consumeString(Consumer&lt;String&gt; function) {        function.accept("Hello");    }    public static void main(String[] args) {        consumeString(s -&gt; System.out.println(s));    }}</code></pre><p>当然，更好的写法是使用方法引用。</p><h3 id="默认方法-andThen">默认方法:andThen</h3><p>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果:消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法 andThen 。下面是JDK的源代码:</p><pre><code class="language-java"> default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; { accept(t); after.accept(t); };    }</code></pre><blockquote><p>java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p></blockquote><p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组合的情况:</p><pre><code class="language-java">public class Demo {    private static void consumeString(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two) {        one.andThen(two).accept("Hello");    }        public static void main(String[] args) {        consumeString(                s -&gt; System.out.println(s.toUpperCase()),                s -&gt; System.out.println(s.toLowerCase()));    }}</code></pre><p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的 组合。</p><h2 id="作用-2">作用</h2><h3 id="格式化打印信息">格式化打印信息</h3><p>下面的字符串数组当中存有多条信息，请按照格式“ 姓名:XX。性别:XX。 ”的格式将信息打印出来。要求将打印姓名的动作作为第一个 Consumer 接口的Lambda实例，将打印性别的动作作为第二个 Consumer 接口的Lambda实 例，将两个 Consumer 接口按照顺序“拼接”到一起。</p><pre><code class="language-java">public class Demo {    public static void main(String[] args) {        String[] array = {"张三,女", "李四,女", "王五,男"};        printInfo(                s -&gt; System.out.print("姓名:" + s.split(",")[0]),                s -&gt; System.out.println("；性别:" + s.split(",")[1] + "。"),                array);    }    private static void printInfo(Consumer&lt;String&gt; one,                                   Consumer&lt;String&gt; two, String[] array) {        for (String info : array) {            one.andThen(two).accept(info);        }    }}// 控制台输出：姓名:张三；性别:女。姓名:李四；性别:女。姓名:王五；性别:男。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 函数式编程</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/java-han-shu-shi-bian-cheng/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/java-han-shu-shi-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1>Java 函数式编程</h1><h2 id="Metadata-54">Metadata</h2><pre><code class="language-yml">title: Java 函数式编程date: 2023-02-21 10:03tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: 函数式编程(Functional programming)是一种编程范式，它将计算视为数学函数的求值，避免使用可变数据和复杂的状态维护。函数式编程通过使用函数来将值转换成抽象单元，接着用于构建软件系统。</code></pre><h2 id="Java-函数式编程">Java 函数式编程</h2><p>函数式编程(Functional programming)是一种编程范式，它将计算视为数学函数的求值，避免使用可变数据和复杂的状态维护。相比命令式编程(imperative programming)，函数式编程更强调函数的应用，而命令式编程更强调状态的变化和命令的执行顺序。</p><p>可以用下面一句话来直白地描述函数式编程：</p><p><strong>函数式编程通过使用函数来将值转换成抽象单元，接着用于构建软件系统。</strong></p><h3 id="概念-2">概念</h3><p>在函数式编程中，有一些概念和范式不同于命令式编程(以及面向对象编程)，是特定于函数式编程的。然而编程语言通常是多种范式的混合体，所以熟悉命令式编程的程序员可能已经熟悉以下概念。</p><h2 id="Java-函数式接口基础">Java 函数式接口基础</h2><p>函数式接口在Java中是指:有且仅有一个抽象方法的接口。 函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。<br>“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。</p><h3 id="格式">格式</h3><p>只要确保接口中有且仅有一个抽象方法即可:</p><pre><code class="language-java">修饰符 interface 接口名称 {    public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容} </code></pre><p>由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单:</p><pre><code class="language-java">public interface MyFunctionalInterface {       void myMethod();}</code></pre><h3 id="FunctionalInterface注解">@FunctionalInterface注解</h3><p>与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解:@FunctionalInterface 。该注解可用于一个接口的定义上:</p><pre><code class="language-java">@FunctionalInterfacepublic interface MyFunctionalInterface {       void myMethod();}</code></pre><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注 意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h3 id="自定义函数式接口">自定义函数式接口</h3><p>对于刚刚定义好的 MyFunctionalInterface 函数式接口，典型使用场景就是作为方法的参数:</p><pre><code class="language-java">public class Demo09FunctionalInterface {    // 使用自定义的函数式接口作为方法参数    private static void doSomething(MyFunctionalInterface inter) {        inter.myMethod(); // 调用自定义的函数式接口方法     }    public static void main(String[] args) {        // 调用使用函数式接口的方法        doSomething(() ‐&gt; System.out.println("Lambda执行啦!"));    } }</code></pre><h2 id="函数式编程基础">函数式编程基础</h2><p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。</p><h3 id="Lambda的延迟执行">Lambda的延迟执行</h3><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以 作为解决方案，提升性能。</p><p>性能浪费的日志案例<br>注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。 一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出:</p><pre><code class="language-java">public class Demo01Logger {    private static void log(int level, String msg) {        if (level == 1) {            System.out.println(msg);        }    }    public static void main(String[] args) {        String msgA = "Hello";        String msgB = "World";        String msgC = "Java";        log(1, msgA + msgB + msgC);    }}</code></pre><p>这段代码存在问题:无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。<strong>如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费</strong>。</p><blockquote><p>备注:SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行 字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进 行字符串拼接。例如: LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位 符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置;否则不会进行字 符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p></blockquote><h4 id="Lambda的更优写法">Lambda的更优写法</h4><p>使用Lambda必然需要一个函数式接口:</p><pre><code class="language-java">@FunctionalInterfacepublic interface MessageBuilder {    String buildMessage();}</code></pre><p>然后对 log 方法进行改造:</p><pre><code class="language-java"> public class Demo02LoggerLambda {    private static void log(int level, MessageBuilder builder) {        if (level == 1) {            System.out.println(builder.buildMessage());        }    }    public static void main(String[] args) {        String msgA = "Hello";        String msgB = "World";        String msgC = "Java";        log(1, () ‐&gt; msgA + msgB + msgC);    }}</code></pre><p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接;否则三个字符串将不会进行拼接。</p><p><strong>证明Lambda的延迟</strong></p><p>下面的代码可以通过结果进行验证:</p><pre><code class="language-java">public class Demo03LoggerDelay {    private static void log(int level, MessageBuilder builder) {        if (level == 1) {            System.out.println(builder.buildMessage());        }    }    public static void main(String[] args) {        String msgA = "Hello";        String msgB = "World";        String msgC = "Java";        log(2, () ‐ &gt; {System.out.println("Lambda执行!"); return msgA + msgB + msgC;});    }}</code></pre><p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。<br>扩展:实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</p><h3 id="使用Lambda作为参数和返回值">使用Lambda作为参数和返回值</h3><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数 式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。</p><p>例如 <code>java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就 可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p><pre><code class="language-java">public class Demo04Runnable {    private static void startThread(Runnable task) {        new Thread(task).start();    }    public static void main(String[] args) {        startThread(() ‐ &gt; System.out.println("线程任务执行!"));    }}</code></pre><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一 个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。</p><pre><code class="language-java">import java.util.Arrays;import java.util.Comparator;public class Demo06Comparator {    private static Comparator&lt;String&gt; newComparator() {        return (a,b) ‐&gt; b.length() ‐a.length();    }    public static void main(String[] args) {        String[] array = {"abc", "ab", "abcd"};        System.out.println(Arrays.toString(array));        Arrays.sort(array, newComparator());        System.out.println(Arrays.toString(array));    }}</code></pre><p>其中直接return一个Lambda表达式即可。</p><h2 id="常用函数式接口-Supplier">常用函数式接口-Supplier</h2><p>undefined</p><h2 id="函数接口-Consumer">函数接口 Consumer</h2><p>undefined</p><h2 id="函数接口-Predicate">函数接口 Predicate</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数接口---supplier</title>
      <link href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-supplier/"/>
      <url>/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-supplier/</url>
      
        <content type="html"><![CDATA[<h1>函数接口—supplier</h1><h2 id="Metadata-58">Metadata</h2><pre><code class="language-yml">title: 函数接口---supplierdate: 2023-02-21 08:42tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/函数式编程categories:  - Javakeywords:  - Javadescription: Supplier 接口被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型数据。</code></pre><h2 id="函数接口—supplier">函数接口—supplier</h2><p><code>java.util.function.supplier&lt;T&gt; </code></p><h3 id="简介-4">简介</h3><p><code>Supplier&lt;T&gt;</code>接口被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型数据。</p><p>Supplier:包含一个无参的方法,所以是可以被<code>@FunctionalInterface</code>标识</p><ul><li><code>T get()</code>:获取结果<ul><li>该方法不需要参数,它会按照某种实现逻辑(有Lambda表达式实现)返回一个数据</li></ul></li></ul><pre><code class="language-java">package java.util.function;/** * Represents a supplier of results. * * &lt;p&gt;There is no requirement that a new or distinct result be returned each * time the supplier is invoked. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is {@link #get()}. * * @param &lt;T&gt; the type of results supplied by this supplier * * @since 1.8 */@FunctionalInterfacepublic interface Supplier&lt;T&gt; {    /**     * Gets a result.     *     * @return a result     */    T get();}</code></pre><h3 id="作用-3">作用</h3><p>supplier一般作用是用来产生一个对象（调用一次get方法，返回一次T所代表的对象）<br>supplier用来创建对象的，它和常规new对象不同:</p><p>比如我们有个Person类，如果：<br>1、<code>Person p1 = new Person();</code>这里会马上创建一个对象<br>2、<code>Supplier&lt;Persion&gt; s1 = Persion::new;</code>这里不会创建对象<br><code>Persion p1 = s1.get();</code> 这里会创建一个对象,而且会返回Persion对象<br><code>Persion p1 = s1.get();</code> 继续创建一个Persion对象</p><h3 id="示例-2">示例</h3><pre><code class="language-java">/*   Supplier接口   Supplier&lt;T&gt;:包含一个无参的方法   T get():获取结果   该方法不需要参数,它会按照某种实现逻辑(有Lambda表达式实现)返回一个数据   Supplier&lt;T&gt;接口也称为生产型接口,如果我们指定了接口的泛型是什么类型,那么接口中的get方法就会产生什么类型数据供我们使用 */public class SupplierDemo {    public static void main(String[] args) {        /*        //匿名类写法        Supplier&lt;String&gt; s= new Supplier&lt;String&gt;() {              @Override              public String get() {                  return "iKun";              }          };        System.out.println(getString(s));         */        //Lambda表达式写法        System.out.println( getString(()-&gt;"iKun"));    }    //定义一个方法     private static String getString(Supplier&lt;String&gt; s){          return s.get();     }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题/Java/函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web</title>
      <link href="/language/java/java-web/java-web/"/>
      <url>/language/java/java-web/java-web/</url>
      
        <content type="html"><![CDATA[<h1>Java Web</h1><h2 id="Metadata-38">Metadata</h2><pre><code class="language-yml">title: Java Webdate: 2023-02-01 18:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java Web</code></pre><h2 id="【Java】-Servlet">【Java】 Servlet</h2><p>undefined</p><h2 id="【Java】-Filter">【Java】 Filter</h2><p>undefined</p><h2 id="【Java】-Listener">【Java】 Listener</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Listener</title>
      <link href="/language/java/java-web/java-listener/"/>
      <url>/language/java/java-web/java-listener/</url>
      
        <content type="html"><![CDATA[<h1>【Java】 Listener</h1><h2 id="Metadata-41">Metadata</h2><pre><code class="language-yml">title: 【Java】 Listenerdate: 2023-02-01 18:55tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Listener</code></pre><h2 id="【Java】-Listener-2">【Java】 Listener</h2><p>web 监听器是一种 Servlet 中的特殊的类，它们能帮助开发者监听 web 中的特定事件，比如 ServletContext,HttpSession,ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p><p><img src="/attachment%5C950509a5c389221f66d5aa7eb3f720ca.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Filter</title>
      <link href="/language/java/java-web/java-filter/"/>
      <url>/language/java/java-web/java-filter/</url>
      
        <content type="html"><![CDATA[<h1>【Java】 Filter</h1><h2 id="Metadata-40">Metadata</h2><pre><code class="language-yml">title: 【Java】 Filterdate: 2023-02-01 18:51tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Filter</code></pre><h2 id="【Java】-Filter-2">【Java】 Filter</h2><p>​ Filter（过滤器）用于拦截用户请求，在服务器作出响应前，可以在拦截后修改 request 和 response。可以实现一次编码，多处应用。Filter 不像 Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。</p><p>Web 开发人员通过 Filter 技术，对 web 服务器管理的所有 web 资源。例如实现 URL 级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。例如对 Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。</p><p>Filter 主要的作用有两个：</p><ul><li>拦截修改请求：在 HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest。根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 头和数据。</li><li>拦截修改响应：在 HttpServletResponse 到达客户端之前，拦截 HttpServletResponse。根据需要检查 HttpServletResponse, 也可以修改 HttpServletResponse 头和数据。</li></ul><p><img src="/attachment%5Ce9d18d57caa13788555c7bab2d29b58c.png" alt></p><h3 id="生命周期">生命周期</h3><p>Filter 接口位于 javax.servlet 包下，其中提供了三个方法，完成了整个过滤器的生命周期。</p><ul><li>init() ：应用程序启动时，servlet 容器就会调用 init 方法。这个方法只调用一次，并且应该包含该过滤器的初始化代码。</li><li>doFilter：每次的访问请求如果符合拦截条件都会调用此方法，获取请求及响应对象，自定义处理逻辑。</li><li>destroy()：服务终止时，会调用 destory 方法，销毁过滤器对象。</li></ul><pre><code class="language-java">public interface Filter {    public default void init(FilterConfig filterConfig) throws ServletException {}    public void doFilter(ServletRequest request, ServletResponse response,            FilterChain chain) throws IOException, ServletException;    public default void destroy() {}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】 Servlet</title>
      <link href="/language/java/java-web/java-servlet/"/>
      <url>/language/java/java-web/java-servlet/</url>
      
        <content type="html"><![CDATA[<h1>【Java】 Servlet</h1><h2 id="Metadata-42">Metadata</h2><pre><code class="language-yml">title: 【Java】 Servletdate: 2023-02-01 18:45tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: 【Java】 Servlet</code></pre><h2 id="【Java】-Servlet-2">【Java】 Servlet</h2><p>Servlet 是 SUN 推出的一套规范，定义了一套处理请求和发送响应的接口。一般认为 Servlet 其实就是一个遵循 Servlet 规范开发的 java 类，Serlvet 是由服务器调用的，运行在服务器端。</p><p>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器。 Tomcat 作为 Servlet 容器，负责处理客户请求, 把请求传送给 Servlet，并将 Servlet 的响应传送回给客户，而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。</p><p><img src="/attachment%5C4e487db9369b8b2458296d6db5eb0fea.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
            <tag> 主题场景/程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 Spring 集成</title>
      <link href="/database/mongodb/mongodb-spring-ji-cheng/"/>
      <url>/database/mongodb/mongodb-spring-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h1>【MongoDB】 Spring 集成</h1><h2 id="Metadata-7">Metadata</h2><pre><code class="language-yml">title: 【MongoDB】 Spring 集成date: 2022-12-20 18:08tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 Spring 集成</code></pre><h2 id="Spring-Data-与-MongoDB">Spring Data 与 MongoDB</h2><h3 id="Spring-Data的层次结构">Spring Data的层次结构</h3><p><img src="/attachment%5C6293fb992b572332a190a1cecb48b691.png" alt></p><p>Spring Data是基于Spring runtime体系的：</p><p><img src="/attachment%5Ce395c0240f8cccfe2233f87adf9f9407.png" alt></p><h3 id="springboot-data-mongo层次结构">springboot-data-mongo层次结构</h3><p><img src="/attachment%5Cb4bd6bb7ec2d65c577a433d5fee440c7.png" alt></p><h2 id="mongodb-Java用法">mongodb+Java用法</h2><h3 id="使用方式及依赖包的引入">使用方式及依赖包的引入</h3><ul><li>引入mongodb-driver, 使用最原生的方式通过Java调用mongodb提供的Java driver;</li><li>引入spring-data-mongo, 自行配置使用spring data 提供的对MongoDB的封装<ul><li>使用MongoTemplate 的方式</li><li>使用MongoRespository 的方式</li></ul></li><li>引入spring-data-mongo-starter, 采用spring autoconfig机制自动装配，然后再使用- MongoTemplate或者MongoRespository方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 Java API</title>
      <link href="/database/mongodb/mongodb-java-api/"/>
      <url>/database/mongodb/mongodb-java-api/</url>
      
        <content type="html"><![CDATA[<h1>【MongoDB】 Java API</h1><h2 id="Metadata-5">Metadata</h2><pre><code class="language-yml">title: 【MongoDB】 Java APIdate: 2022-12-20 18:07tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 Java API</code></pre><h2 id="MongoDB-Driver">MongoDB Driver</h2><pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.mongodb/mongo-java-driver --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;    &lt;version&gt;3.12.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="代码测试">代码测试</h2><pre><code class="language-java">private static final String MONGO_HOST = "xxx.xxx.xxx.xxx";    private static final Integer MONGO_PORT = 27017;    private static final String MONGO_DB = "testdb";    public static void main(String args[]) {        try {            // 连接到 mongodb 服务            MongoClient mongoClient = new MongoClient(MONGO_HOST, MONGO_PORT);            // 连接到数据库            MongoDatabase mongoDatabase = mongoClient.getDatabase(MONGO_DB);            System.out.println("Connect to database successfully");            // 创建Collection            mongoDatabase.createCollection("test");            System.out.println("create collection");            // 获取collection            MongoCollection&lt;Document&gt; collection = mongoDatabase.getCollection("test");            // 插入document            Document doc = new Document("name", "MongoDB")                    .append("type", "database")                    .append("count", 1)                    .append("info", new Document("x", 203).append("y", 102));            collection.insertOne(doc);            // 统计count            System.out.println(collection.countDocuments());            // query - first            Document myDoc = collection.find().first();            System.out.println(myDoc.toJson());            // query - loop all            MongoCursor&lt;Document&gt; cursor = collection.find().iterator();            try {                while (cursor.hasNext()) {                    System.out.println(cursor.next().toJson());                }            } finally {                cursor.close();            }        } catch (Exception e) {            System.err.println(e.getClass().getName() + ": " + e.getMessage());        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 效率工具</title>
      <link href="/database/mongodb/mongodb-xiao-lu-gong-ju/"/>
      <url>/database/mongodb/mongodb-xiao-lu-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1>【MongoDB】 效率工具</h1><h2 id="Metadata-12">Metadata</h2><pre><code class="language-yml">title: 【MongoDB】 效率工具date: 2022-12-20 18:06tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 效率工具</code></pre><h2 id="官方MongoDB-Compass">官方MongoDB Compass</h2><blockquote><p>推荐使用</p></blockquote><p>MongoDB Compass Community由MongoDB开发人员开发，这意味着更高的可靠性和兼容性。它为MongoDB提供GUI mongodb工具，以探索数据库交互；具有完整的CRUD功能并提供可视方式。借助内置模式可视化，用户可以分析文档并显示丰富的结构。为了监控服务器的负载，它提供了数据库操作的实时统计信息。就像MongoDB一样，Compass也有两个版本，一个是Enterprise（付费），社区可以免费使用。</p><h2 id="NoSQLBooster">NoSQLBooster</h2><p>NoSQLBooster是MongoDB CLI界面中非常流行的GUI工具。它正式名称为MongoBooster。NoSQLBooster是一个跨平台，它自带一些mongodb工具来管理数据库和监控服务器。这个Mongodb工具包括服务器监控工具，Visual Explain Plan，查询构建器，SQL查询，ES2017语法支持等。它有免费，个人和商业版本，当然，免费版本有一些功能限制。NoSQLBooster也可用于Windows，MacOS和Linux。支持 sql，免费版 支持 CSV、JSON 导入，但不支持 CSV、JSON 导出。集成了 mongodump/mongorestore，支持监控，和查询优化。</p><h2 id="Robot3T">Robot3T</h2><p>Robo 3T前身是Robomongo。支持Windows，MacOS和Linux系统。Robo 3T 1.3为您提供了对MongoDB 4.0和SCRAM-SHA-256（升级的mongo shell）的支持，支持从MongoDB SRV连接字符串导入，以及许多其他修复和改进。大家也可以找到之前的Robomongo，完全免费的版本使用。</p><h2 id="Vs-Code-plugin">Vs Code plugin</h2>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 索引</title>
      <link href="/database/mongodb/mongodb-suo-yin/"/>
      <url>/database/mongodb/mongodb-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1>【MongoDB】 索引</h1><h2 id="Metadata-11">Metadata</h2><pre><code class="language-yml">title: 【MongoDB】 索引date: 2022-12-20 18:04tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 索引</code></pre><h2 id="聚合-Aggregation-Pipline">聚合 - Aggregation Pipline</h2><blockquote><p>类似于将SQL中的group by + order by + left join … 等操作管道化。</p></blockquote><h3 id="常规使用">常规使用</h3><p><strong>图例理解</strong></p><p><img src="/attachment%5C6d3383df61d47afe1f6af5fdbf57e41c.png" alt></p><p><strong>准备数据</strong></p><pre><code class="language-sh">&gt; db.orders.insertMany( [...     { _id: 1, cust_id: "abc1", ord_date: ISODate("2012-11-02T17:04:11.102Z"), status: "A", amount: 50 },...     { _id: 2, cust_id: "xyz1", ord_date: ISODate("2013-10-01T17:04:11.102Z"), status: "A", amount: 100 },...     { _id: 3, cust_id: "xyz1", ord_date: ISODate("2013-10-12T17:04:11.102Z"), status: "D", amount: 25 },...     { _id: 4, cust_id: "xyz1", ord_date: ISODate("2013-10-11T17:04:11.102Z"), status: "D", amount: 125 },...     { _id: 5, cust_id: "abc1", ord_date: ISODate("2013-11-12T17:04:11.102Z"), status: "A", amount: 25 }... ] );{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3, 4, 5 ] }&gt; db.orders.find({}){ "_id" : 1, "cust_id" : "abc1", "ord_date" : ISODate("2012-11-02T17:04:11.102Z"), "status" : "A", "amount" : 50 }{ "_id" : 2, "cust_id" : "xyz1", "ord_date" : ISODate("2013-10-01T17:04:11.102Z"), "status" : "A", "amount" : 100 }{ "_id" : 3, "cust_id" : "xyz1", "ord_date" : ISODate("2013-10-12T17:04:11.102Z"), "status" : "D", "amount" : 25 }{ "_id" : 4, "cust_id" : "xyz1", "ord_date" : ISODate("2013-10-11T17:04:11.102Z"), "status" : "D", "amount" : 125 }{ "_id" : 5, "cust_id" : "abc1", "ord_date" : ISODate("2013-11-12T17:04:11.102Z"), "status" : "A", "amount" : 25 }&gt;</code></pre><p><strong>聚合操作</strong></p><pre><code class="language-sh">&gt; db.orders.aggregate([...                      { $match: { status: "A" } },...                      { $group: { _id: "$cust_id", total: { $sum: "$amount" } } },...                      { $sort: { total: -1 } }...                    ]){ "_id" : "xyz1", "total" : 100 }{ "_id" : "abc1", "total" : 75 }</code></pre><h3 id="Pipline操作">Pipline操作</h3><p>MongoDB的聚合管道（Pipline）将MongoDB文档在一个阶段（Stage）处理完毕后将结果传递给下一个阶段（Stage）处理。<strong>阶段（Stage）操作是可以重复的。</strong></p><p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p><p>这里我们介绍一下聚合框架中常用的几个Stages：</p><ul><li><code>$project</code>：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li><code>$match</code>：用于过滤数据，只输出符合条件的文档。<code>$match</code>使用MongoDB的标准查询操作。</li><li><code>$limit</code>：用来限制MongoDB聚合管道返回的文档数。</li><li><code>$skip</code>：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li><code>$unwind</code>：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li><code>$group</code>：将集合中的文档分组，可用于统计结果。</li><li><code>$sort</code>：将输入文档排序后输出。</li><li><code>$geoNear</code>：输出接近某一地理位置的有序文档。</li><li><code>$bucket</code>: 分组（分桶）计算。</li><li><code>$facet</code>: 多次分组计算。</li><li><code>$out</code>: 将结果集输出，必须是Pipline最后一个Stage。</li></ul><p><strong>示例</strong></p><ul><li><code>$project</code></li></ul><pre><code class="language-sh">&gt; db.orders.aggregate(...     { $project : {...         _id : 0 , // 默认不显示_id...         cust_id : 1 ,...         status : 1...     }});{ "cust_id" : "abc1", "status" : "A" }{ "cust_id" : "xyz1", "status" : "A" }{ "cust_id" : "xyz1", "status" : "D" }{ "cust_id" : "xyz1", "status" : "D" }{ "cust_id" : "abc1", "status" : "A" }</code></pre><ul><li><code>$skip</code></li></ul><pre><code class="language-sh"> db.orders.aggregate(...     { $skip : 4 });{ "_id" : 5, "cust_id" : "abc1", "ord_date" : ISODate("2013-11-12T17:04:11.102Z"), "status" : "A", "amount" : 25 }</code></pre><ul><li><code>$unwind</code></li></ul><pre><code class="language-sh">&gt; db.inventory2.insertOne({ "_id" : 1, "item" : "ABC1", sizes: [ "S", "M", "L"] }){ "acknowledged" : true, "insertedId" : 1 }&gt; db.inventory2.aggregate( [ { $unwind : "$sizes" } ] ){ "_id" : 1, "item" : "ABC1", "sizes" : "S" }{ "_id" : 1, "item" : "ABC1", "sizes" : "M" }{ "_id" : 1, "item" : "ABC1", "sizes" : "L" }</code></pre><ul><li><code>$bucket</code></li></ul><pre><code class="language-sh">&gt; db.artwork.insertMany([... { "_id" : 1, "title" : "The Pillars of Society", "artist" : "Grosz", "year" : 1926,...     "price" : NumberDecimal("199.99") },... { "_id" : 2, "title" : "Melancholy III", "artist" : "Munch", "year" : 1902,...     "price" : NumberDecimal("280.00") },... { "_id" : 3, "title" : "Dancer", "artist" : "Miro", "year" : 1925,...     "price" : NumberDecimal("76.04") },... { "_id" : 4, "title" : "The Great Wave off Kanagawa", "artist" : "Hokusai",...     "price" : NumberDecimal("167.30") },... { "_id" : 5, "title" : "The Persistence of Memory", "artist" : "Dali", "year" : 1931,...     "price" : NumberDecimal("483.00") },... { "_id" : 6, "title" : "Composition VII", "artist" : "Kandinsky", "year" : 1913,...     "price" : NumberDecimal("385.00") },... { "_id" : 7, "title" : "The Scream", "artist" : "Munch", "year" : 1893 },... { "_id" : 8, "title" : "Blue Flower", "artist" : "O'Keefe", "year" : 1918,...     "price" : NumberDecimal("118.42") }... ]){        "acknowledged" : true,        "insertedIds" : [                1,                2,                3,                4,                5,                6,                7,                8        ]}&gt; db.artwork.find({}){ "_id" : 1, "title" : "The Pillars of Society", "artist" : "Grosz", "year" : 1926, "price" : NumberDecimal("199.99") }{ "_id" : 2, "title" : "Melancholy III", "artist" : "Munch", "year" : 1902, "price" : NumberDecimal("280.00") }{ "_id" : 3, "title" : "Dancer", "artist" : "Miro", "year" : 1925, "price" : NumberDecimal("76.04") }{ "_id" : 4, "title" : "The Great Wave off Kanagawa", "artist" : "Hokusai", "price" : NumberDecimal("167.30") }{ "_id" : 5, "title" : "The Persistence of Memory", "artist" : "Dali", "year" : 1931, "price" : NumberDecimal("483.00") }{ "_id" : 6, "title" : "Composition VII", "artist" : "Kandinsky", "year" : 1913, "price" : NumberDecimal("385.00") }{ "_id" : 7, "title" : "The Scream", "artist" : "Munch", "year" : 1893 } // 注意这里没有price，聚合结果中为Others{ "_id" : 8, "title" : "Blue Flower", "artist" : "O'Keefe", "year" : 1918, "price" : NumberDecimal("118.42") }&gt; db.artwork.aggregate( [...   {...     $bucket: {...       groupBy: "$price",...       boundaries: [ 0, 200, 400 ],...       default: "Other",...       output: {...         "count": { $sum: 1 },...         "titles" : { $push: "$title" }...       }...     }...   }... ] ){ "_id" : 0, "count" : 4, "titles" : [ "The Pillars of Society", "Dancer", "The Great Wave off Kanagawa", "Blue Flower" ] }{ "_id" : 200, "count" : 2, "titles" : [ "Melancholy III", "Composition VII" ] }{ "_id" : "Other", "count" : 2, "titles" : [ "The Persistence of Memory", "The Scream" ] }</code></pre><ul><li><code>$bucket + $facet</code></li></ul><blockquote><p>非常常用！</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">示例</p><p>collapse: closed</p><pre><code class="language-sh">db.artwork.aggregate( [  {    $facet: {      "price": [        {          $bucket: {              groupBy: "$price",              boundaries: [ 0, 200, 400 ],              default: "Other",              output: {                "count": { $sum: 1 },                "artwork" : { $push: { "title": "$title", "price": "$price" } }              }          }        }      ],      "year": [        {          $bucket: {            groupBy: "$year",            boundaries: [ 1890, 1910, 1920, 1940 ],            default: "Unknown",            output: {              "count": { $sum: 1 },              "artwork": { $push: { "title": "$title", "year": "$year" } }            }          }        }      ]    }  }] )<p>// 输出<br>{<br>"year" : [<br>{<br>"_id" : 1890,<br>"count" : 2,<br>"artwork" : [<br>{<br>"title" : "Melancholy III",<br>"year" : 1902<br>},<br>{<br>"title" : "The Scream",<br>"year" : 1893<br>}<br>]<br>},<br>{<br>"_id" : 1910,<br>"count" : 2,<br>"artwork" : [<br>{<br>"title" : "Composition VII",<br>"year" : 1913<br>},<br>{<br>"title" : "Blue Flower",<br>"year" : 1918<br>}<br>]<br>},<br>{<br>"_id" : 1920,<br>"count" : 3,<br>"artwork" : [<br>{<br>"title" : "The Pillars of Society",<br>"year" : 1926<br>},<br>{<br>"title" : "Dancer",<br>"year" : 1925<br>},<br>{<br>"title" : "The Persistence of Memory",<br>"year" : 1931<br>}<br>]<br>},<br>{<br>// Includes the document without a year, e.g., _id: 4<br>"_id" : "Unknown",<br>"count" : 1,<br>"artwork" : [<br>{<br>"title" : "The Great Wave off Kanagawa"<br>}<br>]<br>}<br>],<br>"price" : [<br>{<br>"_id" : 0,<br>"count" : 4,<br>"artwork" : [<br>{<br>"title" : "The Pillars of Society",<br>"price" : NumberDecimal("199.99")<br>},<br>{<br>"title" : "Dancer",<br>"price" : NumberDecimal("76.04")<br>},<br>{<br>"title" : "The Great Wave off Kanagawa",<br>"price" : NumberDecimal("167.30")<br>},<br>{<br>"title" : "Blue Flower",<br>"price" : NumberDecimal("118.42")<br>}<br>]<br>},<br>{<br>"_id" : 200,<br>"count" : 2,<br>"artwork" : [<br>{<br>"title" : "Melancholy III",<br>"price" : NumberDecimal("280.00")<br>},<br>{<br>"title" : "Composition VII",<br>"price" : NumberDecimal("385.00")<br>}<br>]<br>},<br>{<br>// Includes the document without a price, e.g., _id: 7<br>"_id" : "Other",<br>"count" : 2,<br>"artwork" : [<br>{<br>"title" : "The Persistence of Memory",<br>"price" : NumberDecimal("483.00")<br>},<br>{<br>"title" : "The Scream"<br>}<br>]<br>}<br>]<br>}</p></code><p><code class="language-sh"></code></p></pre><p></p></div><blockquote><p>聚合操作使用的比较频繁</p></blockquote><h3 id="Aggregation-Options参数">Aggregation Options参数</h3><ul><li><code>explain</code></li></ul><pre><code class="language-sh">&gt; db.orders.aggregate(...                      [...                        { $match: { status: "A" } },...                        { $group: { _id: "$cust_id", total: { $sum: "$amount" } } },...                        { $sort: { total: -1 } }...                      ],...                      {...                        explain: true...                      }...                    ){        "serverInfo" : {                "host" : "pdai",                "port" : 27017,                "version" : "3.6.19",                "gitVersion" : "41b289ff734a926e784d6ab42c3129f59f40d5b4"        },        "stages" : [                {                        "$cursor" : {                                "query" : {                                        "status" : "A"                                },                                "fields" : {                                        "amount" : 1,                                        "cust_id" : 1,                                        "_id" : 0                                },                                "queryPlanner" : {                                        "plannerVersion" : 1,                                        "namespace" : "testdb.orders",                                        "indexFilterSet" : false,                                        "parsedQuery" : {                                                "status" : {                                                        "$eq" : "A"                                                }                                        },                                        "winningPlan" : {                                                "stage" : "COLLSCAN",                                                "filter" : {                                                        "status" : {                                                                "$eq" : "A"                                                        }                                                },                                                "direction" : "forward"                                        },                                        "rejectedPlans" : [ ]                                }                        }                },                {                        "$group" : {                                "_id" : "$cust_id",                                "total" : {                                        "$sum" : "$amount"                                }                        }                },                {                        "$sort" : {                                "sortKey" : {                                        "total" : -1                                }                        }                }        ],        "ok" : 1}</code></pre><h2 id="聚合-Map-Reduce">聚合 - Map Reduce</h2><p><strong>图例理解</strong></p><p><img src="/attachment%5C1ecfcd8ab17b959f91f9aebde6fdb1db.png" alt></p><h3 id="官网示例">官网示例</h3><ul><li>准备数据</li></ul><pre><code class="language-sh">{     _id: ObjectId("50a8240b927d5d8b5891743c"),     cust_id: "abc123",     ord_date: new Date("Oct 04, 2012"),     status: 'A',     price: 25,     items: [ { sku: "mmm", qty: 5, price: 2.5 },              { sku: "nnn", qty: 5, price: 2.5 } ]}</code></pre><ul><li>计算每个顾客总花费：</li></ul><p>map</p><pre><code class="language-sh">var mapFunction1 = function() {                       emit(this.cust_id, this.price);                   };</code></pre><p>reduce</p><pre><code class="language-sh">var reduceFunction1 = function(keyCustId, valuesPrices) {                          return Array.sum(valuesPrices);                      };</code></pre><p>out</p><pre><code class="language-sh">db.orders.mapReduce(                     mapFunction1,                     reduceFunction1,                     { out: "map_reduce_example" }                   )</code></pre><ul><li>计算每个订单中Items的均价</li></ul><p>map</p><pre><code class="language-sh">var mapFunction2 = function() {                       for (var idx = 0; idx &lt; this.items.length; idx++) {                           var key = this.items[idx].sku;                           var value = {                                         count: 1,                                         qty: this.items[idx].qty                                       };                           emit(key, value);                       }                    };</code></pre><p>reduce</p><pre><code class="language-sh">var reduceFunction2 = function(keySKU, countObjVals) {                     reducedVal = { count: 0, qty: 0 };                     for (var idx = 0; idx &lt; countObjVals.length; idx++) {                         reducedVal.count += countObjVals[idx].count;                         reducedVal.qty += countObjVals[idx].qty;                     }                     return reducedVal;                  };</code></pre><p>finalize</p><pre><code class="language-sh">var finalizeFunction2 = function (key, reducedVal) {                       reducedVal.avg = reducedVal.qty/reducedVal.count;                       return reducedVal;                    };</code></pre><h2 id="索引-2">索引</h2><p>索引即为提升查询等的效率，默认是对_id进行索引的。</p><h3 id="图例理解">图例理解</h3><p>以对users中score进行索引时查询的效果</p><p><img src="/attachment%5C9ae28fdca0f44545bff4406462d525d2.png" alt></p><h3 id="索引的类型">索引的类型</h3><p>对于索引，这里简单介绍下常用的类型，其它类型和例子可以参考</p><ul><li>单一索引</li></ul><p><img src="/attachment%5Cdc6adb1eee3b62cfc710a3ac7e2dd632.png" alt></p><ul><li>复合索引</li></ul><p><img src="/attachment%5C16b5459df3c5a9684462f2649628f31d.png" alt></p><ul><li>多键索引</li></ul><p><img src="/attachment%5C70b7f16bf1139d7ea27a031492d17cc6.png" alt></p><h3 id="对索引的操作">对索引的操作</h3><ul><li><strong>查看集合索引</strong></li></ul><pre><code class="language-sh">db.col.getIndexes()</code></pre><ul><li><strong>查看集合索引大小</strong></li></ul><pre><code class="language-sh">db.col.totalIndexSize()</code></pre><ul><li>删除集合所有索引</li></ul><pre><code class="language-sh">db.col.dropIndexes()</code></pre><ul><li>删除集合指定索引</li></ul><pre><code class="language-sh">db.col.dropIndex("索引名称")</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 CURD</title>
      <link href="/database/mongodb/mongodb-curd/"/>
      <url>/database/mongodb/mongodb-curd/</url>
      
        <content type="html"><![CDATA[<h1>【MongoDB】 CURD</h1><h2 id="Metadata-6">Metadata</h2><pre><code class="language-yml">title: 【MongoDB】 CURDdate: 2022-12-20 18:02tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 CURD</code></pre><h2 id="Insert">Insert</h2><p><strong>图例</strong></p><p><img src="/attachment%5Cf4f4ba4b7189d32e69151b74e8042669.png" alt></p><p><strong>示例</strong></p><pre><code class="language-sh">&gt; db.inventory.insertOne(...    { item: "canvas", qty: 100, tags: ["cotton"], size: { h: 28, w: 35.5, uom: "cm" } }... ){        "acknowledged" : true,        "insertedId" : ObjectId("5f1f8a9a099483199e74737c")}&gt; db.inventory.insertMany([...    { item: "journal", qty: 25, tags: ["blank", "red"], size: { h: 14, w: 21, uom: "cm" } },...    { item: "mat", qty: 85, tags: ["gray"], size: { h: 27.9, w: 35.5, uom: "cm" } },...    { item: "mousepad", qty: 25, tags: ["gel", "blue"], size: { h: 19, w: 22.85, uom: "cm" } }... ]){        "acknowledged" : true,        "insertedIds" : [                ObjectId("5f1f8aa8099483199e74737d"),                ObjectId("5f1f8aa8099483199e74737e"),                ObjectId("5f1f8aa8099483199e74737f")        ]}&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f8a9a099483199e74737c"), "item" : "canvas", "qty" : 100, "tags" : [ "cotton" ], "size" : { "h" : 28, "w" : 35.5, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737d"), "item" : "journal", "qty" : 25, "tags" : [ "blank", "red" ], "size" : { "h" : 14, "w" : 21, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737e"), "item" : "mat", "qty" : 85, "tags" : [ "gray" ], "size" : { "h" : 27.9, "w" : 35.5, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737f"), "item" : "mousepad", "qty" : 25, "tags" : [ "gel", "blue" ], "size" : { "h" : 19, "w" : 22.85, "uom" : "cm" } }</code></pre><h2 id="Query">Query</h2><p><strong>图例</strong></p><p><img src="/attachment%5C537bc15edb4322549b5f265383d380bb.png" alt></p><p><strong>示例</strong></p><pre><code class="language-sh">&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f8a9a099483199e74737c"), "item" : "canvas", "qty" : 100, "tags" : [ "cotton" ], "size" : { "h" : 28, "w" : 35.5, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737d"), "item" : "journal", "qty" : 25, "tags" : [ "blank", "red" ], "size" : { "h" : 14, "w" : 21, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737e"), "item" : "mat", "qty" : 85, "tags" : [ "gray" ], "size" : { "h" : 27.9, "w" : 35.5, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737f"), "item" : "mousepad", "qty" : 25, "tags" : [ "gel", "blue" ], "size" : { "h" : 19, "w" : 22.85, "uom" : "cm" } }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a79"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7a"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7b"), "item" : "planner", "qty" : 75, "size" : { "h" : 22.85, "w" : 30, "uom" : "cm" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7c"), "item" : "postcard", "qty" : 45, "size" : { "h" : 10, "w" : 15.25, "uom" : "cm" }, "status" : "A" }&gt; db.inventory.find( { status: "D" } ){ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7a"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7b"), "item" : "planner", "qty" : 75, "size" : { "h" : 22.85, "w" : 30, "uom" : "cm" }, "status" : "D" }&gt; db.inventory.find( { status: { $in: [ "A", "D" ] } } ){ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a79"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7a"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7b"), "item" : "planner", "qty" : 75, "size" : { "h" : 22.85, "w" : 30, "uom" : "cm" }, "status" : "D" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7c"), "item" : "postcard", "qty" : 45, "size" : { "h" : 10, "w" : 15.25, "uom" : "cm" }, "status" : "A" }&gt; db.inventory.find( { status: "A", qty: { $lt: 30 } } ){ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }&gt; db.inventory.find( { $or: [ { status: "A" }, { qty: { $lt: 30 } } ] } ){ "_id" : ObjectId("5f1f8aa8099483199e74737d"), "item" : "journal", "qty" : 25, "tags" : [ "blank", "red" ], "size" : { "h" : 14, "w" : 21, "uom" : "cm" } }{ "_id" : ObjectId("5f1f8aa8099483199e74737f"), "item" : "mousepad", "qty" : 25, "tags" : [ "gel", "blue" ], "size" : { "h" : 19, "w" : 22.85, "uom" : "cm" } }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a79"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7c"), "item" : "postcard", "qty" : 45, "size" : { "h" : 10, "w" : 15.25, "uom" : "cm" }, "status" : "A" }&gt; db.inventory.find( {...      status: "A",...      $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]... } ){ "_id" : ObjectId("5f1f94de4326f1d6a51d3a78"), "item" : "journal", "qty" : 25, "size" : { "h" : 14, "w" : 21, "uom" : "cm" }, "status" : "A" }{ "_id" : ObjectId("5f1f94de4326f1d6a51d3a7c"), "item" : "postcard", "qty" : 45, "size" : { "h" : 10, "w" : 15.25, "uom" : "cm" }, "status" : "A" }</code></pre><h2 id="Update">Update</h2><p><strong>图例</strong></p><p><img src="/attachment%5Cde70e3547d0ddf2f646ae7e36433ed80.png" alt></p><p><strong>示例</strong></p><pre><code class="language-sh">&gt; db.inventory.insertMany( [...    { item: "mousepad", qty: 25, size: { h: 19, w: 22.85, uom: "cm" }, status: "P" },...    { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "P" },...    { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" }... ] );{        "acknowledged" : true,        "insertedIds" : [                ObjectId("5f1f96cf4326f1d6a51d3a80"),                ObjectId("5f1f96cf4326f1d6a51d3a81"),                ObjectId("5f1f96cf4326f1d6a51d3a82")        ]}&gt; db.inventory.updateOne(...    { item: "paper" },...    {...      $set: { "size.uom": "cm", status: "P" },...      $currentDate: { lastModified: true }...    }... ){ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a80"), "item" : "mousepad", "qty" : 25, "size" : { "h" : 19, "w" : 22.85, "uom" : "cm" }, "status" : "P" }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a81"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "P" }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a82"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "cm" }, "status" : "P", "lastModified" : ISODate("2020-07-28T03:09:17.014Z") }</code></pre><p>updateMany</p><pre><code class="language-sh">&gt; db.inventory.updateMany(...    { "qty": { $lt: 50 } },...    {...      $set: { "size.uom": "in", status: "P" },...      $currentDate: { lastModified: true }...    }... ){ "acknowledged" : true, "matchedCount" : 3, "modifiedCount" : 3 }&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a80"), "item" : "mousepad", "qty" : 25, "size" : { "h" : 19, "w" : 22.85, "uom" : "in" }, "status" : "P", "lastModified" : ISODate("2020-07-28T04:33:50.391Z") }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a81"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "P" }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a82"), "item" : "paper", "qty" : 100, "size" : { "h" : 8.5, "w" : 11, "uom" : "cm" }, "status" : "P", "lastModified" : ISODate("2020-07-28T03:09:17.014Z") }</code></pre><p>replace one</p><pre><code class="language-sh">&gt; db.inventory.replaceOne(...    { item: "paper" },...    { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 40 } ] }... ){ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a80"), "item" : "mousepad", "qty" : 25, "size" : { "h" : 19, "w" : 22.85, "uom" : "in" }, "status" : "P", "lastModified" : ISODate("2020-07-28T04:33:50.391Z") }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a81"), "item" : "notebook", "qty" : 50, "size" : { "h" : 8.5, "w" : 11, "uom" : "in" }, "status" : "P" }{ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a82"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 40 } ] }</code></pre><h2 id="Delete">Delete</h2><p><strong>图例</strong></p><p><img src="/attachment%5C2bc5d015fbb226792deab15c04857fd0.png" alt></p><p><strong>示例</strong></p><pre><code class="language-sh">&gt; db.inventory.deleteMany({ status : "P" }){ "acknowledged" : true, "deletedCount" : 2 }&gt; db.inventory.find( {} ){ "_id" : ObjectId("5f1f96cf4326f1d6a51d3a82"), "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 40 } ] }</code></pre><h2 id="BulkWrite">BulkWrite</h2><blockquote><p>本质是就是将上述的操作批量化。</p></blockquote><pre><code class="language-sh">try {   db.characters.bulkWrite(      [         { insertOne :            {               "document" :               {                  "_id" : 4, "char" : "Dithras", "class" : "barbarian", "lvl" : 4               }            }         },         { insertOne :            {               "document" :               {                  "_id" : 5, "char" : "Taeln", "class" : "fighter", "lvl" : 3               }            }         },         { updateOne :            {               "filter" : { "char" : "Eldon" },               "update" : { $set : { "status" : "Critical Injury" } }            }         },         { deleteOne :            { "filter" : { "char" : "Brisbane"} }         },         { replaceOne :            {               "filter" : { "char" : "Meldane" },               "replacement" : { "char" : "Tanys", "class" : "oracle", "lvl" : 4 }            }         }      ]   );}catch (e) {   print(e);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 安装</title>
      <link href="/database/mongodb/mongodb-an-zhuang/"/>
      <url>/database/mongodb/mongodb-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1>【MongoDB】 安装</h1><h2 id="Metadata-10">Metadata</h2><pre><code class="language-yml">title: 【MongoDB】 安装date: 2022-12-20 18:00tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储description: 【MongoDB】 安装</code></pre><h2 id="参考文档">参考文档</h2><ul><li><strong>官网下载</strong></li></ul><p><a href="https://www.mongodb.com/try/download/community">官网下载</a></p><ul><li><strong>官网文档</strong></li></ul><p><a href="https://docs.mongodb.com/v3.6/administration/install-community/">官网文档</a></p><ul><li><strong>菜鸟教程中安装</strong></li></ul><p><a href="https://www.runoob.com/mongodb/mongodb-window-install.html">菜鸟教程</a></p><h2 id="以Linux为例安装">以Linux为例安装</h2><ul><li>yum源</li></ul><p>创建文件<code>/etc/yum.repos.d/mongodb-org-3.6.repo</code>, 加yum源：</p><pre><code class="language-sh">[mongodb-org-3.6]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.6/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc</code></pre><ul><li>安装</li></ul><pre><code class="language-sh">sudo yum install -y mongodb-org</code></pre><ul><li>运行</li></ul><pre><code class="language-sh">[root@pdai yum.repos.d]# systemctl start mongod[root@pdai yum.repos.d]# sudo systemctl status mongod● mongod.service - MongoDB Database Server   Loaded: loaded (/usr/lib/systemd/system/mongod.service; enabled; vendor preset: disabled)   Active: active (running) since Tue 2020-07-28 09:59:55 CST; 26s ago     Docs: https://docs.mongodb.org/manual  Process: 8868 ExecStart=/usr/bin/mongod $OPTIONS (code=exited, status=0/SUCCESS)  Process: 8865 ExecStartPre=/usr/bin/chmod 0755 /var/run/mongodb (code=exited, status=0/SUCCESS)  Process: 8863 ExecStartPre=/usr/bin/chown mongod:mongod /var/run/mongodb (code=exited, status=0/SUCCESS)  Process: 8862 ExecStartPre=/usr/bin/mkdir -p /var/run/mongodb (code=exited, status=0/SUCCESS) Main PID: 8872 (mongod)   CGroup: /system.slice/mongod.service           └─8872 /usr/bin/mongod -f /etc/mongod.conf</code></pre><h2 id="连接和建库">连接和建库</h2><pre><code class="language-sh">[root@pdai yum.repos.d]# mongo --host 127.0.0.1:27017MongoDB shell version v3.6.19connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodbImplicit session: session { "id" : UUID("cb27e5a9-600f-4f57-9096-c7348a9ae5f9") }MongoDB server version: 3.6.19Welcome to the MongoDB shell.For interactive help, type "help".For more comprehensive documentation, see        http://docs.mongodb.org/Questions? Try the support group        http://groups.google.com/group/mongodb-userServer has startup warnings:2020-07-28T09:59:54.521+0800 I STORAGE  [initandlisten]2020-07-28T09:59:54.521+0800 I STORAGE  [initandlisten] ** WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine2020-07-28T09:59:54.521+0800 I STORAGE  [initandlisten] **          See http://dochub.mongodb.org/core/prodnotes-filesystem2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is 'always'.2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] **        We suggest setting it to 'never'2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is 'always'.2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten] **        We suggest setting it to 'never'2020-07-28T09:59:55.705+0800 I CONTROL  [initandlisten]&gt; show dbs;admin   0.000GBconfig  0.000GBlocal   0.000GB</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongDB】 整体生态</title>
      <link href="/database/mongodb/mongodb-zheng-ti-sheng-tai/"/>
      <url>/database/mongodb/mongodb-zheng-ti-sheng-tai/</url>
      
        <content type="html"><![CDATA[<h1>【MongDB】 整体生态</h1><h2 id="Metadata-9">Metadata</h2><pre><code class="language-yml">title: 【MongDB】 整体生态date: 2022-12-20 17:59tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongDB】 整体生态</code></pre><h2 id="整体生态">整体生态</h2><p><img src="/attachment%5C48ded550d01a74c16eb9500740de971f.png" alt></p><h2 id="MongoDB-Server">MongoDB Server</h2><p><a href="https://www.mongodb.com/try/download/enterprise">Mongodb 企业版</a><br><a href="https://www.mongodb.com/try/download/community">Mongodb 社区版</a></p><h2 id="MongoDB-Cloud">MongoDB Cloud</h2><p><a href="https://www.mongodb.com/docs/launch-manage/">MongoDB Cloud</a></p><h2 id="MongoDB-Drivers">MongoDB Drivers</h2><p><a href="https://www.mongodb.com/docs/drivers/">MongoDB Drivers</a></p><h2 id="工具相关">工具相关</h2><p><a href="https://docs.mongodb.com/tools/">MongoDB Tools</a></p><h3 id="MongoDB-Atlas-Open-Service-Broker">MongoDB Atlas Open Service Broker</h3><p><a href="https://www.openservicebrokerapi.org/">Open Service Broker</a></p><h3 id="MongoDB-Connector-for-BI">MongoDB Connector for BI</h3><p><a href="https://docs.mongodb.com/bi-connector/current/">MongoDB Connector for BI</a></p><p>BI是指Business Intelligence，众所周知的BI工具有Tableau, MicroStrategy和Qlik等；而MongoDB BI Connector充当在mongod或mongos实例与BI工具之间转换查询和数据的层， 这样用户就可以使用SQL创建查询，可视化，图形化和报告等方式来展示MongoDB中的数据。</p><ul><li><code>MongoDB DB</code>: 数据的存储</li><li><code>BI Connector</code>: 提供一个关系模式(Schema)，以及BI工具和MongoDB之间转换SQL查询</li><li><code>ODBC data source name (DSN)</code>: 连接配置数据和认证等.</li><li><code>BI Tool</code>: 数据分析和展示工具.</li></ul><h3 id="MongoDB-Charts">MongoDB Charts</h3><p><a href="https://docs.mongodb.com/charts/saas/">MongoDB Charts</a></p><p>负责MongoDB数据可视化的一个工具。</p><h3 id="MongoDB-Database-Tools">MongoDB Database Tools</h3><p><a href="https://docs.mongodb.com/database-tools/">MongoDB Database Tools</a></p><ul><li>二进制导入导出<ul><li>mongodump Creates a binary export of the contents of a mongod database.</li><li>mongorestore Restores data from a mongodump database dump into a mongod or mongos</li><li>bsondump Converts BSON dump files into JSON.</li></ul></li><li>数据导入导出<ul><li>mongoimport Imports content from an Extended JSON, CSV, or TSV export file.</li><li>mongoexport Produces a JSON or CSV export of data stored in a mongod instance.</li></ul></li><li>诊断工具<ul><li>mongostat Provides a quick overview of the status of a currently running mongod or mongos instance.</li><li>mongotop Provides an overview of the time a mongod instance spends reading and writing data.</li></ul></li><li>GridFS 工具<ul><li>mongofiles Supports manipulating files stored in your MongoDB instance in GridFS objects.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MongoDB】 基本概念</title>
      <link href="/database/mongodb/mongodb-ji-ben-gai-nian/"/>
      <url>/database/mongodb/mongodb-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1>【MongoDB】 基本概念</h1><h2 id="Metadata-8">Metadata</h2><pre><code class="language-yml">title: 【MongoDB】 基本概念date: 2022-12-20 17:56tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MongoDBcategories:  - 数据存储keywords:  - 数据存储/MongoDBdescription: 【MongoDB】 基本概念</code></pre><h2 id="什么是NoSQL？">什么是NoSQL？</h2><p>NoSQL是一种非关系型DMS，不需要固定的架构，可以避免joins链接，并且易于扩展。NoSQL数据库用于具有庞大数据存储需求的分布式数据存储。NoSQL用于大数据和实时Web应用程序。例如，像Twitter，Facebook，Google这样的大型公司，每天可能产生TB级的用户数据。</p><p>NoSQL数据库代表“不仅仅是SQL”或“不是SQL”。虽然NoRELNoSQL会是一个更好的名词。Carl Strozz在1998年引入了NoSQL概念。</p><p>传统的RDBMS使用SQL语法来存储和查询数据。相反，NoSQL数据库系统包含可存储结构化，半结构化，非结构化和多态数据的多种数据库技术。</p><p><img src="/attachment%5C69f491444732255e9ef2563d08f2707d.png" alt></p><h2 id="为什么使用NoSQL？">为什么使用NoSQL？</h2><p>NoSQL数据库的概念在处理大量数据的互联网巨头（例如Google，Facebook，Amazon等）中变得很流行。使用RDBMS处理海量数据时，系统响应时间变慢。</p><p>为了解决此问题，当然可以通过升级现有硬件来“横向扩展”我们的系统。但这个成本很高。</p><p>这个问题的替代方案是在负载增加时将数据库负载分配到多个主机上。这种方法称为“横向扩展”。</p><p><img src="/attachment%5C7cac0f56ab2509ae914acbb84ce97e28.png" alt></p><p>NoSQL数据库是非关系数据库，因此在设计时考虑到Web应用程序，比关系数据库更好地扩展。</p><h3 id="NoSQL数据库的简要历史">NoSQL数据库的简要历史</h3><ul><li>1998年-Carlo Strozzi在他的轻量级开源关系数据库中使用术语NoSQL</li><li>2000年-图形数据库Neo4j启动</li><li>2004年-推出Google BigTable</li><li>2005年-启动CouchDB</li><li>2007年-发布有关Amazon Dynamo的研究论文</li><li>2008年-Facebook开源Cassandra项目</li><li>2009年-重新引入NoSQL术语</li></ul><h3 id="NoSQL的功能">NoSQL的功能</h3><ul><li>非关系<ul><li>NoSQL数据库从不遵循关系模型</li><li>切勿为tables 提供固定的固定列记录</li><li>使用自包含的聚合或BLOB</li><li>不需要对象关系映射和数据规范化</li><li>没有复杂的功能，例如查询语言，查询计划者，</li><li>参照完整性联接，ACID</li></ul></li><li>动态架构<ul><li>NoSQL数据库是无模式的或具有宽松模式的数据库</li><li>不需要对数据架构进行任何形式的定义</li><li>提供同一域中的异构数据结构</li></ul></li></ul><p><img src="/attachment%5Cb82e3f333011634a1f4b432f2f1d1532.png" alt></p><ul><li>简单的API<ul><li>提供易于使用的界面，用于存储和查询提供的数据</li><li>API允许进行低级数据操作和选择方法</li><li>基于文本的协议，通常与带有JSON的HTTP REST一起使用</li><li>多数不使用基于标准的查询语言</li><li>支持Web的数据库作为面向互联网的服务运行</li></ul></li><li>分布式<ul><li>可以以分布式方式执行多个NoSQL数据库</li><li>提供自动缩放和故障转移功能</li><li>通常可牺牲ACID概念来实现可伸缩性和吞吐量</li><li>分布式节点之间几乎没有同步复制，多为异步多主复制，对等，HDFS复制</li><li>仅提供最终的一致性</li><li>无共享架构。这样可以减少协调并提高分布。</li></ul></li></ul><p><img src="/attachment%5C9558c72894de678a64e4535c12813258.png" alt></p><h2 id="什么是MongoDB">什么是MongoDB</h2><p>MongoDB是面向文档的NoSQL数据库，用于大量数据存储。MongoDB是一个在2000年代中期问世的数据库。属于NoSQL数据库的类别。</p><h3 id="MongoDB功能">MongoDB功能</h3><p>每个数据库都包含集合，而集合又包含文档。每个文档可以具有不同数量的字段。每个文档的大小和内容可以互不相同。 文档结构更符合开发人员如何使用各自的编程语言构造其类和对象。开发人员经常会说他们的类不是行和列，而是具有键值对的清晰结构。 从NoSQL数据库的简介中可以看出，行（或在MongoDB中调用的文档）不需要预先定义架构。相反，可以动态创建字段。 MongoDB中可用的数据模型使我们可以更轻松地表示层次结构关系，存储数组和其他更复杂的结构。 可伸缩性– MongoDB环境具有很高的可伸缩性。全球各地的公司已经定义了自己的集群，其中一些集群运行着100多个节点，数据库中包含大约数百万个文档。</p><h3 id="为什么使用MongoDB">为什么使用MongoDB</h3><p>以下是一些为什么应该开始使用MongoDB的原因</p><ul><li><strong>面向文档的</strong>–由于MongoDB是NoSQL类型的数据库，它不是以关系类型的格式存储数据，而是将数据存储在文档中。这使得MongoDB非常灵活，可以适应实际的业务环境和需求。</li><li><strong>临时查询</strong>-MongoDB支持按字段，范围查询和正则表达式搜索。可以查询返回文档中的特定字段。</li><li><strong>索引</strong>-可以创建索引以提高MongoDB中的搜索性能。MongoDB文档中的任何字段都可以建立索引。</li><li><strong>复制</strong>-MongoDB可以提供副本集的高可用性。副本集由两个或多个mongo数据库实例组成。每个副本集成员可以随时充当主副本或辅助副本的角色。主副本是与客户端交互并执行所有读/写操作的主服务器。辅助副本使用内置复制维护主数据的副本。当主副本发生故障时，副本集将自动切换到辅助副本，然后它将成为主服务器。</li><li><strong>负载平衡</strong>-MongoDB使用分片的概念，通过在多个MongoDB实例之间拆分数据来水平扩展。MongoDB可以在多台服务器上运行，以平衡负载或复制数据，以便在硬件出现故障时保持系统正常运行。</li></ul><h2 id="MongoDB常用术语">MongoDB常用术语</h2><ul><li><code>_id</code> – 这是每个MongoDB文档中必填的字段。<code>_id</code>字段表示MongoDB文档中的唯一值。<code>_id</code>字段类似于文档的主键。如果创建的新文档中没有<code>_id</code>字段，MongoDB将自动创建该字段。</li><li><code>集合</code> – 这是MongoDB文档的分组。集合等效于在任何其他RDMS（例如Oracle或MS SQL）中创建的表。集合存在于单个数据库中。从介绍中可以看出，集合不强制执行任何结构。</li><li><code>游标</code> – 这是指向查询结果集的指针。客户可以遍历游标以检索结果。</li><li><code>数据库</code> – 这是像RDMS中那样的集合容器，其中是表的容器。每个数据库在文件系统上都有其自己的文件集。MongoDB服务器可以存储多个数据库。</li><li><code>文档</code> - MongoDB集合中的记录基本上称为文档。文档包含字段名称和值。</li><li><code>字段</code> - 文档中的名称/值对。一个文档具有零个或多个字段。字段类似于关系数据库中的列。</li></ul><h2 id="MongoDB与RDBMS区别">MongoDB与RDBMS区别</h2><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td>表连接,MongoDB不支持</td><td></td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/database/redis/redis/"/>
      <url>/database/redis/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: Redisdate: 2022-12-20 17:52tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/Rediscategories:  - 数据存储keywords:  - 数据存储/Redisdescription: Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</code></pre><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><blockquote><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p></blockquote><p>Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。</p><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p><h2 id="为什么要使用Redis"><a href="#为什么要使用Redis" class="headerlink" title="为什么要使用Redis"></a>为什么要使用Redis</h2><ul><li>读写性能优异<ul><li>Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。</li></ul></li><li>数据类型丰富<ul><li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li></ul></li><li>原子性<ul><li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ul></li><li>丰富的特性<ul><li>Redis支持 publish/subscribe, 通知, key 过期等特性。</li></ul></li><li>持久化<ul><li>Redis支持RDB, AOF等持久化方式</li></ul></li><li>发布订阅<ul><li>Redis支持发布/订阅模式</li></ul></li><li>分布式<ul><li>Redis Cluster</li></ul></li></ul><h2 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h2><h3 id="热点数据的缓存"><a href="#热点数据的缓存" class="headerlink" title="热点数据的缓存"></a>热点数据的缓存</h3><p>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p><p>作为缓存使用时，一般有两种方式保存数据：</p><ul><li>读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。</li><li>插入数据时，同时写入Redis。</li></ul><p>方案一：实施起来简单，但是有两个需要注意的地方：</p><ul><li>避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）</li><li>数据的实时性相对会差一点。</li></ul><p>方案二：数据实时性强，但是开发时不便于统一处理。</p><p>当然，两种方式根据实际情况来适用。如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。</p><h3 id="限时业务的运用"><a href="#限时业务的运用" class="headerlink" title="限时业务的运用"></a>限时业务的运用</h3><p>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p><h3 id="计数器相关问题"><a href="#计数器相关问题" class="headerlink" title="计数器相关问题"></a>计数器相关问题</h3><p>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p><p>在分布式锁的场景中，主要用在比如秒杀系统等。</p><h3 id="延时操作"><a href="#延时操作" class="headerlink" title="延时操作"></a>延时操作</h3><p>比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。</p><p>当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p><h3 id="排行榜相关问题"><a href="#排行榜相关问题" class="headerlink" title="排行榜相关问题"></a>排行榜相关问题</h3><p>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。</p><p>比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p><h3 id="点赞、好友等相互关系的存储"><a href="#点赞、好友等相互关系的存储" class="headerlink" title="点赞、好友等相互关系的存储"></a>点赞、好友等相互关系的存储</h3><p>Redis 利用集合的一些命令，比如求交集、并集、差集等。</p><p>在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p><h3 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h3><p>由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</p><h2 id="数据结构和对象"><a href="#数据结构和对象" class="headerlink" title="数据结构和对象"></a>数据结构和对象</h2><p>undefined</p><h2 id="单机库的实现"><a href="#单机库的实现" class="headerlink" title="单机库的实现"></a>单机库的实现</h2><p>undefined</p><h2 id="多机库实现"><a href="#多机库实现" class="headerlink" title="多机库实现"></a>多机库实现</h2><p>undefined</p><h2 id="重点功能"><a href="#重点功能" class="headerlink" title="重点功能"></a>重点功能</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/database/mysql/mysql/"/>
      <url>/database/mysql/mysql/</url>
      
        <content type="html"><![CDATA[<h1>MySQL</h1><h2 id="Metadata">Metadata</h2><pre><code class="language-yml">title: MySQLdate: 2022-12-20 17:14tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储categories:  - 数据存储keywords:  - 数据存储description: MySQL</code></pre><h2 id="MySQL">MySQL</h2><p>MySQL是一个开源的关系型数据库管理系统（RDBMS），它是使用C和C++编写的，并以GPL（GNU通用公共许可证）发布。MySQL是最流行的开源数据库之一，广泛用于Web应用程序的开发。</p><p><img src="/attachment/a029dedcfa846b84e92c374bf30f4135.png" alt=""></p><h3 id="MySQL具有以下特点：">MySQL具有以下特点：</h3><p>可靠性：MySQL具有高度的稳定性和可靠性，可以处理大量数据和高并发访问。<br>可扩展性：MySQL支持水平和垂直的扩展，可以根据需求增加服务器、集群或分区。<br>灵活性：MySQL支持多种存储引擎，如InnoDB、MyISAM等，可以根据应用程序的要求选择合适的存储引擎。<br>高性能：MySQL通过优化查询语句、索引和缓存等方式提供高性能的数据访问。<br>安全性：MySQL提供了访问控制和权限管理机制，可以保护数据的安全性。<br>跨平台性：MySQL可在各种操作系统上运行，包括Windows、Linux、Mac等。</p><h2 id="【MySQL】-数据类型">【MySQL】 数据类型</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-数据目录">【MySQL】 数据目录</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-字符集">【MySQL】 字符集</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-索引">【MySQL】 索引</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-存储引擎">【MySQL】 存储引擎</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-InnoDB">【MySQL】 InnoDB</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-B-树索引">【MySQL】 B+树索引</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-InnoDB的表空间">【MySQL】 InnoDB的表空间</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-单表访问方法">【MySQL】 单表访问方法</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-连接的原理">【MySQL】 连接的原理</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-MySQL基于成本的优化">【MySQL】 MySQL基于成本的优化</h2><p>undefined</p><h2 id="【MySQL】-InnoDB-的统计数据收集">【MySQL】 InnoDB 的统计数据收集</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-MySQL基于规则的优化">【MySQL】 MySQL基于规则的优化</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-InnoDB的Buffer-Pool">【MySQL】 InnoDB的Buffer Pool</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-Explain详解">【MySQL】 Explain详解</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-optimizer-trace表">【MySQL】 optimizer trace表</h2><p>undefined</p><h2 id="【MySQL】-事务">【MySQL】 事务</h2><p>undefined</p><h2 id="【MySQL】-日志-redo">【MySQL】 日志 - redo</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-日志-undo">【MySQL】 日志 - undo</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-事务的隔离级别与-MVCC">【MySQL】 事务的隔离级别与 MVCC</h2><p>undefined</p><p>undefined</p><h2 id="【MySQL】-锁">【MySQL】 锁</h2><p>undefined</p><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB的MVCC实现机制</title>
      <link href="/database/mysql/mysql-innodb-de-mvcc-shi-xian-ji-zhi/"/>
      <url>/database/mysql/mysql-innodb-de-mvcc-shi-xian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 InnoDB的MVCC实现机制</h1><h2 id="Metadata-13">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 InnoDB的MVCC实现机制date: 2022-12-20 17:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</code></pre><h2 id="前提概要">前提概要</h2><h3 id="什么是MVCC">什么是MVCC?</h3><blockquote><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p></blockquote><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p><h3 id="什么是当前读和快照读？">什么是当前读和快照读？</h3><p>在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p><ul><li>当前读</li></ul><p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</p><ul><li>快照读</li></ul><p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><blockquote><p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p></blockquote><h3 id="当前读，快照读和MVCC的关系">当前读，快照读和MVCC的关系</h3><ul><li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念</li><li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</li><li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 4个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</li></ul><h3 id="MVCC能解决什么问题，好处是？">MVCC能解决什么问题，好处是？</h3><h4 id="数据库并发场景">数据库并发场景?</h4><p>有三种, 分别为：</p><ul><li><strong>读-读</strong>：不存在任何问题，也不需要并发控制</li><li><strong>读-写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li><strong>写-写</strong>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li></ul><h4 id="MVCC带来的好处是？">MVCC带来的好处是？</h4><p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p><h3 id="小结一下">小结一下</h3><p>总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p><ul><li>MVCC + 悲观锁 MVCC解决读写冲突，悲观锁解决写写冲突</li><li>MVCC + 乐观锁 MVCC解决读写冲突，乐观锁解决写写冲突</li></ul><p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p><h2 id="MVCC的实现原理">MVCC的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。</p><h3 id="隐式字段">隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><ul><li><strong>DB_ROW_ID</strong> 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li><li><strong>DB_TRX_ID</strong> 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li><li><strong>DB_ROLL_PTR</strong> 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li><li><strong>DELETED_BIT</strong> 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul><p><img src="/attachment%5Ce118090fcf0177f0f7822e621043d9ff.png" alt></p><p>如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID是当前操作该记录的事务ID； 而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本；delete flag没有展示出来。</p><h3 id="undo日志">undo日志</h3><p>InnoDB把这些为了回滚而记录的这些东西称之为undo log。这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。undo log主要分为3种：</p><ul><li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li><li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。<ul><li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul></li></ul><p>对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：</p><ul><li>比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL</li></ul><p><img src="/attachment%5C32b2e59352be8b865dedc27e777bd42c.png" alt></p><ul><li>现在来了一个事务1对该记录的name做出了修改，改为Tom<ul><li>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</li><li>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</li><li>事务提交后，释放锁</li></ul></li></ul><p><img src="/attachment%5Cb3044c19328d0bc158495ef9975fa0f8.png" alt></p><ul><li>又来了个事务2修改person表的同一个记录，将age修改为30岁<ul><li>在事务2修改该行数据时，数据库也先为该行加锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li><li>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</li><li>事务提交，释放锁</li></ul></li></ul><p><img src="/attachment%5C9b771e5c63c8522f6e4032768194a856.png" alt></p><p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p><h3 id="Read-View-读视图">Read View(读视图)</h3><blockquote><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p></blockquote><p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本</p><p>在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性</p><blockquote><ul><li>trx_list 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID</li><li>up_limit_id 记录trx_list列表中事务ID最小的ID</li><li>low_limit_id ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</li></ul></blockquote><ul><li>首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li><li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li><li>判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</li></ul><h3 id="整体流程">整体流程</h3><p>我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了</p><p>整体的流程是怎么样的呢？我们可以模拟一下</p><p>当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 主从复制与读写分离</title>
      <link href="/database/mysql/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/"/>
      <url>/database/mysql/mysql-zhu-cong-fu-zhi-yu-du-xie-fen-chi/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 主从复制与读写分离</h1><h2 id="Metadata-2">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 主从复制与读写分离date: 2022-12-20 17:11tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 主从复制与读写分离</code></pre><h2 id="主从复制">主从复制</h2><p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 : 负责将主服务器上的数据更改写入二进制日志中。</li><li>I/O 线程 : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li><li>SQL 线程 : 负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><img src="/attachment/dc7c140f0d85ed1557899540327b8f2e.png" alt=""></p><h2 id="读写分离">读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于:</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="/attachment/c46d4e50028a21affc1855ecd3a6a31e.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 分库分表</title>
      <link href="/database/mysql/mysql-fen-ku-fen-biao/"/>
      <url>/database/mysql/mysql-fen-ku-fen-biao/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 分库分表</h1><h2 id="Metadata-18">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 分库分表date: 2022-12-20 17:10tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 分库分表</code></pre><h2 id="水平切分">水平切分</h2><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><h2 id="垂直切分">垂直切分</h2><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><h2 id="Sharding-策略">Sharding 策略</h2><ul><li>哈希取模: hash(key) % NUM_DB</li><li>范围: 可以是 ID 范围也可以是时间范围</li><li>映射表: 使用单独的一个数据库来存储映射关系</li></ul><h2 id="Sharding-存在的问题及解决方案">Sharding 存在的问题及解决方案</h2><h3 id="事务问题">事务问题</h3><p>使用分布式事务来解决，比如 XA 接口。</p><h3 id="链接">链接</h3><p>可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。</p><h3 id="ID-唯一性">ID 唯一性</h3><ul><li>使用全局唯一 ID: GUID</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 性能优化</title>
      <link href="/database/mysql/mysql-xing-neng-you-hua/"/>
      <url>/database/mysql/mysql-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 性能优化</h1><h2 id="Metadata-15">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 性能优化date: 2022-12-20 16:15tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 性能优化</code></pre><h2 id="使用-Explain-进行分析">使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有:</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h2 id="优化数据访问">优化数据访问</h2><h3 id="减少请求的数据量">减少请求的数据量</h3><ul><li>只返回必要的列: 最好不要使用 SELECT * 语句。</li><li>只返回必要的行: 使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id="减少服务器端扫描的行数">减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="重构查询方式">重构查询方式</h2><h3 id="切分大查询">切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><pre><code class="language-sql">rows_affected = 0do {    rows_affected = do_query(    "DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")} while rows_affected &gt; 0</code></pre><h3 id="分解大连接查询">分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><pre><code class="language-sql">SELECT * FROM tabJOIN tag_post ON tag_post.tag_id=tag.idJOIN post ON tag_post.post_id=post.idWHERE tag.tag='mysql';</code></pre><pre><code class="language-sql">SELECT * FROM tag WHERE tag='mysql';SELECT * FROM tag_post WHERE tag_id=1234;SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 索引</title>
      <link href="/database/mysql/mysql-suo-yin/"/>
      <url>/database/mysql/mysql-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 索引</h1><h2 id="Metadata-5">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 索引date: 2022-12-20 16:14tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</code></pre><h2 id="概述-3">概述</h2><ul><li>MySQL索引是在<strong>存储引擎层</strong>实现的，不同存储引擎具有不同的索引类型和实现方式。<ul><li><strong>B+Tree索引</strong>是大多数MySQL存储引擎的默认索引类型。它可以用于查找、排序和分组，适用于全键值、键值范围和键前缀查找。主索引是<strong>聚簇索引</strong>，辅助索引的叶子节点记录着主键的值。</li><li>哈希索引具有快速的查找速度，但失去了有序性，只支持精确查找，无法用于排序和分组。InnoDB存储引擎支持<strong>自适应哈希索引</strong>，在B+Tree索引之上创建哈希索引以提高查找速度。</li><li><strong>全文索引</strong>用于查找文本中的关键词，支持MATCH AGAINST语法。一般使用倒排索引实现。MyISAM和InnoDB存储引擎均支持全文索引。</li><li><strong>空间数据索引</strong>(R-Tree)用于地理数据存储，支持多维度组合查询，必须使用GIS函数来维护数据。只有MyISAM存储引擎支持空间数据索引。</li></ul></li><li>索引优化包括使用<strong>独立的列</strong>、<strong>多列索引</strong>、<strong>选择合适的索引顺序</strong>、<strong>使用前缀索引</strong>和<strong>覆盖索引</strong>等策略，以提高查询性能和减少数据访问量。</li><li>索引的优点包括<strong>减少扫描的数据行数</strong>、<strong>避免排序和分组操作</strong>、<strong>减少随机I/O操作</strong>等。</li><li>索引适用于中到大型表，对于小型表和特大型表需要综合考虑效率和成本，并可能使用其他技术如分区来提升查询性能。</li></ul><h2 id="MySQL-索引">MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3 id="B-Tree-索引">B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><h3 id="哈希索引">哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="全文索引">全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="空间数据索引">空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h2 id="索引优化">索引优化</h2><h3 id="独立的列">独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><h3 id="多列索引">多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><h3 id="索引列的顺序">索引列的顺序</h3><p>让选择性最强的索引列放在前面，索引的选择性是指: 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><h3 id="前缀索引">前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>对于前缀长度的选取需要根据索引选择性来确定。</p><h3 id="覆盖索引">覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点:</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎(例如 MyISAM)在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用(通常比较费时)。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="索引的优点">索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。</li><li>将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。</li></ul><h2 id="索引的使用场景">索引的使用场景</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li><li>对于中到大型的表，索引就非常有效。</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 存储引擎</title>
      <link href="/database/mysql/mysql-cun-chu-yin-qing/"/>
      <url>/database/mysql/mysql-cun-chu-yin-qing/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 存储引擎</h1><h2 id="Metadata-4">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 存储引擎date: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 存储引擎</code></pre><h2 id="概述-2">概述</h2><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>并发</td><td>支持行级锁</td><td>只支持表级锁</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>备份</td><td>支持在线热备份</td><td>不支持</td></tr><tr><td>崩溃恢复</td><td>崩溃后损坏概率低且恢复速度较快</td><td>崩溃后损坏概率高且恢复速度较慢</td></tr><tr><td>其它特性</td><td>较多优化，聚簇索引，MVCC，预测性读等</td><td>压缩表，空间数据索引等</td></tr></tbody></table><h2 id="InnoDB">InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎。</strong></p><p>将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB</p><p>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="MyISAM">MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p><strong>不支持事务。</strong></p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="比较">比较</h2><ul><li>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键: InnoDB 支持外键。</li><li>备份: InnoDB 支持在线热备份。</li><li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性: MyISAM 支持压缩表和空间数据索引。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 InnoDB</title>
      <link href="/database/mysql/mysql-innodb/"/>
      <url>/database/mysql/mysql-innodb/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 InnoDB</h1><h2 id="Metadata-6">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 InnoDBdate: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description:  MySQL 默认的事务型存储引擎，**只有在需要它不支持的特性时，才考虑使用其它存储引擎。**</code></pre><h2 id="概述-4">概述</h2><p>InnoDB是MySQL的默认事务型存储引擎，除非需要其他引擎所支持的特性，否则应该优先考虑使用InnoDB。</p><h3 id="行格式">行格式</h3><p><img src="/attachment/ffcf84f82ac6280384c56151ffc2bd25.png" alt=""></p><ol><li>InnoDB将数据划分为以页为单位的基本交互单元，页的大小通常为<strong>16KB</strong>。</li><li>行格式是指以<strong>记录</strong>为单位向表中<strong>插入数据</strong>的方式，也被称为记录格式。InnoDB支持多种行格式，包括<strong>Compact</strong>、<strong>Redundant</strong>、<strong>Dynamic</strong>和<strong>Compressed</strong>。</li><li>COMPACT行格式是InnoDB中的一种行格式，记录的<strong>额外信息</strong>包括<strong>变长字段长度列表</strong>和<strong>NULL值列表</strong>。变长字段长度列表存储了<strong>变长字段的真实数据占用的字节长度</strong>，NULL值列表表示记录中<strong>允许存储NULL值的列</strong>。<ol><li><strong>记录头信息</strong>是固定的5个字节，包含了记录的一些<strong>标识信息</strong>，如<strong>是否被删除</strong>、<strong>记录的拥有者数量</strong>等。</li><li>记录的<strong>真实数据</strong>包括<strong>隐藏列</strong>和<strong>用户自定义列</strong>，隐藏列包括<strong>row id</strong>、<strong>transaction_id</strong>和<strong>roll_pointer</strong>。<ol><li>InnoDB对主键的生成策略是优先使用用户自定义主键，如果没有定义主键则选择Unique键，如果连Unique键都没有则默认添加一个名为row_id的隐藏列作为主键。</li></ol></li><li>CHAR(M)列的存储格式取决于采用的字符集，定长字符集不会被加到变长字段长度列表，而变长字符集会被加到变长字段长度列表。</li></ol></li><li>REDUNDANT行格式是InnoDB中的另一种行格式，包括<strong>字段长度偏移列表</strong>和<strong>记录头信息</strong>。字段长度偏移列表按<strong>逆序</strong>存储了记录中<strong>各列的长度信息</strong>。</li><li>行溢出数据指<strong>记录中超出页空间限制的部分</strong>，如VARCHAR(M)类型的数据。行溢出数据存储在其他页中，存储在记录中的是该列的部分数据和指向溢出页的地址。</li><li><strong>DYNAMIC</strong>和<strong>COMPRESSED</strong>行格式是InnoDB中的其他行格式，它们在处理行溢出数据时与COMPACT和REDUNDANT有所不同，DYNAMIC和COMPRESSED行格式会将所有字节存储在其他页面中，并在记录的真实数据处存储其他页面的地址。COMRESSED行格式还使用<strong>压缩算法</strong>对页面进行压缩以节省空间。</li></ol><h3 id="数据页">数据页</h3><p><img src="/attachment/a31994d655b51a3ad784cdb78a37cdec.png" alt=""></p><ol><li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于<strong>存放记录</strong>的页叫做<strong>数据页</strong>。</li><li>一个数据页可以被大致划分为7个部分，分别是<ul><li><strong>File Header</strong> ，表示<strong>页的一些通用信息</strong>，占固定的38字节。</li><li><strong>Page Header</strong> ，表示<strong>数据页专有的一些信息</strong>，占固定的56个字节。</li><li><strong>Infimum + Supremum</strong> ，两个<strong>虚拟的伪记录</strong>，分别表示页中的<strong>最小和最大记录</strong>，占固定的26 个字节。</li><li><strong>User Records</strong> ：<strong>真实存储我们插入的记录</strong>的部分，大小不固定。</li><li><strong>Free Space</strong> ：<strong>页中尚未使用的部分</strong>，大小不确定。</li><li><strong>Page Directory</strong> ：<strong>页中的某些记录相对位置</strong>，也就是<strong>各个槽在页面中的地址偏移量</strong>，大小不固定，插入的记录越多，这个部分占用的空间越多。</li><li><strong>File Trailer</strong> ：用于<strong>检验页是否完整</strong>的部分，占用固定的8个字节。</li></ul></li><li>每个记录的头信息中都有一个<strong>next_record</strong> 属性，从而使页中的所有记录串联成一个单链表。</li><li>InnoDB 会为把<strong>页中的记录</strong>划分为若干个<strong>组</strong>，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory 中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul><li>通过<strong>二分法</strong>确定该记录所在的槽。</li><li>通过记录的<strong>next_record属性遍历</strong>该槽所在的组中的各个记录。</li></ul></li><li>每个数据页的File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<strong>双链表</strong>。</li><li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的<strong>校验和</strong>和页面最后修改时<strong>对应的LSN 值</strong>，如果首部和尾部的校验和和LSN 值校验不成功的话，就说明同步过程出现了问题。</li></ol><h2 id="InnoDB-2">InnoDB</h2><p>MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎。</strong></p><p>将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16KB。</p><h2 id="行格式-2">行格式</h2><p>以<strong>记录</strong>为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为<strong>行格式</strong>或者<strong>记录格式</strong>。</p><p>分别是Compact、Redundant、Dynamic和Compressed行格式</p><h3 id="COMPACT行格式">COMPACT行格式</h3><p><img src="/attachment/ffcf84f82ac6280384c56151ffc2bd25.png" alt=""></p><h4 id="记录的额外信息">记录的额外信息</h4><p>服务器为了描述这条记录而不得不额外添加的一些信息</p><h5 id="变长字段长度列表">变长字段长度列表</h5><p>变长字段占用的存储空间:</p><ol><li>真正的数据内容</li><li>占用的字节数</li></ol><p>把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序<strong>逆序</strong>存放</p><p>表示真实数据占用的字节数, InnoDB 有它的一套规则，我们首先声明一下W 、M 和L 的意思：</p><ul><li>假设某个字符集中表示一个字符最多需要使用的字节数为W, 如 utf-8 W=3</li><li>对于变长类型VARCHAR(M) 来说，这种类型表示能存储最多M 个字符, 这个类型能表示的字符串最多占用的字节数就是M×W</li><li>假设它实际存储的字符串占用的字节数是L 。</li></ul><p><strong>规则</strong></p><ul><li>如果M×W &lt;= 255 ，那么使用1个字节来表示真正字符串占用的字节数。</li><li>如果M×W &gt; 255 ，则分为两种情况：<ul><li>如果L &lt;= 127 ，则用1个字节来表示真正字符串占用的字节数。</li><li>如果L &gt; 127 ，则用2个字节来表示真正字符串占用的字节数。</li></ul></li></ul><p>总结一下就是说：如果该可变字段允许存储的最大字节数（ M×W ）超过255字节并且真实存储的字节数（ L ）超过127字节，则使用2个字节，否则使用1个字节。</p><p><strong>变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的</strong></p><h5 id="NULL值列表">NULL值列表</h5><ul><li>首先统计表中允许存储NULL 的列有哪些。</li><li>如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列</li><li>MySQL 规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0 。</li></ul><h5 id="记录头信息">记录头信息</h5><p>固定的5 个字节组成。5 个字节也就是40 个二进制位，不同的位代表不同的意思</p><p><img src="/attachment/92b510b3a75ffc30bdf391748efce9ac.png" alt=""></p><table><thead><tr><th>名称</th><th>大小(单位: bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>“表示当前记录的类型,0表示普通记录,1表示B+树非叶子节点记录,2表示最小记录,3 表示最大记录”</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h4 id="记录的真实数据">记录的真实数据</h4><p>MySQL 会为每个记录默认的添加一些列（也称为隐藏列）</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row id</td><td>否</td><td>6字节</td><td>“行ID,唯一标识一条记录”</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p><strong>InnoDB 表对主键的生成策略</strong></p><ul><li>优先使用用户自定义主键作为主键</li><li>，如果用户没有定义主键，则选取一个Unique 键作为主键</li><li>如果表中连Unique 键都没有定义的话，则InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键</li></ul><p><strong>InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的</strong></p><p><img src="/attachment/164897cb2e3fc44d89528b0d3cf79ca4.png" alt=""></p><h4 id="CHAR-M-列的存储格式">CHAR(M)列的存储格式</h4><p>对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，<br>而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</p><h3 id="Redundant行格式">Redundant行格式</h3><p><img src="/attachment/c8a585e1b88c21da69c71bd0d5b6d2ac.png" alt=""></p><p><img src="/attachment/e615d50c68ae175b01974487ee04f066.png" alt=""></p><p><img src="/attachment/58357277011ad88f08775b314c6f05a1.png" alt=""></p><h4 id="字段长度偏移列表">字段长度偏移列表</h4><ul><li>Redundant 行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表</li><li>多了个偏移两个字，这意味着计算列值长度的方式不像Compact 行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。</li></ul><h4 id="记录头信息-2">记录头信息</h4><p>Redundant 行格式的记录头信息占用6 字节， 48 个二进制位</p><h5 id="Redundant-行格式中NULL-值的处理">Redundant 行格式中NULL 值的处理</h5><p>字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为NULL 的依据，该比特位也可以被称之为NULL比特位。</p><p>在解析一条记录的某个列时，首先看一下该列对应的偏移量的NULL比特位是不是为1 ，如果为1 ，那么该列的值就是NULL ，否则不是NULL 。</p><h5 id="CHAR-M-列的存储格式-2">CHAR(M)列的存储格式</h5><p>只要是使用CHAR(M) 类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和M 的乘积。</p><h4 id="行溢出数据">行溢出数据</h4><h5 id="VARCHAR-M-最多能存储的数据">VARCHAR(M)最多能存储的数据</h5><p>M 最大值是 65535 / W</p><h5 id="记录中的数据太多产生的溢出">记录中的数据太多产生的溢出</h5><p>在本记录的真实数据处只会存储该列的前768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做<strong>行溢出</strong>，存储超出768 字节的那些页面也被称为<strong>溢出页</strong>。</p><p><img src="/attachment/fa846e68587c3abb51a847d2138c0d10.png" alt=""></p><h5 id="行溢出的临界点">行溢出的临界点</h5><p>MySQL 中规定一个页中至少存放两行记录</p><p>一个行中存储了很大的数据时，可能发生行溢出的现象</p><h3 id="Dynamic和Compressed行格式">Dynamic和Compressed行格式</h3><p>版本是5.7 ，它的默认行格式就是<strong>Dynamic</strong></p><p>这俩行格式和Compact 行格式挺像，只不过在处理行溢出数据时有点儿分歧<br>把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址</p><p><img src="/attachment/65e9f4a9a902df32abf850d2fc6caaba.png" alt=""></p><p>Compressed 行格式和Dynamic 不同的一点是， Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间。</p><h2 id="InnoDB数据页结构">InnoDB数据页结构</h2><h3 id="不同类型的页简介">不同类型的页简介</h3><p>一个页的大小一般是16KB</p><p>InnoDB 为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE 信息的页，存放undo 日志信息的页等等等等</p><p>存放记录的页为索引（ INDEX ）页</p><h3 id="数据页结构的快速浏览">数据页结构的快速浏览</h3><p><img src="/attachment/a31994d655b51a3ad784cdb78a37cdec.png" alt=""></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56 字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td>26字节</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8 字节</td><td>校验页是否完整</td></tr></tbody></table><h3 id="记录在页中的存储">记录在页中的存储</h3><p><img src="/attachment/f7714d3da222a5413d0ae4326b8fb6b5.png" alt=""></p><h4 id="记录头信息的秘密">记录头信息的秘密</h4><ul><li>delete_mask</li></ul><p>这个属性标记着当前记录是否被删除，占用1个二进制位，值为0 的时候代表记录并没有被删除，为1 的时候代表记录被删除掉了。</p><p>这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗</p><p>所有被删除掉的记录都会组成一个所谓的<strong>垃圾链表</strong>，在这个链表中的记录占用的空间称之为所谓的<strong>可重用空间</strong>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><ul><li>min_rec_mask</li></ul><p>B+树的每层非叶子节点中的最小记录都会添加该标记</p><ul><li>heap_no</li></ul><p>自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<strong>伪记录</strong>或者<strong>虚拟记录</strong></p><p>这两个伪记录一个代表<strong>最小记录</strong>，一个代表<strong>最大记录</strong></p><p>最小记录和最大记录的heap_no 值分别是0 和1</p><ul><li>record_type</li></ul><p>表示当前记录的类型</p><p>0 表示普通记录<br>1 表示B+树非叶节点记录 (目录项记录)<br>2 表示最小记录<br>3 表示最大记录</p><ul><li>next_record</li></ul><p>从当前记录的真实数据到下一条记录的真实数据的地址偏移量</p><p>下一条记录指得是按照主键值由小到大的顺序的下一条记录</p><p>规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）</p><h3 id="Page-Directory（页目录）">Page Directory（页目录）</h3><ol><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory ，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为槽（英文名： Slot ），所以这个页面目录就是由槽组成的。</li></ol><p>对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。</p><p><strong>分组是按照下边的步骤进行的</strong></p><p>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。<br>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。<br>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</p><p><strong>在一个数据页中查找指定主键值的记录的过程分为两步</strong></p><ol><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li><li>通过记录的next_record 属性遍历该槽所在的组中的各个记录。</li></ol><h3 id="Page-Header（页面头部）">Page Header（页面头部）</h3><p>Page Header 是专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽</p><table><thead><tr><th>名称</th><th>描述</th><th>占用空间大小</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE HEAP_TOP</td><td>2字节</td><td>“还未使用的空间最小地址,也就是说从该地址之后就是Free Space”</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量(包括最小和最大记录以及标记为删除的记录)</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>“第一个已经标记为删除的记录地址(各个已删除的记录通过next_record 也会组成一个单链表,这个单链表中的记录可以被重新利用)”</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量(不包括最小和最大记录以及被标记为删除的记录)</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>“修改当前页的最大事务ID,该值仅在二级索引中定义”</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>“索引ID,表示当前页属于哪个索引”</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10 字节</td><td>“B+树叶子段的头部信息,仅在B+树的Root顷定义”</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10 字节</td><td>“B+树非叶子段的头部信息,仅在B+树的Root页定义”</td></tr></tbody></table><ul><li>PAGE_DIRECTION</li></ul><p>新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION 。</p><ul><li>PAGE_N_DIRECTION</li></ul><p>InnoDB 会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION 这个状态表示</p><h3 id="File-Header（文件头部）">File Header（文件头部）</h3><p>描述了一些针对各种页都通用的一些信息</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4字节</td><td>页的校验和 (checksum值)</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号</td></tr><tr><td>FIL_PAGE PREV</td><td>4字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL PAGE LSN</td><td>8字节</td><td>页面被最后修改时对应的日志序列位置(英文名是:Log Sequence Number)</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE FILE FLUSH LSN</td><td>8字节</td><td>“仅在系统表空间的一个页中定义,代表文件至少被刷新到了对应的LSN值”</td></tr><tr><td>FIL_ PAGE ARCH_ LOG NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li>FIL_PAGE_SPACE_OR_CHKSUM</li></ul><p>当前页面的校验和（checksum）</p><ul><li>FIL_PAGE_OFFSET</li></ul><p>每一个页都有一个单独的页号，就跟你的身份证号码一样， InnoDB 通过页号来可以唯一定位一个页。</p><ul><li>FIL_PAGE_TYPE</li></ul><p>这个代表当前页的类型</p><ul><li>FIL_PAGE_PREV 和FIL_PAGE_NEXT</li></ul><p>FIL_PAGE_PREV 和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号</p><p>并不是所有类型的页都有上一个和下一个页的属性</p><h3 id="File-Trailer">File Trailer</h3><p>每个页的尾部都加了一个File Trailer 部分</p><ul><li>前4个字节代表页的校验和</li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 B+树索引</title>
      <link href="/database/mysql/mysql-b-shu-suo-yin/"/>
      <url>/database/mysql/mysql-b-shu-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 B+树索引</h1><h2 id="Metadata-8">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 B+树索引date: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 B+树索引</code></pre><h2 id="概述-6">概述</h2><p><img src="/attachment/5e8716f5b84177f30a945ea56fee30bd.png" alt=""></p><ol><li>InnoDB中的索引方案：<ul><li>使用页作为存储单位。</li><li>目录项记录存储目录项的页，具有不同的record_type和列。</li><li>用户记录存放在B+树的最底层节点。</li><li><strong>聚簇索引</strong>：主键值搜索时有效，叶子节点存储完整的用户记录。</li><li><strong>二级索引</strong>：通过非主键列搜索，需要在聚簇索引中查找完整记录。</li><li><strong>联合索引</strong>：以多个列的大小作为排序规则建立索引。</li></ul></li><li>InnoDB的B+树索引注意事项：<ul><li><strong>根页面不移动</strong>。</li><li><strong>内节点中目录项记录的唯一性</strong>。</li><li><strong>页面最少存储2条记录</strong>。</li></ul></li><li>索引的使用</li><li>B+ 树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li><li>B+ 树索引适用于下边这些情况：<ul><li><strong>全值匹配</strong></li><li><strong>匹配左边的列</strong></li><li><strong>匹配范围值</strong></li><li><strong>精确匹配某一列并范围匹配另外一列</strong></li><li><strong>用于排序</strong></li><li><strong>用于分组</strong></li></ul></li><li>在使用索引时需要注意下边这些事项：<ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT 属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</li></ul></li></ol><h2 id="没有索引的查找">没有索引的查找</h2><h3 id="在一个页中的查找">在一个页中的查找</h3><ul><li>以主键为搜索条件<br>可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li><li>以其他列作为搜索条件<br>只能从最小记录开始依次遍历单链表中的每条记录</li></ul><h3 id="在很多页中查找">在很多页中查找</h3><p>分为两个步骤</p><ol><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。</li></ol><p>由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录</p><h2 id="索引">索引</h2><p>index_demo 举例</p><p><img src="/attachment/53e7396e9df54ca7190cd8b1be8e8e94.png" alt=""></p><ul><li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、2 表示最小记录、3 表示最大记录、1 我们还没用过，等会再说～</li><li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</li><li>各个列的值：这里只记录在index_demo 表中的三个列，分别是c1 、c2 和c3 。</li><li>其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><h3 id="一个简单的索引方案">一个简单的索引方案</h3><p>新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着</p><p>通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为页分裂。</p><p><img src="/attachment/3032ab03a12c806ba14dace97835f1e1.png" alt=""></p><p><img src="/attachment/3d9d70c7b97da1939ace1387b2af92ed.png" alt=""></p><h3 id="InnoDB中的索引方案">InnoDB中的索引方案</h3><p>InnoDB 是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB 的连续存储空间</p><p>复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<strong>目录项记录</strong></p><ul><li>目录项记录和普通的用户记录的不同点：</li><li>目录项记录的record_type 值是1，而普通用户记录的record_type 值是0。</li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB 自己添加的隐藏列。</li><li>还记得我们之前在唠叨记录头信息的时候说过一个叫min_rec_mask 的属性么，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask 值为1 ，其他别的记录的min_rec_mask 值都是0 。</li></ul><p><strong>实际用户记录其实都存放在B+树的最底层的节点上</strong><br>非叶子节点存储目录项</p><h4 id="聚簇索引">聚簇索引</h4><p><strong>只能在搜索条件是主键值时才能发挥作用</strong></p><p>B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义</li></ol><ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul><ol start="2"><li>B+ 树的叶子节点存储的是完整的用户记录。</li></ol><p>把具有这两种特性的B+ 树称为<strong>聚簇索引</strong>, 所有完整的用户记录都存放在这个聚簇索引的叶子节点处。</p><p>InnoDB 存储引擎会自动的为我们创建聚簇索引，<br>在InnoDB 存储引擎中， 聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。</p><h4 id="二级索引">二级索引</h4><p>这个B+ 树与上边介绍的聚簇索引有几处不同</p><ul><li>使用记录c2 列的大小进行记录和页的排序，这包括三个方面的含义：<ul><li>页内的记录是按照c2 列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的c2 列大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2 列大小顺序排成一个双向链表。</li></ul></li><li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是<strong>c2列+主键这两个列的值</strong>。</li><li>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。</li></ul><p>如果我们现在想通过c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个B+ 树了。</p><ol><li>确定目录项记录页</li></ol><ul><li>根据根页面，也就是页44 ，可以快速定位到目录项记录所在的页为页42 （因为2 &lt; 4 &lt; 9 ）。</li></ul><ol start="2"><li>通过目录项记录页确定用户记录真实所在的页。</li></ol><ul><li>在页42 中可以快速定位到实际存储用户记录的页，但是由于c2 列并没有唯一性约束，所以c2 列值为4 的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4 ，所以确定实际存储用户记录的页在页34 和页35 中。</li></ul><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录。</li></ol><ul><li>到页34 和页35 中定位到具体的记录。</li></ul><ol start="4"><li>但是这个B+ 树的叶子节点中的记录只存储了c2 和c1 （也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li></ol><h4 id="联合索引">联合索引</h4><p>同时以多个列的大小作为排序规则，也就是同时为多个列建立索引</p><ul><li>先把各个记录和页按照c2 列进行排序。</li><li>在记录的c2 列相同的情况下，采用c3 列进行排序</li></ul><p><img src="/attachment/5e8716f5b84177f30a945ea56fee30bd.png" alt=""></p><ul><li>每条目录项记录都由c2 、c3 、页号这三个部分组成，各条记录先按照c2 列的值进行排序，如果记录的c2 列相同，则按照c3 列的值进行排序。</li><li>B+ 树叶子节点处的用户记录由c2 、c3 和主键c1 列组成。</li></ul><p>以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，，不同点如下</p><ul><li>建立联合索引只会建立如上图一样的1棵B+ 树。</li><li>为c2和c3列分别建立索引会分别以c2 和c3 列的大小为排序规则建立2棵B+ 树。</li></ul><h3 id="InnoDB的B-树索引的注意事项">InnoDB的B+树索引的注意事项</h3><ul><li>根页面万年不动窝</li></ul><p>一个B+树索引的根节点自诞生之日起，便不会再移动</p><ul><li>内节点中目录项记录的唯一性</li></ul><p>B+ 树索引的内节点中目录项记录的内容是索引列 + 页号的搭配</p><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是<strong>唯一</strong>的。</p><p>对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的</p><ul><li><p>索引列的值</p></li><li><p>主键值</p></li><li><p>页号</p></li><li><p>一个页面最少存储2条记录</p></li></ul><h3 id="MyISAM中的索引方案简单介绍">MyISAM中的索引方案简单介绍</h3><p>MyISAM 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p><p><img src="/attachment/09cb1fba274d4c535a4d2e97eb335ad1.png" alt=""></p><ul><li>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。</li><li>使用MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。 MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 行号的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！ <strong>MyISAM 中建立的索引相当于全部都是二级索引！</strong></li></ul><h2 id="B-树索引的使用">B+树索引的使用</h2><ul><li>每个索引都对应一棵B+ 树， B+ 树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+ 树的叶子节点，所有目录项记录都存储在内节点。</li><li>InnoDB 存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li><li>我们可以为自己感兴趣的列建立二级索引， 二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li><li>B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li><li>通过索引查找记录是从B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory （页目录），所以在这些页面中的查找非常快。</li></ul><h3 id="索引的代价">索引的代价</h3><p><strong>空间上的代价</strong></p><p>每一棵B+ 树的每一个节点都是一个数据页，一个页默认会占用16KB 的存储空间，一棵很大的B+ 树由许多数据页组成，那可是很大的一片存储空间</p><p><strong>时间上的代价</strong></p><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+ 树索引</p><h3 id="B-树索引适用的条件">B+树索引适用的条件</h3><p><img src="/attachment/d558ddd7a59fdd09e941a154b8b154bb.png" alt=""></p><p>从图中可以看出，这个idx_name_birthday_phone_number 索引对应的B+ 树中页面和记录的排序方式就是这样的：</p><ul><li>先按照name 列的值进行排序。</li><li>如果name 列的值相同，则按照birthday 列的值进行排序。</li><li>如果birthday 列的值也相同，则按照phone_number 的值进行排序。</li></ul><p>因为只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找。</p><h4 id="全值匹配">全值匹配</h4><pre><code class="language-sql">SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';</code></pre><ul><li>因为B+ 树的数据页和记录先是按照name 列的值进行排序的，所以先可以很快定位name 列的值是Ashburn的记录位置。</li><li>在name 列相同的记录里又是按照birthday 列的值进行排序的，所以在name 列的值是Ashburn 的记录里又可以快速定位birthday 列的值是’1990-09-27’ 的记录。</li><li>如果很不幸， name 和birthday 列的值都是相同的，那记录是按照phone_number 列的值排序的，所以联合索引中的三个列都可能被用到。</li></ul><p>WHERE 子句中的几个搜索条件的顺序对查询结果有啥影响么？</p><p><strong>查询优化器</strong></p><p>分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。</p><h4 id="匹配左边的列">匹配左边的列</h4><p>下边的语句就用不到这个B+ 树索引</p><pre><code class="language-sql">SELECT * FROM person_info WHERE birthday = '1990-09-27';</code></pre><p>B+ 树的数据页和记录先是按照name 列的值排序的，在name 列的值相同的情况下才使用birthday 列进行排序，也就是说name 列的值不同的记录中birthday 的值可能是无序的。</p><p><strong>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</strong></p><h4 id="匹配列前缀">匹配列前缀</h4><p>一个排好序的字符串列其实有这样的特点：</p><ul><li>先按照字符串的第一个字符进行排序。</li><li>如果第一个字符相同再按照第二个字符进行排序。</li><li>如果第二个字符相同再按照第三个字符进行排序，依此类推。</li></ul><h4 id="匹配范围值">匹配范围值</h4><p>所有记录都是按照索引列的值从小到大的顺序排好序的</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-sql">SELECT * FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlow';</code></pre><hr><ol><li>找到name 值为Asa 的记录。</li><li>找到name 值为Barlow 的记录。</li><li>哦啦，由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来喽～</li><li>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</li></ol></div><p><strong>如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+ 树索引</strong></p><h4 id="精确匹配某一列并范围匹配另外一列">精确匹配某一列并范围匹配另外一列</h4><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找</p><pre><code class="language-sql">SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday &gt; '1980-01-01' AND birthday &lt; '2000-12-31' AND phone_number &gt; '15100000000';</code></pre><p>这个查询的条件可以分为3个部分：</p><ol><li>name = ‘Ashburn’ ，对name 列进行精确查找，当然可以使用B+ 树索引了。</li><li>birthday &gt; ‘1980-01-01’ AND birthday &lt; ‘2000-12-31’ ，由于name 列是精确查找，所以通过name = ‘Ashburn’ 条件查找后得到的结果的name 值都是相同的，它们会再按照birthday 的值进行排序。所以此时对birthday 列进行范围查找是可以用到B+ 树索引的。</li><li>phone_number &gt; ‘15100000000’ ，通过birthday 的范围查找的记录的birthday 的值可能不同，所以这个条件无法再利用B+ 树索引了，只能遍历上一步查询得到的记录。</li></ol><h4 id="用于排序">用于排序</h4><h5 id="使用联合索引进行排序注意事项">使用联合索引进行排序注意事项</h5><p>ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出, 否则索引失效</p><h5 id="不可以使用索引进行排序的几种情况">不可以使用索引进行排序的几种情况</h5><p><strong>ASC、DESC混用</strong></p><p><strong>WHERE子句中出现非排序使用到的索引列</strong></p><p><strong>排序列包含非同一个索引的列</strong></p><p><strong>排序列使用了复杂的表达式</strong></p><h4 id="用于分组">用于分组</h4><p>分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组</p><h3 id="回表的代价">回表的代价</h3><p>在使用idx_name_birthday_phone_number 索引进行查询时大致可以分为这两个步骤</p><ol><li>从索引idx_name_birthday_phone_number 对应的B+ 树中取出name 值在Asa ～ Barlow 之间的用户记录。</li><li>由于索引idx_name_birthday_phone_number 对应的B+ 树用户记录中只包含name 、birthday 、phone_number 、id 这4个字段，而查询列表是* ，意味着要查询表中所有字段，也就是还要包括country字段。这时需要把从上一步中获取到的每一条记录的id 字段都到聚簇索引对应的B+ 树中找到完整的用户记录，也就是我们通常所说的回表，然后把完整的用户记录返回给查询用户。</li></ol><p><strong>需要回表的记录越多，使用二级索引的性能就越低</strong></p><h4 id="覆盖索引-2">覆盖索引</h4><p>最好在查询列表里只包含索引列</p><p>我们很不鼓励用* 号作为查询列表，最好把我们需要查询的列依次标明。</p><h3 id="如何挑选索引">如何挑选索引</h3><p><strong>只为用于搜索、排序或分组的列创建索引</strong></p><p><strong>考虑列的基数</strong></p><p><strong>索引列的类型尽量小</strong></p><p><strong>索引字符串值的前缀</strong></p><p>只对字符串的前几个字符进行索引</p><p>只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</p><p><strong>让索引列在比较表达式中单独出现</strong></p><p><strong>主键插入顺序</strong></p><p><strong>冗余和重复索引</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 数据目录</title>
      <link href="/database/mysql/mysql-shu-ju-mu-lu/"/>
      <url>/database/mysql/mysql-shu-ju-mu-lu/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 数据目录</h1><h2 id="Metadata-18">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 数据目录date: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 数据目录</code></pre><h2 id="概述-13">概述</h2><ul><li>表空间类型：<ul><li><strong>系统表空间（system tablespace）</strong>：对应文件系统上的一个或多个实际文件，InnoDB使用名为ibdata1的文件来存储数据。</li><li><strong>独立表空间（file-per-table tablespace）</strong>：为每个表创建一个独立的表空间，表空间文件与表名相同，使用.ibd扩展名。</li><li><strong>其他类型的表空间</strong>：通用表空间、undo表空间、临时表空间。</li></ul></li><li>其他文件：<ul><li>服务器进程文件</li><li>服务器日志文件</li><li>默认/自动生成的SSL和RSA证书和密钥文件</li></ul></li><li>文件系统对数据库的影响：<ul><li>数据库和表名称长度限制</li><li>特殊字符的问题</li><li>文件长度受文件系统最大长度限制</li></ul></li><li>MySQL系统数据库简介：<ul><li>mysql数据库：存储<strong>用户账户和权限信息</strong>、<strong>存储过程</strong>、<strong>事件的定义信息</strong>、<strong>日志信息</strong>、<strong>帮助信息</strong>、<strong>时区信息</strong>等。</li><li>information_schema数据库：保存其他数据库的信息和元数据。</li><li>performance_schema数据库：保存MySQL服务器运行过程中的状态信息。</li><li>sys数据库：通过<strong>视图</strong>将information_schema和performance_schema结合起来，<strong>提供更方便的性能信息</strong>。</li></ul></li></ul><h2 id="表空间类型">表空间类型</h2><h3 id="系统表空间（system-tablespace）">系统表空间（system tablespace）</h3><p>对应文件系统上一个或多个实际的文件</p><p>InnoDB 会在数据目录下创建一个名为ibdata1， 大小为12M 的文件</p><p>从MySQL5.5.7到MySQL5.6.6之间的各个版本中，表中的数据都会被默认存储到这个 系统表空间。</p><h3 id="独立表空间-file-per-table-tablespace">独立表空间(file-per-table tablespace)</h3><p>为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。</p><p>使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个.ibd 的扩展名而已</p><h3 id="其他类型的表空间">其他类型的表空间</h3><p>通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）</p><h3 id="其他的文件">其他的文件</h3><ul><li>服务器进程文件</li><li>服务器日志文件</li><li>默认/自动生成的SSL和RSA证书和密钥文件</li></ul><h2 id="文件系统对数据库的影响">文件系统对数据库的影响</h2><h3 id="文件系统的一些制约">文件系统的一些制约</h3><ul><li>数据库名称和表名称不得超过文件系统所允许的最大长度。</li><li>特殊字符的问题</li><li>文件长度受文件系统最大长度限制</li></ul><h2 id="MySQL系统数据库简介">MySQL系统数据库简介</h2><h3 id="mysql">mysql</h3><ul><li>核心</li><li>存储了MySQL的<ul><li>用户账户和权限信息，</li><li>一些存储过程、</li><li>事件的定义信息，</li><li>一些运行过程中产生的日志信息，</li><li>一些帮助信息</li><li>以及时区信息等。</li></ul></li></ul><h3 id="information-schema">information_schema</h3><p>保存着MySQL服务器维护的所有其他数据库的信息<br>一些描述性信息，有时候也称之为<strong>元数据</strong>。</p><h3 id="performance-schema">performance_schema</h3><p>主要保存MySQL服务器运行过程中的一些状态信息</p><h3 id="sys">sys</h3><p>通过视图的形式把information_schema 和performance_schema 结合起来<br>更方便的了解MySQL服务器的一些性能信息</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 字符集</title>
      <link href="/database/mysql/mysql-zi-fu-ji/"/>
      <url>/database/mysql/mysql-zi-fu-ji/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 字符集</h1><h2 id="Metadata-19">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 字符集date: 2022-12-20 16:12tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 字符集</code></pre><h2 id="概述-14">概述</h2><ul><li>MySQL有四个级别的字符集和比较规则：<strong>服务器级别</strong>、<strong>数据库级别</strong>、<strong>表级别</strong>和<strong>列级别</strong>。</li><li>服务器级别包括character_set_server（字符集）和collation_server（比较规则）。</li><li>数据库级别包括character_set_database（当前数据库字符集）和collation_database（当前数据库比较规则）。</li><li>在创建或修改数据库时，可以指定字符集和比较规则，使用CREATE DATABASE和ALTER DATABASE语句。</li><li>表级别包括在创建或修改表时指定字符集和比较规则，使用CREATE TABLE和ALTER TABLE语句。</li><li>列级别包括在创建或修改列时指定字符集和比较规则，使用CREATE TABLE和ALTER TABLE语句。</li><li>在请求发送到服务器并接收结果的过程中，涉及字符集转换：<ul><li><strong>客户端</strong>使用<strong>操作系统</strong>的字符集编码请求字符串，并将其作为字节串发送给服务器。</li><li><strong>服务器</strong>使用<strong>character_set_client</strong>字符集解码接收到的字节串，并按照character_set_connection字符集编码。</li><li>如果character_set_connection字符集与操作的列使用的字符集相同，则直接进行操作；否则，需要将请求中的字符串从character_set_connection字符集转换为列使用的字符集后再进行操作。</li><li>从列获取的字节串将根据character_set_results字符集转换，并发送给客户端。</li><li>客户端使用操作系统的字符集解析接收到的结果集字节串。</li></ul></li></ul><p><img src="/attachment/f96efaf8bd9a6c3dd355cf4bdd82ebd7.png" alt=""></p><h2 id="MySQL-的四个级别的字符集和比较规则">MySQL 的四个级别的字符集和比较规则</h2><h3 id="服务器级别">服务器级别</h3><p>character_set_server 表示服务器级别的字符集， collation_server 表示服务器级别的比较规则。</p><h3 id="数据库级别">数据库级别</h3><p>character_set_database 表示当前数据库的字符集， collation_database 表示当前数据库的比较规则。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">创建指定字符集和比较规则</p><pre><code class="language-java">CREATE DATABASE 【数据库名】[[DEFAULT] CHARACTER SET 【字符集名称】][[DEFAULT] COLLATIE 【比较规则名称】];</code></pre></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">修改指定字符集和比较规则</p><pre><code class="language-java">ALTER DATABASE 【数据库名】[[DEFAULT] CHARACTER SET 【字符集名称】][[DEFAULT] COLLATIE 【比较规则名称】];</code></pre></div><h3 id="表级别">表级别</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">创建指定表字符集和比较规则</p><pre><code class="language-java">CREATE TABLE 【表名】[[DEFAULT] CHARACTER SET 【字符集名称】][[DEFAULT] COLLATIE 【比较规则名称】];</code></pre></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">修改指定表字符集和比较规则</p><pre><code class="language-java">ALTER TABLE 【表名】[[DEFAULT] CHARACTER SET 【字符集名称】][[DEFAULT] COLLATIE 【比较规则名称】];</code></pre></div><h3 id="列级别">列级别</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">创建指定列字符集和比较规则</p><pre><code class="language-java">CREATE TABLE 【表名】 (【列名】【字符串类型】 [ CHARACTER SET 【字符集名称】] [ COLLATIE 【比较规则名称】],...)</code></pre></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">修改指定列字符集和比较规则</p><pre><code class="language-java">ALTER TABLE 【表名】 MODIFY【列名】【字符串类型】 [ CHARACTER SET 【字符集名称】] [ COLLATIE 【比较规则名称】];</code></pre></div><h2 id="从发送请求到接收结果过程中发生的字符集转换">从发送请求到接收结果过程中发生的字符集转换</h2><ol><li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li><li>服务器将客户端发送来的字节串采用character_set_client 代表的字符集进行解码，将解码后的字符串再按照character_set_connection 代表的字符集进行编码。</li><li>如果character_set_connection 代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从character_set_connection 代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li><li>将从某个列获取到的字节串从该列使用的字符集转换为character_set_results 代表的字符集后发送到客户端。</li><li>客户端使用操作系统的字符集解析收到的结果集字节串。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】 数据类型</title>
      <link href="/database/mysql/mysql-shu-ju-lei-xing/"/>
      <url>/database/mysql/mysql-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1>【MySQL】 数据类型</h1><h2 id="Metadata-3">Metadata</h2><pre><code class="language-yml">title: 【MySQL】 数据类型date: 2022-12-20 16:11tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/MySQLcategories:  - 数据存储keywords:  - 数据存储description: 【MySQL】 数据类型</code></pre><h2 id="概述">概述</h2><ul><li>整型字段类型包括：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。较小的整型类型通常更好，INT(11) 中的数字<strong>仅规定显示字符的个数</strong>。</li><li>浮点数字段类型包括：FLOAT、DOUBLE、DECIMAL。DECIMAL的计算比浮点类型更昂贵。</li><li>字符串字段类型包括：CHAR、VARCHAR。VARCHAR是变长类型，节省空间，但在UPDATE时可能会导致<strong>行变长</strong>。VARCHAR会保留末尾空格，而CHAR会删除。</li><li>时间和日期字段类型包括：DATETIME、TIMESTAMP。DATETIME保存从1001年到9999年的日期和时间，精度为秒。TIMESTAMP保存从1970年到2038年的秒数，与时区相关。</li></ul><p>在选择优化数据类型时，更小的类型通常更好。使用简单的类型，避免使用NULL。对于字符串类型，根据需求选择VARCHAR或CHAR。对于标识符，整数类型通常是最佳选择，避免使用字符串类型。</p><h2 id="字段类型">字段类型</h2><h3 id="整型">整型</h3><ul><li><code>TINYINT</code>:  8位存储空间</li><li><code>SMALLINT</code>: 16位存储空间</li><li><code>MEDIUMINT</code>: 24位存储空间</li><li><code>INT</code>: 32位存储空间</li><li><code>BIGINT</code>: 64位存储空间</li></ul><p>一般情况下越小的列越好。</p><p>INT(11) 中的数字<strong>只是规定了交互工具显示字符的个数</strong>，对于存储和计算来说是没有意义的。</p><h3 id="浮点数">浮点数</h3><ul><li><code>FLOAT</code> 为浮点类型</li><li><code>DOUBLE</code> 为浮点类型</li><li><code>DECIMAL</code> 为高精度小数类型</li></ul><p>CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h3 id="字符串">字符串</h3><ul><li><code>CHAR</code>: 定长</li><li><code>VARCHAR</code>: 变长</li></ul><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p><h3 id="时间和日期">时间和日期</h3><p>MySQL 提供了两种相似的日期时间类型: <code>DATETIME</code> 和 <code>TIMESTAMP</code>。</p><h4 id="DATETIME">DATETIME</h4><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值</p><h4 id="TIMESTAMP">TIMESTAMP</h4><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h2 id="选择优化的数据类型">选择优化的数据类型</h2><ul><li>更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少；</li><li>简单就好；例如，整形比字符串操作代价更低；实用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等；</li><li>尽量避免NULL；如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列</li></ul><h3 id="字符串类型">字符串类型</h3><h4 id="VARCHAR-和-CHAR">VARCHAR 和 CHAR</h4><p>VARCHAR是最常见的字符串类型。VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p><p>下面这些情况使用VARCHAR是合适的：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p><p>当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。</p><p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片（行间碎片？）。</p><h4 id="VARCHAR-5-和VARCHAR-200">VARCHAR(5)和VARCHAR(200)</h4><blockquote><p>使用VARCHAR(5)和VARCHAR(200)存储"hello"的空间开销是一样的。那么使用更短的列有什么优势吗？</p></blockquote><p>事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。</p><p>所以最好的策略是只分配真正需要的空间。</p><h4 id="BLOB-和-TEXT">BLOB 和 TEXT</h4><p>BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。</p><p>与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p><p>MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。</p><h3 id="选择表示符（identifier）">选择表示符（identifier）</h3><p>整数类型通常是标识列的最佳选择，因为它们很快并且可以使用AUTO_INCREMENT。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。 对于完全随机的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：</p><ul><li>因为插入值会随机的写入到索引的不同位置，所以使得INSERT语句更慢。这会导致叶分裂、磁盘随机访问。</li><li>SELECT语句会变的更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。</li><li>随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 权限管理</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-quan-xian-guan-li/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-quan-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>【SQL 语言】 权限管理</h1><h2 id="Metadata-30">Metadata</h2><pre><code class="language-yml">title: 【SQL 语言】 权限管理date: 2022-12-20 16:09tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 【SQL 语言】 权限管理</code></pre><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><pre><code class="language-sql">USE mysql;SELECT user FROM user;</code></pre><p><strong>创建账户</strong></p><p>新创建的账户没有任何权限。</p><pre><code class="language-sql">CREATE USER myuser IDENTIFIED BY 'mypassword';</code></pre><p><strong>修改账户名</strong></p><pre><code class="language-sql">RENAME myuser TO newuser;</code></pre><p><strong>删除账户</strong></p><pre><code class="language-sql">DROP USER myuser;</code></pre><p><strong>查看权限</strong></p><pre><code class="language-sql">SHOW GRANTS FOR myuser;</code></pre><p><strong>授予权限</strong></p><p>账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名</p><p><strong>删除权限</strong></p><p>GRANT 和 REVOKE 可在几个层次上控制访问权限:</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><pre><code class="language-sql">REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;</code></pre><p><strong>更改密码</strong></p><p>必须使用 <code>Password()</code> 函数</p><pre><code class="language-sql">SET PASSWROD FOR myuser = Password('new_password');</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 字符集</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-zi-fu-ji/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-zi-fu-ji/</url>
      
        <content type="html"><![CDATA[<h1>【SQL 语言】 字符集</h1><h2 id="Metadata-27">Metadata</h2><pre><code class="language-yml">title: 【SQL 语言】 字符集date: 2022-12-20 16:08tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 字符集为字母和符号的集合</code></pre><p>基本术语:</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定:</p><pre><code class="language-sql">CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;</code></pre><p>可以在排序、分组时指定校对:</p><pre><code class="language-sql">SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 事务管理</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-shi-wu-guan-li/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-shi-wu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>【SQL 语言】 事务管理</h1><h2 id="Metadata-28">Metadata</h2><pre><code class="language-yml">title: 【SQL 语言】 事务管理date: 2022-12-20 16:07tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 事务(transaction)指一组 SQL 语句</code></pre><p>基本术语:</p><ul><li>事务(transaction)指一组 SQL 语句；</li><li>回退(rollback)指撤销指定 SQL 语句的过程；</li><li>提交(commit)指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点(savepoint)指事务处理中设置的临时占位符(placeholder)，你可以对它发布回退(与回退整个事务处理不同)。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><pre><code class="language-sql">START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 游标</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-you-biao/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-you-biao/</url>
      
        <content type="html"><![CDATA[<h1>【SQL 语言】 游标</h1><h2 id="Metadata-31">Metadata</h2><pre><code class="language-yml">title: 【SQL 语言】 游标date: 2022-12-20 16:05tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</code></pre><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤:</p><ul><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ul><pre><code class="language-sql">delimiter //create procedure myprocedure(out ret int)    begin        declare done boolean default 0;        declare mycursor cursor for        select col1 from mytable;        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1        declare continue handler for sqlstate '02000' set done = 1;        open mycursor;        repeat            fetch mycursor into ret;            select ret;        until done end repeat;        close mycursor;    end // delimiter ;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 存储过程</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-cun-chu-guo-cheng/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-cun-chu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1>【SQL 语言】 存储过程</h1><h2 id="Metadata-29">Metadata</h2><pre><code class="language-yml">title: 【SQL 语言】 存储过程date: 2022-12-20 16:02tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 存储过程可以看成是对一系列 SQL 操作的批处理。</code></pre><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p><p>使用存储过程的好处:</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><pre><code class="language-sql">delimiter //create procedure myprocedure( out ret int )    begin        declare y int;        select sum(col1)        from mytable        into y;        select y*y into ret;    end //delimiter ;</code></pre><pre><code class="language-sql">call myprocedure(@ret);select @ret;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 视图</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-shi-tu/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-shi-tu/</url>
      
        <content type="html"><![CDATA[<h1>【SQL 语言】 视图</h1><h2 id="Metadata-32">Metadata</h2><pre><code class="language-yml">title: 【SQL 语言】 视图date: 2022-12-20 15:59tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</code></pre><h2 id="视图">视图</h2><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处:</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><pre><code class="language-sql">CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_colFROM mytableWHERE col5 = val;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 DML</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-dml/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-dml/</url>
      
        <content type="html"><![CDATA[<h1>【SQL 语言】 DML</h1><h2 id="Metadata-25">Metadata</h2><pre><code class="language-yml">title: 【SQL 语言】 DMLdate: 2022-12-20 15:41tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/SQL_语言categories:  - 数据存储keywords:  - 数据存储description: 数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句，通常是数据库专用编程语言之中的一个子集，例如在信息软件产业通行标准的SQL语言中，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入(意指新增或创建)、更新(修改)与删除(销毁)。在使用数据库的系统开发过程中，其中应用程序必然会使用的指令；而加上 SQL的SELECT语句，欧美地区的开发人员把这四种指令，以“CRUD”(分别为 Create, Read, Update, Delete英文四前缀字母缩略的术语)来称呼；而亚洲地区使用汉语的开发人员，或可能以四个汉字：增 查 改 删 来略称。</code></pre><h2 id="简介-2">简介</h2><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句，通常是数据库专用编程语言之中的一个子集，例如在信息软件产业通行标准的SQL语言中，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入(意指新增或创建)、更新(修改)与删除(销毁)。在使用数据库的系统开发过程中，其中应用程序必然会使用的指令；而加上 SQL的SELECT语句，欧美地区的开发人员把这四种指令，以“CRUD”(分别为 Create, Read, Update, Delete英文四前缀字母缩略的术语)来称呼；而亚洲地区使用汉语的开发人员，或可能以四个汉字：增 查 改 删来略称。</p><h2 id="语法结构">语法结构</h2><p>DML 的主要功能即是访问数据，因此其语法都是以读取与写入数据库为主，除了INSERT以外，其他指令都可能需搭配WHERE指令来过滤数据范围，或是不加WHERE指令来访问全部的数据。</p><h3 id="SELECT-2">SELECT</h3><p>主条目：SELECT<br>SELECT是SQL数据操纵语言(DML)中用于查询表格内字段数据的指令，可搭配条件限制的子句(如where)或排列顺序的子句(如order)来获取查询结果。</p><pre><code class="language-sql">SELECT select_list[ INTO new_table ]FROM table_source[ WHERE search_condition ][ GROUP BY group_by_expression ][ HAVING search_condition ][ ORDER BY order_expression [ ASC | DESC ] ]</code></pre><h4 id="DISTINCT">DISTINCT</h4><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><pre><code class="language-sql">SELECT DISTINCT col1, col2FROM mytable;</code></pre><h4 id="LIMIT">LIMIT</h4><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><h3 id="INSERT-2">INSERT</h3><p>主条目：INSERT<br>INSERT 是将数据插入到数据库对象中的指令，可以插入数据的数据库对象有数据表以及可更新查看表两种。</p><p><strong>普通插入</strong></p><pre><code class="language-sql">INSERT INTO mytable(col1, col2)VALUES(val1, val2);</code></pre><p><strong>插入检索出来的数据</strong></p><pre><code class="language-sql">INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2;</code></pre><p><strong>将一个表的内容插入到一个新表</strong></p><pre><code class="language-sql">CREATE TABLE newtable ASSELECT * FROM mytable;</code></pre><h3 id="UPDATE-2">UPDATE</h3><p>主条目：UPDATE<br>UPDATE 指令是依给定条件，将匹配条件的数据表中的数据更新为新的数值。</p><pre><code class="language-sql">UPDATE mytableSET col = valWHERE id = 1;</code></pre><h3 id="DELETE-2">DELETE</h3><p>主条目：DELETE<br>DELETE 指令为自数据库对象中删除数据的指令。</p><pre><code class="language-sql">DELETE FROM mytableWHERE id = 1;</code></pre><p><strong>TRUNCATE TABLE 可以清空表，也就是删除所有行。</strong></p><pre><code class="language-sql">TRUNCATE TABLE mytable;</code></pre><h2 id="DQL">DQL</h2><h3 id="排序">排序</h3><ul><li>ASC : 升序(默认)</li><li>DESC : 降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式:</p><pre><code class="language-sql">SELECT *FROM mytableORDER BY col1 DESC, col2 ASC;</code></pre><h3 id="过滤">过滤</h3><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;&gt; !=</td><td>不等于</td></tr><tr><td>&lt;= !&gt;</td><td>小于等于</td></tr><tr><td>&gt;= !&lt;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在两个值之间</td></tr><tr><td>IS NULL</td><td>为 NULL 值</td></tr></tbody></table><p>应该注意到，NULL 与 0、空字符串都不同。</p><p><strong>AND 和 OR 用于连接多个过滤条件</strong>。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN 操作符用于匹配一组值</strong>，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT 操作符用于否定一个条件</strong>。</p><h3 id="通配符">通配符</h3><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><code>% 匹配 &gt;=0 个任意字符</code>；</li><li><code>_ 匹配 ==1 个任意字符</code>；</li><li><code>[ ] 可以匹配集合内的字符</code>，例如 <code>[ab]</code> 将匹配字符 a 或者 b。</li><li><code>脱字符 ^ 可以对其进行否定</code>，也就是不匹配集合内的字符。</li></ul><p>使用 Like 来进行通配符匹配。</p><pre><code class="language-sql">SELECT *FROM mytableWHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本</code></pre><p><strong>不要滥用通配符，通配符位于开头处匹配会非常慢。</strong></p><h3 id="计算字段">计算字段</h3><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且<strong>转换和格式化后的数据量更少的话可以减少网络通信量</strong>。</p><p>计算字段通常需要使用 <strong>AS 来取别名</strong>，否则输出的时候字段名为计算表达式。</p><pre><code class="language-sql">SELECT col1 * col2 AS aliasFROM mytable;</code></pre><p><strong>CONCAT() 用于连接两个字段</strong>。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。</p><pre><code class="language-sql">SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_colFROM mytable;</code></pre><h3 id="函数">函数</h3><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p><h4 id="汇总">汇总</h4><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p><pre><code class="language-sql">SELECT AVG(DISTINCT col1) AS avg_colFROM mytable;</code></pre><h4 id="文本处理">文本处理</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>LEFT()</td><td>左边的字符</td></tr><tr><td>RIGHT()</td><td>右边的字符</td></tr><tr><td>LOWER()</td><td>转换为小写字符</td></tr><tr><td>UPPER()</td><td>转换为大写字符</td></tr><tr><td>LTRIM()</td><td>去除左边的空格</td></tr><tr><td>RTRIM()</td><td>去除右边的空格</td></tr><tr><td>LENGTH()</td><td>长度</td></tr><tr><td>SOUNDEX()</td><td>转换为语音值</td></tr></tbody></table><p>其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。</p><pre><code class="language-sql">SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple')</code></pre><h4 id="日期和时间处理">日期和时间处理</h4><ul><li>日期格式: YYYY-MM-DD</li><li>时间格式: HH:MM:SS</li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期(天、周等)</td></tr><tr><td>AddTime()</td><td>增加一个时间(时、分等)</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table><h4 id="数值处理">数值处理</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h3 id="分组">分组</h3><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><pre><code class="language-sql">SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num;</code></pre><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><pre><code class="language-sql">SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING num &gt;= 2;</code></pre><p>分组规定:</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h3 id="子查询">子查询</h3><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件:</p><pre><code class="language-sql">SELECT cust_name, (SELECT COUNT(*)                   FROM Orders                   WHERE Orders.cust_id = Customers.cust_id)                   AS orders_numFROM CustomersORDER BY cust_name;</code></pre><h3 id="连接">连接</h3><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h4 id="内连接">内连接</h4><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><pre><code class="language-sql">SELECT A.value, B.valueFROM tablea AS A INNER JOIN tableb AS BON A.key = B.key;</code></pre><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><pre><code class="language-sql">SELECT A.value, B.valueFROM tablea AS A, tableb AS BWHERE A.key = B.key;</code></pre><p>在没有条件语句的情况下返回笛卡尔积。</p><h4 id="自连接">自连接</h4><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><pre><code class="language-sql">SELECT nameFROM employeeWHERE department = (      SELECT department      FROM employee      WHERE name = "Jim");</code></pre><p>自连接版本</p><pre><code class="language-sql">SELECT e1.nameFROM employee AS e1 INNER JOIN employee AS e2ON e1.department = e2.department      AND e2.name = "Jim";</code></pre><h4 id="自然连接">自然连接</h4><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别: <strong>内连接提供连接的列，而自然连接自动连接所有同名列。</strong></p><pre><code class="language-sql">SELECT A.value, B.valueFROM tablea AS A NATURAL JOIN tableb AS B;</code></pre><h4 id="外连接">外连接</h4><p>外连接<strong>保留了没有关联的那些行</strong>。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><h3 id="组合查询">组合查询</h3><p>使用 <strong>UNION 来组合两个查询</strong>，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><pre><code class="language-sql">SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/SQL_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SQL 语言】 DDL</title>
      <link href="/database/sql-yu-yan/sql-yu-yan-ddl/"/>
      <url>/database/sql-yu-yan/sql-yu-yan-ddl/</url>
      
        <content type="html"><![CDATA[<h1>【SQL 语言】 DDL</h1><h2 id="Metadata-22">Metadata</h2><pre><code class="language-yml">title: 【SQL 语言】 DDLdate: 2022-12-20 15:24tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_语言categories:  - 数据存储keywords:  - 数据存储description: 数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。</code></pre><h2 id="简介">简介</h2><p>定义包括结构定义、操作方法定义等。</p><p>数据库模式定义语言并非程序设计语言，DDL数据库模式定义语言是SQL语言（结构化查询语言）的组成部分。SQL语言包括四种主要程序设计语言类别的语句：数据定义语言(DDL)，数据操作语言(DML)，数据控制语言(DCL)和事务控制语言（TCL）。</p><p>DDL描述的模式，必须由计算机软件进行编译，转换为便于计算机存储、查询和操纵的格式，完成这个转换工作的程序称为模式编译器。<br>模式编译器处理模式定义主要产生两种类型的数据：数据字典以及数据类型和结构定义。</p><p>数据字典和数据库内部结构信息是创建该模式所对应的数据库的依据，根据这些信息创建每个数据库对应的逻辑结构；对数据库数据的访问、查询也根据模式信息决定数据存取的方式和类型，以及数据之间的关系和对数据的完整性约束。</p><p>数据字典是模式的内部信息表示，数据字典的存储方式对不同的DBMS各不相同。</p><p>数据类型和结构的定义，是指当应用程序与数据库连接操作时，应用程序需要了解产生和提取的数据类型和结构。是为各种宿主语言提供的用户工作区的数据类型和结构定义，使用户工作区和数据库的逻辑结构相一致，减少数据的转换过程，这种数据类型和结构的定义通常用一个头文件来实现。</p><p>数据库模式的定义通常有两种方式: 交互方式定义模式和通过数据描述语言DDL 描述文本定义模式。</p><h2 id="常见的DDL语句">常见的DDL语句</h2><h3 id="创建数据库">创建数据库</h3><pre><code class="language-sql">CREATE {DATABASE | SCHEMA} db_name[create_specification [, create_specification] ...]create_specification:[DEFAULT] CHARACTER SET charset_name -- 字符集| [DEFAULT] COLLATE collation_name  -- 排序</code></pre><pre><code class="language-sql">CREATE DATABASE test;USE test;</code></pre><h3 id="创建数据库表格">创建数据库表格</h3><pre><code class="language-sql">CREATE [TEMPORARY] TABLE tbl_name[(create_definition,...)][table_options] [select_statement]</code></pre><pre><code class="language-sql">CREATE TABLE mytable (  id INT NOT NULL AUTO_INCREMENT,  col1 INT NOT NULL DEFAULT 1,  col2 VARCHAR(45) NULL,  col3 DATE NULL,  PRIMARY KEY (`id`));</code></pre><h3 id="修改数据库表格">修改数据库表格</h3><pre><code class="language-sql">ALTER TABLE tbl_namealter_specification [, alter_specification] ...alter_specification:ADD [COLUMN] column_definition [FIRST | AFTER col_name ] -- 添加列| ADD [COLUMN] (column_definition,...) -- 添加列| ADD INDEX (index_col_name,...) -- 增加索引| ADD [CONSTRAINT [symbol]]PRIMARY KEY (index_col_name,...) -- 增加主键约束| ADD [CONSTRAINT [symbol]]UNIQUE (index_col_name,...) -- 增加联合约束| ADD (index_col_name,...)  -- | ADD [CONSTRAINT [symbol]]FOREIGN KEY (index_col_name,...)[reference_definition]  -- 增加外键约束| ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT} -- 修改列| CHANGE [COLUMN] old_col_name column_definition[FIRST|AFTER col_name] -- 修改列| MODIFY [COLUMN] column_definition [FIRST | AFTER col_name] -- 修改列| DROP [COLUMN] col_name -- 删除列| DROP PRIMARY KEY -- 删除主键| DROP INDEX index_name -- 删除主键| DROP FOREIGN KEY fk_symbol -- 删除外键| DISABLE KEYS  -- 停用| ENABLE KEYS  -- 启用| RENAME [TO] new_tbl_name -- 重命名表| ORDER BY col_name  -- 排序| CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]  -- 修改字符集| [DEFAULT] CHARACTER SET charset_name [COLLATE collation_name] -- 修改字符集| DISCARD TABLESPACE  -- 丢弃表空间| IMPORT TABLESPACE  -- 引入表空间| table_options  -- 表设置</code></pre><p><strong>添加列</strong></p><pre><code class="language-sql">ALTER TABLE mytableADD col CHAR(20);</code></pre><p><strong>修改列和属性</strong></p><pre><code class="language-sql">---ALTER TABLE 表名 CHANGE 原字段名 新字段名 字段类型 约束条件ALTER TABLE mytable CHANGE col col1 CHAR(32) NOT NULL DEFAULT '123';</code></pre><p><strong>删除列</strong></p><pre><code class="language-sql">ALTER TABLE mytableDROP COLUMN col;</code></pre><h3 id="删除数据库表格">删除数据库表格</h3><pre><code class="language-sql">DROP [TEMPORARY] TABLEtbl_name [, tbl_name] ...[RESTRICT | CASCADE]</code></pre><pre><code class="language-sql">DROP TABLE mytable;</code></pre><h3 id="创建查询视图命令">创建查询视图命令</h3><pre><code class="language-sql">CREATE[ORREPLACE][ALGORITHM={UNDEFINED|MERGE|TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION]</code></pre><h3 id="修改查询视图命令">修改查询视图命令</h3><pre><code class="language-sql">ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION]</code></pre><h3 id="删除查询视图命令">删除查询视图命令</h3><pre><code class="language-sql">DROP VIEWview_name [, view_name] ...[RESTRICT | CASCADE]</code></pre><h3 id="删除数据表内容">删除数据表内容</h3><pre><code class="language-sql">TRUNCATE TABLE name [DROP/REUSE STORAGE]</code></pre><p>DROP STORAGE：显式指明释放数据表和索引的空间<br>REUSE STORAGE：显式指明不释放数据表和索引的空间</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DB SQL】 数据库系统核心知识点</title>
      <link href="/database/db-sql/db-sql-shu-ju-ku-xi-tong-he-xin-zhi-shi-dian/"/>
      <url>/database/db-sql/db-sql-shu-ju-ku-xi-tong-he-xin-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1>【DB SQL】 数据库系统核心知识点</h1><h2 id="Metadata-4">Metadata</h2><pre><code class="language-yml">title: 【DB SQL】 数据库系统核心知识点date: 2022-12-20 15:21tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_SQLcategories:  - 数据存储keywords:  - 数据存储description: 【DB SQL】 数据库系统核心知识点</code></pre><blockquote><p>基于上篇数据库如何工作的基础之上，我们再来梳理下数据库系统中有哪些重要的知识点，包括：事务，并发一致性，封锁，隔离级别，多版本并发控制等。</p></blockquote><h2 id="事务">事务</h2><h3 id="概念">概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><img src="/attachment%5Cf433648c0eba3c43c7e41ba85a824c43.png" alt></p><h3 id="ACID">ACID</h3><h4 id="原子性-Atomicity">原子性(Atomicity)</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。<br>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h4 id="一致性-Consistency">一致性(Consistency)</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h4 id="隔离性-Isolation">隔离性(Isolation)</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h4 id="持久性-Durability">持久性(Durability)</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系:</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><p><img src="/attachment%5Cee1e1fea79addc52ab928237f5044b08.png" alt></p><h3 id="AUTOCOMMIT">AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h2 id="并发一致性问题">并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h3 id="丢失修改">丢失修改</h3><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><h3 id="读脏数据">读脏数据</h3><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h3 id="不可重复读">不可重复读</h3><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h3 id="幻影读">幻影读</h3><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h2 id="封锁">封锁</h2><h3 id="封锁粒度">封锁粒度</h3><p>MySQL 中提供了两种封锁粒度: 行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h3 id="封锁类型">封锁类型</h3><h4 id="读写锁">读写锁</h4><ul><li>排它锁(Exclusive)，简写为 X 锁，又称写锁。</li><li>共享锁(Shared)，简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定:</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><h4 id="意向锁">意向锁</h4><p>使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定:</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>解释如下:</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h3 id="封锁协议">封锁协议</h3><h4 id="三级封锁协议">三级封锁协议</h4><p><strong>一级封锁协议</strong></p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><strong>三级封锁协议</strong></p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><h4 id="两段锁协议">两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><h3 id="MySQL-隐式与显示锁定">MySQL 隐式与显示锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><h2 id="隔离级别">隔离级别</h2><h3 id="未提交读-READ-UNCOMMITTED">未提交读(READ UNCOMMITTED)</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="提交读-READ-COMMITTED">提交读(READ COMMITTED)</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h3 id="可重复读-REPEATABLE-READ">可重复读(REPEATABLE READ)</h3><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><h3 id="可串行化-SERIALIZABLE">可串行化(SERIALIZABLE)</h3><p>强制事务串行执行。</p><h2 id="多版本并发控制">多版本并发控制</h2><p>多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="版本号">版本号</h3><ul><li>系统版本号: 是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号: 事务开始时的系统版本号。</li></ul><h3 id="隐藏的列">隐藏的列</h3><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:</p><ul><li>创建版本号: 指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h3 id="Undo-日志">Undo 日志</h3><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来。</p><h3 id="实现过程">实现过程</h3><p>以下实现过程针对可重复读隔离级别。</p><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><h4 id="SELECT">SELECT</h4><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h4 id="INSERT">INSERT</h4><p>将当前系统版本号作为数据行快照的创建版本号。</p><h4 id="DELETE">DELETE</h4><p>将当前系统版本号作为数据行快照的删除版本号。</p><h4 id="UPDATE">UPDATE</h4><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h3 id="快照读与当前读">快照读与当前读</h3><h4 id="快照读">快照读</h4><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><h4 id="当前读">当前读</h4><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><h2 id="Next-Key-Locks">Next-Key Locks</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读(REPEATABLE READ)隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h3 id="Record-Locks">Record Locks</h3><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h3 id="Gap-Locks">Gap Locks</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><h3 id="Next-Key-Locks-2">Next-Key Locks</h3><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值: 10, 11, 13, and 20，那么就需要锁定以下区间:</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DB SQL】 关系型数据库设计流程</title>
      <link href="/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-liu-cheng/"/>
      <url>/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1>【DB SQL】 关系型数据库设计流程</h1><h2 id="Metadata">Metadata</h2><pre><code class="language-yml">title: 【DB SQL】 关系型数据库设计流程date: 2022-12-20 15:17tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_SQLcategories:  - 数据存储keywords:  - 数据存储description: 【DB SQL】 关系型数据库设计流程</code></pre><h2 id="规范设计的6个阶段">规范设计的6个阶段</h2><blockquote><p>按照规范设计的方法，考虑数据库及其应用系统开发全过程，将数据库设计分为以下6个阶段</p></blockquote><ul><li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求；</li><li><strong>概念结构设计</strong>：主要采用E-R模型进行设计，包括画E-R图；</li><li><strong>逻辑结构设计</strong>：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；</li><li><strong>数据库物理设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径；</li><li><strong>数据库的实施</strong>：包括编程、测试和试运行；</li><li><strong>数据库运行与维护</strong>：系统的运行与数据库的日常维护</li></ul><p><img src="/attachment%5Cd81dfc5266ea967661a1547dea579f34.png" alt></p><p>其中最为重要的是<strong>概念结构设计</strong>和<strong>逻辑结构设计</strong>，所以后面独立两个章节分别具体讲：<code>E-R图</code>和<code>结构设计流程</code>。</p><h3 id="需求分析阶段（常用自顶向下）">需求分析阶段（常用自顶向下）</h3><p>调查的重点是，数据与处理。达到信息要求，处理要求，安全性和完整性要求。</p><p>分析方法常用<strong>SA(Structured  Analysis) 结构化分析方法</strong>，SA方法从最上层的系统组织结构入手，采用自顶向下，逐层分解的方式分析系统。</p><p>数据流图表达了数据和处理过程的关系，在SA方法中，处理过程的处理逻辑常常借助判定表或判定树来描述。在处理功能逐步分解的同事，系统中的数据也逐级分解，形成若干层次的数据流图。系统中的数据则借助数据字典（data dictionary，DD）来描述。数据字典是系统中各类数据描述的集合，数据字典通常包括数据项，数据结构，数据流，数据存储，和处理过程5个阶段。</p><h3 id="概念结构设计阶段（常用自底向上）">概念结构设计阶段（常用自底向上）</h3><blockquote><p>概念结构设计是整个数据库设计的关键，它通过对用户需求进行综合，归纳与抽象，形成了一个独立于具体DBMS的概念模型。</p></blockquote><p>设计概念结构通常有四类方法：</p><ul><li>自顶向下。即首先定义全局概念结构的框架，再逐步细化。</li><li>自底向上。即首先定义各局部应用的概念结构，然后再将他们集成起来，得到全局概念结构。</li><li>逐步扩张。首先定义最重要的核心概念结构，然后向外扩张，以滚雪球的方式逐步生成其他的概念结构，直至总体概念结构。</li><li>混合策略。即自顶向下和自底向上相结合。</li></ul><h3 id="逻辑结构设计阶段（E-R图）">逻辑结构设计阶段（E-R图）</h3><blockquote><p>逻辑结构设计是将概念结构转换为某个DBMS所支持的数据模型，并将进行优化。</p></blockquote><p>E-R图显得异常重要。大家要学会各个实体定义的属性来画出总体的E-R图。</p><p>各分E-R图之间的冲突主要有三类：属性冲突，命名冲突，和结构冲突。</p><p>E-R图向关系模型的转换，要解决的问题是如何将实体性和实体间的联系转换为关系模式，如何确定这些关系模式的属性和码。</p><h3 id="物理设计阶段">物理设计阶段</h3><blockquote><p>物理设计是为逻辑数据结构模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。</p></blockquote><p>首先要对运行的事务详细分析，获得选择物理数据库设计所需要的参数，其次，要充分了解所用的RDBMS的内部特征，特别是系统提供的存取方法和存储结构。</p><p>常用的存取方法有三类：</p><ol><li>索引方法，目前主要是B+树索引方法。</li><li>聚簇方法（Clustering）方法。</li><li>是HASH方法。</li></ol><h3 id="数据库实施阶段">数据库实施阶段</h3><p>数据库实施阶段，设计人员运营DBMS提供的数据库语言（如sql）及其宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制和调试应用程序，组织数据入库，并进行试运行。</p><h3 id="数据库运行和维护阶段">数据库运行和维护阶段</h3><p>数据库应用系统经过试运行后，即可投入正式运行，在数据库系统运行过程中必须不断地对其进行评价，调整，修改。</p><h2 id="E-R图">E-R图</h2><p>Entity-Relationship，有三个组成部分: 实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h3 id="实体的三种联系">实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><img src="/attachment%5C5e3107f8b2c44173e2ff434833a8f3d1.png" alt></p><h3 id="表示出现多次的关系">表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="/attachment%5C95c71b48ed1a97e64dd07b3a96dbaa85.png" alt></p><h3 id="联系的多向性">联系的多向性</h3><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="/attachment%5Cbd8305afbe8a47b513d5fa1b78c55821.png" alt></p><p>一般只使用二元联系，可以把多元联系转换为二元联系。</p><p><img src="/attachment%5C40b3aa2dd4453b82e35fcb41eb7f27d9.png" alt></p><h3 id="表示子类">表示子类</h3><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="/attachment%5Cab1910f1ab5b8905248a51898eed61b0.png" alt></p><h2 id="基于E-R图的数据库结构设计">基于E-R图的数据库结构设计</h2><blockquote><p>上面6个阶段比较抽象的，来看看实际重要的基于E-R图的数据库结构设计示例吧</p></blockquote><h3 id="确定entities及relationships">确定entities及relationships</h3><ul><li>明确宏观行为。数据库是用来做什么的？比如，管理雇员的信息。</li><li>确定entities。对于一系列的行为，确定所管理信息所涉及到的主题范围。这将变成table。比如，- 雇用员工，指定具体部门，确定技能等级。</li><li>确定relationships。分析行为，确定tables之间有何种关系。比如，部门与雇员之间存在一种关系。给这种关系命名。</li><li>细化行为。从宏观行为开始，现在仔细检查这些行为，看有哪些行为能转为微观行为。比如，管理雇员的信息可细化为：</li><li>增加新员工</li><li>修改存在员工信息</li><li>删除调走的员工</li><li>确定业务规则。分析业务规则，确定你要采取哪种。比如，可能有这样一种规则，一个部门有且只能有一个部门领导。这些规则将被设计到数据库的结构中。</li></ul><p>下面举个例子，需求如下： ACME是一个小公司，在5个地方都设有办事处。当前，有75名员工。公司准备快速扩大规模，划分了9个部门，每个部门都有其领导。 为有助于寻求新的员工，人事部门规划了68种技能，为将来人事管理作好准备。员工被招进时，每一种技能的专业等级都被确定。</p><h4 id="定义宏观行为">定义宏观行为</h4><p>一些ACME公司的宏观行为包括：</p><ul><li>招聘员工</li><li>解雇员工</li><li>管理员工个人信息</li><li>管理公司所需的技能信息</li><li>管理哪位员工有哪些技能</li><li>管理部门信息</li><li>管理办事处信息</li></ul><h4 id="确定entities及relationships-2">确定entities及relationships</h4><p>我们可以确定要存放信息的主题领域(表)及其关系，并创建一个基于宏观行为及描述的图表。 我们用方框来代表table，用菱形代表relationship。我们可以确定哪些relationship是一对多，一对一，及多对多。 这是一个E-R草图，以后会细化。</p><p><img src="/attachment%5C883866470bd662c1d3ac0eca66a0b4b6.png" alt></p><h4 id="细化宏观行为">细化宏观行为</h4><p>以下微观行为基于上面宏观行为而形成：</p><ul><li>增加或删除一个员工</li><li>增加或删除一个办事处</li><li>列出一个部门中的所有员工</li><li>增加一项技能</li><li>增加一个员工的一项技能</li><li>确定一个员工的技能</li><li>确定一个员工每项技能的等级</li><li>确定所有拥有相同等级的某项技能的员工</li><li>修改员工的技能等级</li></ul><p>这些微观行为可用来确定需要哪些table或relationship。</p><h4 id="确定业务规则">确定业务规则</h4><p>业务规则常用于确定一对多，一对一，及多对多关系。</p><p>相关的业务规则可能有：</p><ul><li>现在有5个办事处；最多允许扩展到10个。</li><li>员工可以改变部门或办事处</li><li>每个部门有一个部门领导</li><li>每个办事处至多有3个电话号码</li><li>每个电话号码有一个或多个扩展</li><li>员工被招进时，每一种技能的专业等级都被确定。</li><li>每位员工拥有3到20个技能</li><li>某位员工可能被安排在一个办事处，也可能不安排办事处。</li></ul><h3 id="确定所需数据">确定所需数据</h3><p>要确定所需数据：</p><ul><li>确定支持数据</li><li>列出所要跟踪的所有数据。描述table(主题)的数据回答这些问题：谁，什么，哪里，何时，以及为什么</li><li>为每个table建立数据</li><li>列出每个table目前看起来合适的可用数据</li><li>为每个relationship设置数据</li><li>如果有，为每个relationship列出适用的数据</li></ul><h4 id="确定支持数据">确定支持数据</h4><p>你所确定的支持数据将会成为table中的字段名。</p><p><strong>需要注意：</strong></p><ul><li>在确定支持数据时，请一定要参考你之前所确定的宏观行为，以清楚如何利用这些数据。</li><li>比如，如果你知道你需要所有员工的按姓氏排序的列表，确保你将支持数据分解为名字与姓氏，这比简单地提供一个名字会更好。</li><li>你所选择的名称最好保持一致性。这将更易于维护数据库，也更易于阅读所输出的报表。</li><li>比如，如果你在某些地方用了一个缩写名称Emp_status，你就不应该在另外一个地方使用全名(Empolyee_ID)。相反，这些名称应当是Emp_status及Emp_id。</li><li>数据是否与正确的table相对应无关紧要，你可以根据自己的喜好来定。在下节中，你会通过测试对此作出判断。</li></ul><h3 id="标准化数据">标准化数据</h3><h4 id="标准化格式">标准化格式</h4><p>标准化格式是标准化数据的常用测试方式。你的数据通过第一遍测试后，就被认为是达到第一标准化格式；通过第二遍测试，达到第二标准化格式；通过第三遍测试，达到第三标准化格式。</p><p>如何标准格式：</p><ol><li>列出数据</li><li>为每个表确定至少一个键。每个表必须有一个主键。</li><li>确定relationships的键。relationships的键是连接两个表的键。</li><li>检查支持数据列表中的计算数据。计算数据通常不保存在数据库中。</li><li>将数据放在第一遍的标准化格式中：</li><li>从tables及relationships除去重复的数据。</li><li>以你所除去数据创建一个或更多的tables及relationships。</li><li>将数据放在第二遍的标准化格式中：</li><li>用多于一个以上的键确定tables及relationships。</li><li>除去只依赖于键一部分的数据。</li><li>以你所除去数据创建一个或更多的tables及relationships。</li><li>将数据放在第三遍的标准化格式中：</li><li>除去那些依赖于tables或relationships中其他数据，并且不是键的数据。</li><li>以你所除去数据创建一个或更多的tables及relationships。</li></ol><h4 id="数据与键">数据与键</h4><p>在你开始标准化（测试数据）前，简单地列出数据，并为每张表确定一个唯一的主键。这个键可以由一个字段或几个字段（连锁键）组成。</p><p>主键是一张表中唯一区分各行的一组字段。Employee表的主键是Employee ID字段。Works In relationship中的主键包括Office Code及Employee ID字段。给数据库中每一relationship给出一个键，从其所连接的每一个table中抽取其键产生。</p><p><strong>将数据放在第一遍的标准化格式中</strong></p><ul><li>除去重复的组</li><li>要测试第一遍标准化格式，除去重复的组，并将它们放进他们各自的一张表中。</li><li>在下面的例子中，Phone Number可以重复。（一个工作人员可以有多于一个的电话号码。）将重复的组除去，创建一个名为Telephone的新表。在Telephone与Office创建一个名为Associated With的relationship。</li></ul><p><strong>将数据放在第二遍的标准化格式中</strong></p><ul><li>除去那些不依赖于整个键的数据。</li><li>只看那些有一个以上键的tables及relationships。要测试第二遍标准化格式，除去那些不依赖于整个键的任何数据（组成键的所有字段）。</li><li>在此例中，原Employee表有一个由两个字段组成的键。一些数据不依赖于整个键；例如，department name只依赖于其中一个键（Department ID）。因此，Department ID，其他Employee数据并不依赖于它，应移至一个名为Department的新表中，并为Employee及Department建立一个名为Assigned To的relationship。</li></ul><p><strong>将数据放在第三遍的标准化格式中</strong></p><ul><li>除去那些不直接依赖于键的数据。</li><li>要测试第三遍标准化格式，除去那些不是直接依赖于键，而是依赖于其他数据的数据。</li><li>在此例中，原Employee表有依赖于其键（Employee ID）的数据。然而，office location及office phone依赖于其他字段，即Office Code。它们不直接依赖于Employee ID键。将这组数据，包括Office Code，移至一个名为Office的新表中，并为Employee及Office建立一个名为Works In的relationship。</li></ul><h4 id="考量带有数据的关系">考量带有数据的关系</h4><p>你的一些relationship可能集含有数据。这经常发生在多对多的关系中。<br>遇到这种情况，将relationship转化为一个table。relationship的键依旧成为table中的键。</p><h4 id="考量没有数据的关系">考量没有数据的关系</h4><p>要实现没有数据的关系，你需要定义外部键。外部键是含有另外一个表中主键的一个或多个字段。外部键使你能同时连接多表数据。</p><p>有一些基本原则能帮助你决定将这些键放在哪里：</p><p><strong>一对多</strong></p><p>在一对多关系中，“一”中的主键放在“多”中。此例中，外部键放在Employee表中。</p><p><img src="/attachment%5Cb2ea77b7822edbc50f090c3580c32633.png" alt></p><p><strong>一对一</strong></p><p>在一对一关系中，外部键可以放进任一表中。如果必须要放在某一边，而不能放在另一边，应该放在必须的一边。此例中，外部键（Head ID）在Department表中，因为这是必需的。</p><p><img src="/attachment%5C93347ededbb1fba9f73c99a715d9c0b1.png" alt></p><p><strong>多对多</strong></p><p>在多对多关系中，用两个外部键来创建一个新表。已存的旧表通过这个新表来发生联系。</p><p><img src="/attachment%5C6e7d580eb2e92c764e4b64c92ebdcb32.png" alt></p><h3 id="检验设计">检验设计</h3><p>在你完成设计之前，你需要确保它满足你的需要。检查你在一开始时所定义的行为，确认你可以获取行为所需要的所有数据：</p><ul><li>你能找到一个路径来等到你所需要的所有信息吗？</li><li>设计是否满足了你的需要？</li><li>所有需要的数据都可用吗？ 如果你对以上的问题都回答是，你已经差不多完成设计了。</li></ul><h3 id="最终设计">最终设计</h3><h4 id="设计数据库的表属性">设计数据库的表属性</h4><p>数据库设计需要确定有什么表，每张表有什么字段。此节讨论如何指定各字段的属性。</p><p>对于每一字段，你必须决定字段名，数据类型及大小，是否允许NULL值，以及你是否希望数据库限制字段中所允许的值。</p><h4 id="选择字段名">选择字段名</h4><p>字段名可以是字母、数字或符号的任意组合。然而，如果字段名包括了字母、数字或下划线、或并不以字母打头，或者它是个关键字（详见关键字表），那么当使用字段名称时，必须用双引号括起来。</p><p>为字段选择数据类型</p><p>SQL Anywhere支持的数据类型包括：</p><ul><li>整数（int, integer, smallint）</li><li>小数（decimal, numeric）</li><li>浮点数（float, double）</li><li>字符型（char, varchar, long varchar）</li><li>二进制数据类型（binary, long binary）</li><li>日期/时间类型（date, time, timestamp）</li><li>用户自定义类型</li></ul><h4 id="NULL与NOT-NULL">NULL与NOT NULL</h4><p>如果一个字段值是必填的，你就将此字段定义为NOT NULL。否则，字段值可以为NULL值，即可以有空值。SQL中的默认值是允许空值；你应该显示地将字段定义为NOT NULL，除非你有好理由将其设为允许空值。</p><h4 id="选择约束">选择约束</h4><p>尽管字段的数据类型限制了能存在字段中的数据（例如，只能存数字或日期），你或许希望更进一步来约束其允许值。</p><p>你可以通过指定一个“CHECK”约束来限制任意字段的值。你可以使用能在WHERE子句中出现的任何有效条件来约束被允许的值，尽管大多数CHECK约束使用BETWEEN或IN条件。</p><h4 id="选择主键及外部键">选择主键及外部键</h4><p>主键是唯一识别表中每一项记录的字段。如何你的表已经正确标准化，主键应当成为数据库设计的一部分。 外部键是包含另一表中主键值的一个或一组字段。外部键关系在数据库中建立了一对一及一对多关系。如果你的设计已经正确标准化，外部键应当成为数据库设计的一部分。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DB SQL】 关系型数据库设计理论</title>
      <link href="/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-li-lun/"/>
      <url>/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-li-lun/</url>
      
        <content type="html"><![CDATA[<h1>【DB SQL】 关系型数据库设计理论</h1><h2 id="Metadata-3">Metadata</h2><pre><code class="language-yml">title: 【DB SQL】 关系型数据库设计理论date: 2022-12-20 15:16tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_SQLcategories:  - 数据存储keywords:  - 数据存储description: 【DB SQL】 关系型数据库设计理论</code></pre><h2 id="重要的术语">重要的术语</h2><ul><li><strong>属性（attribute）</strong>：列的名字，上图有学号、姓名、班级、兴趣爱好、班主任、课程、授课主任、分数。</li><li><strong>依赖（relation）</strong>：列属性间存在的某种联系。</li><li><strong>元组（tuple）</strong>：每一个行，如第二行 （1301，小明，13班，篮球，王老师，英语，赵英，70） 就是一个元组</li><li><strong>表（table）</strong>：由多个属性，以及众多元组所表示的各个实例组成。</li><li><strong>模式（schema）</strong>：这里我们指逻辑结构，如 学生信息（学号，姓名，班级，兴趣爱好，班主任，课程，授课主任，分数） 的笼统表述。</li><li><strong>域（domain）</strong>：数据类型，如string、integer等，上图中每一个属性都有它的数据类型（即域）。</li><li><strong>键（key）</strong>：由关系的一个或多个属性组成，任意两个键相同的元组，所有属性都相同。需要保证表示键的属性最少。一个关系可以存在好几种键，工程中一般从这些候选键中选出一个作为主键（primary key）。</li><li><strong>候选键（candidate key）</strong>：由关系的一个或多个属性组成，候选键都具备键的特征，都有资格成为主键。</li><li><strong>超键（super key）</strong>：包含键的属性集合，无需保证属性集的最小化。每个键也是超键。可以认为是键的超集。</li><li><strong>外键（foreign key）</strong>：如果某一个关系A中的一个（组）属性是另一个关系B的键，则该（组）属性在A中称为外键。</li><li><strong>主属性（prime attribute）</strong>：所有候选键所包含的属性都是主属性。</li><li><strong>投影（projection）</strong>：选取特定的列，如将关系学生信息投影为学号、姓名即得到上表中仅包含学号、姓名的列</li><li><strong>选择（selection）</strong>：按照一定条件选取特定元组，如选择上表中分数&gt;80的元组。</li><li><strong>笛卡儿积（交叉连接Cross join）</strong>：第一个关系每一行分别与第二个关系的每一行组合。</li><li><strong>自然连接（natural join）</strong>：第一个关系中每一行与第二个关系的每一行进行匹配，如果得到有交叉部分则合并，若无交叉部分则舍弃。</li><li><strong>连接（theta join）</strong>：即加上约束条件的笛卡儿积，先得到笛卡儿积，然后根据约束条件删除不满足的元组。</li><li><strong>外连接（outer join）</strong>：执行自然连接后，将舍弃的部分也加入，并且匹配失败处的属性用NULL代替。</li><li><strong>除法运算（division）</strong>：关系R除以关系S的结果为T，则T包含所有在R但不在S中的属性，且T的元组与S的元组的所有组合在R中。</li></ul><h2 id="函数依赖">函数依赖</h2><blockquote><p>通过函数依赖关系，来帮助你确定表中的合理主外键等；这里只是简介，有这么个概念就可以了，因为大多数情况你不用那些所谓的推倒关系，你也是可以凭借直觉设计出来的。</p></blockquote><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常">异常</h2><ul><li><strong>冗余数据</strong>: 例如 学生-2 出现了两次。</li><li><strong>修改异常</strong>: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li><strong>删除异常</strong>: 删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li><li><strong>插入异常</strong>: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式">范式</h2><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p><img src="/attachment%5C84f9ecf692044e015aaf2f014c016989.png" alt></p><h3 id="1-第一范式-1NF">1. 第一范式 (1NF)</h3><p>属性不可分。</p><h3 id="2-第二范式-2NF">2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><h3 id="3-第三范式-3NF">3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DB SQL】 工作原理</title>
      <link href="/database/db-sql/db-sql-gong-zuo-yuan-li/"/>
      <url>/database/db-sql/db-sql-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1>【DB SQL】 工作原理</h1><h2 id="Metadata-2">Metadata</h2><pre><code class="language-yml">title: 【DB SQL】 工作原理date: 2022-12-20 15:06tags:  - 行动阶段/完成  - 主题场景/数据存储  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/数据存储/DB_SQLcategories:  - 数据存储keywords:  - 数据存储description: 【DB SQL】 工作原理</code></pre><h2 id="知识点">知识点</h2><p><img src="/attachment%5Cfbbcd1449b2c0742f5a638c62466f90e.png" alt></p><h2 id="数据结构及算法">数据结构及算法</h2><h3 id="归并排序">归并排序</h3><p>归并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。</p><p><strong>为什么是归并排序？</strong></p><ul><li>你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。注：这种算法叫『原地算法』(in-place algorithm)</li><li>你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。注：这种算法叫『外部排序』(external sorting)。</li><li>你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。比如，分布式合并排序是Hadoop（那个著名的大数据框架）的关键组件之一。</li></ul><h3 id="二叉搜索树">二叉搜索树</h3><blockquote><p>数据库中查询的时间复杂度，是我们无法使用矩阵，转而使用二叉搜索树(BST)，具体请参考： 树 - 二叉搜索树(BST)</p></blockquote><ul><li>二叉搜索树只需 log(N) 次运算，而如果你直接使用阵列则需要 N 次运算</li></ul><h3 id="B-树索引">B+树索引</h3><blockquote><p>查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法。</p></blockquote><p><strong>如果你在数据库中增加或删除一行</strong></p><ul><li>你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。</li><li>你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。</li></ul><p>换句话说，B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以有些人听到过使用太多索引不是个好主意这类说法。没错，你减慢了快速插入/更新/删除表中的一个行的操作，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷（在本文结尾我们会探讨这个管理器）。</p><h3 id="哈希表">哈希表</h3><p><strong>为什么不用阵列呢？</strong></p><ul><li>如果有了好的哈希函数，在哈希表里搜索的时间复杂度是 O(1)。</li><li>一个哈希表可以只装载一半到内存，剩下的哈希桶可以留在硬盘上。</li><li>用阵列的话，你需要一个连续内存空间。如果你加载一个大表，很难分配足够的连续内存空间。</li></ul><h2 id="全局概览">全局概览</h2><p>数据库一般可以用如下图形来理解：</p><p><img src="/attachment%5C50a3eec5e9f087f44b1b09c60f04293b.png" alt></p><h3 id="核心组件">核心组件</h3><ul><li><strong>进程管理器（process manager）</strong>：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。</li><li><strong>网络管理器（network manager）</strong>：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。</li><li><strong>文件系统管理器（File system manager）</strong>：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</li><li><strong>内存管理器（memory manager）</strong>：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。</li><li><strong>安全管理器（Security Manager）</strong>：用于对用户的验证和授权。</li><li><strong>客户端管理器（Client manager）</strong>：用于管理客户端连接。</li></ul><h3 id="查询管理器">查询管理器</h3><ul><li><strong>查询解析器（Query parser）</strong>：用于检查查询是否合法</li><li><strong>查询重写器（Query rewriter）</strong>：用于预优化查询</li><li><strong>查询优化器（Query optimizer）</strong>：用于优化查询</li><li><strong>查询执行器（Query executor）</strong>：用于编译和执行查询</li></ul><h3 id="数据管理器">数据管理器</h3><ul><li><strong>事务管理器（Transaction manager）</strong>：用于处理事务</li><li><strong>缓存管理器（Cache manager）</strong>：数据被使用之前置于内存，或者数据写入磁盘之前置于内存</li><li><strong>数据访问管理器（Data access manager）</strong>：访问磁盘中的数据</li></ul><h3 id="数据查询的流程">数据查询的流程</h3><p>本章集中探讨数据库如何通过如下进程管理SQL查询的：</p><ul><li>客户端管理器</li><li>查询管理器</li><li>数据管理器（含恢复管理器）</li></ul><h2 id="客户端管理器">客户端管理器</h2><p>客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB …）提供不同的方式来访问数据库。客户端管理器也提供专有的数据库访问API。</p><p><img src="/attachment%5C163228c4e655734050a80d177d6e9857.png" alt></p><p><strong>当你连接到数据库时：</strong></p><ul><li>管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。</li><li>然后，管理器检查是否有空闲进程（或线程）来处理你对查询。</li><li>管理器还会检查数据库是否负载很重。</li><li>管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。</li><li>然后管理器会把你的查询送给查询管理器来处理。</li><li>因为查询处理进程不是『不全则无』的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。</li><li>如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。</li></ul><h2 id="查询管理器-2">查询管理器</h2><p><img src="/attachment%5C5d4489d9412056b3d5aa6fbcc76a9596.png" alt></p><p>这个多步骤操作过程如下：</p><ul><li>查询首先被解析并判断是否合法</li><li>然后被重写，去除了无用的操作并且加入预优化部分</li><li>接着被优化以便提升性能，并被转换为可执行代码和数据访问计划。</li><li>然后计划被编译</li><li>最后，被执行<br>这里我不会过多探讨最后两步，因为它们不太重要。</li></ul><h3 id="查询解析器">查询解析器</h3><p>但这还不算完，解析器还会检查关键字是否使用正确的顺序，比如 WHERE 写在 SELECT 之前会被拒绝。</p><p>然后，解析器要分析查询中的表和字段，使用数据库元数据来检查：</p><ul><li>表是否存在</li><li>表的字段是否存在</li><li>对某类型字段的 运算 是否 可能（比如，你不能将整数和字符串进行比较，你不能对一个整数使用 substring() 函数）<br>接着，解析器检查在查询中你是否有权限来读取（或写入）表。再强调一次：这些权限由DBA分配。<br>在解析过程中，SQL 查询被转换为内部表示（通常是一个树）。<br>如果一切正常，内部表示被送到查询重写器。</li></ul><h3 id="查询重写器">查询重写器</h3><p>在这一步，我们已经有了查询的内部表示，重写器的目标是：</p><ul><li>预优化查询</li><li>避免不必要的运算</li><li>帮助优化器找到合理的最佳解决方案<br>重写器按照一系列已知的规则对查询执行检测。如果查询匹配一种模式的规则，查询就会按照这条规则来重写。下面是（可选）规则的非详尽的列表：</li><li>视图合并：如果你在查询中使用视图，视图就会转换为它的 SQL 代码。</li><li>子查询扁平化：子查询是很难优化的，因此重写器会尝试移除子查询</li><li>去除不必要的运算符：比如，如果你用了 DISTINCT，而其实你有 UNIQUE 约束（这本身就防止了数据出现重复），那么 DISTINCT 关键字就被去掉了。</li><li>排除冗余的联接：如果相同的 JOIN 条件出现两次，比如隐藏在视图中的 JOIN 条件，或者由于传递性产生的无用 JOIN，都会被消除。</li><li>常数计算赋值：如果你的查询需要计算，那么在重写过程中计算会执行一次。比如 WHERE AGE &gt; 10+2 会转换为 WHERE AGE &gt; 12 ， TODATE(“日期字符串”) 会转换为 datetime 格式的日期值。</li><li>（高级）分区裁剪（Partition Pruning）：如果你用了分区表，重写器能够找到需要使用的分区。</li><li>（高级）物化视图重写（Materialized view rewrite）：如果你有个物化视图匹配查询谓词的一个子集，重写器将检查视图是否最新并修改查询，令查询使用物化视图而不是原始表。</li><li>（高级）自定义规则：如果你有自定义规则来修改查询（就像 Oracle policy），重写器就会执行这些规则。</li><li>（高级）OLAP转换：分析/加窗 函数，星形联接，ROLLUP 函数……都会发生转换（但我不确定这是由重写器还是优化器来完成，因为两个进程联系很紧，必须看是什么数据库）。</li></ul><h3 id="统计">统计</h3><ul><li>这些统计信息会帮助优化器估计查询所需的磁盘 I/O、CPU、和内存使用</li><li>统计信息必须及时更新。</li></ul><h3 id="查询优化器">查询优化器</h3><blockquote><p>所有的现代数据库都在用基于成本的优化（即CBO）来优化查询。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。</p></blockquote><p>对于这些联接操作，我会专注于它们的时间复杂度，但是，数据库优化器计算的是它们的 CPU 成本、磁盘 I/O 成本、和内存需求。</p><p>大多数时候瓶颈在于磁盘 I/O 而不是 CPU 使用。</p><h4 id="索引">索引</h4><h4 id="存取路径">存取路径</h4><p>在应用联接运算符（join operators）之前，你首先需要获得数据。以下就是获得数据的方法。</p><ul><li>全扫描</li><li>范围扫描</li><li>唯一扫描</li><li>根据 ROW ID 存取</li><li>其它路径</li></ul><h4 id="联接运算符">联接运算符</h4><p>3个个常用联接运算符：合并联接（Merge join），哈希联接（Hash Join）和嵌套循环联接（Nested Loop Join）。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">内关系和外关系（ inner relation and outer relation）</p><ul><li>一个表</li><li>一个索引</li><li>上一个运算的中间结果（比如上一个联接运算的结果）</li></ul><p>当你联接两个关系时，联接算法对两个关系的处理是不同的。在本文剩余部分，我将假定：</p><ul><li>外关系是左侧数据集</li><li>内关系是右侧数据集</li></ul><p>比如， A JOIN B 是 A 和 B 的联接，这里 A 是外关系，B 是内关系。</p><p>多数情况下， A JOIN B 的成本跟 B JOIN A 的成本是不同的。</p></div><h5 id="嵌套循环联接">嵌套循环联接</h5><blockquote><p>嵌套循环联接是最简单的。</p></blockquote><p><img src="/attachment%5C9a73596fb97e95c90a2df623dc60d5dd.png" alt></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">算法实现</p><ul><li>针对外关系的每一行，查看内关系里的所有行来寻找匹配的行</li></ul><pre><code class="language-c">nested_loop_join(array outer, array inner)  for each row a in outer    for each row b in inner      if (match_join_condition(a,b))        write_result_in_output(a,b)      end if    end for   end for</code></pre><p>由于这是个双迭代，时间复杂度是 O(N*M)。</p><p>由于这个算法非常简单，下面这个版本在内关系太大无法装入内存时，对磁盘 I/O 更加有利。原因如下：</p><ul><li>为了避免逐行读取两个关系，</li><li>你可以成簇读取，把（两个关系里读到的）两簇数据行保存在内存里，</li><li>比较两簇数据，保留匹配的，</li><li>然后从磁盘加载新的数据簇来继续比较</li><li>直到加载了所有数据。</li></ul><pre><code class="language-c">// improved version to reduce the disk I/O.nested_loop_join_v2(file outer, file inner)  for each bunch ba in outer  // ba is now in memory    for each bunch bb in inner        // bb is now in memory        for each row a in ba          for each row b in bb            if (match_join_condition(a,b))              write_result_in_output(a,b)            end if          end for       end for    end for   end for</code><p><code class="language-c"></code></p></pre><p></p></div><h4 id="哈希联接">哈希联接</h4><p>哈希联接更复杂，不过在很多场合比嵌套循环联接成本低。</p><p><img src="/attachment%5C918399908529d8ba5054b06dc01fd17b.png" alt></p><p>哈希联接的原理是：</p><ul><li>读取内关系的所有元素</li><li>在内存里建一个哈希表</li><li>逐条读取外关系的所有元素 +（用哈希表的哈希函数）计算每个元素的哈希值，来查找内关系里相关的哈希桶内</li><li>是否与外关系的元素匹配。</li></ul><p>在时间复杂度方面我需要做些假设来简化问题：</p><ul><li>内关系被划分成 X 个哈希桶</li><li>哈希函数几乎均匀地分布每个关系内数据的哈希值，就是说哈希桶大小一致。</li><li>外关系的元素与哈希桶内的所有元素的匹配，成本是哈希桶内元素的数量。</li></ul><p>时间复杂度是 (M/X) * N + 创建哈希表的成本(M) + 哈希函数的成本 * N 。如果哈希函数创建了足够小规模的哈希桶，那么复杂度就是 O(M+N)。</p><p>还有个哈希联接的版本，对内存有利但是对磁盘 I/O 不够有利。 这回是这样的：</p><ul><li>计算内关系和外关系双方的哈希表</li><li>保存哈希表到磁盘</li><li>然后逐个哈希桶比较（其中一个读入内存，另一个逐行读取）。</li></ul><h5 id="合并联接">合并联接</h5><blockquote><p>合并联接是唯一产生排序的联接算法。</p></blockquote><ol><li>（可选）排序联接运算：两个输入源都按照联接关键字排序。</li><li>合并联接运算：排序后的输入源合并到一起。</li></ol><ul><li>排序<ul><li>如果表内部就是有序的，比如联接条件里一个索引组织表(index-organized table)</li><li>如果关系是联接条件里的一个索引</li><li>如果联接应用在一个查询中已经排序的中间结果</li></ul></li><li>合并联接</li></ul><p><img src="/attachment%5Cfe166576c0204dd204b132f689f31b6e.png" alt></p><p>这部分与我们研究过的合并排序中的合并运算非常相似。不过这一次呢，我们不是从两个关系里挑选所有元素，而是只挑选相同的元素。道理如下：</p><ul><li>在两个关系中，比较当前元素（当前=头一次出现的第一个）</li><li>如果相同，就把两个元素都放入结果，再比较两个关系里的下一个元素</li><li>如果不同，就去带有最小元素的关系里找下一个元素（因为下一个元素可能会匹配）</li><li>重复 1、2、3步骤直到其中一个关系的最后一个元素。</li></ul><p><strong>哪个算法最好</strong></p><ul><li>空闲内存：没有足够的内存的话就跟强大的哈希联接拜拜吧（至少是完全内存中哈希联接）。</li><li>两个数据集的大小。比如，如果一个大表联接一个很小的表，那么嵌套循环联接就比哈希联接快，因为后者有创建哈希的高昂成本；如果两个表都非常大，那么嵌套循环联接CPU成本就很高昂。</li><li>是否有索引：有两个 B+树索引的话，聪明的选择似乎是合并联接。</li><li>结果是否需要排序：即使你用到的是未排序的数据集，你也可能想用成本较高的合并联接（带排序的），因为最终得到排序的结果后，你可以把它和另一个合并联接串起来（或者也许因为查询用 ORDER BY/GROUP BY/DISTINCT 等操作符隐式或显式地要求一个排序结果）。</li><li>关系是否已经排序：这时候合并联接是最好的候选项。</li><li>联接的类型：是等值联接（比如 tableA.col1 = tableB.col2 ）？ 还是内联接？外联接？笛卡尔乘积？或者自联接？有些联接在特定环境下是无法工作的。</li><li>数据的分布：如果联接条件的数据是倾斜的（比如根据姓氏来联接人，但是很多人同姓），用哈希联接将是个灾难，原因是哈希函数将产生分布极不均匀的哈希桶。</li><li>如果你希望联接操作使用多线程或多进程。</li></ul><h4 id="查询计划缓存">查询计划缓存</h4><p>由于创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存，来避免重复计算。这个话题比较大，因为数据库需要知道什么时候更新过时的计划。办法是设置一个上限，如果一个表的统计变化超过了上限，关于该表的查询计划就从缓存中清除。</p><h3 id="查询执行器">查询执行器</h3><p>在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符 (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。为了获得和写入数据，查询执行器与数据管理器交互，本文下一部分来讨论数据管理器。</p><h2 id="数据管理器-2">数据管理器</h2><p><img src="/attachment%5Caf894784e841229c3fb6ca65f2310723.png" alt></p><p>在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。但是有 2 个问题：</p><ul><li>关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。</li><li>数据提取是数据库中速度最慢的操作，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。</li></ul><h3 id="缓存管理器">缓存管理器</h3><blockquote><p>数据库的主要瓶颈是磁盘 I/O。为了提高性能，现代数据库使用缓存管理器。</p></blockquote><p><img src="/attachment%5C81abc6005712f0dc391185442b6a5cd0.png" alt></p><p>查询执行器不会直接从文件系统拿数据，而是向缓存管理器要。缓存管理器有一个内存缓存区，叫做缓冲池，从内存读取数据显著地提升数据库性能。</p><h4 id="预读">预读</h4><p>缓存管理器在缓冲池里保存所有的这些数据。为了确定一条数据是否有用，缓存管理器给缓存的数据添加了额外的信息（叫闩锁）。</p><h4 id="缓冲区置换策略">缓冲区置换策略</h4><blockquote><p>多数现代数据库(至少 SQL Server, MySQL, Oracle 和 DB2)使用 LRU 算法。</p></blockquote><h4 id="写缓冲区">写缓冲区</h4><p>缓冲区保存的是页（最小的数据单位）而不是行（逻辑上/人类习惯的观察数据的方式）。</p><h3 id="事务管理器">事务管理器</h3><p>一个ACID事务是一个工作单元，它要保证4个属性：</p><ul><li>原子性（Atomicity）: 事务『要么全部完成，要么全部取消』，即使它持续运行10个小时。如果事务崩溃，状态回到事务之前（事务回滚）。</li><li>一致性（Consistency）: 只有合法的数据（依照关系约束和函数约束）能写入数据库，一致性与原子性和隔离性有关。</li><li>隔离性（Isolation）: 如果2个事务 A 和 B 同时运行，事务 A 和 B 最终的结果是相同的，不管 A 是结束于 B 之前/之后/运行期间。</li><li>持久性（Durability）: 一旦事务提交（也就是成功执行）,不管发生什么（崩溃或者出错），数据要保存在数据库中。</li></ul><h3 id="并发控制">并发控制</h3><p>确保隔离性、一致性和原子性的真正问题是对相同数据的写操作（增、更、删）：</p><ul><li>如果所有事务只是读取数据，它们可以同时工作，不会更改另一个事务的行为。</li><li>如果（至少）有一个事务在修改其他事务读取的数据，数据库需要找个办法对其它事务隐藏这种修改。而且，它还需要确保这个修改操作不会被另一个看不到这些数据修改的事务擦除。</li></ul><p>这个问题叫并发控制。</p><h3 id="锁管理器">锁管理器</h3><p>多数数据库使用锁和/或数据版本控制。</p><h3 id="日志管理器">日志管理器</h3><p>数据库把数据保存在内存缓冲区内。但如果当事务提交时服务器崩溃，崩溃时还在内存里的数据会丢失，这破坏了事务的持久性。你可以把所有数据都写在磁盘上，但是如果服务器崩溃，最终数据可能只有部分写入磁盘，这破坏了事务的原子性。</p><p>事务作出的任何修改必须是或者撤销，或者完成。</p><ul><li>影子副本/页（Shadow copies/pages）</li><li>事务日志（Transaction log）</li></ul><h4 id="WAL（预写式日志）">WAL（预写式日志）</h4><p>影子副本/页在运行较多事务的大型数据库时制造了大量磁盘开销，所以现代数据库使用事务日志。事务日志必须保存在稳定的存储上</p><p>多数数据库（至少是Oracle,SQL Server,DB2,PostgreSQL, MySQL 和SQLite) 使用预写日志协议（Write-Ahead Logging protocol ，WAL）来处理事务日志。WAL协议有 3 个规则：</p><ul><li>每个对数据库的修改都产生一条日志记录，在数据写入磁盘之前日志记录必须写入事务日志。</li><li>日志记录必须按顺序写入；记录 A 发生在记录 B 之前，则 A 必须写在 B 之前。</li><li>当一个事务提交时，在事务成功之前，提交顺序必须写入到事务日志。</li></ul><p><img src="/attachment%5C8e3558d83703552ed6f6388350cc4f2f.png" alt></p><h4 id="ARIES">ARIES</h4><blockquote><p>IBM 研究人员『发明』了WAL的增强版，叫 ARIES。ARIES 或多或少地在现代数据库中使用，逻辑未必相同，但AIRES背后的概念无处不在。ARIES 代表『数据库恢复原型算法』（Algorithms forRecovery andIsolationExploitingSemantics）。</p></blockquote><p>这个技术要达到一个双重目标：</p><ul><li>写日志的同时保持良好性能</li><li>快速和可靠的数据恢复</li></ul><p>有多个原因让数据库不得不回滚事务：</p><ul><li>因为用户取消</li><li>因为服务器或网络故障</li><li>因为事务破坏了数据库完整性（比如一个列有唯一性约束而事务添加了重复值）</li><li>因为死锁</li></ul><h4 id="日志">日志</h4><p>事务的每一个操作（增/删/改）产生一条日志，由如下内容组成：</p><ul><li>LSN：一个唯一的日志序列号（Log Sequence Number）。LSN是按时间顺序分配的，这意味着如果操作 A 先于操作 B，log A 的 LSN 要比 log B 的 LSN 小。</li><li>TransID：产生操作的事务ID。</li><li>PageID：被修改的数据在磁盘上的位置。磁盘数据的最小单位是页，所以数据的位置就是它所处页的位置。</li><li>PrevLSN：同一个事务产生的上一条日志记录的链接。</li><li>UNDO：取消本次操作的方法。比如，如果操作是一次更新，UNDO将或者保存元素更新前的值/状态（物理UNDO），或者回到原来状态的反向操作（逻辑UNDO, 只使用逻辑UNDO，因为处理物理UNDO太过混乱了)。</li><li>REDO：重复本次操作的方法。 同样的，有 2 种方法：或者保存操作后的元素值/状态，或者保存操作本身以便重复。</li><li>…：（供您参考，一个 ARIES 日志还有 2 个字段：UndoNxtLSN 和 Type）。</li></ul><p><img src="/attachment%5Cb1344a43d057400787187307301a1e47.png" alt></p><h4 id="日志缓冲区">日志缓冲区</h4><blockquote><p>为了防止写日志成为主要的瓶颈，数据库使用了日志缓冲区。</p></blockquote><p><img src="/attachment%5C8b05656facd850eee123d6e1b0793c58.png" alt></p><p>当查询执行器要求做一次修改：</p><ul><li>缓存管理器将修改存入自己的缓冲区；</li><li>日志管理器将相关的日志存入自己的缓冲区；</li><li>到了这一步，查询执行器认为操作完成了（因此可以请求做另一次修改）；</li><li>接着（不久以后）日志管理器把日志写入事务日志，什么时候写日志由某算法来决定。</li><li>接着（不久以后）缓存管理器把修改写入磁盘，什么时候写盘由某算法来决定。</li></ul><p>当事务提交，意味着事务每一个操作的5个步骤都完成了。</p><h4 id="STEAL-和-FORCE-策略">STEAL 和 FORCE 策略</h4><p>下面是这些策略对恢复的影响：</p><ul><li>STEAL/NO-FORCE 需要 UNDO 和 REDO: 性能高，但是日志和恢复过程更复杂 (比如 ARIES)。多数数据库选择这个策略。 注：这是我从多个学术论文和教程里看到的，但并没有看到官方文档里显式说明这一点。</li><li>STEAL/ FORCE 只需要 UNDO.</li><li>NO-STEAL/NO-FORCE 只需要 REDO.</li><li>NO-STEAL/FORCE 什么也不需要: 性能最差，而且需要巨大的内存。</li></ul><h4 id="关于恢复">关于恢复</h4><p>ARIES从崩溃中恢复有三个阶段：</p><ol><li>分析阶段：恢复进程读取全部事务日志，来重建崩溃过程中所发生事情的时间线，决定哪个事务要回滚（所有未提交的事务都要回滚）、崩溃时哪些数据需要写盘。</li><li>Redo阶段：这一关从分析中选中的一条日志记录开始，使用 REDO 来将数据库恢复到崩溃之前的状态。<ul><li>在REDO阶段，REDO日志按照时间顺序处理（使用LSN）。</li><li>对每一条日志，恢复进程需要读取包含数据的磁盘页LSN。</li><li>如果LSN（磁盘页）&gt;= LSN（日志记录），说明数据已经在崩溃前写到磁盘（但是值已经被日志之后、崩溃之前的某个操作覆盖），所以不需要做什么。</li><li>如果LSN（磁盘页）&lt; LSN（日志记录），那么磁盘上的页将被更新。</li><li>即使将被回滚的事务，REDO也是要做的，因为这样简化了恢复过程（但是我相信现代数据库不会这么做的）。</li></ul></li><li>Undo阶段：这一阶段回滚所有崩溃时未完成的事务。回滚从每个事务的最后一条日志开始，并且按照时间倒序处理UNDO日志（使用日志记录的PrevLSN）。</li></ol><p>恢复过程中，事务日志必须留意恢复过程的操作，以便写入磁盘的数据与事务日志相一致。一个解决办法是移除被取消的事务产生的日志记录，但是这个太困难了。相反，ARIES在事务日志中记录补偿日志，来逻辑上删除被取消的事务的日志记录。</p><p>当事务被『手工』取消，或者被锁管理器取消（为了消除死锁），或仅仅因为网络故障而取消，那么分析阶段就不需要了。对于哪些需要 REDO 哪些需要 UNDO 的信息在 2 个内存表中：</p><ul><li>事务表（保存当前所有事务的状态）</li><li>脏页表（保存哪些数据需要写入磁盘）</li></ul><p>当新的事务产生时，这两个表由缓存管理器和事务管理器更新。因为是在内存中，当数据库崩溃时它们也被破坏掉了。</p><p>分析阶段的任务就是在崩溃之后，用事务日志中的信息重建上述的两个表。为了加快分析阶段，ARIES提出了一个概念：检查点（check point），就是不时地把事务表和脏页表的内容，还有此时最后一条LSN写入磁盘。那么在分析阶段当中，只需要分析这个LSN之后的日志即可。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/数据存储 </tag>
            
            <tag> 细化主题/数据存储/DB_SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 final</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 final</h1><h2 id="Metadata-34">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 finaldate: 2022-12-14 15:02tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 final</code></pre><h2 id="final-基础使用">final 基础使用</h2><h3 id="修饰类">修饰类</h3><p>当某个类的整体定义为 final 时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p><p>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中给任何方法添加 final 关键字是没有任何意义的。</p><h3 id="修饰方法">修饰方法</h3><ul><li>private 方法是隐式的 final</li><li>final 方法是可以被重载的</li></ul><h4 id="private-final">private final</h4><p>类中所有 private 方法都隐式地指定为 final 的，由于无法取用 private 方法，所以也就不能覆盖它。可以对 private 方法增添 final 关键字，但这样做并没有什么好处。</p><h4 id="final-方法是可以被重载的">final 方法是可以被重载的</h4><p>我们知道父类的 final 方法是不能够被子类重写的，那么 final 方法可以被重载吗? 答案是可以的，下面代码是正确的。</p><h3 id="修饰参数">修饰参数</h3><p>Java 允许在参数列表中以声明的方式将参数指明为 final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p><h4 id="所有的final修饰的字段都是编译期常量吗">所有的final修饰的字段都是编译期常量吗?</h4><p>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</p><h4 id="static-final">static final</h4><p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p><h4 id="blank-final">blank final</h4><p>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p><ul><li>在定义处进行赋值(这不叫空白final)</li><li>在构造器中进行赋值，保证了该值在被使用前赋值。</li></ul><p>这增强了final的灵活性。</p><h2 id="final域重排序规则">final域重排序规则</h2><h3 id="final域为基本类型">final域为基本类型</h3><h4 id="写final域重排序规则">写final域重排序规则</h4><p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外；</li><li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li></ul><h4 id="读final域重排序规则">读final域重排序规则</h4><p>read()方法主要包含了三个操作：</p><ul><li>初次读引用变量finalDemo;</li><li>初次读引用变量finalDemo的普通域a;</li><li>初次读引用变量finalDemo的final域b;</li></ul><h3 id="final域为引用类型">final域为引用类型</h3><h4 id="对final修饰的对象的成员域写操作">对final修饰的对象的成员域写操作</h4><p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。</p><h4 id="对final修饰的对象的成员域读操作">对final修饰的对象的成员域读操作</h4><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下<code>arrays[0] = 1</code>，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p><h3 id="关于final重排序的总结">关于final重排序的总结</h3><ul><li>基本数据类型:<ul><li>final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li><li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li></ul></li><li>引用数据类型：</li><li>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li></ul><h2 id="final再深入理解">final再深入理解</h2><h3 id="final的实现原理">final的实现原理</h3><p>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p><h3 id="为什么final引用不能从构造函数中“溢出”">为什么final引用不能从构造函数中“溢出”</h3><p>上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 final</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 final</h1><h2 id="Metadata-51">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 finaldate: 2022-12-14 15:02tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 final</code></pre><h2 id="final-基础使用">final 基础使用</h2><h3 id="修饰类">修饰类</h3><p>当某个类的整体定义为 final 时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p><p>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中给任何方法添加 final 关键字是没有任何意义的。</p><h3 id="修饰方法">修饰方法</h3><ul><li>private 方法是隐式的 final</li><li>final 方法是可以被重载的</li></ul><h4 id="private-final">private final</h4><p>类中所有 private 方法都隐式地指定为 final 的，由于无法取用 private 方法，所以也就不能覆盖它。可以对 private 方法增添 final 关键字，但这样做并没有什么好处。</p><h4 id="final-方法是可以被重载的">final 方法是可以被重载的</h4><p>我们知道父类的 final 方法是不能够被子类重写的，那么 final 方法可以被重载吗? 答案是可以的，下面代码是正确的。</p><h3 id="修饰参数">修饰参数</h3><p>Java 允许在参数列表中以声明的方式将参数指明为 final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p><h4 id="所有的final修饰的字段都是编译期常量吗">所有的final修饰的字段都是编译期常量吗?</h4><p>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</p><h4 id="static-final">static final</h4><p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p><h4 id="blank-final">blank final</h4><p>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p><ul><li>在定义处进行赋值(这不叫空白final)</li><li>在构造器中进行赋值，保证了该值在被使用前赋值。</li></ul><p>这增强了final的灵活性。</p><h2 id="final域重排序规则">final域重排序规则</h2><h3 id="final域为基本类型">final域为基本类型</h3><h4 id="写final域重排序规则">写final域重排序规则</h4><p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外；</li><li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li></ul><h4 id="读final域重排序规则">读final域重排序规则</h4><p>read()方法主要包含了三个操作：</p><ul><li>初次读引用变量finalDemo;</li><li>初次读引用变量finalDemo的普通域a;</li><li>初次读引用变量finalDemo的final域b;</li></ul><h3 id="final域为引用类型">final域为引用类型</h3><h4 id="对final修饰的对象的成员域写操作">对final修饰的对象的成员域写操作</h4><p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。</p><h4 id="对final修饰的对象的成员域读操作">对final修饰的对象的成员域读操作</h4><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下<code>arrays[0] = 1</code>，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p><h3 id="关于final重排序的总结">关于final重排序的总结</h3><ul><li>基本数据类型:<ul><li>final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li><li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li></ul></li><li>引用数据类型：</li><li>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li></ul><h2 id="final再深入理解">final再深入理解</h2><h3 id="final的实现原理">final的实现原理</h3><p>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p><h3 id="为什么final引用不能从构造函数中“溢出”">为什么final引用不能从构造函数中“溢出”</h3><p>上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 volatile</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-volatile/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-volatile/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 volatile</h1><h2 id="Metadata-37">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 volatiledate: 2022-12-14 15:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 volatile</code></pre><h2 id="volatile-的作用详解">volatile 的作用详解</h2><h3 id="防重排序">防重排序</h3><pre><code class="language-java">public class Singleton {    public static volatile Singleton singleton;        private Singleton() {};    public static Singleton getInstance() {        if (singleton == null) {            synchronized (singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}</code></pre><p>现在我们分析一下为什么要在变量 singleton 之间加上 volatile 关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p><ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul><p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量。</p><h3 id="实现可见性">实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p><h3 id="保证原子性-单次读-写">保证原子性: 单次读 / 写</h3><h4 id="问题-1：-i-为什么不能保证原子性">问题 1： i++ 为什么不能保证原子性?</h4><p>对于原子性，需要强调一点，也是大家容易误解的一点：对 volatile 变量的单次读 / 写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++ 这种操作的原子性，因为本质上 i++ 是读、写两次操作。</p><h4 id="问题-2：-共享的-long-和-double-变量的为什么要用-volatile">问题 2： 共享的 long 和 double 变量的为什么要用 volatile?</h4><p>因为 long 和 double 两种数据类型的操作可分为高 32 位和低 32 位两部分，因此普通的 long 或 double 类型读 / 写可能不是原子的。因此，鼓励大家将共享的 long 和 double 变量设置为 volatile 类型，这样能保证任何情况下对 long 和 double 的单次读 / 写操作都具有原子性。</p><h2 id="volatile-的实现原理">volatile 的实现原理</h2><h3 id="volatile-可见性实现">volatile 可见性实现</h3><blockquote><p>volatile 变量的内存可见性是基于内存屏障 (Memory Barrier) 实现:</p></blockquote><ul><li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li><li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止 + 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</li></ul><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><h4 id="lock-指令">lock 指令</h4><p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议 (MESI) 来保证。</p><h4 id="缓存一致性">缓存一致性</h4><p>缓存是分段 (line) 的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “嗅探(snooping)” 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p><h3 id="volatile-有序性实现">volatile 有序性实现</h3><p>volatile 的 happens-before 关系</p><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-1.png" alt></p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读 / 写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-3.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-4.png" alt></p><h2 id="volatile-的应用场景">volatile 的应用场景</h2><p>使用 volatile 必须具备的条件</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><h3 id="模式-1：状态标志">模式 1：状态标志</h3><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p><h3 id="模式-2：一次性安全发布-one-time-safe-publication">模式 2：一次性安全发布 (one-time safe publication)</h3><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值 (由另一个线程写入) 和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定 (double-checked-locking) 问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p><h3 id="模式-3：独立观察-independent-observation">模式 3：独立观察 (independent observation)</h3><p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p><h3 id="模式-4：volatile-bean-模式">模式 4：volatile bean 模式</h3><p>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。</p><h3 id="模式-5：开销较低的读－写锁策略">模式 5：开销较低的读－写锁策略</h3><p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作 (读、添加、存储) 的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p><h3 id="模式-6：双重检查-double-checked">模式 6：双重检查 (double-checked)</h3><p>单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 volatile</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-volatile/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-volatile/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 volatile</h1><h2 id="Metadata-53">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 volatiledate: 2022-12-14 15:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 volatile</code></pre><h2 id="volatile-的作用详解">volatile 的作用详解</h2><h3 id="防重排序">防重排序</h3><pre><code class="language-java">public class Singleton {    public static volatile Singleton singleton;        private Singleton() {};    public static Singleton getInstance() {        if (singleton == null) {            synchronized (singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}</code></pre><p>现在我们分析一下为什么要在变量 singleton 之间加上 volatile 关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p><ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul><p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量。</p><h3 id="实现可见性">实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p><h3 id="保证原子性-单次读-写">保证原子性: 单次读 / 写</h3><h4 id="问题-1：-i-为什么不能保证原子性">问题 1： i++ 为什么不能保证原子性?</h4><p>对于原子性，需要强调一点，也是大家容易误解的一点：对 volatile 变量的单次读 / 写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++ 这种操作的原子性，因为本质上 i++ 是读、写两次操作。</p><h4 id="问题-2：-共享的-long-和-double-变量的为什么要用-volatile">问题 2： 共享的 long 和 double 变量的为什么要用 volatile?</h4><p>因为 long 和 double 两种数据类型的操作可分为高 32 位和低 32 位两部分，因此普通的 long 或 double 类型读 / 写可能不是原子的。因此，鼓励大家将共享的 long 和 double 变量设置为 volatile 类型，这样能保证任何情况下对 long 和 double 的单次读 / 写操作都具有原子性。</p><h2 id="volatile-的实现原理">volatile 的实现原理</h2><h3 id="volatile-可见性实现">volatile 可见性实现</h3><blockquote><p>volatile 变量的内存可见性是基于内存屏障 (Memory Barrier) 实现:</p></blockquote><ul><li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li><li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止 + 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</li></ul><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><h4 id="lock-指令">lock 指令</h4><p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议 (MESI) 来保证。</p><h4 id="缓存一致性">缓存一致性</h4><p>缓存是分段 (line) 的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “嗅探(snooping)” 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p><h3 id="volatile-有序性实现">volatile 有序性实现</h3><p>volatile 的 happens-before 关系</p><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-1.png" alt></p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读 / 写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-3.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-volatile-4.png" alt></p><h2 id="volatile-的应用场景">volatile 的应用场景</h2><p>使用 volatile 必须具备的条件</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><h3 id="模式-1：状态标志">模式 1：状态标志</h3><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p><h3 id="模式-2：一次性安全发布-one-time-safe-publication">模式 2：一次性安全发布 (one-time safe publication)</h3><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值 (由另一个线程写入) 和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定 (double-checked-locking) 问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p><h3 id="模式-3：独立观察-independent-observation">模式 3：独立观察 (independent observation)</h3><p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p><h3 id="模式-4：volatile-bean-模式">模式 4：volatile bean 模式</h3><p>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。</p><h3 id="模式-5：开销较低的读－写锁策略">模式 5：开销较低的读－写锁策略</h3><p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作 (读、添加、存储) 的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p><h3 id="模式-6：双重检查-double-checked">模式 6：双重检查 (double-checked)</h3><p>单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】synchronized</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-synchronized/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-synchronized/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】synchronized</h1><h2 id="Metadata-39">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】synchronizeddate: 2022-12-14 14:57tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 Synchronized</code></pre><h2 id="【Java-多线程并发】synchronized-2">【Java 多线程并发】synchronized</h2><blockquote><p>在Java中除了提供Lock API外还在语法层面上提供了synchronized关键字来实现互斥同步原语</p></blockquote><p>在应用 Sychronized 关键字时需要把握如下注意点：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li><li>每个实例都对应有自己的一把锁 (this), 不同实例之间互不影响；例外：锁对象是 *.class 以及 synchronized 修饰的是 static 方法的时候，所有对象公用同一把锁</li><li>synchronized 修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li></ul><h2 id="对象锁">对象锁</h2><p>包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)</p><h3 id="代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁">代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence = new SynchronizedObjectLock();    @Override    public void run() {        // 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行        synchronized (this) {            System.out.println("我是线程" + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "结束");        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instence);        Thread t2 = new Thread(instence);        t1.start();        t2.start();    }}</code></pre><h3 id="方法锁形式：synchronized修饰普通方法，锁对象默认为this">方法锁形式：synchronized修饰普通方法，锁对象默认为this</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence = new SynchronizedObjectLock();    @Override    public void run() {        method();    }    public synchronized void method() {        System.out.println("我是线程" + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "结束");    }    public static void main(String[] args) {        Thread t1 = new Thread(instence);        Thread t2 = new Thread(instence);        t1.start();        t2.start();    }}</code></pre><h2 id="类锁">类锁</h2><p>指synchronize修饰静态的方法或指定锁对象为Class对象</p><h3 id="synchronize修饰静态方法">synchronize修饰静态方法</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();    @Override    public void run() {        method();    }    // synchronized用在普通方法上，默认的锁就是this，当前实例    public synchronized void method() {        System.out.println("我是线程" + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "结束");    }    public static void main(String[] args) {        // t1和t2对应的this是两个不同的实例，所以代码不会串行        Thread t1 = new Thread(instence1);        Thread t2 = new Thread(instence2);        t1.start();        t2.start();    }}</code></pre><h3 id="synchronized指定锁对象为Class对象">synchronized指定锁对象为Class对象</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();    @Override    public void run() {        // 所有线程需要的锁都是同一把        synchronized(SynchronizedObjectLock.class){            System.out.println("我是线程" + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "结束");        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instence1);        Thread t2 = new Thread(instence2);        t1.start();        t2.start();    }}</code></pre><h2 id="Synchronized原理分析">Synchronized原理分析</h2><h3 id="加锁和释放锁的原理">加锁和释放锁的原理</h3><p><img src="/attachment%5C2bfd5508d9cb8a994c26149dac733340.png" alt></p><h3 id="可重入原理：加锁次数计数器">可重入原理：加锁次数计数器</h3><ul><li>什么是可重入？可重入锁？</li></ul><p><strong>可重入：</strong>（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</p><p><strong>可重入锁：</strong> 又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><h3 id="保证可见性的原理：内存模型和happens-before规则">保证可见性的原理：内存模型和happens-before规则</h3><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。</p><h2 id="JVM-中锁的优化">JVM 中锁的优化</h2><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。</p><ul><li><strong>锁粗化(Lock Coarsening)：</strong> 也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</li><li><strong>锁消除(Lock Elimination)：</strong> 通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</li><li><strong>轻量级锁(Lightweight Locking)：</strong> 这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</li><li><strong>偏向锁(Biased Locking)：</strong> 是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</li><li><strong>适应性自旋(Adaptive Spinning)：</strong> 当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。</li></ul><h3 id="锁的类型">锁的类型</h3><blockquote><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p></blockquote><h4 id="自旋锁">自旋锁</h4><blockquote><p>为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</p></blockquote><p>如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。</p><h4 id="自适应自旋锁">自适应自旋锁</h4><p>自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么 JVM 会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到 100 此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM 对程序的锁的状态预测会越来越准确，JVM 也会越来越聪明。</p><h3 id="锁消除">锁消除</h3><p>锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。<br>JVM 会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那 JVM 就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p><h3 id="锁粗化">锁粗化</h3><p>尽可能的将同步块的作用范围限制到尽量小的范围 (只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p><h3 id="轻量级锁">轻量级锁</h3><p>在对象头中 (<code>Object Header</code>) 存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为 32 位或者 64 位 (视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针 (<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p><h4 id="轻量级锁加锁">轻量级锁加锁</h4><p>在线程执行同步块之前，JVM 会先在当前线程的栈帧中创建一个名为锁记录 (<code>Lock Record</code>) 的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝 (JVM 会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>) 这个时候线程堆栈与对象头的状态如图：</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-5.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-6.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-7.png" alt></p><h3 id="偏向锁">偏向锁</h3><blockquote><p>在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p></blockquote><p>只需要简单的测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-8.png" alt></p><h4 id="偏向锁的撤销">偏向锁的撤销</h4><p>偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点 (就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM 会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-9.png" alt></p><h3 id="锁的优缺点对比">锁的优缺点对比</h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要 CAS 操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了响应速度</td><td>如线程成始终得不到锁竞争的线程，使用自旋会消耗 CPU 性能</td><td>追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不适用自旋，不会消耗 CPU</td><td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table><h2 id="Synchronized-与-Lock">Synchronized 与 Lock</h2><p>synchronized 的缺陷</p><ul><li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock 可以中断和设置超时</li><li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件 (某个对象)，相对而言，读写锁更加灵活</li><li><code>无法知道是否成功获得锁</code>，相对而言，Lock 可以拿到状态，如果成功获取锁，…，如果获取失败，…</li></ul><h3 id="Lock-解决相应问题">Lock 解决相应问题</h3><p>Lock 类这里不做过多解释，主要看里面的 4 个方法:</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个 boolean 值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized 只有锁只与一个条件 (是否获取锁) 相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p><h2 id="深入">深入</h2><p>synchronized 是通过软件 (JVM) 实现的，简单易用，即使在 JDK5 之后有了 Lock，仍然被广泛的使用。</p><p><strong>使用 Synchronized 有哪些要注意的？</strong></p><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用 Lock 也不要用 synchronized 关键字，用 java.util.concurrent 包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用 synchronized 关键，因为代码量少，避免出错</li></ul><p><strong>synchronized 是公平锁吗？</strong></p><p>synchronized 实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】synchronized</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-synchronized/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-synchronized/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】synchronized</h1><h2 id="Metadata-55">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】synchronizeddate: 2022-12-14 14:57tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 Synchronized</code></pre><h2 id="【Java-多线程并发】synchronized-2">【Java 多线程并发】synchronized</h2><blockquote><p>在Java中除了提供Lock API外还在语法层面上提供了synchronized关键字来实现互斥同步原语</p></blockquote><p>在应用 Sychronized 关键字时需要把握如下注意点：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li><li>每个实例都对应有自己的一把锁 (this), 不同实例之间互不影响；例外：锁对象是 *.class 以及 synchronized 修饰的是 static 方法的时候，所有对象公用同一把锁</li><li>synchronized 修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li></ul><h2 id="对象锁">对象锁</h2><p>包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)</p><h3 id="代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁">代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence = new SynchronizedObjectLock();    @Override    public void run() {        // 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行        synchronized (this) {            System.out.println("我是线程" + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "结束");        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instence);        Thread t2 = new Thread(instence);        t1.start();        t2.start();    }}</code></pre><h3 id="方法锁形式：synchronized修饰普通方法，锁对象默认为this">方法锁形式：synchronized修饰普通方法，锁对象默认为this</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence = new SynchronizedObjectLock();    @Override    public void run() {        method();    }    public synchronized void method() {        System.out.println("我是线程" + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "结束");    }    public static void main(String[] args) {        Thread t1 = new Thread(instence);        Thread t2 = new Thread(instence);        t1.start();        t2.start();    }}</code></pre><h2 id="类锁">类锁</h2><p>指synchronize修饰静态的方法或指定锁对象为Class对象</p><h3 id="synchronize修饰静态方法">synchronize修饰静态方法</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();    @Override    public void run() {        method();    }    // synchronized用在普通方法上，默认的锁就是this，当前实例    public synchronized void method() {        System.out.println("我是线程" + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "结束");    }    public static void main(String[] args) {        // t1和t2对应的this是两个不同的实例，所以代码不会串行        Thread t1 = new Thread(instence1);        Thread t2 = new Thread(instence2);        t1.start();        t2.start();    }}</code></pre><h3 id="synchronized指定锁对象为Class对象">synchronized指定锁对象为Class对象</h3><pre><code class="language-java">public class SynchronizedObjectLock implements Runnable {    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();    @Override    public void run() {        // 所有线程需要的锁都是同一把        synchronized(SynchronizedObjectLock.class){            System.out.println("我是线程" + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "结束");        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instence1);        Thread t2 = new Thread(instence2);        t1.start();        t2.start();    }}</code></pre><h2 id="Synchronized原理分析">Synchronized原理分析</h2><h3 id="加锁和释放锁的原理">加锁和释放锁的原理</h3><p><img src="/attachment%5C2bfd5508d9cb8a994c26149dac733340.png" alt></p><h3 id="可重入原理：加锁次数计数器">可重入原理：加锁次数计数器</h3><ul><li>什么是可重入？可重入锁？</li></ul><p><strong>可重入：</strong>（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</p><p><strong>可重入锁：</strong> 又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><h3 id="保证可见性的原理：内存模型和happens-before规则">保证可见性的原理：内存模型和happens-before规则</h3><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。</p><h2 id="JVM-中锁的优化">JVM 中锁的优化</h2><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。</p><ul><li><strong>锁粗化(Lock Coarsening)：</strong> 也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</li><li><strong>锁消除(Lock Elimination)：</strong> 通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</li><li><strong>轻量级锁(Lightweight Locking)：</strong> 这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</li><li><strong>偏向锁(Biased Locking)：</strong> 是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</li><li><strong>适应性自旋(Adaptive Spinning)：</strong> 当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。</li></ul><h3 id="锁的类型">锁的类型</h3><blockquote><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p></blockquote><h4 id="自旋锁">自旋锁</h4><blockquote><p>为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</p></blockquote><p>如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。</p><h4 id="自适应自旋锁">自适应自旋锁</h4><p>自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么 JVM 会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到 100 此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM 对程序的锁的状态预测会越来越准确，JVM 也会越来越聪明。</p><h3 id="锁消除">锁消除</h3><p>锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。<br>JVM 会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那 JVM 就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p><h3 id="锁粗化">锁粗化</h3><p>尽可能的将同步块的作用范围限制到尽量小的范围 (只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p><h3 id="轻量级锁">轻量级锁</h3><p>在对象头中 (<code>Object Header</code>) 存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为 32 位或者 64 位 (视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针 (<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p><h4 id="轻量级锁加锁">轻量级锁加锁</h4><p>在线程执行同步块之前，JVM 会先在当前线程的栈帧中创建一个名为锁记录 (<code>Lock Record</code>) 的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝 (JVM 会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>) 这个时候线程堆栈与对象头的状态如图：</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-5.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-6.png" alt></p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-7.png" alt></p><h3 id="偏向锁">偏向锁</h3><blockquote><p>在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p></blockquote><p>只需要简单的测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-8.png" alt></p><h4 id="偏向锁的撤销">偏向锁的撤销</h4><p>偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点 (就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM 会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p><img src="https://pdai.tech/_images/thread/java-thread-x-key-schronized-9.png" alt></p><h3 id="锁的优缺点对比">锁的优缺点对比</h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要 CAS 操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了响应速度</td><td>如线程成始终得不到锁竞争的线程，使用自旋会消耗 CPU 性能</td><td>追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不适用自旋，不会消耗 CPU</td><td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table><h2 id="Synchronized-与-Lock">Synchronized 与 Lock</h2><p>synchronized 的缺陷</p><ul><li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock 可以中断和设置超时</li><li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件 (某个对象)，相对而言，读写锁更加灵活</li><li><code>无法知道是否成功获得锁</code>，相对而言，Lock 可以拿到状态，如果成功获取锁，…，如果获取失败，…</li></ul><h3 id="Lock-解决相应问题">Lock 解决相应问题</h3><p>Lock 类这里不做过多解释，主要看里面的 4 个方法:</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个 boolean 值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized 只有锁只与一个条件 (是否获取锁) 相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p><h2 id="深入">深入</h2><p>synchronized 是通过软件 (JVM) 实现的，简单易用，即使在 JDK5 之后有了 Lock，仍然被广泛的使用。</p><p><strong>使用 Synchronized 有哪些要注意的？</strong></p><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用 Lock 也不要用 synchronized 关键字，用 java.util.concurrent 包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用 synchronized 关键，因为代码量少，避免出错</li></ul><p><strong>synchronized 是公平锁吗？</strong></p><p>synchronized 实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程并发</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1>Java 多线程并发</h1><h2 id="Metadata-33">Metadata</h2><pre><code class="language-yml">title: Java 多线程并发date: 2022-12-14 14:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题categories:  - Javakeywords:  - Java/多线程并发description: Java 多线程并发</code></pre><h2 id="Java-多线程并发-2">Java 多线程并发</h2><p><img src="/attachment%5C3041eb7b6dfc4a8cc4eb38ad02234ac8.png" alt></p><h2 id="【Java-多线程并发】-理论基础">【Java 多线程并发】 理论基础</h2><p><a href="../java-duo-xian-cheng-bing-fa-li-lun-ji-chu">【Java 多线程并发】 理论基础</a></p><h2 id="【Java-多线程并发】-final">【Java 多线程并发】 final</h2><p><a href="../java-duo-xian-cheng-bing-fa-final">【Java 多线程并发】 final</a></p><h2 id="【Java-多线程并发】-volatile">【Java 多线程并发】 volatile</h2><p><a href="../java-duo-xian-cheng-bing-fa-volatile">【Java 多线程并发】 volatile</a></p><h2 id="【Java-多线程并发】synchronized">【Java 多线程并发】synchronized</h2><p><a href="../java-duo-xian-cheng-bing-fa-synchronized">【Java 多线程并发】 synchronized</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程并发</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1>Java 多线程并发</h1><h2 id="Metadata-50">Metadata</h2><pre><code class="language-yml">title: Java 多线程并发date: 2022-12-14 14:56tags:  - 行动阶段/完成  - 主题场景/程序  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题categories:  - Javakeywords:  - Java/多线程并发description: Java 多线程并发</code></pre><h2 id="Java-多线程并发-2">Java 多线程并发</h2><p><img src="/attachment%5C3041eb7b6dfc4a8cc4eb38ad02234ac8.png" alt></p><h2 id="【Java-多线程并发】-理论基础">【Java 多线程并发】 理论基础</h2><p>undefined</p><h2 id="【Java-多线程并发】-final">【Java 多线程并发】 final</h2><p>undefined</p><h2 id="【Java-多线程并发】-volatile">【Java 多线程并发】 volatile</h2><p>undefined</p><h2 id="【Java-多线程并发】synchronized">【Java 多线程并发】synchronized</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 主题场景/程序 </tag>
            
            <tag> 细化主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 理论基础</title>
      <link href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-li-lun-ji-chu/"/>
      <url>/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-li-lun-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 理论基础</h1><h2 id="Metadata-38">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 理论基础date: 2022-12-14 14:55tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 理论基础</code></pre><h2 id="多线程的意义">多线程的意义</h2><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 <code>可见性</code>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 <code>原子性</code>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 <code>有序性</code>问题</li></ul><h2 id="并发出现问题的根源-并发三要素">并发出现问题的根源: 并发三要素</h2><h3 id="可见性-CPU-缓存引起">可见性: CPU 缓存引起</h3><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>这就是可见性问题，线程 1 对变量 i 修改了之后，线程 2 没有立即看到线程 1 修改的值。</p><h3 id="原子性-分时复用引起">原子性: 分时复用引起</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>由于 CPU 分时复用（线程切换）的存在，线程 1 执行了第一条指令后，就切换到线程 2 执行，假如线程 2 执行了这三条指令后，再切换会线程 1 执行后续两条指令，将造成最后写到内存中的 i 值是 2 而不是 3。</p><h3 id="有序性-重排序引起">有序性: 重排序引起</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-3.png" alt></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><h2 id="JAVA-是怎么解决并发问题的-JMM-Java-内存模型）">JAVA 是怎么解决并发问题的: JMM(Java 内存模型）</h2><p><strong>理解的第一个维度：核心知识点</strong></p><p>JMM 本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p><ul><li>原子性</li></ul><p>在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><blockquote><p>Java 内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></blockquote><ul><li>可见性</li></ul><p>Java 提供了 volatile 关键字来保证可见性。</p><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><ul><li>有序性</li></ul><p>在 Java 里面，可以通过 volatile 关键字来保证一定的 “有序性”（具体原理在下一节讲述）。另外可以通过 synchronized 和 Lock 来保证有序性，很显然，synchronized 和 Lock 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然 JMM 是通过 Happens-Before 规则来保证有序性的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 多线程并发】 理论基础</title>
      <link href="/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-li-lun-ji-chu/"/>
      <url>/language/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-li-lun-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1>【Java 多线程并发】 理论基础</h1><h2 id="Metadata-52">Metadata</h2><pre><code class="language-yml">title: 【Java 多线程并发】 理论基础date: 2022-12-14 14:55tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/多线程并发categories:  - Javakeywords:  - Java/多线程并发description: 多线程并发 理论基础</code></pre><h2 id="多线程的意义">多线程的意义</h2><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 <code>可见性</code>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 <code>原子性</code>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 <code>有序性</code>问题</li></ul><h2 id="并发出现问题的根源-并发三要素">并发出现问题的根源: 并发三要素</h2><h3 id="可见性-CPU-缓存引起">可见性: CPU 缓存引起</h3><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>这就是可见性问题，线程 1 对变量 i 修改了之后，线程 2 没有立即看到线程 1 修改的值。</p><h3 id="原子性-分时复用引起">原子性: 分时复用引起</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>由于 CPU 分时复用（线程切换）的存在，线程 1 执行了第一条指令后，就切换到线程 2 执行，假如线程 2 执行了这三条指令后，再切换会线程 1 执行后续两条指令，将造成最后写到内存中的 i 值是 2 而不是 3。</p><h3 id="有序性-重排序引起">有序性: 重排序引起</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-3.png" alt></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><h2 id="JAVA-是怎么解决并发问题的-JMM-Java-内存模型）">JAVA 是怎么解决并发问题的: JMM(Java 内存模型）</h2><p><strong>理解的第一个维度：核心知识点</strong></p><p>JMM 本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p><ul><li>原子性</li></ul><p>在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><blockquote><p>Java 内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></blockquote><ul><li>可见性</li></ul><p>Java 提供了 volatile 关键字来保证可见性。</p><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><ul><li>有序性</li></ul><p>在 Java 里面，可以通过 volatile 关键字来保证一定的 “有序性”（具体原理在下一节讲述）。另外可以通过 synchronized 和 Lock 来保证有序性，很显然，synchronized 和 Lock 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然 JMM 是通过 Happens-Before 规则来保证有序性的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/多线程并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】内存模型</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-mo-xing/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】内存模型</h1><h2 id="Metadata-17">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】内存模型date: 2022-12-14 14:50tags:  - 行动阶段/未完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 内存模型</code></pre><h2 id="JMM-引入">JMM 引入</h2><h3 id="从堆栈说起">从堆栈说起</h3><p>JVM 内部使用的 Java 内存模型在线程栈和堆之间划分内存。 此图从逻辑角度说明了 Java 内存模型：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-1.png" alt></p><h3 id="堆栈里面放了什么">堆栈里面放了什么?</h3><p>线程堆栈还包含正在执行的每个方法的所有局部变量 (调用堆栈上的所有方法)。 线程只能访问它自己的线程堆栈。 由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。 因此，每个线程都有自己的每个局部变量的版本。</p><p>基本类型的所有局部变量 (boolean，byte，short，char，int，long，float，double) 完全存储在线程堆栈中，因此对其他线程不可见。 一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身。</p><p>堆包含了在 Java 应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类 (例如 Byte，Integer，Long 等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-2.png" alt></p><p>局部变量可以是基本类型，在这种情况下，它完全保留在线程堆栈上。</p><p>局部变量也可以是对象的引用。 在这种情况下，引用 (局部变量) 存储在线程堆栈中，但是对象本身存储在堆 (Heap) 上。</p><p>对象的成员变量与对象本身一起存储在堆上。 当成员变量是基本类型时，以及它是对象的引用时都是如此。</p><p>静态类变量也与类定义一起存储在堆上。</p><h3 id="线程栈如何访问堆上对象">线程栈如何访问堆上对象?</h3><p>所有具有对象引用的线程都可以访问堆上的对象。 当一个线程有权访问一个对象时，它也可以访问该对象的成员变量。 如果两个线程同时在同一个对象上调用一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本。</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-3.png" alt></p><p>两个线程有一组局部变量。 其中一个局部变量 (局部变量 2) 指向堆上的共享对象(对象 3)。 两个线程各自对同一对象具有不同的引用。 它们的引用是局部变量，因此存储在每个线程的线程堆栈中(在每个线程堆栈上)。 但是，这两个不同的引用指向堆上的同一个对象。</p><p>注意共享对象 (对象 3) 如何将对象 2 和对象 4 作为成员变量引用(由对象 3 到对象 2 和对象 4 的箭头所示)。 通过对象 3 中的这些成员变量引用，两个线程可以访问对象 2 和对象 4.</p><p>该图还显示了一个局部变量，该变量指向堆上的两个不同对象。 在这种情况下，引用指向两个不同的对象 (对象 1 和对象 5)，而不是同一个对象。 理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象 1 和对象 5。 但是在上图中，每个线程只引用了两个对象中的一个。</p><h2 id="JMM-与硬件内存结构关系">JMM 与硬件内存结构关系</h2><h3 id="硬件内存结构简介">硬件内存结构简介</h3><p>现代硬件内存架构与内部 Java 内存模型略有不同。 了解硬件内存架构也很重要，以了解 Java 内存模型如何与其一起工作。 本节介绍了常见的硬件内存架构，后面的部分将介绍 Java 内存模型如何与其配合使用。</p><p>这是现代计算机硬件架构的简化图：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-4.png" alt></p><p>现代计算机通常有 2 个或更多 CPU。 其中一些 CPU 也可能有多个内核。 关键是，在具有 2 个或更多 CPU 的现代计算机上，可以同时运行多个线程。 每个 CPU 都能够在任何给定时间运行一个线程。 这意味着如果您的 Java 应用程序是多线程的，线程真的在可能同时运行.</p><p>每个 CPU 基本上都包含一组在 CPU 内存中的寄存器。 CPU 可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为 CPU 可以比访问主存储器更快地访问这些寄存器。</p><p>每个 CPU 还可以具有 CPU 高速缓存存储器层。 事实上，大多数现代 CPU 都有一些大小的缓存存储层。 CPU 可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU 高速缓存存储器介于内部寄存器和主存储器的速度之间。 某些 CPU 可能有多个缓存层 (级别 1 和级别 2)，但要了解 Java 内存模型如何与内存交互，这一点并不重要。 重要的是要知道 CPU 可以有某种缓存存储层。</p><p>计算机还包含主存储区 (RAM)。 所有 CPU 都可以访问主内存。 主存储区通常比 CPU 的高速缓存存储器大得多。同时访问速度也就较慢.</p><p>通常，当 CPU 需要访问主存储器时，它会将部分主存储器读入其 CPU 缓存。 它甚至可以将部分缓存读入其内部寄存器，然后对其执行操作。 当 CPU 需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。</p><h3 id="JMM-与硬件内存连接-引入">JMM 与硬件内存连接 - 引入</h3><p>如前所述，Java 内存模型和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于 CPU 高速缓存和内部 CPU 寄存器中。 这在图中说明：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-5.png" alt></p><h3 id="JMM-与硬件内存连接-对象共享后的可见性">JMM 与硬件内存连接 - 对象共享后的可见性</h3><p>如果两个或多个线程共享一个对象，而没有正确使用 volatile 声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。</p><p>想象一下，共享对象最初存储在主存储器中。 然后，在 CPU 上运行的线程将共享对象读入其 CPU 缓存中。 它在那里对共享对象进行了更改。 只要 CPU 缓存尚未刷新回主内存，共享对象的更改版本对于在其他 CPU 上运行的线程是不可见的。 这样，每个线程最终都可能拥有自己的共享对象副本，每个副本都位于不同的 CPU 缓存中。</p><p>下图描绘了该情况。 在左 CPU 上运行的一个线程将共享对象复制到其 CPU 缓存中，并将其 count 变量更改为 2. 对于在右边的 CPU 上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-6.png" alt></p><p>要解决此问题，您可以使用 Java 的 volatile 关键字。 volatile 关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存。</p><p>要解决此问题，您可以使用 Java synchronized 块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为 volatile</p><h2 id="基础">基础</h2><h3 id="并发编程模型的分类">并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<mark style="background: #FF5582A6;">共享内存</mark>和<mark style="background: #FF5582A6;">消息传递</mark>。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><h3 id="Java-内存模型的抽象">Java 内存模型的抽象</h3><p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用 “共享变量” 这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-1.png" alt></p><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ul><li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li><li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li></ul><p>下面通过示意图来说明这两个步骤：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-2.png" alt></p><p>如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。</p><p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</p><h3 id="重排序">重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-3.png" alt></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h3 id="处理器重排序与内存屏障指令">处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！</p><p>常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p><ul><li>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</li><li>※注 2：上表中的 x86 包括 x64 及 AMD64。</li><li>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</li><li>※注 4：数据依赖性后文会专门说明。</li></ul><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1; LoadLoad; Load2</td><td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td>Store1; StoreStore; Store2</td><td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td>Load1; LoadStore; Store2</td><td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td>Store1; StoreLoad; Load2</td><td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td></tr></tbody></table><p>StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p><p>StoreLoad Barriers 是一个 “全能型” 的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h3 id="happens-before">happens-before</h3><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p><p>happens-before 与 JMM 的关系如下图所示：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-5.png" alt></p><p>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><h2 id="重排序-2">重排序</h2><h3 id="数据依赖性">数据依赖性</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
            <tag> 行动阶段/未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】内存模型</title>
      <link href="/language/java/java-jvm/java-jvm-nei-cun-mo-xing/"/>
      <url>/language/java/java-jvm/java-jvm-nei-cun-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】内存模型</h1><h2 id="Metadata-36">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】内存模型date: 2022-12-14 14:50tags:  - 行动阶段/未完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 内存模型</code></pre><h2 id="JMM-引入">JMM 引入</h2><h3 id="从堆栈说起">从堆栈说起</h3><p>JVM 内部使用的 Java 内存模型在线程栈和堆之间划分内存。 此图从逻辑角度说明了 Java 内存模型：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-1.png" alt></p><h3 id="堆栈里面放了什么">堆栈里面放了什么?</h3><p>线程堆栈还包含正在执行的每个方法的所有局部变量 (调用堆栈上的所有方法)。 线程只能访问它自己的线程堆栈。 由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。 因此，每个线程都有自己的每个局部变量的版本。</p><p>基本类型的所有局部变量 (boolean，byte，short，char，int，long，float，double) 完全存储在线程堆栈中，因此对其他线程不可见。 一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身。</p><p>堆包含了在 Java 应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类 (例如 Byte，Integer，Long 等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-2.png" alt></p><p>局部变量可以是基本类型，在这种情况下，它完全保留在线程堆栈上。</p><p>局部变量也可以是对象的引用。 在这种情况下，引用 (局部变量) 存储在线程堆栈中，但是对象本身存储在堆 (Heap) 上。</p><p>对象的成员变量与对象本身一起存储在堆上。 当成员变量是基本类型时，以及它是对象的引用时都是如此。</p><p>静态类变量也与类定义一起存储在堆上。</p><h3 id="线程栈如何访问堆上对象">线程栈如何访问堆上对象?</h3><p>所有具有对象引用的线程都可以访问堆上的对象。 当一个线程有权访问一个对象时，它也可以访问该对象的成员变量。 如果两个线程同时在同一个对象上调用一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本。</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-3.png" alt></p><p>两个线程有一组局部变量。 其中一个局部变量 (局部变量 2) 指向堆上的共享对象(对象 3)。 两个线程各自对同一对象具有不同的引用。 它们的引用是局部变量，因此存储在每个线程的线程堆栈中(在每个线程堆栈上)。 但是，这两个不同的引用指向堆上的同一个对象。</p><p>注意共享对象 (对象 3) 如何将对象 2 和对象 4 作为成员变量引用(由对象 3 到对象 2 和对象 4 的箭头所示)。 通过对象 3 中的这些成员变量引用，两个线程可以访问对象 2 和对象 4.</p><p>该图还显示了一个局部变量，该变量指向堆上的两个不同对象。 在这种情况下，引用指向两个不同的对象 (对象 1 和对象 5)，而不是同一个对象。 理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象 1 和对象 5。 但是在上图中，每个线程只引用了两个对象中的一个。</p><h2 id="JMM-与硬件内存结构关系">JMM 与硬件内存结构关系</h2><h3 id="硬件内存结构简介">硬件内存结构简介</h3><p>现代硬件内存架构与内部 Java 内存模型略有不同。 了解硬件内存架构也很重要，以了解 Java 内存模型如何与其一起工作。 本节介绍了常见的硬件内存架构，后面的部分将介绍 Java 内存模型如何与其配合使用。</p><p>这是现代计算机硬件架构的简化图：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-4.png" alt></p><p>现代计算机通常有 2 个或更多 CPU。 其中一些 CPU 也可能有多个内核。 关键是，在具有 2 个或更多 CPU 的现代计算机上，可以同时运行多个线程。 每个 CPU 都能够在任何给定时间运行一个线程。 这意味着如果您的 Java 应用程序是多线程的，线程真的在可能同时运行.</p><p>每个 CPU 基本上都包含一组在 CPU 内存中的寄存器。 CPU 可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为 CPU 可以比访问主存储器更快地访问这些寄存器。</p><p>每个 CPU 还可以具有 CPU 高速缓存存储器层。 事实上，大多数现代 CPU 都有一些大小的缓存存储层。 CPU 可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU 高速缓存存储器介于内部寄存器和主存储器的速度之间。 某些 CPU 可能有多个缓存层 (级别 1 和级别 2)，但要了解 Java 内存模型如何与内存交互，这一点并不重要。 重要的是要知道 CPU 可以有某种缓存存储层。</p><p>计算机还包含主存储区 (RAM)。 所有 CPU 都可以访问主内存。 主存储区通常比 CPU 的高速缓存存储器大得多。同时访问速度也就较慢.</p><p>通常，当 CPU 需要访问主存储器时，它会将部分主存储器读入其 CPU 缓存。 它甚至可以将部分缓存读入其内部寄存器，然后对其执行操作。 当 CPU 需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。</p><h3 id="JMM-与硬件内存连接-引入">JMM 与硬件内存连接 - 引入</h3><p>如前所述，Java 内存模型和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于 CPU 高速缓存和内部 CPU 寄存器中。 这在图中说明：</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-5.png" alt></p><h3 id="JMM-与硬件内存连接-对象共享后的可见性">JMM 与硬件内存连接 - 对象共享后的可见性</h3><p>如果两个或多个线程共享一个对象，而没有正确使用 volatile 声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。</p><p>想象一下，共享对象最初存储在主存储器中。 然后，在 CPU 上运行的线程将共享对象读入其 CPU 缓存中。 它在那里对共享对象进行了更改。 只要 CPU 缓存尚未刷新回主内存，共享对象的更改版本对于在其他 CPU 上运行的线程是不可见的。 这样，每个线程最终都可能拥有自己的共享对象副本，每个副本都位于不同的 CPU 缓存中。</p><p>下图描绘了该情况。 在左 CPU 上运行的一个线程将共享对象复制到其 CPU 缓存中，并将其 count 变量更改为 2. 对于在右边的 CPU 上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.</p><p><img src="https://pdai.tech/_images/jvm/java-memory-model-6.png" alt></p><p>要解决此问题，您可以使用 Java 的 volatile 关键字。 volatile 关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存。</p><p>要解决此问题，您可以使用 Java synchronized 块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为 volatile</p><h2 id="基础">基础</h2><h3 id="并发编程模型的分类">并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<mark style="background: #FF5582A6;">共享内存</mark>和<mark style="background: #FF5582A6;">消息传递</mark>。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><h3 id="Java-内存模型的抽象">Java 内存模型的抽象</h3><p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用 “共享变量” 这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-1.png" alt></p><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ul><li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li><li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li></ul><p>下面通过示意图来说明这两个步骤：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-2.png" alt></p><p>如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。</p><p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</p><h3 id="重排序">重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-3.png" alt></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h3 id="处理器重排序与内存屏障指令">处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！</p><p>常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p><ul><li>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</li><li>※注 2：上表中的 x86 包括 x64 及 AMD64。</li><li>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</li><li>※注 4：数据依赖性后文会专门说明。</li></ul><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1; LoadLoad; Load2</td><td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td>Store1; StoreStore; Store2</td><td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td>Load1; LoadStore; Store2</td><td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td>Store1; StoreLoad; Load2</td><td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td></tr></tbody></table><p>StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p><p>StoreLoad Barriers 是一个 “全能型” 的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h3 id="happens-before">happens-before</h3><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p><p>happens-before 与 JMM 的关系如下图所示：</p><p><img src="https://pdai.tech/_images/jvm/java-jmm-5.png" alt></p><p>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><h2 id="重排序-2">重排序</h2><h3 id="数据依赖性">数据依赖性</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
            <tag> 行动阶段/未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 内存结构</title>
      <link href="/java/java-jvm/java-jvm-nei-cun-jie-gou/"/>
      <url>/java/java-jvm/java-jvm-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】 内存结构</h1><h2 id="Metadata-18">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】 内存结构date: 2022-12-14 14:48tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 内存结构</code></pre><h2 id="运行时数据区">运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法区</li><li><strong>线程共享</strong>：堆、方法区, 堆外内存（Java7 的永久代或 JDK8 的元空间、代码缓存）</li></ul><h2 id="一、程序计数器">一、程序计数器</h2><p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。</p><p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或 PC 计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</p><h3 id="1-1-作用">1.1 作用</h3><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5kmznm1sj31m50u0wph.jpg" alt></p><p>（分析：进入 class 文件所在目录，执行 <code>javap -v xx.class</code> 反解析（或者通过 IDEA 插件 <code>Jclasslib</code> 直接查看，上图），可以看到当前类对应的 Code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。）</p><h3 id="1-2-概述">1.2 概述</h3><ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li></ul><h2 id="二、虚拟机栈">二、虚拟机栈</h2><h3 id="2-1-概述">2.1 概述</h3><blockquote><p>Java 虚拟机栈 (Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧 (Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p></blockquote><p><strong>作用</strong>：</p><ul><li>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li></ul><p><strong>特点</strong>：</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈 / 压栈），方法执行结束<strong>出栈</strong></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><p><strong>栈中可能出现的异常</strong>：</p><p>Java 虚拟机规范允许 <strong>Java 虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 <strong>OutOfMemoryError</strong> 异常</li></ul><p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><h3 id="2-2-栈的存储单位">2.2 栈的存储单位</h3><p>栈中存储什么？</p><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li><li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h3 id="2-3-栈运行原理">2.3 栈运行原理</h3><ul><li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循 “先进后出 / 后进先出” 原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li></ul><h3 id="2-4-栈帧的内部结构">2.4 栈帧的内部结构</h3><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）(或称为表达式栈)</li><li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li><li>一些附加信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" alt></p><h4 id="2-4-1-局部变量表">2.4.1. 局部变量表</h4><ul><li>局部变量表也被称为局部变量数组或者本地变量表</li><li>是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li></ul><h5 id="槽-Slot">槽 Slot</h5><ul><li>局部变量表最基本的存储单元是 Slot（变量槽）</li><li>在局部变量表中，32 位以内的类型只占用一个 Slot(包括 returnAddress 类型)，64 位的类型（long 和 double）占用两个连续的 Slot<ul><li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true</li><li>long 和 double 则占据两个 Slot</li></ul></li><li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot 上</li><li><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</li><li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为 this 变量不存在于当前方法的局部变量表中）</li><li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）</li><li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul><h4 id="2-4-2-操作数栈">2.4.2. 操作数栈</h4><ul><li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称为<strong>表达式栈</strong>（Expression Stack）</li><li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong></li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li></ul><h5 id="概述">概述</h5><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 数据项中</li><li>栈中的任何一个元素都可以是任意的 Java 数据类型<ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 PC 寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说 <strong>Java 虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li></ul><h5 id="栈顶缓存（Top-of-stack-Cashing）">栈顶缓存（Top-of-stack-Cashing）</h5><p>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读 / 写速度非常迅速，甚至可以比内存的读 / 写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的 CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读 / 写次数。由于操作数是存储在内存中的，因此频繁的执行内存读 / 写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读 / 写次数，提升执行引擎的执行效率</strong></p><h4 id="2-4-3-动态链接（指向运行时常量池的方法引用）">2.4.3. 动态链接（指向运行时常量池的方法引用）</h4><ul><li><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 (Dynamic Linking)。</li><li>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gca4k4gndgj31d20o2td0.jpg" alt></p><h5 id="JVM-是如何执行方法调用的">JVM 是如何执行方法调用的</h5><p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class 文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p><ul><li><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li><li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p><ul><li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li></ul><h5 id="虚方法和非虚方法">虚方法和非虚方法</h5><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>其他方法称为虚方法</li></ul><h5 id="虚方法表">虚方法表</h5><p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。<br>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。<br>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><h4 id="2-4-4-方法返回地址（return-address）">2.4.4. 方法返回地址（return address）</h4><p>用来存放调用该方法的 PC 寄存器的值。</p><p>一个方法的结束，有两种方式</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。<br>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong><br>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定<br>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</li><li>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong><br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li></ol><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p><h4 id="2-4-5-附加信息">2.4.5. 附加信息</h4><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p><h2 id="三、本地方法栈">三、本地方法栈</h2><h3 id="3-1-本地方法接口">3.1 本地方法接口</h3><p>简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">为什么要使用本地方法（Native Method）?</p><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p><ul><li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li><li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li><li>Sun's Java：Sun 的解释器就是 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用 Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是 C 实现的，并被植入 JVM 内部。</li></ul></div><h3 id="3-2-本地方法栈（Native-Method-Stack）">3.2 本地方法栈（Native Method Stack）</h3><ul><li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈也是线程私有的</li><li>允许线程固定或者可动态扩展的内存大小<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li></ul></li><li>本地方法是使用 C 语言实现的</li><li>它的具体做法是 <code>Native Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li><li>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</li><li>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</li></ul><blockquote><p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote><h2 id="四、堆内存">四、堆内存</h2><h3 id="4-1-内存划分">4.1 内存划分</h3><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p><ul><li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li><li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li><li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg" alt></p><h4 id="年轻代-Young-Generation">年轻代 (Young Generation)</h4><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为 from/to 或 s0/s1），默认比例是<code>8:1:1</code></p><ul><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行 <strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ul><h4 id="老年代-Old-Generation">老年代 (Old Generation)</h4><p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主 GC（Major GC），通常需要更长的时间。</p><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg" alt></p><h4 id="元空间">元空间</h4><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p><h3 id="4-2-设置堆内存大小和-OOM">4.2 设置堆内存大小和 OOM</h3><p>Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 <code>-Xmx</code> 和 <code>-Xms</code> 来设定</p><ul><li><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></li></ul><p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p><p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p><ul><li>默认情况下，初始堆内存大小为：电脑内存大小 / 64</li><li>默认情况下，最大堆内存大小为：电脑内存大小 / 4</li></ul><h4 id="查看-JVM-堆内存分配">查看 JVM 堆内存分配</h4><ol><li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li><li>默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置<ul><li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li></ul></li><li>若在 JDK 7 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄<br>此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code> 将会失效，而 JDK 8 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code><br>在 JDK 8 中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划</li></ol><p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小<br>计算依据是 <strong>GC 过程</strong>中统计的 <strong>GC 时间</strong>、<strong>吞吐量</strong>、<strong>内存占用量</strong></p><h3 id="4-3-对象在堆中的生命周期">4.3 对象在堆中的生命周期</h3><ol><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代<ul><li>新生代又被进一步划分为 <strong>Eden 区</strong> 和 <strong>Survivor 区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul></li><li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区<ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul></li><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）<ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会 + 1</li></ul></li><li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li></ol><h3 id="4-4-对象的分配过程">4.4 对象的分配过程</h3><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new 的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li><li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li></ol><h3 id="4-5-GC-垃圾回收简介">4.5 GC 垃圾回收简介</h3><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li><li>目前只有 G1 GC 会有这种行为</li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><h3 id="4-6-TLAB">4.6 TLAB</h3><h4 id="什么是-TLAB-（Thread-Local-Allocation-Buffer）">什么是 TLAB （Thread Local Allocation Buffer）?</h4><ul><li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li><li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li></ul><h4 id="为什么要有-TLAB">为什么要有 TLAB ?</h4><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h3 id="4-7-堆是分配对象存储的唯一选择吗">4.7 堆是分配对象存储的唯一选择吗</h3><blockquote><p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么 “绝对” 了。 ——《深入理解 Java 虚拟机》</p></blockquote><h4 id="逃逸分析">逃逸分析</h4><p><strong>逃逸分析 (Escape Analysis) <strong>是目前 Java 虚拟机中比较前沿的优化技术</strong>。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li></ul><p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将 sb 返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，但是其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p><p><strong>参数设置：</strong></p><ul><li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li><li>如果使用较早版本，可以通过<code>-XX"+DoEscapeAnalysis</code>显式开启</li></ul><p>开发中使用局部变量，就不要在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做优化：</p><ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li></ul><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p><p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p><h5 id="代码优化之同步省略（消除）">代码优化之同步省略（消除）</h5><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li><li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li></ul><h5 id="代码优化之标量替换">代码优化之标量替换</h5><p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p><p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p><h5 id="代码优化之栈上分配">代码优化之栈上分配</h5><p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><p><strong>总结：</strong></p><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</p><p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><h2 id="五、方法区">五、方法区</h2><ul><li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li><li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本 / 字段 / 方法 / 接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</li><li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li><li>JVM 关闭后方法区即被释放</li></ul><h3 id="5-1-解惑">5.1 解惑</h3><ul><li><strong>方法区（method area）</strong> 只是 <strong>JVM 规范</strong>中定义的一个<strong>概念</strong>，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（PermGen）</strong> 是  <strong>Hotspot</strong> 虚拟机特有的概念， Java8 的时候又被<strong>元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li><li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生 OOM（都会有溢出异常）</li><li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li><li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</li><li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code></li><li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）</li></ul><p>所以对于方法区，Java8 之后的变化：</p><ul><li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li><li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li><li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul><h3 id="5-2-设置方法区内存的大小">5.2 设置方法区内存的大小</h3><p>JDK8 及以后：</p><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li><li>默认值依赖于平台。Windows 下，<code>-XX:MetaspaceSize</code> 是 21M，<code>-XX:MaxMetaspacaSize</code> 的值是 -1，即没有限制</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为 20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li></ul><h3 id="5-3-方法区内部结构">5.3 方法区内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><h4 id="类型信息">类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p><ul><li>这个类型的完整有效名称（全名 = 包名. 类名）</li><li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h4 id="域（Field）信息">域（Field）信息</h4><ul><li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li></ul><h4 id="方法（Method）信息">方法（Method）信息</h4><ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h3 id="5-4-运行时常量池">5.4 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p><h4 id="常量池">常量池</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p><h5 id="为什么需要常量池？">为什么需要常量池？</h5><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><p>如下，我们通过 jclasslib 查看一个只有 Main 方法的简单类，字节码中的 #2 指向的就是 Constant Pool</p><p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池">运行时常量池</h4><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li><li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址<ul><li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li></ul></li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li></ul><h3 id="5-5-方法区在-JDK6、7、8-中的演进细节">5.5 方法区在 JDK6、7、8 中的演进细节</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>jdk1.6 及之前</td><td>有永久代，静态变量存放在永久代上</td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池、静态变量移除，保存在堆中</td></tr><tr><td>jdk1.8 及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td></tr></tbody></table><h4 id="移除永久代原因">移除永久代原因</h4><ul><li>为永久代设置空间大小是很难确定的。<br>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</li><li>对永久代进行调优较困难</li></ul><h3 id="5-6-方法区的垃圾回收">5.6 方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>判定一个类型是否属于 “不再被使用的类”，需要同时满足三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】 内存结构</title>
      <link href="/language/java/java-jvm/java-jvm-nei-cun-jie-gou/"/>
      <url>/language/java/java-jvm/java-jvm-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】 内存结构</h1><h2 id="Metadata-37">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】 内存结构date: 2022-12-14 14:48tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 内存结构</code></pre><h2 id="运行时数据区">运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法区</li><li><strong>线程共享</strong>：堆、方法区, 堆外内存（Java7 的永久代或 JDK8 的元空间、代码缓存）</li></ul><h2 id="一、程序计数器">一、程序计数器</h2><p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。</p><p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或 PC 计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</p><h3 id="1-1-作用">1.1 作用</h3><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5kmznm1sj31m50u0wph.jpg" alt></p><p>（分析：进入 class 文件所在目录，执行 <code>javap -v xx.class</code> 反解析（或者通过 IDEA 插件 <code>Jclasslib</code> 直接查看，上图），可以看到当前类对应的 Code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。）</p><h3 id="1-2-概述">1.2 概述</h3><ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li></ul><h2 id="二、虚拟机栈">二、虚拟机栈</h2><h3 id="2-1-概述">2.1 概述</h3><blockquote><p>Java 虚拟机栈 (Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧 (Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p></blockquote><p><strong>作用</strong>：</p><ul><li>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li></ul><p><strong>特点</strong>：</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈 / 压栈），方法执行结束<strong>出栈</strong></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><p><strong>栈中可能出现的异常</strong>：</p><p>Java 虚拟机规范允许 <strong>Java 虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 <strong>OutOfMemoryError</strong> 异常</li></ul><p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><h3 id="2-2-栈的存储单位">2.2 栈的存储单位</h3><p>栈中存储什么？</p><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li><li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h3 id="2-3-栈运行原理">2.3 栈运行原理</h3><ul><li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循 “先进后出 / 后进先出” 原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li></ul><h3 id="2-4-栈帧的内部结构">2.4 栈帧的内部结构</h3><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）(或称为表达式栈)</li><li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li><li>一些附加信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" alt></p><h4 id="2-4-1-局部变量表">2.4.1. 局部变量表</h4><ul><li>局部变量表也被称为局部变量数组或者本地变量表</li><li>是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li></ul><h5 id="槽-Slot">槽 Slot</h5><ul><li>局部变量表最基本的存储单元是 Slot（变量槽）</li><li>在局部变量表中，32 位以内的类型只占用一个 Slot(包括 returnAddress 类型)，64 位的类型（long 和 double）占用两个连续的 Slot<ul><li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true</li><li>long 和 double 则占据两个 Slot</li></ul></li><li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot 上</li><li><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</li><li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为 this 变量不存在于当前方法的局部变量表中）</li><li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）</li><li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul><h4 id="2-4-2-操作数栈">2.4.2. 操作数栈</h4><ul><li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称为<strong>表达式栈</strong>（Expression Stack）</li><li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong></li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li></ul><h5 id="概述">概述</h5><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 数据项中</li><li>栈中的任何一个元素都可以是任意的 Java 数据类型<ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 PC 寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说 <strong>Java 虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li></ul><h5 id="栈顶缓存（Top-of-stack-Cashing）">栈顶缓存（Top-of-stack-Cashing）</h5><p>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读 / 写速度非常迅速，甚至可以比内存的读 / 写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的 CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读 / 写次数。由于操作数是存储在内存中的，因此频繁的执行内存读 / 写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读 / 写次数，提升执行引擎的执行效率</strong></p><h4 id="2-4-3-动态链接（指向运行时常量池的方法引用）">2.4.3. 动态链接（指向运行时常量池的方法引用）</h4><ul><li><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 (Dynamic Linking)。</li><li>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gca4k4gndgj31d20o2td0.jpg" alt></p><h5 id="JVM-是如何执行方法调用的">JVM 是如何执行方法调用的</h5><p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class 文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p><ul><li><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li><li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p><ul><li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li></ul><h5 id="虚方法和非虚方法">虚方法和非虚方法</h5><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>其他方法称为虚方法</li></ul><h5 id="虚方法表">虚方法表</h5><p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。<br>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。<br>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><h4 id="2-4-4-方法返回地址（return-address）">2.4.4. 方法返回地址（return address）</h4><p>用来存放调用该方法的 PC 寄存器的值。</p><p>一个方法的结束，有两种方式</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。<br>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong><br>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定<br>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</li><li>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong><br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li></ol><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p><h4 id="2-4-5-附加信息">2.4.5. 附加信息</h4><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p><h2 id="三、本地方法栈">三、本地方法栈</h2><h3 id="3-1-本地方法接口">3.1 本地方法接口</h3><p>简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">为什么要使用本地方法（Native Method）?</p><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p><ul><li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li><li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li><li>Sun's Java：Sun 的解释器就是 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用 Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是 C 实现的，并被植入 JVM 内部。</li></ul></div><h3 id="3-2-本地方法栈（Native-Method-Stack）">3.2 本地方法栈（Native Method Stack）</h3><ul><li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈也是线程私有的</li><li>允许线程固定或者可动态扩展的内存大小<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li></ul></li><li>本地方法是使用 C 语言实现的</li><li>它的具体做法是 <code>Native Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li><li>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</li><li>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</li></ul><blockquote><p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote><h2 id="四、堆内存">四、堆内存</h2><h3 id="4-1-内存划分">4.1 内存划分</h3><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p><ul><li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li><li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li><li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg" alt></p><h4 id="年轻代-Young-Generation">年轻代 (Young Generation)</h4><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为 from/to 或 s0/s1），默认比例是<code>8:1:1</code></p><ul><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行 <strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ul><h4 id="老年代-Old-Generation">老年代 (Old Generation)</h4><p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主 GC（Major GC），通常需要更长的时间。</p><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg" alt></p><h4 id="元空间">元空间</h4><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p><h3 id="4-2-设置堆内存大小和-OOM">4.2 设置堆内存大小和 OOM</h3><p>Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 <code>-Xmx</code> 和 <code>-Xms</code> 来设定</p><ul><li><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></li></ul><p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p><p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p><ul><li>默认情况下，初始堆内存大小为：电脑内存大小 / 64</li><li>默认情况下，最大堆内存大小为：电脑内存大小 / 4</li></ul><h4 id="查看-JVM-堆内存分配">查看 JVM 堆内存分配</h4><ol><li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li><li>默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置<ul><li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li></ul></li><li>若在 JDK 7 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄<br>此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code> 将会失效，而 JDK 8 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code><br>在 JDK 8 中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划</li></ol><p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小<br>计算依据是 <strong>GC 过程</strong>中统计的 <strong>GC 时间</strong>、<strong>吞吐量</strong>、<strong>内存占用量</strong></p><h3 id="4-3-对象在堆中的生命周期">4.3 对象在堆中的生命周期</h3><ol><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代<ul><li>新生代又被进一步划分为 <strong>Eden 区</strong> 和 <strong>Survivor 区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul></li><li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区<ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul></li><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）<ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会 + 1</li></ul></li><li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li></ol><h3 id="4-4-对象的分配过程">4.4 对象的分配过程</h3><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new 的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li><li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li></ol><h3 id="4-5-GC-垃圾回收简介">4.5 GC 垃圾回收简介</h3><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li><li>目前只有 G1 GC 会有这种行为</li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><h3 id="4-6-TLAB">4.6 TLAB</h3><h4 id="什么是-TLAB-（Thread-Local-Allocation-Buffer）">什么是 TLAB （Thread Local Allocation Buffer）?</h4><ul><li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li><li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li></ul><h4 id="为什么要有-TLAB">为什么要有 TLAB ?</h4><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h3 id="4-7-堆是分配对象存储的唯一选择吗">4.7 堆是分配对象存储的唯一选择吗</h3><blockquote><p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么 “绝对” 了。 ——《深入理解 Java 虚拟机》</p></blockquote><h4 id="逃逸分析">逃逸分析</h4><p><strong>逃逸分析 (Escape Analysis) <strong>是目前 Java 虚拟机中比较前沿的优化技术</strong>。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li></ul><p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将 sb 返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，但是其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p><p><strong>参数设置：</strong></p><ul><li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li><li>如果使用较早版本，可以通过<code>-XX"+DoEscapeAnalysis</code>显式开启</li></ul><p>开发中使用局部变量，就不要在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做优化：</p><ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li></ul><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p><p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p><h5 id="代码优化之同步省略（消除）">代码优化之同步省略（消除）</h5><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li><li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li></ul><h5 id="代码优化之标量替换">代码优化之标量替换</h5><p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p><p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p><h5 id="代码优化之栈上分配">代码优化之栈上分配</h5><p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><p><strong>总结：</strong></p><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</p><p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><h2 id="五、方法区">五、方法区</h2><ul><li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li><li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本 / 字段 / 方法 / 接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</li><li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li><li>JVM 关闭后方法区即被释放</li></ul><h3 id="5-1-解惑">5.1 解惑</h3><ul><li><strong>方法区（method area）</strong> 只是 <strong>JVM 规范</strong>中定义的一个<strong>概念</strong>，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（PermGen）</strong> 是  <strong>Hotspot</strong> 虚拟机特有的概念， Java8 的时候又被<strong>元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li><li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生 OOM（都会有溢出异常）</li><li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li><li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</li><li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code></li><li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）</li></ul><p>所以对于方法区，Java8 之后的变化：</p><ul><li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li><li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li><li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul><h3 id="5-2-设置方法区内存的大小">5.2 设置方法区内存的大小</h3><p>JDK8 及以后：</p><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li><li>默认值依赖于平台。Windows 下，<code>-XX:MetaspaceSize</code> 是 21M，<code>-XX:MaxMetaspacaSize</code> 的值是 -1，即没有限制</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为 20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li></ul><h3 id="5-3-方法区内部结构">5.3 方法区内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><h4 id="类型信息">类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p><ul><li>这个类型的完整有效名称（全名 = 包名. 类名）</li><li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h4 id="域（Field）信息">域（Field）信息</h4><ul><li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li></ul><h4 id="方法（Method）信息">方法（Method）信息</h4><ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h3 id="5-4-运行时常量池">5.4 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p><h4 id="常量池">常量池</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p><h5 id="为什么需要常量池？">为什么需要常量池？</h5><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><p>如下，我们通过 jclasslib 查看一个只有 Main 方法的简单类，字节码中的 #2 指向的就是 Constant Pool</p><p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池">运行时常量池</h4><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li><li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址<ul><li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li></ul></li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li></ul><h3 id="5-5-方法区在-JDK6、7、8-中的演进细节">5.5 方法区在 JDK6、7、8 中的演进细节</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>jdk1.6 及之前</td><td>有永久代，静态变量存放在永久代上</td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池、静态变量移除，保存在堆中</td></tr><tr><td>jdk1.8 及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td></tr></tbody></table><h4 id="移除永久代原因">移除永久代原因</h4><ul><li>为永久代设置空间大小是很难确定的。<br>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</li><li>对永久代进行调优较困难</li></ul><h3 id="5-6-方法区的垃圾回收">5.6 方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>判定一个类型是否属于 “不再被使用的类”，需要同时满足三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】JAVA 类加载机制</title>
      <link href="/java/java-jvm/java-jvm-java-lei-jia-zai-ji-zhi/"/>
      <url>/java/java-jvm/java-jvm-java-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】JAVA 类加载机制</h1><h2 id="Metadata-16">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】JAVA 类加载机制date: 2022-12-14 14:47tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 类加载机制</code></pre><h2 id="类的生命周期">类的生命周期</h2><p>其中类加载的过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，<em>而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定 (也成为动态绑定或晚期绑定)</em>。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_2.png" alt></p><h3 id="类的加载-查找并加载类的二进制数据">类的加载: 查找并加载类的二进制数据</h3><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_1.png" alt></p><p>相对于类加载的其他阶段而言，<em>加载阶段 (准确地说，是加载阶段获取类的二进制字节流的动作) 是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被 “首次主动使用” 时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了. class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误 (LinkageError 错误) 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">加载. class 文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载. class 文件</li><li>从 zip，jar 等归档文件中加载. class 文件</li><li>从专有数据库中提取. class 文件</li><li>将 Java 源文件动态编译为. class 文件</li></ul></div><h3 id="连接">连接</h3><h4 id="验证-确保被加载的类的正确性">验证: 确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成 4 个阶段的检验动作:</p><ul><li><code>文件格式验证</code>: 验证字节流是否符合 Class 文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><code>元数据验证</code>: 对字节码描述的信息进行语义分析 (注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合 Java 语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><code>符号引用验证</code>: 确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p></blockquote><h4 id="准备-为类的静态变量分配内存，并将其初始化为默认值">准备: 为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意:</p><ul><li>这时候进行内存分配的仅包括类变量 (<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值 (如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在 Java 代码中被显式地赋予的值。<br>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量 value 在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">注意点</p><ul><li>对基本数据类型来说，对于类变量 (static) 和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li><li>如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。假设上面的类变量 value 被定义为: <code>public static final int value = 3；</code>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li></ul></div><h4 id="解析-把类中的符号引用转换为直接引用">解析: 把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符 7 类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><h3 id="初始化">初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p><strong>JVM 初始化步骤</strong></p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p><ul><li>创建类的实例，也就是 new 的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射 (如 Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java 虚拟机启动时被标明为启动类的类 (Java Test)，直接使用 java.exe 命令来运行某个主类</li></ul><h3 id="使用">使用</h3><p>类访问方法区内的数据结构的接口， 对象是 Heap 区的数据。</p><h3 id="卸载">卸载</h3><p><strong>Java 虚拟机将结束生命周期的几种情况</strong></p><ul><li>执行了 System.exit() 方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li></ul><h2 id="类加载器，-JVM-类加载机制">类加载器， JVM 类加载机制</h2><h3 id="类加载器的层次">类加载器的层次</h3><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_3.png" alt></p><blockquote><p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><blockquote><p>站在 Java 虚拟机的角度来讲，只存在两种不同的类加载器: 启动类加载器: 它使用 C++ 实现 (这里仅限于<code>Hotspot</code>，也就是 JDK1.5 之后默认的虚拟机，有很多其他的虚拟机是用 Java 语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p></blockquote><p><strong>站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类</strong> :</p><p><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在 JDK\jre\lib(JDK 代表 JDK 的安装目录，下同) 下，或被 - Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库 (如 rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载)。启动类加载器是无法被 Java 程序直接引用的。</p><p><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库 (如 javax.* 开头的类)，开发者可以直接使用扩展类加载器。</p><p><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径 (ClassPath) 所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为 JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassLoader，便可以做到如下几点:</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得 java class，例如数据库中和网络中。</li></ul><h3 id="寻找类加载器">寻找类加载器</h3><pre><code class="language-java">ClassLoader loader = Thread.currentThread().getContextClassLoader();</code></pre><h3 id="类的加载">类的加载</h3><p>类加载有三种方式:</p><p>1、命令行启动应用时候由 JVM 初始化加载<br>2、通过 Class.forName() 方法动态加载<br>3、通过 ClassLoader.loadClass() 方法动态加载</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">Class.forName() 和 ClassLoader.loadClass() 区别</p><p>collapse: open</p><ul><li>Class.forName(): 将类的. class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；</li><li>ClassLoader.loadClass(): 只干一件事情，就是将. class 文件加载到 jvm 中，不会执行 static 中的内容, 只有在 newInstance 才会去执行 static 块。</li><li>Class.forName(name, initialize, loader) 带参函数也可控制是否加载 static 块。并且只有调用了 newInstance() 方法采用调用构造函数，创建类的对象 。</li></ul></div><h2 id="JVM-类加载机制">JVM 类加载机制</h2><ul><li><code>全盘负责</code>，当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><code>缓存机制</code>，缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效</li><li><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">双亲委派机制过程</p><ol><li>当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。</li><li>当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。</li><li>如果 BootStrapClassLoader 加载失败 (例如在 $JAVA_HOME/jre/lib 里未查找到该 class)，会使用 ExtClassLoader 来尝试加载；</li><li>若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。</li></ol></div><p><strong>双亲委派优势</strong></p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证 Java 程序安全稳定运行</li></ul><h2 id="自定义类加载器">自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程:</p><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对 class 文件进行加密，因此没有解密的过程。</p><p><strong>这里有几点需要注意</strong> :</p><p>1、这里传递的文件名需要是类的全限定性名称，即<code>com.pdai.jvm.classloader.Test2</code>格式的，因为 defineClass 方法是按这种格式进行处理的。<br>2、最好不要重写 loadClass 方法，因为这样容易破坏双亲委托模式。<br>3、这类 Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】JAVA 类加载机制</title>
      <link href="/language/java/java-jvm/java-jvm-java-lei-jia-zai-ji-zhi/"/>
      <url>/language/java/java-jvm/java-jvm-java-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】JAVA 类加载机制</h1><h2 id="Metadata-35">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】JAVA 类加载机制date: 2022-12-14 14:47tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: JAVA 类加载机制</code></pre><h2 id="类的生命周期">类的生命周期</h2><p>其中类加载的过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，<em>而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定 (也成为动态绑定或晚期绑定)</em>。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_2.png" alt></p><h3 id="类的加载-查找并加载类的二进制数据">类的加载: 查找并加载类的二进制数据</h3><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_1.png" alt></p><p>相对于类加载的其他阶段而言，<em>加载阶段 (准确地说，是加载阶段获取类的二进制字节流的动作) 是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被 “首次主动使用” 时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了. class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误 (LinkageError 错误) 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">加载. class 文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载. class 文件</li><li>从 zip，jar 等归档文件中加载. class 文件</li><li>从专有数据库中提取. class 文件</li><li>将 Java 源文件动态编译为. class 文件</li></ul></div><h3 id="连接-2">连接</h3><h4 id="验证-确保被加载的类的正确性">验证: 确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成 4 个阶段的检验动作:</p><ul><li><code>文件格式验证</code>: 验证字节流是否符合 Class 文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><code>元数据验证</code>: 对字节码描述的信息进行语义分析 (注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合 Java 语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><code>符号引用验证</code>: 确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p></blockquote><h4 id="准备-为类的静态变量分配内存，并将其初始化为默认值">准备: 为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意:</p><ul><li>这时候进行内存分配的仅包括类变量 (<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值 (如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在 Java 代码中被显式地赋予的值。<br>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量 value 在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">注意点</p><ul><li>对基本数据类型来说，对于类变量 (static) 和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li><li>如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。假设上面的类变量 value 被定义为: <code>public static final int value = 3；</code>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li></ul></div><h4 id="解析-把类中的符号引用转换为直接引用">解析: 把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符 7 类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><h3 id="初始化">初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p><strong>JVM 初始化步骤</strong></p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p><ul><li>创建类的实例，也就是 new 的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射 (如 Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java 虚拟机启动时被标明为启动类的类 (Java Test)，直接使用 java.exe 命令来运行某个主类</li></ul><h3 id="使用">使用</h3><p>类访问方法区内的数据结构的接口， 对象是 Heap 区的数据。</p><h3 id="卸载">卸载</h3><p><strong>Java 虚拟机将结束生命周期的几种情况</strong></p><ul><li>执行了 System.exit() 方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li></ul><h2 id="类加载器，-JVM-类加载机制">类加载器， JVM 类加载机制</h2><h3 id="类加载器的层次">类加载器的层次</h3><p><img src="https://pdai.tech/_images/jvm/java_jvm_classload_3.png" alt></p><blockquote><p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><blockquote><p>站在 Java 虚拟机的角度来讲，只存在两种不同的类加载器: 启动类加载器: 它使用 C++ 实现 (这里仅限于<code>Hotspot</code>，也就是 JDK1.5 之后默认的虚拟机，有很多其他的虚拟机是用 Java 语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p></blockquote><p><strong>站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类</strong> :</p><p><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在 JDK\jre\lib(JDK 代表 JDK 的安装目录，下同) 下，或被 - Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库 (如 rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载)。启动类加载器是无法被 Java 程序直接引用的。</p><p><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库 (如 javax.* 开头的类)，开发者可以直接使用扩展类加载器。</p><p><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径 (ClassPath) 所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为 JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassLoader，便可以做到如下几点:</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得 java class，例如数据库中和网络中。</li></ul><h3 id="寻找类加载器">寻找类加载器</h3><pre><code class="language-java">ClassLoader loader = Thread.currentThread().getContextClassLoader();</code></pre><h3 id="类的加载">类的加载</h3><p>类加载有三种方式:</p><p>1、命令行启动应用时候由 JVM 初始化加载<br>2、通过 Class.forName() 方法动态加载<br>3、通过 ClassLoader.loadClass() 方法动态加载</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">Class.forName() 和 ClassLoader.loadClass() 区别</p><p>collapse: open</p><ul><li>Class.forName(): 将类的. class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；</li><li>ClassLoader.loadClass(): 只干一件事情，就是将. class 文件加载到 jvm 中，不会执行 static 中的内容, 只有在 newInstance 才会去执行 static 块。</li><li>Class.forName(name, initialize, loader) 带参函数也可控制是否加载 static 块。并且只有调用了 newInstance() 方法采用调用构造函数，创建类的对象 。</li></ul></div><h2 id="JVM-类加载机制">JVM 类加载机制</h2><ul><li><code>全盘负责</code>，当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><code>缓存机制</code>，缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效</li><li><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">双亲委派机制过程</p><ol><li>当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。</li><li>当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。</li><li>如果 BootStrapClassLoader 加载失败 (例如在 $JAVA_HOME/jre/lib 里未查找到该 class)，会使用 ExtClassLoader 来尝试加载；</li><li>若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。</li></ol></div><p><strong>双亲委派优势</strong></p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证 Java 程序安全稳定运行</li></ul><h2 id="自定义类加载器">自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程:</p><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对 class 文件进行加密，因此没有解密的过程。</p><p><strong>这里有几点需要注意</strong> :</p><p>1、这里传递的文件名需要是类的全限定性名称，即<code>com.pdai.jvm.classloader.Test2</code>格式的，因为 defineClass 方法是按这种格式进行处理的。<br>2、最好不要重写 loadClass 方法，因为这样容易破坏双亲委托模式。<br>3、这类 Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM</title>
      <link href="/java/java-jvm/java-jvm/"/>
      <url>/java/java-jvm/java-jvm/</url>
      
        <content type="html"><![CDATA[<h1>Java JVM</h1><h2 id="Metadata-13">Metadata</h2><pre><code class="language-yml">title: Java JVMdate: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java JVM</code></pre><h2 id="【Java-JVM】字节码编码">【Java JVM】字节码编码</h2><p><a href="../java-jvm-zi-jie-ma-bian-ma/">【Java JVM】字节码编码</a></p><h2 id="【Java-JVM】JAVA-类加载机制">【Java JVM】JAVA 类加载机制</h2><p><a href="../java-jvm-java-lei-jia-zai-ji-zhi/">【Java JVM】JAVA 类加载机制</a></p><h2 id="【Java-JVM】-内存结构">【Java JVM】 内存结构</h2><p><a href="../java-jvm-nei-cun-jie-gou/">【Java JVM】 内存结构</a></p><h2 id="【Java-JVM】内存模型">【Java JVM】内存模型</h2><p><a href="../java-jvm-nei-cun-mo-xing/">【Java JVM】内存模型</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】字节码编码</title>
      <link href="/java/java-jvm/java-jvm-zi-jie-ma-bian-ma/"/>
      <url>/java/java-jvm/java-jvm-zi-jie-ma-bian-ma/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】字节码编码</h1><h2 id="Metadata-20">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】字节码编码date: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 字节码编码</code></pre><h2 id="简介-2">简介</h2><p>计算机是不能直接运行 java 代码的，必须要先运行 java 虚拟机，再由 java 虚拟机运行编译后的 java 代码。这个编译后的 java 代码，就是本文要介绍的 java 字节码。</p><ul><li>Java 代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的 JVM 虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li><li>JVM 也不再只支持 Java，由此衍生出了许多基于 JVM 的编程语言，如 Groovy, Scala, Koltin 等等。</li></ul><p><img src="https://pdai.tech/_images/jvm/java-jvm-class-1.png" alt></p><h2 id="Java-字节码文件">Java 字节码文件</h2><p>class 文件本质上是一个以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在 class 文件中。jvm 根据其特定的规则解析该二进制数据，从而得到相关信息。</p><p>Class 文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。</p><h3 id="Class-文件的结构属性">Class 文件的结构属性</h3><p><img src="https://pdai.tech/_images/jvm/java-jvm-class-2.png" alt></p><h3 id="示例">示例</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p>collapse: closed</p><p>以文本的形式打开生成的 class 文件，内容如下:</p><pre><code class="language-class">cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0007 0008 0c00 0500 0601 0010 636f 6d2f7268 7974 686d 372f 4d61 696e 0100 106a6176 612f 6c61 6e67 2f4f 626a 6563 74002100 0300 0400 0000 0100 0200 0500 06000000 0200 0100 0700 0800 0100 0900 00001d00 0100 0100 0000 052a b700 01b1 00000001 000a 0000 0006 0001 0000 0003 0001000b 000c 0001 0009 0000 001f 0002 00010000 0007 2ab4 0002 0460 ac00 0000 01000a00 0000 0600 0100 0000 0800 0100 0d000000 0200 0e</code><p><code class="language-class"></code></p></pre><p></p></div><ul><li>文件开头的 4 个字节 (“cafe babe”) 称之为 <code>魔数</code>，唯有以 “cafe babe” 开头的 class 文件方可被虚拟机所接受，这 4 个字节就是字节码文件的身份识别。</li><li>0000 是编译器 jdk 版本的次版本号 0，0034 转化为十进制是 52, 是主版本号，java 的版本号从 45 开始，除 1.0 和 1.1 都是使用 45.x 外, 以后每升一个大版本，版本号加一。也就是说，编译生成该 class 文件的 jdk 版本为 1.8.0。</li></ul><h3 id="反编译字节码文件">反编译字节码文件</h3><blockquote><p>使用到 java 内置的一个反编译工具 javap 可以反编译字节码文件, 用法: <code>javap &lt;options&gt; &lt;classes&gt;</code></p></blockquote><p>其中<code>&lt;options&gt;</code>选项包括:</p><pre><code class="language-text">  -help  --help  -?        输出此用法消息  -version                 版本信息  -v  -verbose             输出附加信息  -l                       输出行号和本地变量表  -public                  仅显示公共类和成员  -protected               显示受保护的/公共类和成员  -package                 显示程序包/受保护的/公共类                           和成员 (默认)  -p  -private             显示所有类和成员  -c                       对代码进行反汇编  -s                       输出内部类型签名  -sysinfo                 显示正在处理的类的                           系统信息 (路径, 大小, 日期, MD5 散列)  -constants               显示最终常量  -classpath &lt;path&gt;        指定查找用户类文件的位置  -cp &lt;path&gt;               指定查找用户类文件的位置  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</code></pre><p>输入命令<code>javap -verbose -p Main.class</code>查看输出内容:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">collapse: closed</p><pre><code>Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class  Last modified 2018-4-7; size 362 bytes  MD5 checksum 4aed8540b098992663b7ba08c65312de  Compiled from "Main.java"public class com.rhythm7.Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #4.#18            #2 = Fieldref           #3.#19            #3 = Class              #20               #4 = Class              #21               #5 = Utf8               m   #6 = Utf8               I   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               LocalVariableTable  #12 = Utf8               this  #13 = Utf8               Lcom/rhythm7/Main;  #14 = Utf8               inc  #15 = Utf8               ()I  #16 = Utf8               SourceFile  #17 = Utf8               Main.java  #18 = NameAndType        #7:#8            #19 = NameAndType        #5:#6            #20 = Utf8               com/rhythm7/Main  #21 = Utf8               java/lang/Object{  private int m;    descriptor: I    flags: ACC_PRIVATE<p>public com.rhythm7.Main();<br>descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack=1, locals=1, args_size=1<br>0: aload_0<br>1: invokespecial #1<br>4: return<br>LineNumberTable:<br>line 3: 0<br>LocalVariableTable:<br>Start  Length  Slot  Name   Signature<br>0       5     0  this   Lcom/rhythm7/Main;</p><p>public int inc();<br>descriptor: ()I<br>flags: ACC_PUBLIC<br>Code:<br>stack=2, locals=1, args_size=1<br>0: aload_0<br>1: getfield      #2<br>4: iconst_1<br>5: iadd<br>6: ireturn<br>LineNumberTable:<br>line 8: 0<br>LocalVariableTable:<br>Start  Length  Slot  Name   Signature<br>0       7     0  this   Lcom/rhythm7/Main;<br>}<br>SourceFile: "Main.java"</p></code><p><code></code></p></pre><p></p></div><h3 id="字节码文件信息">字节码文件信息</h3><p>开头的 7 行信息包括: Class 文件当前所在位置，最后修改时间，文件大小，MD5 值，编译自哪个文件，类的全限定名，jdk 次版本号，主版本号。</p><p>然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下:</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为 Public 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为 final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用 invokespecial 字节码指令的新语义．</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志这个类并非由用户代码产生</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h3 id="常量池-2">常量池</h3><p><code>Constant pool</code>意为常量池。</p><p>常量池可以理解成 Class 文件中的资源仓库。主要存放的是两大类常量：字面量 (Literal) 和符号引用(Symbolic References)。字面量类似于 java 中的常量概念，如文本字符串，final 常量等，而符号引用则属于编译原理方面的概念，包括以下三种:</p><ul><li>类和接口的全限定名 (Fully Qualified Name)</li><li>字段的名称和描述符号 (Descriptor)</li><li>方法的名称和描述符</li></ul><p>不同于 C/C++, JVM 是在加载 Class 文件的时候才进行的动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。 直接通过反编译文件来查看字节码内容：</p><pre><code>#1 = Methodref          #4.#18         #4 = Class              #21            #7 = Utf8               &lt;init&gt;#8 = Utf8               ()V#18 = NameAndType        #7:#8          #21 = Utf8               java/lang/Object</code></pre><p><strong>第一个常量</strong>是一个方法定义，指向了第 4 和第 18 个常量。以此类推查看第 4 和第 18 个常量。最后可以拼接成第一个常量右侧的注释内容:</p><pre><code>java/lang/Object."&lt;init&gt;":()V</code></pre><p>这段可以理解为该类的实例构造器的声明，由于 Main 类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了 Main 类的直接父类是 Object。 该方法默认返回值是 V, 也就是 void，无返回值。</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型 byte</td></tr><tr><td>C</td><td>基本类型 char</td></tr><tr><td>D</td><td>基本类型 double</td></tr><tr><td>F</td><td>基本类型 float</td></tr><tr><td>I</td><td>基本类型 int</td></tr><tr><td>J</td><td>基本类型 long</td></tr><tr><td>S</td><td>基本类型 short</td></tr><tr><td>Z</td><td>基本类型 boolean</td></tr><tr><td>V</td><td>特殊类型 void</td></tr><tr><td>L</td><td>对象类型，以分号结尾，如 Ljava/lang/Object;</td></tr></tbody></table><p>对于数组类型，每一位使用一个前置的<code>[</code>字符来描述，如定义一个<code>java.lang.String[][]</code>类型的维数组，将被记录为<code>[[Ljava/lang/String;</code></p><h3 id="方法表集合">方法表集合</h3><p>在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的 16 进制文件内容如何，我们直接看反编译后的内容。</p><p>code 内的主要属性为:</p><ul><li><p><strong>stack</strong>: 最大操作数栈，JVM 运行时会根据这个值来分配栈帧 (Frame) 中的操作栈深度, 此处为 1</p></li><li><p><strong>locals</strong>: 局部变量所需的存储空间，单位为 Slot, Slot 是虚拟机为局部变量分配内存时所使用的最小单位，为 4 个字节大小。方法参数 (包括实例方法中的隐藏参数 this)，显示异常处理器的参数 (try catch 中的 catch 块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals 的大小并不一定等于所有局部变量所占的 Slot 之和，因为局部变量中的 Slot 是可以重用的。</p></li><li><p><strong>args_size</strong>: 方法参数的个数，这里是 1，因为每个实例方法都会有一个隐藏参数 this</p></li><li><p><strong>attribute_info</strong>: 方法体内容，0,1,4 为字节码 “行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的<code>java/lang/Object."":()V</code>, 然后执行返回语句，结束方法。</p></li><li><p><strong>LineNumberTable</strong>: 该属性的作用是描述源码行号与字节码行号 (字节码偏移量) 之间的对应关系。可以使用 -g:none 或 - g:lines 选项来取消或要求生成这项信息，如果选择不生成 LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</p></li><li><p><strong>LocalVariableTable</strong>: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars 来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是 arg0, arg1 这样的占位符。 start 表示该局部变量在哪一行开始可见，length 表示可见行数，Slot 代表所在帧栈位置，Name 是变量名称，然后是类型签名。</p></li></ul><h3 id="类名">类名</h3><p>最后很显然是源码文件：</p><pre><code>SourceFile: "Main.java"</code></pre><h2 id="字节码增强技术">字节码增强技术</h2><p>从最直接操纵字节码的实现方式开始深入进行剖析</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-1.png" alt></p><h3 id="ASM">ASM</h3><h4 id="ASM-简介">ASM 简介</h4><p>ASM 是一个通用的 Java 字节码操作和分析框架。 它可以用于修改现有类或直接以二进制形式动态生成类。 ASM 提供了一些常见的字节码转换和分析算法，可以从中构建自定义复杂转换和代码分析工具。 ASM 提供与其他 Java 字节码框架类似的功能，但专注于性能。 因为它的设计和实现尽可能小而且快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中）。</p><p><mark style="background: #FF5582A6;">对于需要手动操纵字节码的需求，可以使用 ASM，它可以直接生产 .class 字节码文件，也可以在类被加载入 JVM 之前动态修改类行为。</mark></p><p>ASM 的应用场景有 AOP（Cglib 就是基于 ASM）、热部署、修改其他 jar 包中的类等。</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-2.png" alt></p><h4 id="ASM-API">ASM API</h4><h5 id="核心-API">核心 API</h5><p>ASM Core API 可以类比解析 XML 文件中的 SAX 方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用 Core API。在 Core API 中有以下几个关键类：</p><ul><li>ClassReader：用于读取已经编译好的. class 文件。</li><li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li><li>各种 Visitor 类：如上所述，CoreAPI 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 Visitor，比如用于访问方法的 MethodVisitor、用于访问类变量的 FieldVisitor、用于访问注解的 AnnotationVisitor 等。为了实现 AOP，重点要使用的是 MethodVisitor。</li></ul><h5 id="树形-API">树形 API</h5><p>ASM Tree API 可以类比解析 XML 文件中的 DOM 方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi 不同于 CoreAPI，TreeAPI 通过各种 Node 类来映射字节码的各个区域，类比 DOM 节点，就可以很好地理解这种编程方式。</p><h4 id="直接利用-ASM-实现-AOP">直接利用 ASM 实现 AOP</h4><p>利用 ASM 的 CoreAPI 来增强类。这里不纠结于 AOP 的专业名词如切片、通知，只实现在方法调用前、后增加逻辑，通俗易懂且方便理解。首先定义需要被增强的 Base 类：其中只包含一个 process() 方法，方法内输出一行 “process”。增强后，我们期望的是，方法执行前输出 “start”，之后输出”end”。</p><p>为了利用 ASM 实现 AOP，需要定义两个类：一个是 MyClassVisitor 类，用于对字节码的 visit 以及修改；另一个是 Generator 类，在这个类中定义 ClassReader 和 ClassWriter，其中的逻辑是，classReader 读取字节码，然后交给 MyClassVisitor 类处理，处理完成后由 ClassWriter 写字节码并将旧的字节码替换掉。Generator 类较简单，我们先看一下它的实现，如下所示，然后重点解释 MyClassVisitor 类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import org.objectweb.asm.ClassReader;import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.ClassWriter;<p>public class Generator {<br>public static void main(String[] args) throws Exception {</p><pre><code>    ClassReader classReader = new ClassReader(&amp;quot;meituan/bytecode/asm/Base&amp;quot;);    ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);        ClassVisitor classVisitor = new MyClassVisitor(classWriter);    classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);    byte[] data = classWriter.toByteArray();        File f = new File(&amp;quot;operation-server/target/classes/meituan/bytecode/asm/Base.class&amp;quot;);    FileOutputStream fout = new FileOutputStream(f);    fout.write(data);    fout.close();    System.out.println(&amp;quot;now generator cc success!!!!!&amp;quot;);}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><p>MyClassVisitor 继承自 ClassVisitor，用于对字节码的观察。它还包含一个内部类 MyMethodVisitor，继承自 MethodVisitor 用于对类内方法的观察，它的整体代码如下：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><p>利用这个类就可以实现对字节码的修改。详细解读其中的代码，对字节码做修改的步骤是：</p><ul><li>首先通过 MyClassVisitor 类中的 visitMethod 方法，判断当前字节码读到哪一个方法了。跳过构造方法 <code>&lt;init&gt;</code> 后，将需要被增强的方法交给内部类 MyMethodVisitor 来进行处理。</li><li>接下来，进入内部类 MyMethodVisitor 中的 visitCode 方法，它会在 ASM 开始访问某一个方法的 Code 区时被调用，重写 visitCode 方法，将 AOP 中的前置逻辑就放在这里。 MyMethodVisitor 继续读取字节码指令，每当 ASM 访问到无参数指令时，都会调用 MyMethodVisitor 中的 visitInsn 方法。我们判断了当前指令是否为无参数的 “return” 指令，如果是就在它的前面添加一些指令，也就是将 AOP 的后置逻辑放在该方法中。</li><li>综上，重写 MyMethodVisitor 中的两个方法，就可以实现 AOP 了，而重写方法时就需要用 ASM 的写法，手动写入或者修改字节码。通过调用 methodVisitor 的 visitXXXXInsn()方法就可以实现字节码的插入，XXXX 对应相应的操作码助记符类型，比如 mv.visitLdcInsn(“end”)对应的操作码就是 ldc “end”，即将字符串 “end” 压入栈。 完成这两个 visitor 类后，运行 Generator 中的 main 方法完成对 Base 类的字节码增强，增强后的结果可以在编译后的 target 文件夹中找到 Base.class 文件进行查看，可以看到反编译后的代码已经改变了。然后写一个测试类 MyTest，在其中 new Base()，并调用 base.process()方法，可以看到下图右侧所示的 AOP 实现效果：</li></ul><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-3.png" alt></p><pre><code class="language-java">import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.MethodVisitor;import org.objectweb.asm.Opcodes;<p>public class MyClassVisitor extends ClassVisitor implements Opcodes {<br>public MyClassVisitor(ClassVisitor cv) {<br>super(ASM5, cv);<br>}<br>@Override<br>public void visit(int version, int access, String name, String signature,<br>String superName, String[] interfaces) {<br>cv.visit(version, access, name, signature, superName, interfaces);<br>}<br>@Override<br>public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {<br>MethodVisitor mv = cv.visitMethod(access, name, desc, signature,<br>exceptions);</p><pre><code>    if (!name.equals(&amp;quot;&amp;lt;init&amp;gt;&amp;quot;) &amp;amp;&amp;amp; mv != null) {        mv = new MyMethodVisitor(mv);    }    return mv;}class MyMethodVisitor extends MethodVisitor implements Opcodes {    public MyMethodVisitor(MethodVisitor mv) {        super(Opcodes.ASM5, mv);    }    @Override    public void visitCode() {        super.visitCode();        mv.visitFieldInsn(GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);        mv.visitLdcInsn(&amp;quot;start&amp;quot;);        mv.visitMethodInsn(INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;, false);    }    @Override    public void visitInsn(int opcode) {        if ((opcode &amp;gt;= Opcodes.IRETURN &amp;amp;&amp;amp; opcode &amp;lt;= Opcodes.RETURN)                || opcode == Opcodes.ATHROW) {                        mv.visitFieldInsn(GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);            mv.visitLdcInsn(&amp;quot;end&amp;quot;);            mv.visitMethodInsn(INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;, false);        }        mv.visitInsn(opcode);    }}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="ASM-工具">ASM 工具</h4><p>利用 ASM 手写字节码时，需要利用一系列 visitXXXXInsn() 方法来写对应的助记符，所以需要先将每一行源代码转化为一个个的助记符，然后通过 ASM 的语法转换为 visitXXXXInsn() 这种写法。第一步将源码转化为助记符就已经够麻烦了，不熟悉字节码操作集合的话，需要我们将代码编译后再反编译，才能得到源代码对应的助记符。第二步利用 ASM 写字节码时，如何传参也很令人头疼。ASM 社区也知道这两个问题，所以提供了工具 <a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline">ASM ByteCode Outline (opens new window)</a>。</p><p>安装后，右键选择 “Show Bytecode Outline”，在新标签页中选择“ASMified” 这个 tab，如图 19 所示，就可以看到这个类中的代码对应的 ASM 写法了。图中上下两个红框分别对应 AOP 中的前置逻辑于后置逻辑，将这两块直接复制到 visitor 中的 visitMethod()以及 visitInsn()方法中，就可以了。</p><h3 id="Javassist">Javassist</h3><p>ASM 是在指令层次上操作字节码的，阅读上文后，我们的直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，我们再简单介绍另外一类框架：强调源代码层次操作字节码的框架 Javassist。</p><p>利用 Javassist 实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是 ClassPool、CtClass、CtMethod、CtField 这四个类：</p><ul><li>CtClass（compile-time class）：编译时类信息，它是一个 class 文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个 CtClass 对象，用来表示这个类文件。</li><li>ClassPool：从开发视角来看，ClassPool 是一张保存 CtClass 信息的 HashTable，key 为类名，value 为类名对应的 CtClass 对象。当我们需要对某个类进行修改时，就是通过 pool.getCtClass(“className”) 方法从 pool 中获取到相应的 CtClass。</li><li>CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。</li></ul><p>了解这四个类后，我们可以写一个小 Demo 来展示 Javassist 简单、快速的特点。我们依然是对 Base 中的 process() 方法做增强，在方法调用前后分别输出”start” 和”end”，实现代码如下。我们需要做的就是从 pool 中获取到相应的 CtClass 对象和其中的方法，然后执行 method.insertBefore 和 insertAfter 方法，参数为要插入的 Java 代码，再以字符串的形式传入即可，实现起来也极为简单。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import com.meituan.mtrace.agent.javassist.*;</code><p><code class="language-java">public class JavassistTest {<br>public static void main(String[] args) throws NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException, IOException {<br>ClassPool cp = ClassPool.getDefault();<br>CtClass cc = cp.get("meituan.bytecode.javassist.Base");<br>CtMethod m = cc.getDeclaredMethod("process");<br>m.insertBefore("{ System.out.println(&amp;quot;start&amp;quot;); }");<br>m.insertAfter("{ System.out.println(&amp;quot;end&amp;quot;); }");<br>Class c = cc.toClass();<br>cc.writeFile("/Users/zen/projects");<br>Base h = (Base)c.newInstance();<br>h.process();<br>}<br>}</code></p></pre><p></p></div><h2 id="运行时类的重载">运行时类的重载</h2><h3 id="Instrument">Instrument</h3><p>instrument 是 JVM 提供的一个可以修改已加载类的类库，专门为 Java 语言编写的插桩服务提供支持。它需要依赖 JVMTI 的 Attach API 机制实现，JVMTI 这一部分，我们将在下一小节进行介绍。在 JDK 1.6 以前，instrument 只能在 JVM 刚启动开始加载类时生效，而在 JDK 1.6 之后，instrument 支持了在运行时对类定义的修改。要使用 instrument 的类修改功能，我们需要实现它提供的 ClassFileTransformer 接口，定义一个类文件转换器。接口中的 transform() 方法会在类文件被加载时调用，而在 transform 方法里，我们可以利用上文中的 ASM 或 Javassist 对传入的字节码进行改写或替换，生成新的字节码数组后返回。</p><p>我们定义一个实现了 ClassFileTransformer 接口的类 TestTransformer，依然在其中利用 Javassist 对 Base 类中的 process()方法进行增强，在前后分别打印 “start” 和“end”，代码如下：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import java.lang.instrument.ClassFileTransformer;<p>public class TestTransformer implements ClassFileTransformer {<br>@Override<br>public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {<br>System.out.println("Transforming " + className);<br>try {<br>ClassPool cp = ClassPool.getDefault();<br>CtClass cc = cp.get("meituan.bytecode.jvmti.Base");<br>CtMethod m = cc.getDeclaredMethod("process");<br>m.insertBefore("{ System.out.println(&amp;quot;start&amp;quot;); }");<br>m.insertAfter("{ System.out.println(&amp;quot;end&amp;quot;); }");<br>return cc.toBytecode();<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>return null;<br>}<br>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><p>现在有了 Transformer，那么它要如何注入到正在运行的 JVM 呢？还需要定义一个 Agent，借助 Agent 的能力将 Instrument 注入到 JVM 中。我们将在下一小节介绍 Agent，现在要介绍的是 Agent 中用到的另一个类 Instrumentation。在 JDK 1.6 之后，Instrumentation 可以做启动后的 Instrument、本地代码（Native Code）的 Instrument，以及动态改变 Classpath 等等。我们可以向 Instrumentation 中添加上文中定义的 Transformer，并指定要被重加载的类，代码如下所示。这样，当 Agent 被 Attach 到一个 JVM 中时，就会执行类字节码替换并重载入 JVM 的操作。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import java.lang.instrument.Instrumentation;<p>public class TestAgent {<br>public static void agentmain(String args, Instrumentation inst) {</p><pre><code>    inst.addTransformer(new TestTransformer(), true);    try {                inst.retransformClasses(Base.class);        System.out.println(&amp;quot;Agent Load Done.&amp;quot;);    } catch (Exception e) {        System.out.println(&amp;quot;agent load failed!&amp;quot;);    }}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="JVMTI-Agent-Attach-API">JVMTI &amp; Agent &amp; Attach API</h3><p>追根溯源需要先介绍 JPDA（Java Platform Debugger Architecture）。如果 JVM 启动时开启了 JPDA，那么类是允许被重新加载的。在这种情况下，已被加载的旧版本类信息可以被卸载，然后重新加载新版本的类。正如 JDPA 名称中的 Debugger，JDPA 其实是一套用于调试 Java 程序的标准，任何 JDK 都必须实现该标准。</p><p>JPDA 定义了一整套完整的体系，它将调试体系分为三部分，并规定了三者之间的通信接口。三部分由低到高分别是 Java 虚拟机工具接口（JVMTI），Java 调试协议（JDWP）以及 Java 调试接口（JDI），三者之间的关系如下图所示：</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-6.png" alt></p><p>现在回到正题，我们可以借助 JVMTI 的一部分能力，帮助动态重载类信息。JVM TI（JVM TOOL INTERFACE，JVM 工具接口）是 JVM 提供的一套对 JVM 进行操作的工具接口。通过 JVMTI，可以实现对 JVM 的多种操作，它通过接口注册各种事件勾子，在 JVM 事件触发时，同时触发预定义的勾子，以实现对各个 JVM 事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC 开始和结束、方法调用进入和退出、临界区竞争与等待、VM 启动与退出等等。</p><p>而 Agent 就是 JVMTI 的一种实现，Agent 有两种启动方式，一是随 Java 进程启动而启动，经常见到的 java -agentlib 就是这种方式；二是运行时载入，通过 attach API，将模块（jar 包）动态地 Attach 到指定进程 id 的 Java 进程内。</p><p>Attach API 的作用是提供 JVM 进程间通信的能力，比如说我们为了让另外一个 JVM 进程把线上服务的线程 Dump 出来，会运行 jstack 或 jmap 的进程，并传递 pid 的参数，告诉它要对哪个进程进行线程 Dump，这就是 Attach API 做的事情。在下面，我们将通过 Attach API 的 loadAgent() 方法，将打包好的 Agent jar 包动态 Attach 到目标 JVM 上。具体实现起来的步骤如下：</p><ul><li>定义 Agent，并在其中实现 AgentMain 方法，如上一小节中定义的代码块 7 中的 TestAgent 类；</li><li>然后将 TestAgent 类打成一个包含 MANIFEST.MF 的 jar 包，其中 MANIFEST.MF 文件中将 Agent-Class 属性指定为 TestAgent 的全限定名</li><li>最后利用 Attach API，将我们打包好的 jar 包 Attach 到指定的 JVM pid 上</li><li>由于在 MANIFEST.MF 中指定了 Agent-Class，所以在 Attach 后，目标 JVM 在运行时会走到 TestAgent 类中定义的 agentmain()方法，而在这个方法中，我们利用 Instrumentation，将指定类的字节码通过定义的类转化器 TestTransformer 做了 Base 类的字节码替换（通过 javassist），并完成了类的重新加载。由此，我们达成了 “在 JVM 运行时，改变类的字节码并重新载入类信息” 的目的。</li></ul><h3 id="使用场景">使用场景</h3><ul><li>热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。</li><li>Mock：测试时候对某些服务做 Mock。</li><li>性能诊断工具：比如 bTrace 就是利用 Instrument，实现无侵入地跟踪一个正在运行的 JVM，监控到类和方法级别的状态信息。</li></ul><h2 id="总结">总结</h2><p>字节码增强技术相当于是一把打开运行时 JVM 的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪 JVM 运行中程序的状态。此外，我们平时使用的动态代理、AOP 也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。综上所述，掌握字节码增强后可以高效地定位并快速修复一些棘手的问题（如线上性能问题、方法出现不可控的出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM</title>
      <link href="/language/java/java-jvm/java-jvm/"/>
      <url>/language/java/java-jvm/java-jvm/</url>
      
        <content type="html"><![CDATA[<h1>Java JVM</h1><h2 id="Metadata-34">Metadata</h2><pre><code class="language-yml">title: Java JVMdate: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java JVM</code></pre><h2 id="【Java-JVM】字节码编码">【Java JVM】字节码编码</h2><p>undefined</p><h2 id="【Java-JVM】JAVA-类加载机制">【Java JVM】JAVA 类加载机制</h2><p>undefined</p><h2 id="【Java-JVM】-内存结构">【Java JVM】 内存结构</h2><p>undefined</p><h2 id="【Java-JVM】内存模型">【Java JVM】内存模型</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java JVM】字节码编码</title>
      <link href="/language/java/java-jvm/java-jvm-zi-jie-ma-bian-ma/"/>
      <url>/language/java/java-jvm/java-jvm-zi-jie-ma-bian-ma/</url>
      
        <content type="html"><![CDATA[<h1>【Java JVM】字节码编码</h1><h2 id="Metadata-39">Metadata</h2><pre><code class="language-yml">title: 【Java JVM】字节码编码date: 2022-12-14 14:39tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace  - 细化主题/Java/JVMcategories:  - Javakeywords:  - Java/JVMdescription: 字节码编码</code></pre><h2 id="简介-3">简介</h2><p>计算机是不能直接运行 java 代码的，必须要先运行 java 虚拟机，再由 java 虚拟机运行编译后的 java 代码。这个编译后的 java 代码，就是本文要介绍的 java 字节码。</p><ul><li>Java 代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的 JVM 虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li><li>JVM 也不再只支持 Java，由此衍生出了许多基于 JVM 的编程语言，如 Groovy, Scala, Koltin 等等。</li></ul><p><img src="https://pdai.tech/_images/jvm/java-jvm-class-1.png" alt></p><h2 id="Java-字节码文件">Java 字节码文件</h2><p>class 文件本质上是一个以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在 class 文件中。jvm 根据其特定的规则解析该二进制数据，从而得到相关信息。</p><p>Class 文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。</p><h3 id="Class-文件的结构属性">Class 文件的结构属性</h3><p><img src="https://pdai.tech/_images/jvm/java-jvm-class-2.png" alt></p><h3 id="示例">示例</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p>collapse: closed</p><p>以文本的形式打开生成的 class 文件，内容如下:</p><pre><code class="language-class">cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0007 0008 0c00 0500 0601 0010 636f 6d2f7268 7974 686d 372f 4d61 696e 0100 106a6176 612f 6c61 6e67 2f4f 626a 6563 74002100 0300 0400 0000 0100 0200 0500 06000000 0200 0100 0700 0800 0100 0900 00001d00 0100 0100 0000 052a b700 01b1 00000001 000a 0000 0006 0001 0000 0003 0001000b 000c 0001 0009 0000 001f 0002 00010000 0007 2ab4 0002 0460 ac00 0000 01000a00 0000 0600 0100 0000 0800 0100 0d000000 0200 0e</code><p><code class="language-class"></code></p></pre><p></p></div><ul><li>文件开头的 4 个字节 (“cafe babe”) 称之为 <code>魔数</code>，唯有以 “cafe babe” 开头的 class 文件方可被虚拟机所接受，这 4 个字节就是字节码文件的身份识别。</li><li>0000 是编译器 jdk 版本的次版本号 0，0034 转化为十进制是 52, 是主版本号，java 的版本号从 45 开始，除 1.0 和 1.1 都是使用 45.x 外, 以后每升一个大版本，版本号加一。也就是说，编译生成该 class 文件的 jdk 版本为 1.8.0。</li></ul><h3 id="反编译字节码文件">反编译字节码文件</h3><blockquote><p>使用到 java 内置的一个反编译工具 javap 可以反编译字节码文件, 用法: <code>javap &lt;options&gt; &lt;classes&gt;</code></p></blockquote><p>其中<code>&lt;options&gt;</code>选项包括:</p><pre><code class="language-text">  -help  --help  -?        输出此用法消息  -version                 版本信息  -v  -verbose             输出附加信息  -l                       输出行号和本地变量表  -public                  仅显示公共类和成员  -protected               显示受保护的/公共类和成员  -package                 显示程序包/受保护的/公共类                           和成员 (默认)  -p  -private             显示所有类和成员  -c                       对代码进行反汇编  -s                       输出内部类型签名  -sysinfo                 显示正在处理的类的                           系统信息 (路径, 大小, 日期, MD5 散列)  -constants               显示最终常量  -classpath &lt;path&gt;        指定查找用户类文件的位置  -cp &lt;path&gt;               指定查找用户类文件的位置  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</code></pre><p>输入命令<code>javap -verbose -p Main.class</code>查看输出内容:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">collapse: closed</p><pre><code>Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class  Last modified 2018-4-7; size 362 bytes  MD5 checksum 4aed8540b098992663b7ba08c65312de  Compiled from "Main.java"public class com.rhythm7.Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #4.#18            #2 = Fieldref           #3.#19            #3 = Class              #20               #4 = Class              #21               #5 = Utf8               m   #6 = Utf8               I   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               LocalVariableTable  #12 = Utf8               this  #13 = Utf8               Lcom/rhythm7/Main;  #14 = Utf8               inc  #15 = Utf8               ()I  #16 = Utf8               SourceFile  #17 = Utf8               Main.java  #18 = NameAndType        #7:#8            #19 = NameAndType        #5:#6            #20 = Utf8               com/rhythm7/Main  #21 = Utf8               java/lang/Object{  private int m;    descriptor: I    flags: ACC_PRIVATE<p>public com.rhythm7.Main();<br>descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack=1, locals=1, args_size=1<br>0: aload_0<br>1: invokespecial #1<br>4: return<br>LineNumberTable:<br>line 3: 0<br>LocalVariableTable:<br>Start  Length  Slot  Name   Signature<br>0       5     0  this   Lcom/rhythm7/Main;</p><p>public int inc();<br>descriptor: ()I<br>flags: ACC_PUBLIC<br>Code:<br>stack=2, locals=1, args_size=1<br>0: aload_0<br>1: getfield      #2<br>4: iconst_1<br>5: iadd<br>6: ireturn<br>LineNumberTable:<br>line 8: 0<br>LocalVariableTable:<br>Start  Length  Slot  Name   Signature<br>0       7     0  this   Lcom/rhythm7/Main;<br>}<br>SourceFile: "Main.java"</p></code><p><code></code></p></pre><p></p></div><h3 id="字节码文件信息">字节码文件信息</h3><p>开头的 7 行信息包括: Class 文件当前所在位置，最后修改时间，文件大小，MD5 值，编译自哪个文件，类的全限定名，jdk 次版本号，主版本号。</p><p>然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下:</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为 Public 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为 final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用 invokespecial 字节码指令的新语义．</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志这个类并非由用户代码产生</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h3 id="常量池-2">常量池</h3><p><code>Constant pool</code>意为常量池。</p><p>常量池可以理解成 Class 文件中的资源仓库。主要存放的是两大类常量：字面量 (Literal) 和符号引用(Symbolic References)。字面量类似于 java 中的常量概念，如文本字符串，final 常量等，而符号引用则属于编译原理方面的概念，包括以下三种:</p><ul><li>类和接口的全限定名 (Fully Qualified Name)</li><li>字段的名称和描述符号 (Descriptor)</li><li>方法的名称和描述符</li></ul><p>不同于 C/C++, JVM 是在加载 Class 文件的时候才进行的动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。 直接通过反编译文件来查看字节码内容：</p><pre><code>#1 = Methodref          #4.#18         #4 = Class              #21            #7 = Utf8               &lt;init&gt;#8 = Utf8               ()V#18 = NameAndType        #7:#8          #21 = Utf8               java/lang/Object</code></pre><p><strong>第一个常量</strong>是一个方法定义，指向了第 4 和第 18 个常量。以此类推查看第 4 和第 18 个常量。最后可以拼接成第一个常量右侧的注释内容:</p><pre><code>java/lang/Object."&lt;init&gt;":()V</code></pre><p>这段可以理解为该类的实例构造器的声明，由于 Main 类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了 Main 类的直接父类是 Object。 该方法默认返回值是 V, 也就是 void，无返回值。</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型 byte</td></tr><tr><td>C</td><td>基本类型 char</td></tr><tr><td>D</td><td>基本类型 double</td></tr><tr><td>F</td><td>基本类型 float</td></tr><tr><td>I</td><td>基本类型 int</td></tr><tr><td>J</td><td>基本类型 long</td></tr><tr><td>S</td><td>基本类型 short</td></tr><tr><td>Z</td><td>基本类型 boolean</td></tr><tr><td>V</td><td>特殊类型 void</td></tr><tr><td>L</td><td>对象类型，以分号结尾，如 Ljava/lang/Object;</td></tr></tbody></table><p>对于数组类型，每一位使用一个前置的<code>[</code>字符来描述，如定义一个<code>java.lang.String[][]</code>类型的维数组，将被记录为<code>[[Ljava/lang/String;</code></p><h3 id="方法表集合">方法表集合</h3><p>在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的 16 进制文件内容如何，我们直接看反编译后的内容。</p><p>code 内的主要属性为:</p><ul><li><p><strong>stack</strong>: 最大操作数栈，JVM 运行时会根据这个值来分配栈帧 (Frame) 中的操作栈深度, 此处为 1</p></li><li><p><strong>locals</strong>: 局部变量所需的存储空间，单位为 Slot, Slot 是虚拟机为局部变量分配内存时所使用的最小单位，为 4 个字节大小。方法参数 (包括实例方法中的隐藏参数 this)，显示异常处理器的参数 (try catch 中的 catch 块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals 的大小并不一定等于所有局部变量所占的 Slot 之和，因为局部变量中的 Slot 是可以重用的。</p></li><li><p><strong>args_size</strong>: 方法参数的个数，这里是 1，因为每个实例方法都会有一个隐藏参数 this</p></li><li><p><strong>attribute_info</strong>: 方法体内容，0,1,4 为字节码 “行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的<code>java/lang/Object."":()V</code>, 然后执行返回语句，结束方法。</p></li><li><p><strong>LineNumberTable</strong>: 该属性的作用是描述源码行号与字节码行号 (字节码偏移量) 之间的对应关系。可以使用 -g:none 或 - g:lines 选项来取消或要求生成这项信息，如果选择不生成 LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</p></li><li><p><strong>LocalVariableTable</strong>: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars 来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是 arg0, arg1 这样的占位符。 start 表示该局部变量在哪一行开始可见，length 表示可见行数，Slot 代表所在帧栈位置，Name 是变量名称，然后是类型签名。</p></li></ul><h3 id="类名">类名</h3><p>最后很显然是源码文件：</p><pre><code>SourceFile: "Main.java"</code></pre><h2 id="字节码增强技术">字节码增强技术</h2><p>从最直接操纵字节码的实现方式开始深入进行剖析</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-1.png" alt></p><h3 id="ASM">ASM</h3><h4 id="ASM-简介">ASM 简介</h4><p>ASM 是一个通用的 Java 字节码操作和分析框架。 它可以用于修改现有类或直接以二进制形式动态生成类。 ASM 提供了一些常见的字节码转换和分析算法，可以从中构建自定义复杂转换和代码分析工具。 ASM 提供与其他 Java 字节码框架类似的功能，但专注于性能。 因为它的设计和实现尽可能小而且快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中）。</p><p><mark style="background: #FF5582A6;">对于需要手动操纵字节码的需求，可以使用 ASM，它可以直接生产 .class 字节码文件，也可以在类被加载入 JVM 之前动态修改类行为。</mark></p><p>ASM 的应用场景有 AOP（Cglib 就是基于 ASM）、热部署、修改其他 jar 包中的类等。</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-2.png" alt></p><h4 id="ASM-API">ASM API</h4><h5 id="核心-API">核心 API</h5><p>ASM Core API 可以类比解析 XML 文件中的 SAX 方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用 Core API。在 Core API 中有以下几个关键类：</p><ul><li>ClassReader：用于读取已经编译好的. class 文件。</li><li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li><li>各种 Visitor 类：如上所述，CoreAPI 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 Visitor，比如用于访问方法的 MethodVisitor、用于访问类变量的 FieldVisitor、用于访问注解的 AnnotationVisitor 等。为了实现 AOP，重点要使用的是 MethodVisitor。</li></ul><h5 id="树形-API">树形 API</h5><p>ASM Tree API 可以类比解析 XML 文件中的 DOM 方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi 不同于 CoreAPI，TreeAPI 通过各种 Node 类来映射字节码的各个区域，类比 DOM 节点，就可以很好地理解这种编程方式。</p><h4 id="直接利用-ASM-实现-AOP">直接利用 ASM 实现 AOP</h4><p>利用 ASM 的 CoreAPI 来增强类。这里不纠结于 AOP 的专业名词如切片、通知，只实现在方法调用前、后增加逻辑，通俗易懂且方便理解。首先定义需要被增强的 Base 类：其中只包含一个 process() 方法，方法内输出一行 “process”。增强后，我们期望的是，方法执行前输出 “start”，之后输出”end”。</p><p>为了利用 ASM 实现 AOP，需要定义两个类：一个是 MyClassVisitor 类，用于对字节码的 visit 以及修改；另一个是 Generator 类，在这个类中定义 ClassReader 和 ClassWriter，其中的逻辑是，classReader 读取字节码，然后交给 MyClassVisitor 类处理，处理完成后由 ClassWriter 写字节码并将旧的字节码替换掉。Generator 类较简单，我们先看一下它的实现，如下所示，然后重点解释 MyClassVisitor 类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import org.objectweb.asm.ClassReader;import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.ClassWriter;<p>public class Generator {<br>public static void main(String[] args) throws Exception {</p><pre><code>    ClassReader classReader = new ClassReader(&amp;quot;meituan/bytecode/asm/Base&amp;quot;);    ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);        ClassVisitor classVisitor = new MyClassVisitor(classWriter);    classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);    byte[] data = classWriter.toByteArray();        File f = new File(&amp;quot;operation-server/target/classes/meituan/bytecode/asm/Base.class&amp;quot;);    FileOutputStream fout = new FileOutputStream(f);    fout.write(data);    fout.close();    System.out.println(&amp;quot;now generator cc success!!!!!&amp;quot;);}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><p>MyClassVisitor 继承自 ClassVisitor，用于对字节码的观察。它还包含一个内部类 MyMethodVisitor，继承自 MethodVisitor 用于对类内方法的观察，它的整体代码如下：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><p>利用这个类就可以实现对字节码的修改。详细解读其中的代码，对字节码做修改的步骤是：</p><ul><li>首先通过 MyClassVisitor 类中的 visitMethod 方法，判断当前字节码读到哪一个方法了。跳过构造方法 <code>&lt;init&gt;</code> 后，将需要被增强的方法交给内部类 MyMethodVisitor 来进行处理。</li><li>接下来，进入内部类 MyMethodVisitor 中的 visitCode 方法，它会在 ASM 开始访问某一个方法的 Code 区时被调用，重写 visitCode 方法，将 AOP 中的前置逻辑就放在这里。 MyMethodVisitor 继续读取字节码指令，每当 ASM 访问到无参数指令时，都会调用 MyMethodVisitor 中的 visitInsn 方法。我们判断了当前指令是否为无参数的 “return” 指令，如果是就在它的前面添加一些指令，也就是将 AOP 的后置逻辑放在该方法中。</li><li>综上，重写 MyMethodVisitor 中的两个方法，就可以实现 AOP 了，而重写方法时就需要用 ASM 的写法，手动写入或者修改字节码。通过调用 methodVisitor 的 visitXXXXInsn()方法就可以实现字节码的插入，XXXX 对应相应的操作码助记符类型，比如 mv.visitLdcInsn(“end”)对应的操作码就是 ldc “end”，即将字符串 “end” 压入栈。 完成这两个 visitor 类后，运行 Generator 中的 main 方法完成对 Base 类的字节码增强，增强后的结果可以在编译后的 target 文件夹中找到 Base.class 文件进行查看，可以看到反编译后的代码已经改变了。然后写一个测试类 MyTest，在其中 new Base()，并调用 base.process()方法，可以看到下图右侧所示的 AOP 实现效果：</li></ul><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-3.png" alt></p><pre><code class="language-java">import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.MethodVisitor;import org.objectweb.asm.Opcodes;<p>public class MyClassVisitor extends ClassVisitor implements Opcodes {<br>public MyClassVisitor(ClassVisitor cv) {<br>super(ASM5, cv);<br>}<br>@Override<br>public void visit(int version, int access, String name, String signature,<br>String superName, String[] interfaces) {<br>cv.visit(version, access, name, signature, superName, interfaces);<br>}<br>@Override<br>public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {<br>MethodVisitor mv = cv.visitMethod(access, name, desc, signature,<br>exceptions);</p><pre><code>    if (!name.equals(&amp;quot;&amp;lt;init&amp;gt;&amp;quot;) &amp;amp;&amp;amp; mv != null) {        mv = new MyMethodVisitor(mv);    }    return mv;}class MyMethodVisitor extends MethodVisitor implements Opcodes {    public MyMethodVisitor(MethodVisitor mv) {        super(Opcodes.ASM5, mv);    }    @Override    public void visitCode() {        super.visitCode();        mv.visitFieldInsn(GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);        mv.visitLdcInsn(&amp;quot;start&amp;quot;);        mv.visitMethodInsn(INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;, false);    }    @Override    public void visitInsn(int opcode) {        if ((opcode &amp;gt;= Opcodes.IRETURN &amp;amp;&amp;amp; opcode &amp;lt;= Opcodes.RETURN)                || opcode == Opcodes.ATHROW) {                        mv.visitFieldInsn(GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);            mv.visitLdcInsn(&amp;quot;end&amp;quot;);            mv.visitMethodInsn(INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;, false);        }        mv.visitInsn(opcode);    }}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="ASM-工具">ASM 工具</h4><p>利用 ASM 手写字节码时，需要利用一系列 visitXXXXInsn() 方法来写对应的助记符，所以需要先将每一行源代码转化为一个个的助记符，然后通过 ASM 的语法转换为 visitXXXXInsn() 这种写法。第一步将源码转化为助记符就已经够麻烦了，不熟悉字节码操作集合的话，需要我们将代码编译后再反编译，才能得到源代码对应的助记符。第二步利用 ASM 写字节码时，如何传参也很令人头疼。ASM 社区也知道这两个问题，所以提供了工具 <a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline">ASM ByteCode Outline (opens new window)</a>。</p><p>安装后，右键选择 “Show Bytecode Outline”，在新标签页中选择“ASMified” 这个 tab，如图 19 所示，就可以看到这个类中的代码对应的 ASM 写法了。图中上下两个红框分别对应 AOP 中的前置逻辑于后置逻辑，将这两块直接复制到 visitor 中的 visitMethod()以及 visitInsn()方法中，就可以了。</p><h3 id="Javassist">Javassist</h3><p>ASM 是在指令层次上操作字节码的，阅读上文后，我们的直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，我们再简单介绍另外一类框架：强调源代码层次操作字节码的框架 Javassist。</p><p>利用 Javassist 实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是 ClassPool、CtClass、CtMethod、CtField 这四个类：</p><ul><li>CtClass（compile-time class）：编译时类信息，它是一个 class 文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个 CtClass 对象，用来表示这个类文件。</li><li>ClassPool：从开发视角来看，ClassPool 是一张保存 CtClass 信息的 HashTable，key 为类名，value 为类名对应的 CtClass 对象。当我们需要对某个类进行修改时，就是通过 pool.getCtClass(“className”) 方法从 pool 中获取到相应的 CtClass。</li><li>CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。</li></ul><p>了解这四个类后，我们可以写一个小 Demo 来展示 Javassist 简单、快速的特点。我们依然是对 Base 中的 process() 方法做增强，在方法调用前后分别输出”start” 和”end”，实现代码如下。我们需要做的就是从 pool 中获取到相应的 CtClass 对象和其中的方法，然后执行 method.insertBefore 和 insertAfter 方法，参数为要插入的 Java 代码，再以字符串的形式传入即可，实现起来也极为简单。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import com.meituan.mtrace.agent.javassist.*;</code><p><code class="language-java">public class JavassistTest {<br>public static void main(String[] args) throws NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException, IOException {<br>ClassPool cp = ClassPool.getDefault();<br>CtClass cc = cp.get("meituan.bytecode.javassist.Base");<br>CtMethod m = cc.getDeclaredMethod("process");<br>m.insertBefore("{ System.out.println(&amp;quot;start&amp;quot;); }");<br>m.insertAfter("{ System.out.println(&amp;quot;end&amp;quot;); }");<br>Class c = cc.toClass();<br>cc.writeFile("/Users/zen/projects");<br>Base h = (Base)c.newInstance();<br>h.process();<br>}<br>}</code></p></pre><p></p></div><h2 id="运行时类的重载">运行时类的重载</h2><h3 id="Instrument">Instrument</h3><p>instrument 是 JVM 提供的一个可以修改已加载类的类库，专门为 Java 语言编写的插桩服务提供支持。它需要依赖 JVMTI 的 Attach API 机制实现，JVMTI 这一部分，我们将在下一小节进行介绍。在 JDK 1.6 以前，instrument 只能在 JVM 刚启动开始加载类时生效，而在 JDK 1.6 之后，instrument 支持了在运行时对类定义的修改。要使用 instrument 的类修改功能，我们需要实现它提供的 ClassFileTransformer 接口，定义一个类文件转换器。接口中的 transform() 方法会在类文件被加载时调用，而在 transform 方法里，我们可以利用上文中的 ASM 或 Javassist 对传入的字节码进行改写或替换，生成新的字节码数组后返回。</p><p>我们定义一个实现了 ClassFileTransformer 接口的类 TestTransformer，依然在其中利用 Javassist 对 Base 类中的 process()方法进行增强，在前后分别打印 “start” 和“end”，代码如下：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import java.lang.instrument.ClassFileTransformer;<p>public class TestTransformer implements ClassFileTransformer {<br>@Override<br>public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {<br>System.out.println("Transforming " + className);<br>try {<br>ClassPool cp = ClassPool.getDefault();<br>CtClass cc = cp.get("meituan.bytecode.jvmti.Base");<br>CtMethod m = cc.getDeclaredMethod("process");<br>m.insertBefore("{ System.out.println(&amp;quot;start&amp;quot;); }");<br>m.insertAfter("{ System.out.println(&amp;quot;end&amp;quot;); }");<br>return cc.toBytecode();<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>return null;<br>}<br>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><p>现在有了 Transformer，那么它要如何注入到正在运行的 JVM 呢？还需要定义一个 Agent，借助 Agent 的能力将 Instrument 注入到 JVM 中。我们将在下一小节介绍 Agent，现在要介绍的是 Agent 中用到的另一个类 Instrumentation。在 JDK 1.6 之后，Instrumentation 可以做启动后的 Instrument、本地代码（Native Code）的 Instrument，以及动态改变 Classpath 等等。我们可以向 Instrumentation 中添加上文中定义的 Transformer，并指定要被重加载的类，代码如下所示。这样，当 Agent 被 Attach 到一个 JVM 中时，就会执行类字节码替换并重载入 JVM 的操作。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">代码</p><p>collapse: closed</p><pre><code class="language-java">import java.lang.instrument.Instrumentation;<p>public class TestAgent {<br>public static void agentmain(String args, Instrumentation inst) {</p><pre><code>    inst.addTransformer(new TestTransformer(), true);    try {                inst.retransformClasses(Base.class);        System.out.println(&amp;quot;Agent Load Done.&amp;quot;);    } catch (Exception e) {        System.out.println(&amp;quot;agent load failed!&amp;quot;);    }}</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="JVMTI-Agent-Attach-API">JVMTI &amp; Agent &amp; Attach API</h3><p>追根溯源需要先介绍 JPDA（Java Platform Debugger Architecture）。如果 JVM 启动时开启了 JPDA，那么类是允许被重新加载的。在这种情况下，已被加载的旧版本类信息可以被卸载，然后重新加载新版本的类。正如 JDPA 名称中的 Debugger，JDPA 其实是一套用于调试 Java 程序的标准，任何 JDK 都必须实现该标准。</p><p>JPDA 定义了一整套完整的体系，它将调试体系分为三部分，并规定了三者之间的通信接口。三部分由低到高分别是 Java 虚拟机工具接口（JVMTI），Java 调试协议（JDWP）以及 Java 调试接口（JDI），三者之间的关系如下图所示：</p><p><img src="https://pdai.tech/_images/jvm/java-class-enhancer-6.png" alt></p><p>现在回到正题，我们可以借助 JVMTI 的一部分能力，帮助动态重载类信息。JVM TI（JVM TOOL INTERFACE，JVM 工具接口）是 JVM 提供的一套对 JVM 进行操作的工具接口。通过 JVMTI，可以实现对 JVM 的多种操作，它通过接口注册各种事件勾子，在 JVM 事件触发时，同时触发预定义的勾子，以实现对各个 JVM 事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC 开始和结束、方法调用进入和退出、临界区竞争与等待、VM 启动与退出等等。</p><p>而 Agent 就是 JVMTI 的一种实现，Agent 有两种启动方式，一是随 Java 进程启动而启动，经常见到的 java -agentlib 就是这种方式；二是运行时载入，通过 attach API，将模块（jar 包）动态地 Attach 到指定进程 id 的 Java 进程内。</p><p>Attach API 的作用是提供 JVM 进程间通信的能力，比如说我们为了让另外一个 JVM 进程把线上服务的线程 Dump 出来，会运行 jstack 或 jmap 的进程，并传递 pid 的参数，告诉它要对哪个进程进行线程 Dump，这就是 Attach API 做的事情。在下面，我们将通过 Attach API 的 loadAgent() 方法，将打包好的 Agent jar 包动态 Attach 到目标 JVM 上。具体实现起来的步骤如下：</p><ul><li>定义 Agent，并在其中实现 AgentMain 方法，如上一小节中定义的代码块 7 中的 TestAgent 类；</li><li>然后将 TestAgent 类打成一个包含 MANIFEST.MF 的 jar 包，其中 MANIFEST.MF 文件中将 Agent-Class 属性指定为 TestAgent 的全限定名</li><li>最后利用 Attach API，将我们打包好的 jar 包 Attach 到指定的 JVM pid 上</li><li>由于在 MANIFEST.MF 中指定了 Agent-Class，所以在 Attach 后，目标 JVM 在运行时会走到 TestAgent 类中定义的 agentmain()方法，而在这个方法中，我们利用 Instrumentation，将指定类的字节码通过定义的类转化器 TestTransformer 做了 Base 类的字节码替换（通过 javassist），并完成了类的重新加载。由此，我们达成了 “在 JVM 运行时，改变类的字节码并重新载入类信息” 的目的。</li></ul><h3 id="使用场景">使用场景</h3><ul><li>热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。</li><li>Mock：测试时候对某些服务做 Mock。</li><li>性能诊断工具：比如 bTrace 就是利用 Instrument，实现无侵入地跟踪一个正在运行的 JVM，监控到类和方法级别的状态信息。</li></ul><h2 id="总结">总结</h2><p>字节码增强技术相当于是一把打开运行时 JVM 的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪 JVM 运行中程序的状态。此外，我们平时使用的动态代理、AOP 也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。综上所述，掌握字节码增强后可以高效地定位并快速修复一些棘手的问题（如线上性能问题、方法出现不可控的出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace </tag>
            
            <tag> 细化主题/Java/JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 WeakHashMap</title>
      <link href="/java/java-ji-he/java-ji-he-weakhashmap/"/>
      <url>/java/java-ji-he/java-ji-he-weakhashmap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 WeakHashMap</h1><h2 id="Metadata-31">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 WeakHashMapdate: 2022-12-14 14:29tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: WeakHashMap</code></pre><h2 id="总体介绍-3">总体介绍</h2><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。<br>更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况:</p><ul><li>调用两次<code>size()</code>方法返回不同的值；</li><li>两次调用<code>isEmpty()</code>方法，第一次返回false，第二次返回true；</li><li>两次调用<code>containsKey()</code>方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；</li><li>两次调用<code>get()</code>方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。<br>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，WeakHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。<br>要明白 WeakHashMap 的工作原理，还需要引入一个概念 : 弱引用(WeakReference)。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的有效引用 并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。<br>WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。<br>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</li></ul><h2 id="具体实现">具体实现</h2><p>WeakHashMap的存储结构类似于Map - HashSet &amp; HashMap 源码解析，这里不再赘述。<br>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p><h2 id="Weak-HashSet">Weak HashSet?</h2><p>如果你看过前几篇关于 Map 和 Set 的讲解，一定会问: 既然有 WeakHashMap，是否有 WeekHashSet 呢? 答案是没有:( 。不过Java Collections工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 Map包装成一个Set。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 WeakHashMap</title>
      <link href="/language/java/java-ji-he/java-ji-he-weakhashmap/"/>
      <url>/language/java/java-ji-he/java-ji-he-weakhashmap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 WeakHashMap</h1><h2 id="Metadata-66">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 WeakHashMapdate: 2022-12-14 14:29tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: WeakHashMap</code></pre><h2 id="总体介绍-3">总体介绍</h2><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。<br>更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况:</p><ul><li>调用两次<code>size()</code>方法返回不同的值；</li><li>两次调用<code>isEmpty()</code>方法，第一次返回false，第二次返回true；</li><li>两次调用<code>containsKey()</code>方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；</li><li>两次调用<code>get()</code>方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。<br>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，WeakHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。<br>要明白 WeakHashMap 的工作原理，还需要引入一个概念 : 弱引用(WeakReference)。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的有效引用 并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。<br>WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。<br>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</li></ul><h2 id="具体实现">具体实现</h2><p>WeakHashMap的存储结构类似于Map - HashSet &amp; HashMap 源码解析，这里不再赘述。<br>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p><h2 id="Weak-HashSet">Weak HashSet?</h2><p>如果你看过前几篇关于 Map 和 Set 的讲解，一定会问: 既然有 WeakHashMap，是否有 WeekHashSet 呢? 答案是没有:( 。不过Java Collections工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 Map包装成一个Set。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 TreeSet &amp; TreeMap</title>
      <link href="/java/java-ji-he/java-ji-he-treeset-treemap/"/>
      <url>/java/java-ji-he/java-ji-he-treeset-treemap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 TreeSet &amp; TreeMap</h1><h2 id="Metadata-30">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 TreeSet &amp; TreeMapdate: 2022-12-14 14:28tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: TreeSet &amp; TreeMap</code></pre><h2 id="总体介绍-2">总体介绍</h2><p>之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)**。因此本文将重点分析TreeMap。</p><p>Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p><p>TreeMap底层通过红黑树(Red-Black tree)实现，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="/attachment%5C7a7166f88bbf82409e0ea2dfef3fb432.png" alt></p><p>出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成(wrapped)同步的:</p><pre><code class="language-java">SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></pre><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h2 id="预备知识">预备知识</h2><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(Rotate Left)，右旋(RotateRight)**。</p><h3 id="左旋">左旋</h3><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment%5C5032edc39f7b7fc0d8b1bb352641b5c9.png" alt></p><h3 id="右旋">右旋</h3><p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment%5C4a47735be3f67803d2bb86f0b523126e.png" alt></p><h3 id="寻找节点后继">寻找节点后继</h3><p>对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="/attachment%5C5a8f8447940c459fdcfa2e59ccd2376a.png" alt></p><h2 id="方法剖析-2">方法剖析</h2><h3 id="get-3">get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据key的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的entry。</p><p><img src="/attachment%5Ceb8661b88f7261fb41c2730481d104d0.png" alt></p><h3 id="put-2">put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。</p><p>上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的entry并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。<br><img src="/attachment%5C92a9af8db273d3091dea45a5cb592716.png" alt><br>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><h3 id="remove-3">remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到key值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p><p>getEntry()函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p><p>由于<strong>红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。</p><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/attachment%5C92a9af8db273d3091dea45a5cb592716.png" alt></p><p>上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。</p><p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><h3 id="TreeSet">TreeSet</h3><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 TreeSet &amp; TreeMap</title>
      <link href="/language/java/java-ji-he/java-ji-he-treeset-treemap/"/>
      <url>/language/java/java-ji-he/java-ji-he-treeset-treemap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 TreeSet &amp; TreeMap</h1><h2 id="Metadata-65">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 TreeSet &amp; TreeMapdate: 2022-12-14 14:28tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: TreeSet &amp; TreeMap</code></pre><h2 id="总体介绍-2">总体介绍</h2><p>之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)**。因此本文将重点分析TreeMap。</p><p>Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p><p>TreeMap底层通过红黑树(Red-Black tree)实现，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="/attachment%5C7a7166f88bbf82409e0ea2dfef3fb432.png" alt></p><p>出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成(wrapped)同步的:</p><pre><code class="language-java">SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></pre><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h2 id="预备知识">预备知识</h2><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(Rotate Left)，右旋(RotateRight)**。</p><h3 id="左旋">左旋</h3><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment%5C5032edc39f7b7fc0d8b1bb352641b5c9.png" alt></p><h3 id="右旋">右旋</h3><p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/attachment%5C4a47735be3f67803d2bb86f0b523126e.png" alt></p><h3 id="寻找节点后继">寻找节点后继</h3><p>对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="/attachment%5C5a8f8447940c459fdcfa2e59ccd2376a.png" alt></p><h2 id="方法剖析-3">方法剖析</h2><h3 id="get-3">get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据key的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的entry。</p><p><img src="/attachment%5Ceb8661b88f7261fb41c2730481d104d0.png" alt></p><h3 id="put-2">put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。</p><p>上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的entry并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。<br><img src="/attachment%5C92a9af8db273d3091dea45a5cb592716.png" alt><br>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><h3 id="remove-3">remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到key值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p><p>getEntry()函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p><p>由于<strong>红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。</p><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/attachment%5C92a9af8db273d3091dea45a5cb592716.png" alt></p><p>上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。</p><p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><h3 id="TreeSet">TreeSet</h3><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedHashSet&amp;Map</title>
      <link href="/java/java-ji-he/java-ji-he-linkedhashset-map/"/>
      <url>/java/java-ji-he/java-ji-he-linkedhashset-map/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 LinkedHashSet&amp;Map</h1><h2 id="Metadata-28">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 LinkedHashSet&amp;Mapdate: 2022-12-14 14:27tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedHashSet&amp;Map</code></pre><h2 id="总体介绍">总体介绍</h2><p>如果你已看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文将要讲解的LinkedHashSet和LinkedHashMap其实也是一回事。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap(适配器模式)。因此本文将重点分析LinkedHashMap。</p><p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。</p><p><img src="/attachment%5Ca2a0572e540cb3667a33ff02a9506ba3.png" alt></p><p>事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。</p><p>除了可以保迭代历顺序，这种结构还有一个好处 : 迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。</p><p>有两个参数可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要<code>@Override hashCode()</code>和<code>equals()</code>方法。</p><p>出于性能原因，LinkedHashMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成(wrapped)同步的:</p><pre><code class="language-java">Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></pre><h2 id="方法剖析">方法剖析</h2><h3 id="get-2">get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行参考前文，这里不再赘述。</p><h3 id="put">put()</h3><p><code>put(K key, V value)</code>方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的entry。</p><p>注意，这里的插入有<strong>两重含义</strong>:</p><ol><li>从table的角度看，新的<code>entry</code>需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol><p><img src="/attachment%5Cb3a124c667ece2d44b38023cf6b28415.png" alt></p><p>上述代码中用到了<code>addBefore()</code>方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。</p><p>上述代码只是简单修改相关entry的引用而已。</p><h3 id="remove-2">remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到key值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的删除也有两重含义:</p><blockquote><ol><li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="/attachment%5Cb2057acdb4b57a0381c29f3da5e18e07.png" alt></p><h2 id="LinkedHashSet">LinkedHashSet</h2><p>前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。</p><h2 id="LinkedHashMap经典用法">LinkedHashMap经典用法</h2><p>LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问<code>removeEldestEntry()</code>是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让<code>removeEldestEntry()</code>返回true，就能够实现一个固定大小的FIFO策略的缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedHashSet&amp;Map</title>
      <link href="/language/java/java-ji-he/java-ji-he-linkedhashset-map/"/>
      <url>/language/java/java-ji-he/java-ji-he-linkedhashset-map/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 LinkedHashSet&amp;Map</h1><h2 id="Metadata-62">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 LinkedHashSet&amp;Mapdate: 2022-12-14 14:27tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedHashSet&amp;Map</code></pre><h2 id="总体介绍">总体介绍</h2><p>如果你已看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文将要讲解的LinkedHashSet和LinkedHashMap其实也是一回事。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap(适配器模式)。因此本文将重点分析LinkedHashMap。</p><p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。</p><p><img src="/attachment%5Ca2a0572e540cb3667a33ff02a9506ba3.png" alt></p><p>事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。</p><p>除了可以保迭代历顺序，这种结构还有一个好处 : 迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。</p><p>有两个参数可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要<code>@Override hashCode()</code>和<code>equals()</code>方法。</p><p>出于性能原因，LinkedHashMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成(wrapped)同步的:</p><pre><code class="language-java">Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></pre><h2 id="方法剖析">方法剖析</h2><h3 id="get-2">get()</h3><p><code>get(Object key)</code>方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行参考前文，这里不再赘述。</p><h3 id="put">put()</h3><p><code>put(K key, V value)</code>方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的entry。</p><p>注意，这里的插入有<strong>两重含义</strong>:</p><ol><li>从table的角度看，新的<code>entry</code>需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol><p><img src="/attachment%5Cb3a124c667ece2d44b38023cf6b28415.png" alt></p><p>上述代码中用到了<code>addBefore()</code>方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。</p><p>上述代码只是简单修改相关entry的引用而已。</p><h3 id="remove-2">remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到key值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的删除也有两重含义:</p><blockquote><ol><li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="/attachment%5Cb2057acdb4b57a0381c29f3da5e18e07.png" alt></p><h2 id="LinkedHashSet">LinkedHashSet</h2><p>前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。</p><h2 id="LinkedHashMap经典用法">LinkedHashMap经典用法</h2><p>LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问<code>removeEldestEntry()</code>是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让<code>removeEldestEntry()</code>返回true，就能够实现一个固定大小的FIFO策略的缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】HashSet &amp; HashMap</title>
      <link href="/java/java-ji-he/java-ji-he-hashset-hashmap/"/>
      <url>/java/java-ji-he/java-ji-he-hashset-hashmap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】HashSet &amp; HashMap</h1><h2 id="Metadata-36">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】HashSet &amp; HashMapdate: 2022-12-14 14:26tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: HashSet &amp; HashMap</code></pre><h2 id="Java7-HashMap">Java7 HashMap</h2><h3 id="概述-5">概述</h3><p>之所以把HashSet和HashMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap(适配器模式)。因此本文将重点分析HashMap。</p><p>HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式。</strong></p><p><img src="/attachment%5C0e757c0ad4f83dc5a4d23e3766a40b5b.png" alt></p><p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。</p><p>有两个参数可以影响HashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到HashMap或HashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要<code>@Override</code> hashCode()和equals()方法。</p><h3 id="get-4">get()</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个entry。</p><p><img src="/attachment%5C657342a08666fd428fa01da97955e06a.png" alt></p><p>上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><h3 id="put-3">put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为头插法。</p><p><img src="/attachment%5C8352c0cd711fff93e7177ecf74436844.png" alt></p><h2 id="Java8-HashMap">Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>来一张图简单示意一下吧：</p><p><img src="/attachment%5C46d8f27734298c8228231f63d3948780.png" alt></p><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="数组扩容">数组扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><h3 id="get-过程分析">get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ul><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等( = = 或equals)的 key</li></ul><h3 id="HashSet">HashSet</h3><p>前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】HashSet &amp; HashMap</title>
      <link href="/language/java/java-ji-he/java-ji-he-hashset-hashmap/"/>
      <url>/language/java/java-ji-he/java-ji-he-hashset-hashmap/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】HashSet &amp; HashMap</h1><h2 id="Metadata-67">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】HashSet &amp; HashMapdate: 2022-12-14 14:26tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: HashSet &amp; HashMap</code></pre><h2 id="Java7-HashMap">Java7 HashMap</h2><h3 id="概述-4">概述</h3><p>之所以把HashSet和HashMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap(适配器模式)。因此本文将重点分析HashMap。</p><p>HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式。</strong></p><p><img src="/attachment%5C0e757c0ad4f83dc5a4d23e3766a40b5b.png" alt></p><p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。</p><p>有两个参数可以影响HashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到HashMap或HashSet中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要<code>@Override</code> hashCode()和equals()方法。</p><h3 id="get-4">get()</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个entry。</p><p><img src="/attachment%5C657342a08666fd428fa01da97955e06a.png" alt></p><p>上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><h3 id="put-3">put()</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为头插法。</p><p><img src="/attachment%5C8352c0cd711fff93e7177ecf74436844.png" alt></p><h2 id="Java8-HashMap">Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>来一张图简单示意一下吧：</p><p><img src="/attachment%5C46d8f27734298c8228231f63d3948780.png" alt></p><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="数组扩容">数组扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><h3 id="get-过程分析">get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ul><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等( = = 或equals)的 key</li></ul><h3 id="HashSet">HashSet</h3><p>前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】PriorityQueue</title>
      <link href="/java/java-ji-he/java-ji-he-priorityqueue/"/>
      <url>/java/java-ji-he/java-ji-he-priorityqueue/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】PriorityQueue</h1><h2 id="Metadata-35">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】PriorityQueuedate: 2022-12-14 14:25tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: PriorityQueue</code></pre><h2 id="概述-4">概述</h2><p>前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><p>Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为PriorityQueue的底层实现。</p><p><img src="/attachment%5C312394fa06a43080329f9f1fafa64962.png" alt></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:</p><ul><li><code>leftNo = parentNo*2+1</code></li><li><code>rightNo = parentNo*2+2</code></li><li><code>parentNo = (nodeNo-1)/2</code></li></ul><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p>PriorityQueue的<code>peek()</code>和<code>element</code>操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。</p><h2 id="方法剖析-4">方法剖析</h2><h3 id="add-和offer">add()和offer()</h3><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。</p><p><img src="/attachment%5C4d6d38c41256871b2dc7aaff20f458c9.png" alt></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素x并维持堆的特性。</p><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为 : <strong>从k指定的位置开始，将<code>x</code>逐层与当前点的parent进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong> 。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h3 id="element-和peek">element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p><p><img src="/attachment%5C659365dc4d6a29fc83e2ca41681c0958.png" alt></p><h3 id="remove-和poll">remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/attachment%5C824b6d4b5dd97fa012eb0331473a4b30.png" alt></p><h3 id="remove-Object-o">remove(Object o)</h3><p><code>remove(Object o)</code>方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况:</p><ol><li>删除的是最后一个元素。直接删除即可，不需要调整。</li><li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</li></ol><p><img src="/attachment%5C59bbb3fa3b3e9145fb9ad09faa16a7dc.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】PriorityQueue</title>
      <link href="/language/java/java-ji-he/java-ji-he-priorityqueue/"/>
      <url>/language/java/java-ji-he/java-ji-he-priorityqueue/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】PriorityQueue</h1><h2 id="Metadata-68">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】PriorityQueuedate: 2022-12-14 14:25tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: PriorityQueue</code></pre><h2 id="概述-5">概述</h2><p>前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><p>Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为PriorityQueue的底层实现。</p><p><img src="/attachment%5C312394fa06a43080329f9f1fafa64962.png" alt></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:</p><ul><li><code>leftNo = parentNo*2+1</code></li><li><code>rightNo = parentNo*2+2</code></li><li><code>parentNo = (nodeNo-1)/2</code></li></ul><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p>PriorityQueue的<code>peek()</code>和<code>element</code>操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。</p><h2 id="方法剖析-4">方法剖析</h2><h3 id="add-和offer">add()和offer()</h3><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。</p><p><img src="/attachment%5C4d6d38c41256871b2dc7aaff20f458c9.png" alt></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素x并维持堆的特性。</p><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为 : <strong>从k指定的位置开始，将<code>x</code>逐层与当前点的parent进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong> 。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h3 id="element-和peek">element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p><p><img src="/attachment%5C659365dc4d6a29fc83e2ca41681c0958.png" alt></p><h3 id="remove-和poll">remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/attachment%5C824b6d4b5dd97fa012eb0331473a4b30.png" alt></p><h3 id="remove-Object-o">remove(Object o)</h3><p><code>remove(Object o)</code>方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况:</p><ol><li>删除的是最后一个元素。直接删除即可，不需要调整。</li><li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</li></ol><p><img src="/attachment%5C59bbb3fa3b3e9145fb9ad09faa16a7dc.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 Stack&amp;Queue</title>
      <link href="/java/java-ji-he/java-ji-he-stack-queue/"/>
      <url>/java/java-ji-he/java-ji-he-stack-queue/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 Stack&amp;Queue</h1><h2 id="Metadata-32">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 Stack&amp;Queuedate: 2022-12-14 14:24tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: Stack&amp;Queue</code></pre><h2 id="Stack-Queue概述">Stack &amp; Queue概述</h2><p>Java里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。</p><h2 id="Queue">Queue</h2><p>Queue接口继承自Collection接口，除了最基本的<code>Collection</code>的方法之外，它还支持额外的<code>insertion</code>, <code>extraction</code>和<code>inspection</code>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td></tr><tr><td>Remove</td><td>remove()</td></tr><tr><td>Examine</td><td>element()</td></tr></tbody></table><h2 id="Deque">Deque</h2><p><code>Deque</code>是"<code>double ended queue</code>", 表示双向的队列，英文读作"deck". Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p><table><thead><tr><th>First Element - Head</th><th>Last Element - Tail</th></tr></thead><tbody><tr><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td></tr><tr><td>Examine</td><td>getFirst()</td></tr></tbody></table><p>当把<code>Deque</code>当做<code>FIFO</code>的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下:</p><p>Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td><td>向队尾插入元素，失败则返回false</td></tr><tr><td>remove()</td><td>removeFirst()</td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td>poll()</td><td>pollFirst()</td><td>获取并删除队首元素，失败则返回null</td></tr><tr><td>element()</td><td>getFirst()</td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除队首元素，失败则返回null</td></tr></tbody></table><p>下表列出了Deque与Stack对应的接口:</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td>offerFirst(e)</td><td>向栈顶插入元素，失败则返回false</td></tr><tr><td>pop()</td><td>removeFirst()</td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>pollFirst()</td><td>获取并删除栈顶元素，失败则返回null</td></tr><tr><td>peek()</td><td>getFirst()</td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则返回null</td></tr></tbody></table><p>上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。</p><p>ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。</p><p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p><img src="/attachment%5C08d0890337e4677367a3599ba968166b.png" alt></p><p>上图中我们看到，<code>head</code> <strong>指向首端第一个有效元素</strong>，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><h2 id="方法剖析-3">方法剖析</h2><h3 id="addFirst">addFirst()</h3><p><code>addFirst(E e)</code> 的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[–head] = e即可。</p><p><img src="/attachment%5C978a80c9de15f7d5c8f028867fb3ee9f.png" alt></p><p>实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。</p><pre><code class="language-java">//addFirst(E e)public void addFirst(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界    if (head == tail)//1.空间是否够用        doubleCapacity();//扩容}</code></pre><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。</p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p><p><img src="/attachment%5C06c965f8d110aa684fc6e289c3b0ff97.png" alt></p><p>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><pre><code class="language-java">//doubleCapacity()private void doubleCapacity() {    assert head == tail;    int p = head;    int n = elements.length;    int r = n - p; // head右边元素的个数    int newCapacity = n &lt;&lt; 1;//原空间的2倍    if (newCapacity &lt; 0)        throw new IllegalStateException("Sorry, deque too big");    Object[] a = new Object[newCapacity];    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分    elements = (E[])a;    head = 0;    tail = n;}</code></pre><h3 id="addLast">addLast()</h3><p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。</p><p><img src="/attachment%5Cb46ab44c8c54c0ab4dcaf88edb518eb7.png" alt></p><pre><code class="language-java">public void addLast(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[tail] = e;//赋值    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理        doubleCapacity();//扩容}</code></pre><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h3 id="pollFirst">pollFirst()</h3><p><code>pollFirst()</code>的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当<code>elements[head] == null</code>时，意味着容器为空。</p><pre><code class="language-java">public E pollFirst() {    E result = elements[head];    if (result == null)//null值意味着deque为空        return null;    elements[h] = null;//let GC work    head = (head + 1) &amp; (elements.length - 1);//下标越界处理    return result;}</code></pre><h3 id="pollLast">pollLast()</h3><p>pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="language-java">public E pollLast() {    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素    E result = elements[t];    if (result == null)//null值意味着deque为空        return null;    elements[t] = null;//let GC work    tail = t;    return result;}</code></pre><h3 id="peekFirst">peekFirst()</h3><p><code>peekFirst()</code>的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回<code>elements[head]</code>即可。</p><h3 id="peekLast">peekLast()</h3><p><code>peekLast()</code>的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="language-java">public E peekLast() {    return elements[(tail - 1) &amp; (elements.length - 1)];} </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 Stack&amp;Queue</title>
      <link href="/language/java/java-ji-he/java-ji-he-stack-queue/"/>
      <url>/language/java/java-ji-he/java-ji-he-stack-queue/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 Stack&amp;Queue</h1><h2 id="Metadata-64">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 Stack&amp;Queuedate: 2022-12-14 14:24tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: Stack&amp;Queue</code></pre><h2 id="Stack-Queue概述">Stack &amp; Queue概述</h2><p>Java里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。</p><h2 id="Queue">Queue</h2><p>Queue接口继承自Collection接口，除了最基本的<code>Collection</code>的方法之外，它还支持额外的<code>insertion</code>, <code>extraction</code>和<code>inspection</code>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td></tr><tr><td>Remove</td><td>remove()</td></tr><tr><td>Examine</td><td>element()</td></tr></tbody></table><h2 id="Deque">Deque</h2><p><code>Deque</code>是"<code>double ended queue</code>", 表示双向的队列，英文读作"deck". Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p><table><thead><tr><th>First Element - Head</th><th>Last Element - Tail</th></tr></thead><tbody><tr><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td></tr><tr><td>Examine</td><td>getFirst()</td></tr></tbody></table><p>当把<code>Deque</code>当做<code>FIFO</code>的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下:</p><p>Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td><td>向队尾插入元素，失败则返回false</td></tr><tr><td>remove()</td><td>removeFirst()</td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td>poll()</td><td>pollFirst()</td><td>获取并删除队首元素，失败则返回null</td></tr><tr><td>element()</td><td>getFirst()</td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除队首元素，失败则返回null</td></tr></tbody></table><p>下表列出了Deque与Stack对应的接口:</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td>offerFirst(e)</td><td>向栈顶插入元素，失败则返回false</td></tr><tr><td>pop()</td><td>removeFirst()</td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>pollFirst()</td><td>获取并删除栈顶元素，失败则返回null</td></tr><tr><td>peek()</td><td>getFirst()</td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则返回null</td></tr></tbody></table><p>上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。</p><p>ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。</p><p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p><img src="/attachment%5C08d0890337e4677367a3599ba968166b.png" alt></p><p>上图中我们看到，<code>head</code> <strong>指向首端第一个有效元素</strong>，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><h2 id="方法剖析-2">方法剖析</h2><h3 id="addFirst">addFirst()</h3><p><code>addFirst(E e)</code> 的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[–head] = e即可。</p><p><img src="/attachment%5C978a80c9de15f7d5c8f028867fb3ee9f.png" alt></p><p>实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。</p><pre><code class="language-java">//addFirst(E e)public void addFirst(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界    if (head == tail)//1.空间是否够用        doubleCapacity();//扩容}</code></pre><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。</p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p><p><img src="/attachment%5C06c965f8d110aa684fc6e289c3b0ff97.png" alt></p><p>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><pre><code class="language-java">//doubleCapacity()private void doubleCapacity() {    assert head == tail;    int p = head;    int n = elements.length;    int r = n - p; // head右边元素的个数    int newCapacity = n &lt;&lt; 1;//原空间的2倍    if (newCapacity &lt; 0)        throw new IllegalStateException("Sorry, deque too big");    Object[] a = new Object[newCapacity];    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分    elements = (E[])a;    head = 0;    tail = n;}</code></pre><h3 id="addLast">addLast()</h3><p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。</p><p><img src="/attachment%5Cb46ab44c8c54c0ab4dcaf88edb518eb7.png" alt></p><pre><code class="language-java">public void addLast(E e) {    if (e == null)//不允许放入null        throw new NullPointerException();    elements[tail] = e;//赋值    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理        doubleCapacity();//扩容}</code></pre><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h3 id="pollFirst">pollFirst()</h3><p><code>pollFirst()</code>的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当<code>elements[head] == null</code>时，意味着容器为空。</p><pre><code class="language-java">public E pollFirst() {    E result = elements[head];    if (result == null)//null值意味着deque为空        return null;    elements[h] = null;//let GC work    head = (head + 1) &amp; (elements.length - 1);//下标越界处理    return result;}</code></pre><h3 id="pollLast">pollLast()</h3><p>pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="language-java">public E pollLast() {    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素    E result = elements[t];    if (result == null)//null值意味着deque为空        return null;    elements[t] = null;//let GC work    tail = t;    return result;}</code></pre><h3 id="peekFirst">peekFirst()</h3><p><code>peekFirst()</code>的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回<code>elements[head]</code>即可。</p><h3 id="peekLast">peekLast()</h3><p><code>peekLast()</code>的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。</p><pre><code class="language-java">public E peekLast() {    return elements[(tail - 1) &amp; (elements.length - 1)];} </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedList</title>
      <link href="/java/java-ji-he/java-ji-he-linkedlist/"/>
      <url>/java/java-ji-he/java-ji-he-linkedlist/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 LinkedList</h1><h2 id="Metadata-29">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 LinkedListdate: 2022-12-14 14:23tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedList</code></pre><h2 id="概述-3">概述</h2><p>LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类(它是个接口名字)。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。</p><p><img src="/attachment%5C68cde8f6127c75943241f2fec6f1fb9b.png" alt></p><p>LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。</p><h2 id="LinkedLists实现">LinkedLists实现</h2><h3 id="底层数据结构-2">底层数据结构</h3><p>LinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，而将Queue和Stack以及Deque相关的知识放在下一节讲。双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。</p><pre><code class="language-java">    transient int size = 0;    /**     * Pointer to first node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (first.prev == null &amp;&amp; first.item != null)     */    transient Node&lt;E&gt; first;    /**     * Pointer to last node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     */    transient Node&lt;E&gt; last;</code></pre><p>其中Node是私有的内部类:</p><pre><code class="language-java">    private static class Node&lt;E&gt; {        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {            this.item = element;            this.next = next;            this.prev = prev;        }    }</code></pre><h3 id="构造函数">构造函数</h3><pre><code class="language-java">    /**     * Constructs an empty list.     */    public LinkedList() {    }    /**     * Constructs a list containing the elements of the specified     * collection, in the order they are returned by the collection's     * iterator.     *     * @param  c the collection whose elements are to be placed into this list     * @throws NullPointerException if the specified collection is null     */    public LinkedList(Collection&lt;? extends E&gt; c) {        this();        addAll(c);    }</code></pre><h3 id="getFirst-getLast">getFirst(), getLast()</h3><p>获取第一个元素， 和获取最后一个元素:</p><pre><code class="language-java">    /**     * Returns the first element in this list.     *     * @return the first element in this list     * @throws NoSuchElementException if this list is empty     */    public E getFirst() {        final Node&lt;E&gt; f = first;        if (f == null)            throw new NoSuchElementException();        return f.item;    }    /**     * Returns the last element in this list.     *     * @return the last element in this list     * @throws NoSuchElementException if this list is empty     */    public E getLast() {        final Node&lt;E&gt; l = last;        if (l == null)            throw new NoSuchElementException();        return l.item;    }</code></pre><h3 id="removeFirst-removeLast-remove-e-remove-index">removeFirst(), removeLast(), remove(e), remove(index)</h3><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><img src="/attachment%5Cb190f02840a986ee73942dda0f3e37b8.png" alt></p><p>删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p><p><code>remove(int index)</code>使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。</p><h3 id="add">add()</h3><p><code>add()</code>方法有两个版本，一个是<code>add(E e)</code>，该方法在<code>LinkedList</code>的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><p><img src="/attachment%5Cdfc813989f550f643c970e9dcfd90051.png" alt></p><p><code>add(int index, E element)</code>, 当<code>index==size</code>时，等同于<code>add(E e)</code>; 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p><p>上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</p><h3 id="addAll">addAll()</h3><p>addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p><h3 id="clear">clear()</h3><p>为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。</p><h3 id="Positional-Access-方法">Positional Access 方法</h3><p>通过index获取元素</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 LinkedList</title>
      <link href="/language/java/java-ji-he/java-ji-he-linkedlist/"/>
      <url>/language/java/java-ji-he/java-ji-he-linkedlist/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 LinkedList</h1><h2 id="Metadata-63">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 LinkedListdate: 2022-12-14 14:23tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: LinkedList</code></pre><h2 id="概述-3">概述</h2><p>LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类(它是个接口名字)。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。</p><p><img src="/attachment%5C68cde8f6127c75943241f2fec6f1fb9b.png" alt></p><p>LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。</p><h2 id="LinkedLists实现">LinkedLists实现</h2><h3 id="底层数据结构-2">底层数据结构</h3><p>LinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，而将Queue和Stack以及Deque相关的知识放在下一节讲。双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。</p><pre><code class="language-java">    transient int size = 0;    /**     * Pointer to first node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (first.prev == null &amp;&amp; first.item != null)     */    transient Node&lt;E&gt; first;    /**     * Pointer to last node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     */    transient Node&lt;E&gt; last;</code></pre><p>其中Node是私有的内部类:</p><pre><code class="language-java">    private static class Node&lt;E&gt; {        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {            this.item = element;            this.next = next;            this.prev = prev;        }    }</code></pre><h3 id="构造函数">构造函数</h3><pre><code class="language-java">    /**     * Constructs an empty list.     */    public LinkedList() {    }    /**     * Constructs a list containing the elements of the specified     * collection, in the order they are returned by the collection's     * iterator.     *     * @param  c the collection whose elements are to be placed into this list     * @throws NullPointerException if the specified collection is null     */    public LinkedList(Collection&lt;? extends E&gt; c) {        this();        addAll(c);    }</code></pre><h3 id="getFirst-getLast">getFirst(), getLast()</h3><p>获取第一个元素， 和获取最后一个元素:</p><pre><code class="language-java">    /**     * Returns the first element in this list.     *     * @return the first element in this list     * @throws NoSuchElementException if this list is empty     */    public E getFirst() {        final Node&lt;E&gt; f = first;        if (f == null)            throw new NoSuchElementException();        return f.item;    }    /**     * Returns the last element in this list.     *     * @return the last element in this list     * @throws NoSuchElementException if this list is empty     */    public E getLast() {        final Node&lt;E&gt; l = last;        if (l == null)            throw new NoSuchElementException();        return l.item;    }</code></pre><h3 id="removeFirst-removeLast-remove-e-remove-index">removeFirst(), removeLast(), remove(e), remove(index)</h3><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><img src="/attachment%5Cb190f02840a986ee73942dda0f3e37b8.png" alt></p><p>删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p><p><code>remove(int index)</code>使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。</p><h3 id="add">add()</h3><p><code>add()</code>方法有两个版本，一个是<code>add(E e)</code>，该方法在<code>LinkedList</code>的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><p><img src="/attachment%5Cdfc813989f550f643c970e9dcfd90051.png" alt></p><p><code>add(int index, E element)</code>, 当<code>index==size</code>时，等同于<code>add(E e)</code>; 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p><p>上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</p><h3 id="addAll">addAll()</h3><p>addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p><h3 id="clear">clear()</h3><p>为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。</p><h3 id="Positional-Access-方法">Positional Access 方法</h3><p>通过index获取元素</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/java/java-ji-he/java-ji-he/"/>
      <url>/java/java-ji-he/java-ji-he/</url>
      
        <content type="html"><![CDATA[<h1>Java 集合</h1><h2 id="Metadata-26">Metadata</h2><pre><code class="language-yml">title: Java 集合date: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 集合</code></pre><h2 id="Java-集合-2">Java 集合</h2><p><img src="/attachment%5C7727cae2e6a5956678ac0bbedc6748d6.png" alt></p><h2 id="【Java-集合】-ArrayList">【Java 集合】 ArrayList</h2><p><a href="../java-ji-he-arraylist">【Java 集合】 ArrayList</a></p><h2 id="【Java-集合】-LinkedList">【Java 集合】 LinkedList</h2><p><a href="../java-ji-he-linkedlist">【Java 集合】 LinkedList</a></p><h2 id="【Java-集合】-LinkedHashSet-Map">【Java 集合】 LinkedHashSet&amp;Map</h2><p><a href="../java-ji-he-linkedhashset-map">【Java 集合】 LinkedHashSet&amp;Map</a></p><h2 id="【Java-集合】-Stack-Queue">【Java 集合】 Stack&amp;Queue</h2><p><a href="../java-ji-he-stack-queue">【Java 集合】 Stack&amp;Queue</a></p><h2 id="【Java-集合】-TreeSet-TreeMap">【Java 集合】 TreeSet &amp; TreeMap</h2><p><a href="../java-ji-he-treeset-treemap">【Java 集合】 TreeSet &amp; TreeMap</a></p><h2 id="【Java-集合】-WeakHashMap">【Java 集合】 WeakHashMap</h2><p><a href="../java-ji-he-weakhashmap">【Java 集合】 WeakHashMap</a></p><h2 id="【Java-集合】PriorityQueue">【Java 集合】PriorityQueue</h2><p><a href="../java-ji-he-priorityqueue">【Java 集合】PriorityQueue</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 ArrayList</title>
      <link href="/java/java-ji-he/java-ji-he-arraylist/"/>
      <url>/java/java-ji-he/java-ji-he-arraylist/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 ArrayList</h1><h2 id="Metadata-27">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 ArrayListdate: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: 集合</code></pre><h2 id="概述-2">概述</h2><p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><p><img src="/attachment%5C8bcaee4d397913b246c1598cac55fea4.png" alt></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><h2 id="ArrayList的实现">ArrayList的实现</h2><h3 id="底层数据结构">底层数据结构</h3><pre><code class="language-java">/**     * The array buffer into which the elements of the ArrayList are stored.     * The capacity of the ArrayList is the length of this array buffer. Any     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA     * will be expanded to DEFAULT_CAPACITY when the first element is added.     */    transient Object[] elementData; // non-private to simplify nested class access    /**     * The size of the ArrayList (the number of elements it contains).     *     * @serial     */    private int size;</code></pre><h3 id="自动扩容">自动扩容</h3><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><pre><code class="language-ad-tip">当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。</code></pre><p><img src="/attachment%5C63ae74eaa7189b56a8ac2d7407e60a57.png" alt></p><h3 id="add-addAll">add(), addAll()</h3><p>跟C++ 的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。</p><p><img src="/attachment%5Ce68ac4bef1a5e34817cbd016daef64c8.png" alt></p><h3 id="set">set()</h3><p>既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。</p><h3 id="get">get()</h3><p>get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</p><h3 id="remove">remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。</p><h3 id="trimToSize">trimToSize()</h3><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。</p><h3 id="indexOf-lastIndexOf">indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index<br>获取元素的最后一次出现的index</p><h3 id="Fail-Fast机制">Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 集合】 ArrayList</title>
      <link href="/language/java/java-ji-he/java-ji-he-arraylist/"/>
      <url>/language/java/java-ji-he/java-ji-he-arraylist/</url>
      
        <content type="html"><![CDATA[<h1>【Java 集合】 ArrayList</h1><h2 id="Metadata-60">Metadata</h2><pre><code class="language-yml">title: 【Java 集合】 ArrayListdate: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/集合categories:  - Javakeywords:  - Java/集合description: 集合</code></pre><h2 id="概述-2">概述</h2><p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><p><img src="/attachment%5C8bcaee4d397913b246c1598cac55fea4.png" alt></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><h2 id="ArrayList的实现">ArrayList的实现</h2><h3 id="底层数据结构">底层数据结构</h3><pre><code class="language-java">/**     * The array buffer into which the elements of the ArrayList are stored.     * The capacity of the ArrayList is the length of this array buffer. Any     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA     * will be expanded to DEFAULT_CAPACITY when the first element is added.     */    transient Object[] elementData; // non-private to simplify nested class access    /**     * The size of the ArrayList (the number of elements it contains).     *     * @serial     */    private int size;</code></pre><h3 id="自动扩容">自动扩容</h3><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><pre><code class="language-ad-tip">当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。</code></pre><p><img src="/attachment%5C63ae74eaa7189b56a8ac2d7407e60a57.png" alt></p><h3 id="add-addAll">add(), addAll()</h3><p>跟C++ 的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。</p><p><img src="/attachment%5Ce68ac4bef1a5e34817cbd016daef64c8.png" alt></p><h3 id="set">set()</h3><p>既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。</p><h3 id="get">get()</h3><p>get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</p><h3 id="remove">remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。</p><h3 id="trimToSize">trimToSize()</h3><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。</p><h3 id="indexOf-lastIndexOf">indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index<br>获取元素的最后一次出现的index</p><h3 id="Fail-Fast机制">Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/language/java/java-ji-he/java-ji-he/"/>
      <url>/language/java/java-ji-he/java-ji-he/</url>
      
        <content type="html"><![CDATA[<h1>Java 集合</h1><h2 id="Metadata-61">Metadata</h2><pre><code class="language-yml">title: Java 集合date: 2022-12-14 14:21tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 集合</code></pre><h2 id="Java-集合-2">Java 集合</h2><p><img src="/attachment%5C7727cae2e6a5956678ac0bbedc6748d6.png" alt></p><h2 id="【Java-集合】-ArrayList">【Java 集合】 ArrayList</h2><p>undefined</p><h2 id="【Java-集合】-LinkedList">【Java 集合】 LinkedList</h2><p>undefined</p><h2 id="【Java-集合】-LinkedHashSet-Map">【Java 集合】 LinkedHashSet&amp;Map</h2><p>undefined</p><h2 id="【Java-集合】-Stack-Queue">【Java 集合】 Stack&amp;Queue</h2><p>undefined</p><h2 id="【Java-集合】-TreeSet-TreeMap">【Java 集合】 TreeSet &amp; TreeMap</h2><p>undefined</p><h2 id="【Java-集合】-WeakHashMap">【Java 集合】 WeakHashMap</h2><p>undefined</p><h2 id="【Java-集合】PriorityQueue">【Java 集合】PriorityQueue</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 注解</title>
      <link href="/java/java-ji-chu/java-ji-chu-zhu-jie/"/>
      <url>/java/java-ji-chu/java-ji-chu-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 注解</h1><h2 id="Metadata-23">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 注解date: 2022-12-14 14:13tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/注解categories:  - Javakeywords:  - Java/基础  - 注解description: 注解</code></pre><h2 id="作用">作用</h2><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="分类">分类</h2><ul><li><strong>Java自带的标准注解</strong>，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li><li><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li><li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li></ul><h3 id="内置注解">内置注解</h3><ul><li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li></ul><h4 id="Override">@Override</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li><strong>用来修饰方法</strong></li><li><strong>编译时有效</strong></li><li><strong>重写的父类的中的相同签名的方法</strong></li></ul><h4 id="Deprecated">@Deprecated</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {}</code></pre></div><ul><li>被文档化</li><li>保留到运行时</li><li>修饰构造方法、属性、局部变量、方法、包、参数、类型</li></ul><p>告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h4 id="SuppressWarnings">@SuppressWarnings</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings {    String[] value();}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li>修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量</li><li>只能存活在源码时</li><li>取值为<code>String[]</code></li></ul><p>告诉编译器忽略指定的警告信息</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing/unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table></div><h3 id="元注解">元注解</h3><h4 id="Target">@Target</h4><p><strong>作用</strong></p><p>描述注解的使用范围（即：被修饰的注解可以用在什么地方）</p><p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了<code>@Target</code> 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在<code>ElementType</code> 枚举中。</p><p><strong>ElementType</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum ElementType {<pre><code>TYPE, // 类、接口、枚举类FIELD, // 成员变量（包括：枚举常量）METHOD, // 成员方法PARAMETER, // 方法参数CONSTRUCTOR, // 构造方法LOCAL_VARIABLE, // 局部变量ANNOTATION_TYPE, // 注解类PACKAGE, // 可用于修饰：包TYPE_PARAMETER, // 类型参数，JDK 1.8 新增TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Retention-RetentionTarget">@Retention &amp; @RetentionTarget</h4><p><strong>作用</strong></p><p>描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。<br>用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在<code>RetentionPolicy</code>枚举中。</p><p><strong>RetentionPolicy</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum RetentionPolicy {<pre><code>SOURCE,    // 源文件保留CLASS,       // 编译期保留，默认值RUNTIME   // 运行期保留，可通过反射去获取注解信息</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Documented">@Documented</h4><p><strong>作用</strong></p><p>描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p><h4 id="Inherited">@Inherited</h4><p><strong>作用</strong></p><p>被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p><h4 id="Repeatable">@Repeatable</h4><p><strong>作用</strong></p><p>重复注解 <code>ElementType.TYPE_USE</code></p><h4 id="Native">@Native</h4><p><strong>作用</strong></p><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p><h3 id="注解与反射接口">注解与反射接口</h3><p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。</p><ul><li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li></ul><p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p><p><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></p><p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p><ul><li><code>Annotation[] getAnnotations()</code></li></ul><p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p><ul><li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p><ul><li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p><ul><li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code></li></ul><p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p><h3 id="自定义注解">自定义注解</h3><ul><li></li></ul><h2 id="注解实现的原理">注解实现的原理</h2><h3 id="注解的本质">注解的本质</h3><p>注解是一个接口，一个继承自Annotation的接口。<br>里面每一个属性，其实就是接口的一个抽象方法。</p><p>这里推荐你两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li><li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li></ul><h2 id="注解的应用场景">注解的应用场景</h2><h3 id="配置化到注解化-框架的演进">配置化到注解化 - 框架的演进</h3><p>Spring 框架 配置化到注解化的转变。</p><h3 id="继承实现到注解实现-Junit3到Junit4">继承实现到注解实现 - Junit3到Junit4</h3><blockquote><p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p></blockquote><h3 id="自定义注解和AOP-通过切面实现解耦">自定义注解和AOP - 通过切面实现解耦</h3><ul><li>自定义Log注解</li><li>实现日志的切面, 对自定义注解Log作切点进行拦截</li></ul><h2 id="Tips">Tips</h2><h3 id="注解不支持继承">注解不支持继承</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 注解</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-zhu-jie/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 注解</h1><h2 id="Metadata-47">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 注解date: 2022-12-14 14:13tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/注解categories:  - Javakeywords:  - Java/基础  - 注解description: 注解</code></pre><h2 id="作用">作用</h2><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="分类">分类</h2><ul><li><strong>Java自带的标准注解</strong>，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li><li><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li><li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li></ul><h3 id="内置注解">内置注解</h3><ul><li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li></ul><h4 id="Override">@Override</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li><strong>用来修饰方法</strong></li><li><strong>编译时有效</strong></li><li><strong>重写的父类的中的相同签名的方法</strong></li></ul><h4 id="Deprecated">@Deprecated</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {}</code></pre></div><ul><li>被文档化</li><li>保留到运行时</li><li>修饰构造方法、属性、局部变量、方法、包、参数、类型</li></ul><p>告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h4 id="SuppressWarnings">@SuppressWarnings</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings {    String[] value();}</code><p><code class="language-java"></code></p></pre><p></p></div><ul><li>修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量</li><li>只能存活在源码时</li><li>取值为<code>String[]</code></li></ul><p>告诉编译器忽略指定的警告信息</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing/unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table></div><h3 id="元注解">元注解</h3><h4 id="Target">@Target</h4><p><strong>作用</strong></p><p>描述注解的使用范围（即：被修饰的注解可以用在什么地方）</p><p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了<code>@Target</code> 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在<code>ElementType</code> 枚举中。</p><p><strong>ElementType</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum ElementType {<pre><code>TYPE, // 类、接口、枚举类FIELD, // 成员变量（包括：枚举常量）METHOD, // 成员方法PARAMETER, // 方法参数CONSTRUCTOR, // 构造方法LOCAL_VARIABLE, // 局部变量ANNOTATION_TYPE, // 注解类PACKAGE, // 可用于修饰：包TYPE_PARAMETER, // 类型参数，JDK 1.8 新增TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Retention-RetentionTarget">@Retention &amp; @RetentionTarget</h4><p><strong>作用</strong></p><p>描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。<br>用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在<code>RetentionPolicy</code>枚举中。</p><p><strong>RetentionPolicy</strong></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public enum RetentionPolicy {<pre><code>SOURCE,    // 源文件保留CLASS,       // 编译期保留，默认值RUNTIME   // 运行期保留，可通过反射去获取注解信息</code></pre><p>}</p></code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="Documented">@Documented</h4><p><strong>作用</strong></p><p>描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p><h4 id="Inherited">@Inherited</h4><p><strong>作用</strong></p><p>被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p><h4 id="Repeatable">@Repeatable</h4><p><strong>作用</strong></p><p>重复注解 <code>ElementType.TYPE_USE</code></p><h4 id="Native">@Native</h4><p><strong>作用</strong></p><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p><h3 id="注解与反射接口">注解与反射接口</h3><p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。</p><ul><li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li></ul><p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p><p><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></p><p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p><ul><li><code>Annotation[] getAnnotations()</code></li></ul><p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p><ul><li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p><ul><li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p><ul><li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code></li></ul><p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p><h3 id="自定义注解">自定义注解</h3><ul><li></li></ul><h2 id="注解实现的原理">注解实现的原理</h2><h3 id="注解的本质">注解的本质</h3><p>注解是一个接口，一个继承自Annotation的接口。<br>里面每一个属性，其实就是接口的一个抽象方法。</p><p>这里推荐你两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li><li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li></ul><h2 id="注解的应用场景">注解的应用场景</h2><h3 id="配置化到注解化-框架的演进">配置化到注解化 - 框架的演进</h3><p>Spring 框架 配置化到注解化的转变。</p><h3 id="继承实现到注解实现-Junit3到Junit4">继承实现到注解实现 - Junit3到Junit4</h3><blockquote><p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p></blockquote><h3 id="自定义注解和AOP-通过切面实现解耦">自定义注解和AOP - 通过切面实现解耦</h3><ul><li>自定义Log注解</li><li>实现日志的切面, 对自定义注解Log作切点进行拦截</li></ul><h2 id="Tips">Tips</h2><h3 id="注解不支持继承">注解不支持继承</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 泛型</title>
      <link href="/java/java-ji-chu/java-ji-chu-fan-xing/"/>
      <url>/java/java-ji-chu/java-ji-chu-fan-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 泛型</h1><h2 id="Metadata-22">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 泛型date: 2022-12-14 14:12tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/泛型categories:  - Javakeywords:  - Java/基础  - 泛型description: 泛型</code></pre><h2 id="描述-2">描述</h2><p>泛型的本质是为了参数化类型。</p><ul><li>适用于多种数据类型执行相同的代码（代码复用）</li><li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li></ul><h2 id="泛型的基本使用">泛型的基本使用</h2><h3 id="泛型类">泛型类</h3><h3 id="泛型接口">泛型接口</h3><h3 id="泛型方法">泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p><p>定义泛型方法语法格式</p><p><img src="/attachment%5Cddcdc6a539768f8dc7017062098af3bb.png" alt></p><ul><li>调用泛型方法语法格式</li></ul><p><img src="/attachment%5Cef4e9cc951e4f6e085f5e62fd0156c58.png" alt></p><h3 id="泛型数组">泛型数组</h3><ul><li></li></ul><h3 id="小结">小结</h3><pre><code class="language-java">&lt;?&gt; 无限制通配符&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类// 使用原则《Effictive Java》// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限1. 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;2. 如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 泛型</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-fan-xing/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-fan-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 泛型</h1><h2 id="Metadata-46">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 泛型date: 2022-12-14 14:12tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/泛型categories:  - Javakeywords:  - Java/基础  - 泛型description: 泛型</code></pre><h2 id="描述-2">描述</h2><p>泛型的本质是为了参数化类型。</p><ul><li>适用于多种数据类型执行相同的代码（代码复用）</li><li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li></ul><h2 id="泛型的基本使用">泛型的基本使用</h2><h3 id="泛型类">泛型类</h3><h3 id="泛型接口">泛型接口</h3><h3 id="泛型方法">泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p><p>定义泛型方法语法格式</p><p><img src="/attachment%5Cddcdc6a539768f8dc7017062098af3bb.png" alt></p><ul><li>调用泛型方法语法格式</li></ul><p><img src="/attachment%5Cef4e9cc951e4f6e085f5e62fd0156c58.png" alt></p><h3 id="泛型数组">泛型数组</h3><ul><li></li></ul><h3 id="小结-2">小结</h3><pre><code class="language-java">&lt;?&gt; 无限制通配符&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类// 使用原则《Effictive Java》// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限1. 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;2. 如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 异常</title>
      <link href="/java/java-ji-chu/java-ji-chu-yi-chang/"/>
      <url>/java/java-ji-chu/java-ji-chu-yi-chang/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 异常</h1><h2 id="Metadata-21">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 异常date: 2022-12-14 14:11tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/异常categories:  - Javakeywords:  - Java/基础  - 异常description: 异常</code></pre><h2 id="描述">描述</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:</p><ul><li>受检异常 : 需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li>非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><h2 id="异常基础">异常基础</h2><h3 id="异常关键字">异常关键字</h3><ul><li><code>try</code> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><code>catch</code> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><code>finally</code> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><code>throw</code> – 用于抛出异常。</li><li><code>throws</code> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h3 id="异常的申明-throws">异常的申明(throws)</h3><p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><h3 id="Throws抛出异常的规则">Throws抛出异常的规则</h3><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="异常的自定义">异常的自定义</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public class MyException extends Exception {    public MyException(){ }    public MyException(String msg){        super(msg);    }    // ...}</code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="异常的捕获">异常的捕获</h3><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h4 id="try-catch">try-catch</h4><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private static void readFile(String filePath) {    try {        // code    } catch (FileNotFoundException | UnknownHostException e) {        // handle FileNotFoundException or UnknownHostException    } catch (IOException e){        // handle IOException    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-catch-finally">try-catch-finally</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">try {                            //执行程序代码，可能会出现异常                 } catch(Exception e) {       //捕获异常并处理   } finally {    //必执行的代码}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-finally">try-finally</h4><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h4 id="try-with-resource">try-with-resource</h4><p>JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 <code>AutoCloseable</code> 接口的类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private  static void tryWithResourceTest(){    try (Scanner scanner = new Scanner(new FileInputStream("c:/abc"),"UTF-8")){        // code    } catch (IOException e){        // handle exception    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h2 id="异常的层次结构">异常的层次结构</h2><p>Java异常类层次结构图：</p><p><img src="/attachment%5C33441534b3f04acef0aca20b2b192abb.png" alt></p><h3 id="Throwable">Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h3 id="Error">Error</h3><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>此类错误一般表示代码运行时 JVM 出现问题。通常有 <code>Virtual MachineError</code>（虚拟机运行错误）、<code>NoClassDefFoundError</code>（类定义错误）等。比如 <code>OutOfMemoryError</code>：内存不足错误；<code>StackOverflowError</code>：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><h3 id="Exception-异常">Exception (异常)</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><h4 id="运行时异常">运行时异常</h4><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h4 id="非运行时异常-（编译异常）">非运行时异常 （编译异常）</h4><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）">可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</h3><h4 id="可查异常（编译器要求必须处置的异常）：">可查异常（编译器要求必须处置的异常）：</h4><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h4 id="不可查异常-编译器不要求强制处置的异常">不可查异常(编译器不要求强制处置的异常)</h4><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h2 id="注意点">注意点</h2><h3 id="尽量使用标准的异常">尽量使用标准的异常</h3><p>重用现有的异常有几个好处：</p><ul><li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li><li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li><li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li></ul><p>Java标准异常中有几个是经常被使用的异常。如下表格：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table></div><h3 id="对异常进行文档说明">对异常进行文档说明</h3><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p><p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><h3 id="优先捕获最具体的异常">优先捕获最具体的异常</h3><h3 id="不要捕获-Throwable-类">不要捕获 Throwable 类</h3><h3 id="不要忽略异常">不要忽略异常</h3><h3 id="不要记录并抛出异常">不要记录并抛出异常</h3><h3 id="包装异常时不要抛弃原始的异常">包装异常时不要抛弃原始的异常</h3><h3 id="不要使用异常控制程序的流程">不要使用异常控制程序的流程</h3><h3 id="不要在finally块中使用return">不要在finally块中使用return</h3><h2 id></h2><h2 id="总结-2">总结</h2><ul><li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li><li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li><li>finally语句块中的代码一定会被执行，常用于回收资源 。</li><li>throws：声明一个异常，告知方法调用者。</li><li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li></ul><p>Java编程思想一书中，对异常的总结。</p><ul><li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li><li>让类库和程序更安全。</li></ul><h2 id="常用的异常">常用的异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ul><li>RuntimeException<ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li>IOException<ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li>其他<ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 异常</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-yi-chang/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-yi-chang/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 异常</h1><h2 id="Metadata-44">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 异常date: 2022-12-14 14:11tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/异常categories:  - Javakeywords:  - Java/基础  - 异常description: 异常</code></pre><h2 id="描述">描述</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:</p><ul><li>受检异常 : 需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li>非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><h2 id="异常基础">异常基础</h2><h3 id="异常关键字">异常关键字</h3><ul><li><code>try</code> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><code>catch</code> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><code>finally</code> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><code>throw</code> – 用于抛出异常。</li><li><code>throws</code> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h3 id="异常的申明-throws">异常的申明(throws)</h3><p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><h3 id="Throws抛出异常的规则">Throws抛出异常的规则</h3><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="异常的自定义">异常的自定义</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">public class MyException extends Exception {    public MyException(){ }    public MyException(String msg){        super(msg);    }    // ...}</code><p><code class="language-java"></code></p></pre><p></p></div><h3 id="异常的捕获">异常的捕获</h3><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h4 id="try-catch">try-catch</h4><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private static void readFile(String filePath) {    try {        // code    } catch (FileNotFoundException | UnknownHostException e) {        // handle FileNotFoundException or UnknownHostException    } catch (IOException e){        // handle IOException    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-catch-finally">try-catch-finally</h4><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">try {                            //执行程序代码，可能会出现异常                 } catch(Exception e) {       //捕获异常并处理   } finally {    //必执行的代码}</code><p><code class="language-java"></code></p></pre><p></p></div><h4 id="try-finally">try-finally</h4><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h4 id="try-with-resource">try-with-resource</h4><p>JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 <code>AutoCloseable</code> 接口的类。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><pre><code class="language-java">private  static void tryWithResourceTest(){    try (Scanner scanner = new Scanner(new FileInputStream("c:/abc"),"UTF-8")){        // code    } catch (IOException e){        // handle exception    }}</code><p><code class="language-java"></code></p></pre><p></p></div><h2 id="异常的层次结构">异常的层次结构</h2><p>Java异常类层次结构图：</p><p><img src="/attachment%5C33441534b3f04acef0aca20b2b192abb.png" alt></p><h3 id="Throwable">Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h3 id="Error">Error</h3><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>此类错误一般表示代码运行时 JVM 出现问题。通常有 <code>Virtual MachineError</code>（虚拟机运行错误）、<code>NoClassDefFoundError</code>（类定义错误）等。比如 <code>OutOfMemoryError</code>：内存不足错误；<code>StackOverflowError</code>：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><h3 id="Exception-异常">Exception (异常)</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><h4 id="运行时异常">运行时异常</h4><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h4 id="非运行时异常-（编译异常）">非运行时异常 （编译异常）</h4><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）">可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</h3><h4 id="可查异常（编译器要求必须处置的异常）：">可查异常（编译器要求必须处置的异常）：</h4><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h4 id="不可查异常-编译器不要求强制处置的异常">不可查异常(编译器不要求强制处置的异常)</h4><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h2 id="注意点">注意点</h2><h3 id="尽量使用标准的异常">尽量使用标准的异常</h3><p>重用现有的异常有几个好处：</p><ul><li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li><li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li><li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li></ul><p>Java标准异常中有几个是经常被使用的异常。如下表格：</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table></div><h3 id="对异常进行文档说明">对异常进行文档说明</h3><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p><p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><h3 id="优先捕获最具体的异常">优先捕获最具体的异常</h3><h3 id="不要捕获-Throwable-类">不要捕获 Throwable 类</h3><h3 id="不要忽略异常">不要忽略异常</h3><h3 id="不要记录并抛出异常">不要记录并抛出异常</h3><h3 id="包装异常时不要抛弃原始的异常">包装异常时不要抛弃原始的异常</h3><h3 id="不要使用异常控制程序的流程">不要使用异常控制程序的流程</h3><h3 id="不要在finally块中使用return">不要在finally块中使用return</h3><h2 id></h2><h2 id="总结-2">总结</h2><ul><li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li><li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li><li>finally语句块中的代码一定会被执行，常用于回收资源 。</li><li>throws：声明一个异常，告知方法调用者。</li><li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li></ul><p>Java编程思想一书中，对异常的总结。</p><ul><li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li><li>让类库和程序更安全。</li></ul><h2 id="常用的异常">常用的异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ul><li>RuntimeException<ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li>IOException<ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li>其他<ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 反射</title>
      <link href="/java/java-ji-chu/java-ji-chu-fan-she/"/>
      <url>/java/java-ji-chu/java-ji-chu-fan-she/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 反射</h1><h2 id="Metadata-19">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 反射date: 2022-12-14 14:09tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/反射categories:  - Javakeywords:  - Java/基础  - 反射description: 反射</code></pre><h2 id="基础-2">基础</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:</p><ul><li>Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor : 可以用 Constructor 创建新的对象。</li></ul><h3 id="Class-类">Class 类</h3><p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p><ul><li>Class类也是类的一种，与class关键字是不一样的。</li><li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li><li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 反射</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-fan-she/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-fan-she/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 反射</h1><h2 id="Metadata-45">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 反射date: 2022-12-14 14:09tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/反射categories:  - Javakeywords:  - Java/基础  - 反射description: 反射</code></pre><h2 id="基础-2">基础</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:</p><ul><li>Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor : 可以用 Constructor 创建新的对象。</li></ul><h3 id="Class-类">Class 类</h3><p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p><ul><li>Class类也是类的一种，与class关键字是不一样的。</li><li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li><li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 面向对象</title>
      <link href="/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/"/>
      <url>/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 面向对象</h1><h2 id="Metadata-24">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 面向对象date: 2022-12-14 14:07tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/面向对象categories:  - Javakeywords:  - Java/基础  - 面向对象description: 面向对象</code></pre><h2 id="三大特性">三大特性</h2><h3 id="封装">封装</h3><p>利用抽象数据类型<mark style="background: #FF5582A6;">将数据和基于数据的操作封装在一起</mark>，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p><strong>优点:</strong></p><ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><h3 id="继承">继承</h3><p>继承实现了 <mark style="background: #FF5582A6;">IS-A 关系</mark>，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循<strong>里氏替换原则</strong>，<mark style="background: #FF5582A6;">子类对象必须能够替换掉所有父类对象</mark>。</p><h3 id="多态">多态</h3><p>多态分为编译时多态和运行时多态:</p><ul><li><strong>编译时多态</strong>主要指<mark style="background: #ABF7F7A6;">方法的重载</mark></li><li><strong>运行时多态</strong>指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><h2 id="类图">类图</h2><h3 id="泛化关系-Generalization">泛化关系 (Generalization)</h3><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE3NXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNzUgMjA3IiB3aWR0aD0iMTc1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE0IiB4PSIyMy41IiB5PSIyMi45OTUxIj5HZW5lcmFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgVmVoaWNhbC0tPjxnIGlkPSJlbGVtX1ZlaGljYWwiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iVmVoaWNhbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODEiIHg9IjQzIiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjU4IiBjeT0iNjAuMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik02MC45Njg4LDY1LjkzNzUgUTYwLjM5MDYsNjYuMjM0NCA1OS43NSw2Ni4zNzUgUTU5LjEwOTQsNjYuNTMxMyA1OC40MDYzLDY2LjUzMTMgUTU1LjkwNjMsNjYuNTMxMyA1NC41NzgxLDY0Ljg5MDYgUTUzLjI2NTYsNjMuMjM0NCA1My4yNjU2LDYwLjEwOTQgUTUzLjI2NTYsNTYuOTg0NCA1NC41NzgxLDU1LjMyODEgUTU1LjkwNjMsNTMuNjcxOSA1OC40MDYzLDUzLjY3MTkgUTU5LjEwOTQsNTMuNjcxOSA1OS43NSw1My44MjgxIFE2MC40MDYzLDUzLjk4NDQgNjAuOTY4OCw1NC4yODEzIEw2MC45Njg4LDU3IFE2MC4zNDM4LDU2LjQyMTkgNTkuNzUsNTYuMTU2MyBRNTkuMTU2Myw1NS44NzUgNTguNTMxMyw1NS44NzUgUTU3LjE4NzUsNTUuODc1IDU2LjUsNTYuOTUzMSBRNTUuODEyNSw1OC4wMTU2IDU1LjgxMjUsNjAuMTA5NCBRNTUuODEyNSw2Mi4yMDMxIDU2LjUsNjMuMjgxMyBRNTcuMTg3NSw2NC4zNDM4IDU4LjUzMTMsNjQuMzQzOCBRNTkuMTU2Myw2NC4zNDM4IDU5Ljc1LDY0LjA3ODEgUTYwLjM0MzgsNjMuNzk2OSA2MC45Njg4LDYzLjIxODggTDYwLjk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSI3MiIgeT0iNjUuMTQzNiI+VmVoaWNhbDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI0NCIgeDI9IjEyMyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iNDQiIHgyPSIxMjMiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgQ2FyLS0+PGcgaWQ9ImVsZW1fQ2FyIj48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IkNhciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNTUiIHg9IjciIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuOTY4OCwxNzMuOTM3NSBRMjQuMzkwNiwxNzQuMjM0NCAyMy43NSwxNzQuMzc1IFEyMy4xMDk0LDE3NC41MzEzIDIyLjQwNjMsMTc0LjUzMTMgUTE5LjkwNjMsMTc0LjUzMTMgMTguNTc4MSwxNzIuODkwNiBRMTcuMjY1NiwxNzEuMjM0NCAxNy4yNjU2LDE2OC4xMDk0IFExNy4yNjU2LDE2NC45ODQ0IDE4LjU3ODEsMTYzLjMyODEgUTE5LjkwNjMsMTYxLjY3MTkgMjIuNDA2MywxNjEuNjcxOSBRMjMuMTA5NCwxNjEuNjcxOSAyMy43NSwxNjEuODI4MSBRMjQuNDA2MywxNjEuOTg0NCAyNC45Njg4LDE2Mi4yODEzIEwyNC45Njg4LDE2NSBRMjQuMzQzOCwxNjQuNDIxOSAyMy43NSwxNjQuMTU2MyBRMjMuMTU2MywxNjMuODc1IDIyLjUzMTMsMTYzLjg3NSBRMjEuMTg3NSwxNjMuODc1IDIwLjUsMTY0Ljk1MzEgUTE5LjgxMjUsMTY2LjAxNTYgMTkuODEyNSwxNjguMTA5NCBRMTkuODEyNSwxNzAuMjAzMSAyMC41LDE3MS4yODEzIFEyMS4xODc1LDE3Mi4zNDM4IDIyLjUzMTMsMTcyLjM0MzggUTIzLjE1NjMsMTcyLjM0MzggMjMuNzUsMTcyLjA3ODEgUTI0LjM0MzgsMTcxLjc5NjkgMjQuOTY4OCwxNzEuMjE4OCBMMjQuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIzIiB4PSIzNiIgeT0iMTczLjE0MzYiPkNhcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNjEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjYxIiB5MT0iMTkyLjI5NjkiIHkyPSIxOTIuMjk2OSIvPjwvZz48IS0tY2xhc3MgVHJ1Y2stLT48ZyBpZD0iZWxlbV9UcnVjayI+PHJlY3QgY29kZUxpbmU9IjYiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJUcnVjayIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzEiIHg9Ijk3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMTIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTQuOTY4OCwxNzMuOTM3NSBRMTE0LjM5MDYsMTc0LjIzNDQgMTEzLjc1LDE3NC4zNzUgUTExMy4xMDk0LDE3NC41MzEzIDExMi40MDYzLDE3NC41MzEzIFExMDkuOTA2MywxNzQuNTMxMyAxMDguNTc4MSwxNzIuODkwNiBRMTA3LjI2NTYsMTcxLjIzNDQgMTA3LjI2NTYsMTY4LjEwOTQgUTEwNy4yNjU2LDE2NC45ODQ0IDEwOC41NzgxLDE2My4zMjgxIFExMDkuOTA2MywxNjEuNjcxOSAxMTIuNDA2MywxNjEuNjcxOSBRMTEzLjEwOTQsMTYxLjY3MTkgMTEzLjc1LDE2MS44MjgxIFExMTQuNDA2MywxNjEuOTg0NCAxMTQuOTY4OCwxNjIuMjgxMyBMMTE0Ljk2ODgsMTY1IFExMTQuMzQzOCwxNjQuNDIxOSAxMTMuNzUsMTY0LjE1NjMgUTExMy4xNTYzLDE2My44NzUgMTEyLjUzMTMsMTYzLjg3NSBRMTExLjE4NzUsMTYzLjg3NSAxMTAuNSwxNjQuOTUzMSBRMTA5LjgxMjUsMTY2LjAxNTYgMTA5LjgxMjUsMTY4LjEwOTQgUTEwOS44MTI1LDE3MC4yMDMxIDExMC41LDE3MS4yODEzIFExMTEuMTg3NSwxNzIuMzQzOCAxMTIuNTMxMywxNzIuMzQzOCBRMTEzLjE1NjMsMTcyLjM0MzggMTEzLjc1LDE3Mi4wNzgxIFExMTQuMzQzOCwxNzEuNzk2OSAxMTQuOTY4OCwxNzEuMjE4OCBMMTE0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzOSIgeD0iMTI2IiB5PSIxNzMuMTQzNiI+VHJ1Y2s8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgVmVoaWNhbCB0byBDYXItLT48ZyBpZD0ibGlua19WZWhpY2FsX0NhciI+PHBhdGggY29kZUxpbmU9IjgiIGQ9Ik02My43MiwxMTIuMDg2OSBDNTcuNCwxMjUuNzQ2OSA1MC42NSwxNDAuMzU2OSA0NS4yMywxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJWZWhpY2FsLWJhY2t0by1DYXIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iNTcuMzcsMTA5LjE0NjksNzIuMTEsOTMuOTM2OSw3MC4wNywxMTUuMDI2OSw1Ny4zNywxMDkuMTQ2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgVmVoaWNhbCB0byBUcnVjay0tPjxnIGlkPSJsaW5rX1ZlaGljYWxfVHJ1Y2siPjxwYXRoIGNvZGVMaW5lPSI5IiBkPSJNMTAzLjI4LDExMi4wODY5IEMxMDkuNiwxMjUuNzQ2OSAxMTYuMzUsMTQwLjM1NjkgMTIxLjc3LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9IlZlaGljYWwtYmFja3RvLVRydWNrIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijk2LjkzLDExNS4wMjY5LDk0Ljg5LDkzLjkzNjksMTA5LjYzLDEwOS4xNDY5LDk2LjkzLDExNS4wMjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNF9ESW9yQXBDY2lJWXA5cENfWnVhaEVJSW1rTFdYQnBTWENKaW8xeWZtSll3MmlhQUJJdjZta0JnWXFXYXNEaFl2TzVhSzBlV1cwXS0tPjwvZz48L3N2Zz4="><h3 id="实现关系-Realization">实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE1OXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNTkgMjA3IiB3aWR0aD0iMTU5cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODUiIHg9IjMwIiB5PSIyMi45OTUxIj5SZWFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgTW92ZUJlaGF2aW9yLS0+PGcgaWQ9ImVsZW1fTW92ZUJlaGF2aW9yIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTMxIiB4PSIxMS41IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI2LjUiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIyLjQyMTksNTYuMDYyNSBMMjIuNDIxOSw1My45MDYzIEwyOS44MTI1LDUzLjkwNjMgTDI5LjgxMjUsNTYuMDYyNSBMMjcuMzQzOCw1Ni4wNjI1IEwyNy4zNDM4LDY0LjE0MDYgTDI5LjgxMjUsNjQuMTQwNiBMMjkuODEyNSw2Ni4yOTY5IEwyMi40MjE5LDY2LjI5NjkgTDIyLjQyMTksNjQuMTQwNiBMMjQuODkwNiw2NC4xNDA2IEwyNC44OTA2LDU2LjA2MjUgTDIyLjQyMTksNTYuMDYyNSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBmb250LXN0eWxlPSJpdGFsaWMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9IjQwLjUiIHk9IjY1LjE0MzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMi41IiB4Mj0iMTQxLjUiIHkxPSI3Ni4yOTY5IiB5Mj0iNzYuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyLjUiIHgyPSIxNDEuNSIgeTE9Ijg0LjI5NjkiIHkyPSI4NC4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBGbHktLT48ZyBpZD0iZWxlbV9GbHkiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRmx5IiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI1MCIgeD0iNyIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNC45Njg4LDE3My45Mzc1IFEyNC4zOTA2LDE3NC4yMzQ0IDIzLjc1LDE3NC4zNzUgUTIzLjEwOTQsMTc0LjUzMTMgMjIuNDA2MywxNzQuNTMxMyBRMTkuOTA2MywxNzQuNTMxMyAxOC41NzgxLDE3Mi44OTA2IFExNy4yNjU2LDE3MS4yMzQ0IDE3LjI2NTYsMTY4LjEwOTQgUTE3LjI2NTYsMTY0Ljk4NDQgMTguNTc4MSwxNjMuMzI4MSBRMTkuOTA2MywxNjEuNjcxOSAyMi40MDYzLDE2MS42NzE5IFEyMy4xMDk0LDE2MS42NzE5IDIzLjc1LDE2MS44MjgxIFEyNC40MDYzLDE2MS45ODQ0IDI0Ljk2ODgsMTYyLjI4MTMgTDI0Ljk2ODgsMTY1IFEyNC4zNDM4LDE2NC40MjE5IDIzLjc1LDE2NC4xNTYzIFEyMy4xNTYzLDE2My44NzUgMjIuNTMxMywxNjMuODc1IFEyMS4xODc1LDE2My44NzUgMjAuNSwxNjQuOTUzMSBRMTkuODEyNSwxNjYuMDE1NiAxOS44MTI1LDE2OC4xMDk0IFExOS44MTI1LDE3MC4yMDMxIDIwLjUsMTcxLjI4MTMgUTIxLjE4NzUsMTcyLjM0MzggMjIuNTMxMywxNzIuMzQzOCBRMjMuMTU2MywxNzIuMzQzOCAyMy43NSwxNzIuMDc4MSBRMjQuMzQzOCwxNzEuNzk2OSAyNC45Njg4LDE3MS4yMTg4IEwyNC45Njg4LDE3My45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTgiIHg9IjM2IiB5PSIxNzMuMTQzNiI+Rmx5PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSI1NiIgeTE9IjE4NC4yOTY5IiB5Mj0iMTg0LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNTYiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBSdW4tLT48ZyBpZD0iZWxlbV9SdW4iPjxyZWN0IGNvZGVMaW5lPSI2IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iUnVuIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI2MCIgeD0iOTIiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEwNyIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEwOS45Njg4LDE3My45Mzc1IFExMDkuMzkwNiwxNzQuMjM0NCAxMDguNzUsMTc0LjM3NSBRMTA4LjEwOTQsMTc0LjUzMTMgMTA3LjQwNjMsMTc0LjUzMTMgUTEwNC45MDYzLDE3NC41MzEzIDEwMy41NzgxLDE3Mi44OTA2IFExMDIuMjY1NiwxNzEuMjM0NCAxMDIuMjY1NiwxNjguMTA5NCBRMTAyLjI2NTYsMTY0Ljk4NDQgMTAzLjU3ODEsMTYzLjMyODEgUTEwNC45MDYzLDE2MS42NzE5IDEwNy40MDYzLDE2MS42NzE5IFExMDguMTA5NCwxNjEuNjcxOSAxMDguNzUsMTYxLjgyODEgUTEwOS40MDYzLDE2MS45ODQ0IDEwOS45Njg4LDE2Mi4yODEzIEwxMDkuOTY4OCwxNjUgUTEwOS4zNDM4LDE2NC40MjE5IDEwOC43NSwxNjQuMTU2MyBRMTA4LjE1NjMsMTYzLjg3NSAxMDcuNTMxMywxNjMuODc1IFExMDYuMTg3NSwxNjMuODc1IDEwNS41LDE2NC45NTMxIFExMDQuODEyNSwxNjYuMDE1NiAxMDQuODEyNSwxNjguMTA5NCBRMTA0LjgxMjUsMTcwLjIwMzEgMTA1LjUsMTcxLjI4MTMgUTEwNi4xODc1LDE3Mi4zNDM4IDEwNy41MzEzLDE3Mi4zNDM4IFExMDguMTU2MywxNzIuMzQzOCAxMDguNzUsMTcyLjA3ODEgUTEwOS4zNDM4LDE3MS43OTY5IDEwOS45Njg4LDE3MS4yMTg4IEwxMDkuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSIxMjEiIHk9IjE3My4xNDM2Ij5SdW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgTW92ZUJlaGF2aW9yIHRvIEZseS0tPjxnIGlkPSJsaW5rX01vdmVCZWhhdmlvcl9GbHkiPjxwYXRoIGNvZGVMaW5lPSI4IiBkPSJNNTguODQsMTEyLjA4NjkgQzUzLjAzLDEyNS43NDY5IDQ2LjgzLDE0MC4zNTY5IDQxLjg1LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9Ik1vdmVCZWhhdmlvci1iYWNrdG8tRmx5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSI1Mi4yNywxMDkuNjI2OSw2Ni41Myw5My45NTY5LDY1LjE2LDExNS4wOTY5LDUyLjI3LDEwOS42MjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBNb3ZlQmVoYXZpb3IgdG8gUnVuLS0+PGcgaWQ9ImxpbmtfTW92ZUJlaGF2aW9yX1J1biI+PHBhdGggY29kZUxpbmU9IjkiIGQ9Ik05NS4xNiwxMTIuMDg2OSBDMTAwLjk3LDEyNS43NDY5IDEwNy4xNywxNDAuMzU2OSAxMTIuMTUsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iTW92ZUJlaGF2aW9yLWJhY2t0by1SdW4iIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijg4Ljg0LDExNS4wOTY5LDg3LjQ3LDkzLjk1NjksMTAxLjczLDEwOS42MjY5LDg4Ljg0LDExNS4wOTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkwyNGZEcENjaUlZcDlwQ19adWloQ0FxYWpJYWpDSmJObXBJekJUS2hESTJwQnAyX1lJaXY5QjJ2TVNDa2ZYQkEySWU1Z2FMS2VzREpld080TE84ZzI1MEMwXS0tPjwvZz48L3N2Zz4="><h3 id="聚合关系-Aggregation">聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM0MXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNDEgMjA3IiB3aWR0aD0iMzQxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTciIHg9IjExNSIgeT0iMjIuOTk1MSI+QWdncmVnYXRpb248L3RleHQ+PCEtLWNsYXNzIENvbXB1dGVyLS0+PGcgaWQ9ImVsZW1fQ29tcHV0ZXIiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcHV0ZXIiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEwMSIgeD0iMTI4IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjE0MyIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTQ1Ljk2ODgsNjUuOTM3NSBRMTQ1LjM5MDYsNjYuMjM0NCAxNDQuNzUsNjYuMzc1IFExNDQuMTA5NCw2Ni41MzEzIDE0My40MDYzLDY2LjUzMTMgUTE0MC45MDYzLDY2LjUzMTMgMTM5LjU3ODEsNjQuODkwNiBRMTM4LjI2NTYsNjMuMjM0NCAxMzguMjY1Niw2MC4xMDk0IFExMzguMjY1Niw1Ni45ODQ0IDEzOS41NzgxLDU1LjMyODEgUTE0MC45MDYzLDUzLjY3MTkgMTQzLjQwNjMsNTMuNjcxOSBRMTQ0LjEwOTQsNTMuNjcxOSAxNDQuNzUsNTMuODI4MSBRMTQ1LjQwNjMsNTMuOTg0NCAxNDUuOTY4OCw1NC4yODEzIEwxNDUuOTY4OCw1NyBRMTQ1LjM0MzgsNTYuNDIxOSAxNDQuNzUsNTYuMTU2MyBRMTQ0LjE1NjMsNTUuODc1IDE0My41MzEzLDU1Ljg3NSBRMTQyLjE4NzUsNTUuODc1IDE0MS41LDU2Ljk1MzEgUTE0MC44MTI1LDU4LjAxNTYgMTQwLjgxMjUsNjAuMTA5NCBRMTQwLjgxMjUsNjIuMjAzMSAxNDEuNSw2My4yODEzIFExNDIuMTg3NSw2NC4zNDM4IDE0My41MzEzLDY0LjM0MzggUTE0NC4xNTYzLDY0LjM0MzggMTQ0Ljc1LDY0LjA3ODEgUTE0NS4zNDM4LDYzLjc5NjkgMTQ1Ljk2ODgsNjMuMjE4OCBMMTQ1Ljk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSIxNTciIHk9IjY1LjE0MzYiPkNvbXB1dGVyPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyOSIgeDI9IjIyOCIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTI5IiB4Mj0iMjI4IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWNsYXNzIEtleWJvYXJkLS0+PGcgaWQ9ImVsZW1fS2V5Ym9hcmQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iS2V5Ym9hcmQiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijk3IiB4PSI3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsMTczLjkzNzUgUTI0LjM5MDYsMTc0LjIzNDQgMjMuNzUsMTc0LjM3NSBRMjMuMTA5NCwxNzQuNTMxMyAyMi40MDYzLDE3NC41MzEzIFExOS45MDYzLDE3NC41MzEzIDE4LjU3ODEsMTcyLjg5MDYgUTE3LjI2NTYsMTcxLjIzNDQgMTcuMjY1NiwxNjguMTA5NCBRMTcuMjY1NiwxNjQuOTg0NCAxOC41NzgxLDE2My4zMjgxIFExOS45MDYzLDE2MS42NzE5IDIyLjQwNjMsMTYxLjY3MTkgUTIzLjEwOTQsMTYxLjY3MTkgMjMuNzUsMTYxLjgyODEgUTI0LjQwNjMsMTYxLjk4NDQgMjQuOTY4OCwxNjIuMjgxMyBMMjQuOTY4OCwxNjUgUTI0LjM0MzgsMTY0LjQyMTkgMjMuNzUsMTY0LjE1NjMgUTIzLjE1NjMsMTYzLjg3NSAyMi41MzEzLDE2My44NzUgUTIxLjE4NzUsMTYzLjg3NSAyMC41LDE2NC45NTMxIFExOS44MTI1LDE2Ni4wMTU2IDE5LjgxMjUsMTY4LjEwOTQgUTE5LjgxMjUsMTcwLjIwMzEgMjAuNSwxNzEuMjgxMyBRMjEuMTg3NSwxNzIuMzQzOCAyMi41MzEzLDE3Mi4zNDM4IFEyMy4xNTYzLDE3Mi4zNDM4IDIzLjc1LDE3Mi4wNzgxIFEyNC4zNDM4LDE3MS43OTY5IDI0Ljk2ODgsMTcxLjIxODggTDI0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NSIgeD0iMzYiIHk9IjE3My4xNDM2Ij5LZXlib2FyZDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTAzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMDMiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBNb3VzZS0tPjxnIGlkPSJlbGVtX01vdXNlIj48cmVjdCBjb2RlTGluZT0iNiIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdXNlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI3OSIgeD0iMTM5IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxNTQiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xNTYuOTY4OCwxNzMuOTM3NSBRMTU2LjM5MDYsMTc0LjIzNDQgMTU1Ljc1LDE3NC4zNzUgUTE1NS4xMDk0LDE3NC41MzEzIDE1NC40MDYzLDE3NC41MzEzIFExNTEuOTA2MywxNzQuNTMxMyAxNTAuNTc4MSwxNzIuODkwNiBRMTQ5LjI2NTYsMTcxLjIzNDQgMTQ5LjI2NTYsMTY4LjEwOTQgUTE0OS4yNjU2LDE2NC45ODQ0IDE1MC41NzgxLDE2My4zMjgxIFExNTEuOTA2MywxNjEuNjcxOSAxNTQuNDA2MywxNjEuNjcxOSBRMTU1LjEwOTQsMTYxLjY3MTkgMTU1Ljc1LDE2MS44MjgxIFExNTYuNDA2MywxNjEuOTg0NCAxNTYuOTY4OCwxNjIuMjgxMyBMMTU2Ljk2ODgsMTY1IFExNTYuMzQzOCwxNjQuNDIxOSAxNTUuNzUsMTY0LjE1NjMgUTE1NS4xNTYzLDE2My44NzUgMTU0LjUzMTMsMTYzLjg3NSBRMTUzLjE4NzUsMTYzLjg3NSAxNTIuNSwxNjQuOTUzMSBRMTUxLjgxMjUsMTY2LjAxNTYgMTUxLjgxMjUsMTY4LjEwOTQgUTE1MS44MTI1LDE3MC4yMDMxIDE1Mi41LDE3MS4yODEzIFExNTMuMTg3NSwxNzIuMzQzOCAxNTQuNTMxMywxNzIuMzQzOCBRMTU1LjE1NjMsMTcyLjM0MzggMTU1Ljc1LDE3Mi4wNzgxIFExNTYuMzQzOCwxNzEuNzk2OSAxNTYuOTY4OCwxNzEuMjE4OCBMMTU2Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0NyIgeD0iMTY4IiB5PSIxNzMuMTQzNiI+TW91c2U8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTQwIiB4Mj0iMjE3IiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE0MCIgeDI9IjIxNyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLWNsYXNzIFNjcmVlbi0tPjxnIGlkPSJlbGVtX1NjcmVlbiI+PHJlY3QgY29kZUxpbmU9IjciIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJTY3JlZW4iIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjgxIiB4PSIyNTMiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI2OCIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI3MC45Njg4LDE3My45Mzc1IFEyNzAuMzkwNiwxNzQuMjM0NCAyNjkuNzUsMTc0LjM3NSBRMjY5LjEwOTQsMTc0LjUzMTMgMjY4LjQwNjMsMTc0LjUzMTMgUTI2NS45MDYzLDE3NC41MzEzIDI2NC41NzgxLDE3Mi44OTA2IFEyNjMuMjY1NiwxNzEuMjM0NCAyNjMuMjY1NiwxNjguMTA5NCBRMjYzLjI2NTYsMTY0Ljk4NDQgMjY0LjU3ODEsMTYzLjMyODEgUTI2NS45MDYzLDE2MS42NzE5IDI2OC40MDYzLDE2MS42NzE5IFEyNjkuMTA5NCwxNjEuNjcxOSAyNjkuNzUsMTYxLjgyODEgUTI3MC40MDYzLDE2MS45ODQ0IDI3MC45Njg4LDE2Mi4yODEzIEwyNzAuOTY4OCwxNjUgUTI3MC4zNDM4LDE2NC40MjE5IDI2OS43NSwxNjQuMTU2MyBRMjY5LjE1NjMsMTYzLjg3NSAyNjguNTMxMywxNjMuODc1IFEyNjcuMTg3NSwxNjMuODc1IDI2Ni41LDE2NC45NTMxIFEyNjUuODEyNSwxNjYuMDE1NiAyNjUuODEyNSwxNjguMTA5NCBRMjY1LjgxMjUsMTcwLjIwMzEgMjY2LjUsMTcxLjI4MTMgUTI2Ny4xODc1LDE3Mi4zNDM4IDI2OC41MzEzLDE3Mi4zNDM4IFEyNjkuMTU2MywxNzIuMzQzOCAyNjkuNzUsMTcyLjA3ODEgUTI3MC4zNDM4LDE3MS43OTY5IDI3MC45Njg4LDE3MS4yMTg4IEwyNzAuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSIyODIiIHk9IjE3My4xNDM2Ij5TY3JlZW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMjU0IiB4Mj0iMzMzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjI1NCIgeDI9IjMzMyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBLZXlib2FyZC0tPjxnIGlkPSJsaW5rX0NvbXB1dGVyX0tleWJvYXJkIj48cGF0aCBjb2RlTGluZT0iOSIgZD0iTTE0MC42LDEwMS45NTY5IEMxMjEuNzgsMTE4LjE3NjkgOTkuNDgsMTM3LjM5NjkgODIuNDMsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLUtleWJvYXJkIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9IjE1MC4zNiw5My41NDY5LDE0My4yMDM4LDk0LjQzNTEsMTQxLjI3MTMsMTAxLjM4MjQsMTQ4LjQyNzUsMTAwLjQ5NDIsMTUwLjM2LDkzLjU0NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tcmV2ZXJzZSBsaW5rIENvbXB1dGVyIHRvIE1vdXNlLS0+PGcgaWQ9ImxpbmtfQ29tcHV0ZXJfTW91c2UiPjxwYXRoIGNvZGVMaW5lPSIxMCIgZD0iTTE3OC41LDEwNi44MzY5IEMxNzguNSwxMjEuOTI2OSAxNzguNSwxMzguODQ2OSAxNzguNSwxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJDb21wdXRlci1iYWNrdG8tTW91c2UiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iMTc4LjUsOTQuMDc2OSwxNzQuNSwxMDAuMDc2OSwxNzguNSwxMDYuMDc2OSwxODIuNSwxMDAuMDc2OSwxNzguNSw5NC4wNzY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBTY3JlZW4tLT48ZyBpZD0ibGlua19Db21wdXRlcl9TY3JlZW4iPjxwYXRoIGNvZGVMaW5lPSIxMSIgZD0iTTIxNC4xOCwxMDIuMTg2OSBDMjMxLjczLDExOC4zNTY5IDI1Mi40NiwxMzcuNDY2OSAyNjguMzIsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLVNjcmVlbiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIyMDQuODUsOTMuNTg2OSwyMDYuNTU0NCwxMDAuNTkzNywyMTMuNjc3OCwxMDEuNzE1MywyMTEuOTczMyw5NC43MDg1LDIwNC44NSw5My41ODY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNG5GQnFmREpvcDlwQ19adWFoRUlJbWtMZDNFcG9xZUJLYWpXZEF6S29rSnlYRUJLZzFTdF9wSXViR2VFcFl2QTNLTGcwLWNHbzVWTG5VWDdhS0tlV3I1MkFlUjAwMDBdLS0+PC9nPjwvc3ZnPg=="><h3 id="组合关系-Composition">组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjI5OHB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyOTggMjA3IiB3aWR0aD0iMjk4cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTgiIHg9IjkzLjI1IiB5PSIyMi45OTUxIj5Db21wb3NpdGlvbjwvdGV4dD48IS0tY2xhc3MgQ29tcGFueS0tPjxnIGlkPSJlbGVtX0NvbXBhbnkiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcGFueSIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iOTciIHg9IjEwMC41IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjExNS41IiBjeT0iNjAuMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTguNDY4OCw2NS45Mzc1IFExMTcuODkwNiw2Ni4yMzQ0IDExNy4yNSw2Ni4zNzUgUTExNi42MDk0LDY2LjUzMTMgMTE1LjkwNjMsNjYuNTMxMyBRMTEzLjQwNjMsNjYuNTMxMyAxMTIuMDc4MSw2NC44OTA2IFExMTAuNzY1Niw2My4yMzQ0IDExMC43NjU2LDYwLjEwOTQgUTExMC43NjU2LDU2Ljk4NDQgMTEyLjA3ODEsNTUuMzI4MSBRMTEzLjQwNjMsNTMuNjcxOSAxMTUuOTA2Myw1My42NzE5IFExMTYuNjA5NCw1My42NzE5IDExNy4yNSw1My44MjgxIFExMTcuOTA2Myw1My45ODQ0IDExOC40Njg4LDU0LjI4MTMgTDExOC40Njg4LDU3IFExMTcuODQzOCw1Ni40MjE5IDExNy4yNSw1Ni4xNTYzIFExMTYuNjU2Myw1NS44NzUgMTE2LjAzMTMsNTUuODc1IFExMTQuNjg3NSw1NS44NzUgMTE0LDU2Ljk1MzEgUTExMy4zMTI1LDU4LjAxNTYgMTEzLjMxMjUsNjAuMTA5NCBRMTEzLjMxMjUsNjIuMjAzMSAxMTQsNjMuMjgxMyBRMTE0LjY4NzUsNjQuMzQzOCAxMTYuMDMxMyw2NC4zNDM4IFExMTYuNjU2Myw2NC4zNDM4IDExNy4yNSw2NC4wNzgxIFExMTcuODQzOCw2My43OTY5IDExOC40Njg4LDYzLjIxODggTDExOC40Njg4LDY1LjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NSIgeD0iMTI5LjUiIHk9IjY1LjE0MzYiPkNvbXBhbnk8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTAxLjUiIHgyPSIxOTYuNSIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTAxLjUiIHgyPSIxOTYuNSIgeTE9Ijg0LjI5NjkiIHkyPSI4NC4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBEZXBhcnRtZW50QS0tPjxnIGlkPSJlbGVtX0RlcGFydG1lbnRBIj48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IkRlcGFydG1lbnRBIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxMjQiIHg9IjciIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuOTY4OCwxNzMuOTM3NSBRMjQuMzkwNiwxNzQuMjM0NCAyMy43NSwxNzQuMzc1IFEyMy4xMDk0LDE3NC41MzEzIDIyLjQwNjMsMTc0LjUzMTMgUTE5LjkwNjMsMTc0LjUzMTMgMTguNTc4MSwxNzIuODkwNiBRMTcuMjY1NiwxNzEuMjM0NCAxNy4yNjU2LDE2OC4xMDk0IFExNy4yNjU2LDE2NC45ODQ0IDE4LjU3ODEsMTYzLjMyODEgUTE5LjkwNjMsMTYxLjY3MTkgMjIuNDA2MywxNjEuNjcxOSBRMjMuMTA5NCwxNjEuNjcxOSAyMy43NSwxNjEuODI4MSBRMjQuNDA2MywxNjEuOTg0NCAyNC45Njg4LDE2Mi4yODEzIEwyNC45Njg4LDE2NSBRMjQuMzQzOCwxNjQuNDIxOSAyMy43NSwxNjQuMTU2MyBRMjMuMTU2MywxNjMuODc1IDIyLjUzMTMsMTYzLjg3NSBRMjEuMTg3NSwxNjMuODc1IDIwLjUsMTY0Ljk1MzEgUTE5LjgxMjUsMTY2LjAxNTYgMTkuODEyNSwxNjguMTA5NCBRMTkuODEyNSwxNzAuMjAzMSAyMC41LDE3MS4yODEzIFEyMS4xODc1LDE3Mi4zNDM4IDIyLjUzMTMsMTcyLjM0MzggUTIzLjE1NjMsMTcyLjM0MzggMjMuNzUsMTcyLjA3ODEgUTI0LjM0MzgsMTcxLjc5NjkgMjQuOTY4OCwxNzEuMjE4OCBMMjQuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkyIiB4PSIzNiIgeT0iMTczLjE0MzYiPkRlcGFydG1lbnRBPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMzAiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjEzMCIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLWNsYXNzIERlcGFydG1lbnRCLS0+PGcgaWQ9ImVsZW1fRGVwYXJ0bWVudEIiPjxyZWN0IGNvZGVMaW5lPSI2IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRGVwYXJ0bWVudEIiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEyNSIgeD0iMTY2LjUiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjE4MS41IiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTg0LjQ2ODgsMTczLjkzNzUgUTE4My44OTA2LDE3NC4yMzQ0IDE4My4yNSwxNzQuMzc1IFExODIuNjA5NCwxNzQuNTMxMyAxODEuOTA2MywxNzQuNTMxMyBRMTc5LjQwNjMsMTc0LjUzMTMgMTc4LjA3ODEsMTcyLjg5MDYgUTE3Ni43NjU2LDE3MS4yMzQ0IDE3Ni43NjU2LDE2OC4xMDk0IFExNzYuNzY1NiwxNjQuOTg0NCAxNzguMDc4MSwxNjMuMzI4MSBRMTc5LjQwNjMsMTYxLjY3MTkgMTgxLjkwNjMsMTYxLjY3MTkgUTE4Mi42MDk0LDE2MS42NzE5IDE4My4yNSwxNjEuODI4MSBRMTgzLjkwNjMsMTYxLjk4NDQgMTg0LjQ2ODgsMTYyLjI4MTMgTDE4NC40Njg4LDE2NSBRMTgzLjg0MzgsMTY0LjQyMTkgMTgzLjI1LDE2NC4xNTYzIFExODIuNjU2MywxNjMuODc1IDE4Mi4wMzEzLDE2My44NzUgUTE4MC42ODc1LDE2My44NzUgMTgwLDE2NC45NTMxIFExNzkuMzEyNSwxNjYuMDE1NiAxNzkuMzEyNSwxNjguMTA5NCBRMTc5LjMxMjUsMTcwLjIwMzEgMTgwLDE3MS4yODEzIFExODAuNjg3NSwxNzIuMzQzOCAxODIuMDMxMywxNzIuMzQzOCBRMTgyLjY1NjMsMTcyLjM0MzggMTgzLjI1LDE3Mi4wNzgxIFExODMuODQzOCwxNzEuNzk2OSAxODQuNDY4OCwxNzEuMjE4OCBMMTg0LjQ2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MyIgeD0iMTk1LjUiIHk9IjE3My4xNDM2Ij5EZXBhcnRtZW50QjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxNjcuNSIgeDI9IjI5MC41IiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE2Ny41IiB4Mj0iMjkwLjUiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcGFueSB0byBEZXBhcnRtZW50QS0tPjxnIGlkPSJsaW5rX0NvbXBhbnlfRGVwYXJ0bWVudEEiPjxwYXRoIGNvZGVMaW5lPSI4IiBkPSJNMTIyLjc5LDEwNC4wMjY5IEMxMTAuODksMTE5Ljc5NjkgOTcuMTQsMTM4LjAxNjkgODYuNTIsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcGFueS1iYWNrdG8tRGVwYXJ0bWVudEEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iMTMwLjUzLDkzLjc2NjksMTIzLjcyMjYsOTYuMTQ1OSwxMjMuMzAwNSwxMDMuMzQ0NywxMzAuMTA3OCwxMDAuOTY1NiwxMzAuNTMsOTMuNzY2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcGFueSB0byBEZXBhcnRtZW50Qi0tPjxnIGlkPSJsaW5rX0NvbXBhbnlfRGVwYXJ0bWVudEIiPjxwYXRoIGNvZGVMaW5lPSI5IiBkPSJNMTc1LjIxLDEwNC4wMjY5IEMxODcuMTEsMTE5Ljc5NjkgMjAwLjg2LDEzOC4wMTY5IDIxMS40OCwxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJDb21wYW55LWJhY2t0by1EZXBhcnRtZW50QiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxNjcuNDcsOTMuNzY2OSwxNjcuODkyMiwxMDAuOTY1NiwxNzQuNjk5NSwxMDMuMzQ0NywxNzQuMjc3NCw5Ni4xNDU5LDE2Ny40Nyw5My43NjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTQ3hGQlNXbHBZcDlwQ19adWFoRUlJbWsxV2lidmJMMlVJd2YxT2I1OVJjZlVJTUU2MjlFTjVuR25HZlFraGVlSWg2QkV0NDEwMDAwXS0tPjwvZz48L3N2Zz4="><h3 id="关联关系-Association">关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSI5OXB4IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiBzdHlsZT0id2lkdGg6MjE1cHg7aGVpZ2h0Ojk5cHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjE1IDk5IiB3aWR0aD0iMjE1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTEiIHg9IjU1IiB5PSIyMi45OTUxIj5Bc3NvY2lhdGlvbjwvdGV4dD48IS0tY2xhc3MgU2Nob29sLS0+PGcgaWQ9ImVsZW1fU2Nob29sIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IlNjaG9vbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzkiIHg9IjciIHk9IjQ0LjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsNjUuOTM3NSBRMjQuMzkwNiw2Ni4yMzQ0IDIzLjc1LDY2LjM3NSBRMjMuMTA5NCw2Ni41MzEzIDIyLjQwNjMsNjYuNTMxMyBRMTkuOTA2Myw2Ni41MzEzIDE4LjU3ODEsNjQuODkwNiBRMTcuMjY1Niw2My4yMzQ0IDE3LjI2NTYsNjAuMTA5NCBRMTcuMjY1Niw1Ni45ODQ0IDE4LjU3ODEsNTUuMzI4MSBRMTkuOTA2Myw1My42NzE5IDIyLjQwNjMsNTMuNjcxOSBRMjMuMTA5NCw1My42NzE5IDIzLjc1LDUzLjgyODEgUTI0LjQwNjMsNTMuOTg0NCAyNC45Njg4LDU0LjI4MTMgTDI0Ljk2ODgsNTcgUTI0LjM0MzgsNTYuNDIxOSAyMy43NSw1Ni4xNTYzIFEyMy4xNTYzLDU1Ljg3NSAyMi41MzEzLDU1Ljg3NSBRMjEuMTg3NSw1NS44NzUgMjAuNSw1Ni45NTMxIFExOS44MTI1LDU4LjAxNTYgMTkuODEyNSw2MC4xMDk0IFExOS44MTI1LDYyLjIwMzEgMjAuNSw2My4yODEzIFEyMS4xODc1LDY0LjM0MzggMjIuNTMxMyw2NC4zNDM4IFEyMy4xNTYzLDY0LjM0MzggMjMuNzUsNjQuMDc4MSBRMjQuMzQzOCw2My43OTY5IDI0Ljk2ODgsNjMuMjE4OCBMMjQuOTY4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDciIHg9IjM2IiB5PSI2NS4xNDM2Ij5TY2hvb2w8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9Ijg1IiB5MT0iNzYuMjk2OSIgeTI9Ijc2LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iODUiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgU3R1ZGVudC0tPjxnIGlkPSJlbGVtX1N0dWRlbnQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iU3R1ZGVudCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODciIHg9IjEyMSIgeT0iNDQuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMzYiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEzOC45Njg4LDY1LjkzNzUgUTEzOC4zOTA2LDY2LjIzNDQgMTM3Ljc1LDY2LjM3NSBRMTM3LjEwOTQsNjYuNTMxMyAxMzYuNDA2Myw2Ni41MzEzIFExMzMuOTA2Myw2Ni41MzEzIDEzMi41NzgxLDY0Ljg5MDYgUTEzMS4yNjU2LDYzLjIzNDQgMTMxLjI2NTYsNjAuMTA5NCBRMTMxLjI2NTYsNTYuOTg0NCAxMzIuNTc4MSw1NS4zMjgxIFExMzMuOTA2Myw1My42NzE5IDEzNi40MDYzLDUzLjY3MTkgUTEzNy4xMDk0LDUzLjY3MTkgMTM3Ljc1LDUzLjgyODEgUTEzOC40MDYzLDUzLjk4NDQgMTM4Ljk2ODgsNTQuMjgxMyBMMTM4Ljk2ODgsNTcgUTEzOC4zNDM4LDU2LjQyMTkgMTM3Ljc1LDU2LjE1NjMgUTEzNy4xNTYzLDU1Ljg3NSAxMzYuNTMxMyw1NS44NzUgUTEzNS4xODc1LDU1Ljg3NSAxMzQuNSw1Ni45NTMxIFExMzMuODEyNSw1OC4wMTU2IDEzMy44MTI1LDYwLjEwOTQgUTEzMy44MTI1LDYyLjIwMzEgMTM0LjUsNjMuMjgxMyBRMTM1LjE4NzUsNjQuMzQzOCAxMzYuNTMxMyw2NC4zNDM4IFExMzcuMTU2Myw2NC4zNDM4IDEzNy43NSw2NC4wNzgxIFExMzguMzQzOCw2My43OTY5IDEzOC45Njg4LDYzLjIxODggTDEzOC45Njg4LDY1LjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NSIgeD0iMTUwIiB5PSI2NS4xNDM2Ij5TdHVkZW50PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyMiIgeDI9IjIwNyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTIyIiB4Mj0iMjA3IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWxpbmsgU2Nob29sIHRvIFN0dWRlbnQtLT48ZyBpZD0ibGlua19TY2hvb2xfU3R1ZGVudCI+PHBhdGggY29kZUxpbmU9IjciIGQ9Ik04Ni4xNCw2OC4yOTY5IEM5Ny42Nyw2OC4yOTY5IDEwOS4yLDY4LjI5NjkgMTIwLjczLDY4LjI5NjkgIiBmaWxsPSJub25lIiBpZD0iU2Nob29sLVN0dWRlbnQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgiIHg9IjkzLjkxMzQiIHk9IjY0LjAzOTciPjE8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOCIgeD0iMTA1LjExNjciIHk9IjY0LjE3OSI+bjwvdGV4dD48L2c+PCEtLVNSQz1bQXlhaW9LYkxTMm1rcGFfRUoycDlwQ19adWFoRUlJbWtMV1hFcGlaRnB1NW5JYWZKS2xEQWtCV1dlV2ZBWGFlQWtXZkFVS2ZtNkcwMF0tLT48L2c+PC9zdmc+"><h3 id="依赖关系-Dependency">依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:</p><ul><li>A 类是 B 类中的(某中方法的)局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMzlweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM0MXB4O2hlaWdodDoyMzlweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNDEgMjM5IiB3aWR0aD0iMzQxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9IjExNCIgeT0iMjIuOTk1MSI+RGVwZW5kZW5jeTwvdGV4dD48IS0tY2xhc3MgVmVoaWNsZS0tPjxnIGlkPSJlbGVtX1ZlaGljbGUiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjY0LjI5NjkiIGlkPSJWZWhpY2xlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxNTciIHg9Ijg0IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEzMy4yNSIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTM2LjIxODgsNjUuOTM3NSBRMTM1LjY0MDYsNjYuMjM0NCAxMzUsNjYuMzc1IFExMzQuMzU5NCw2Ni41MzEzIDEzMy42NTYzLDY2LjUzMTMgUTEzMS4xNTYzLDY2LjUzMTMgMTI5LjgyODEsNjQuODkwNiBRMTI4LjUxNTYsNjMuMjM0NCAxMjguNTE1Niw2MC4xMDk0IFExMjguNTE1Niw1Ni45ODQ0IDEyOS44MjgxLDU1LjMyODEgUTEzMS4xNTYzLDUzLjY3MTkgMTMzLjY1NjMsNTMuNjcxOSBRMTM0LjM1OTQsNTMuNjcxOSAxMzUsNTMuODI4MSBRMTM1LjY1NjMsNTMuOTg0NCAxMzYuMjE4OCw1NC4yODEzIEwxMzYuMjE4OCw1NyBRMTM1LjU5MzgsNTYuNDIxOSAxMzUsNTYuMTU2MyBRMTM0LjQwNjMsNTUuODc1IDEzMy43ODEzLDU1Ljg3NSBRMTMyLjQzNzUsNTUuODc1IDEzMS43NSw1Ni45NTMxIFExMzEuMDYyNSw1OC4wMTU2IDEzMS4wNjI1LDYwLjEwOTQgUTEzMS4wNjI1LDYyLjIwMzEgMTMxLjc1LDYzLjI4MTMgUTEzMi40Mzc1LDY0LjM0MzggMTMzLjc4MTMsNjQuMzQzOCBRMTM0LjQwNjMsNjQuMzQzOCAxMzUsNjQuMDc4MSBRMTM1LjU5MzgsNjMuNzk2OSAxMzYuMjE4OCw2My4yMTg4IEwxMzYuMjE4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTAiIHg9IjE1My43NSIgeT0iNjUuMTQzNiI+VmVoaWNsZTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4NSIgeDI9IjI0MCIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iODUiIHgyPSIyNDAiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0NSIgeD0iOTAiIHk9IjEwMS4yOTIiPm1vdmUoTW92ZUJlaGF2aW9yKTwvdGV4dD48L2c+PCEtLWNsYXNzIE1vdmVCZWhhdmlvci0tPjxnIGlkPSJlbGVtX01vdmVCZWhhdmlvciI+PHJlY3QgY29kZUxpbmU9IjgiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNjQuMjk2OSIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTMxIiB4PSI3IiB5PSIxNjguMjk2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE4NC4yOTY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTE3LjkyMTksMTgwLjA2MjUgTDE3LjkyMTksMTc3LjkwNjMgTDI1LjMxMjUsMTc3LjkwNjMgTDI1LjMxMjUsMTgwLjA2MjUgTDIyLjg0MzgsMTgwLjA2MjUgTDIyLjg0MzgsMTg4LjE0MDYgTDI1LjMxMjUsMTg4LjE0MDYgTDI1LjMxMjUsMTkwLjI5NjkgTDE3LjkyMTksMTkwLjI5NjkgTDE3LjkyMTksMTg4LjE0MDYgTDIwLjM5MDYsMTg4LjE0MDYgTDIwLjM5MDYsMTgwLjA2MjUgTDE3LjkyMTksMTgwLjA2MjUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC1zdHlsZT0iaXRhbGljIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk5IiB4PSIzNiIgeT0iMTg5LjE0MzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTM3IiB5MT0iMjAwLjI5NjkiIHkyPSIyMDAuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMzciIHkxPSIyMDguMjk2OSIgeTI9IjIwOC4yOTY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDgiIHg9IjEzIiB5PSIyMjUuMjkyIj5tb3ZlKCk8L3RleHQ+PC9nPjxnIGlkPSJlbGVtX04iPjxwYXRoIGQ9Ik0xNzMsMTg3Ljc5NjkgTDE3MywyMTIuOTI5NyBBMCwwIDAgMCAwIDE3MywyMTIuOTI5NyBMMzM0LDIxMi45Mjk3IEEwLDAgMCAwIDAgMzM0LDIxMi45Mjk3IEwzMzQsMTk3Ljc5NjkgTDMyNCwxODcuNzk2OSBMMjQ4LjYzLDE4Ny43OTY5IEwxODUuOTMsMTA4LjcxNjkgTDI0MC42MywxODcuNzk2OSBMMTczLDE4Ny43OTY5IEEwLDAgMCAwIDAgMTczLDE4Ny43OTY5ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTMyNCwxODcuNzk2OSBMMzI0LDE5Ny43OTY5IEwzMzQsMTk3Ljc5NjkgTDMyNCwxODcuNzk2OSAiIGZpbGw9IiNGRUZGREQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0MCIgeD0iMTc5IiB5PSIyMDQuODYzOCI+TW92ZUJlaGF2aW9yLm1vdmUoKTwvdGV4dD48L2c+PCEtLWxpbmsgVmVoaWNsZSB0byBNb3ZlQmVoYXZpb3ItLT48ZyBpZD0ibGlua19WZWhpY2xlX01vdmVCZWhhdmlvciI+PHBhdGggY29kZUxpbmU9IjE0IiBkPSJNMTM5LjMyLDEwOC43MTY5IEMxMjcuMTUsMTI1LjIyNjkgMTEyLjE1LDE0NS41NDY5IDk5LjQ2LDE2Mi43NTY5ICIgZmlsbD0ibm9uZSIgaWQ9IlZlaGljbGUtdG8tTW92ZUJlaGF2aW9yIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSI5Ni41LDE2Ni43NjY5LDEwNS4wNjk2LDE2MS45MTI5LDk5LjQ3NDgsMTYyLjc0ODEsOTguNjM5NSwxNTcuMTUzMiw5Ni41LDE2Ni43NjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNGFqSUNyQklTckJoa0pZSWl2OUIydk0yNGxEbzRtNm9iSHBBRzExUmR2UGdlT2xhNzFBcEtXaW95bWxxa0lndlVCQXAyajlCS2ZCSjR2TEc5UDJyVzlNYmZUVmFnZ1dYQW40M29BZmY5MU9oRTM3bkdNcElxX0YzaUthUDFjV0VXMDBdLS0+PC9nPjwvc3ZnPg=="><h2 id="面向对象设计的-SOLID-原则">面向对象设计的 SOLID 原则</h2><table><thead><tr><th>缩写</th><th>全名</th><th>中文</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr></tbody></table><h3 id="SRP-单一责任原则">SRP 单一责任原则</h3><p>当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是<mark style="background: #FF5582A6;">让一个类只做一种类型责任</mark>，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</p><h3 id="OCP-开放封闭原则">OCP 开放封闭原则</h3><p>软件实体应该是<mark style="background: #FF5582A6;">可扩展，而不可修改的</mark>。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。</p><h3 id="LSP-里氏替换原则">LSP 里氏替换原则</h3><p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有 is-A 关系</p><h3 id="DIP-依赖倒置原则">DIP 依赖倒置原则</h3><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ol><h3 id="ISP-接口分离原则">ISP 接口分离原则</h3><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用<mark style="background: #FF5582A6;">多个专门的接口比使用单一的总接口总要好</mark>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】 面向对象</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】 面向对象</h1><h2 id="Metadata-48">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】 面向对象date: 2022-12-14 14:07tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/面向对象categories:  - Javakeywords:  - Java/基础  - 面向对象description: 面向对象</code></pre><h2 id="三大特性">三大特性</h2><h3 id="封装">封装</h3><p>利用抽象数据类型<mark style="background: #FF5582A6;">将数据和基于数据的操作封装在一起</mark>，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p><strong>优点:</strong></p><ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><h3 id="继承">继承</h3><p>继承实现了 <mark style="background: #FF5582A6;">IS-A 关系</mark>，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循<strong>里氏替换原则</strong>，<mark style="background: #FF5582A6;">子类对象必须能够替换掉所有父类对象</mark>。</p><h3 id="多态">多态</h3><p>多态分为编译时多态和运行时多态:</p><ul><li><strong>编译时多态</strong>主要指<mark style="background: #ABF7F7A6;">方法的重载</mark></li><li><strong>运行时多态</strong>指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><h2 id="类图">类图</h2><h3 id="泛化关系-Generalization">泛化关系 (Generalization)</h3><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE3NXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNzUgMjA3IiB3aWR0aD0iMTc1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE0IiB4PSIyMy41IiB5PSIyMi45OTUxIj5HZW5lcmFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgVmVoaWNhbC0tPjxnIGlkPSJlbGVtX1ZlaGljYWwiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iVmVoaWNhbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODEiIHg9IjQzIiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjU4IiBjeT0iNjAuMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik02MC45Njg4LDY1LjkzNzUgUTYwLjM5MDYsNjYuMjM0NCA1OS43NSw2Ni4zNzUgUTU5LjEwOTQsNjYuNTMxMyA1OC40MDYzLDY2LjUzMTMgUTU1LjkwNjMsNjYuNTMxMyA1NC41NzgxLDY0Ljg5MDYgUTUzLjI2NTYsNjMuMjM0NCA1My4yNjU2LDYwLjEwOTQgUTUzLjI2NTYsNTYuOTg0NCA1NC41NzgxLDU1LjMyODEgUTU1LjkwNjMsNTMuNjcxOSA1OC40MDYzLDUzLjY3MTkgUTU5LjEwOTQsNTMuNjcxOSA1OS43NSw1My44MjgxIFE2MC40MDYzLDUzLjk4NDQgNjAuOTY4OCw1NC4yODEzIEw2MC45Njg4LDU3IFE2MC4zNDM4LDU2LjQyMTkgNTkuNzUsNTYuMTU2MyBRNTkuMTU2Myw1NS44NzUgNTguNTMxMyw1NS44NzUgUTU3LjE4NzUsNTUuODc1IDU2LjUsNTYuOTUzMSBRNTUuODEyNSw1OC4wMTU2IDU1LjgxMjUsNjAuMTA5NCBRNTUuODEyNSw2Mi4yMDMxIDU2LjUsNjMuMjgxMyBRNTcuMTg3NSw2NC4zNDM4IDU4LjUzMTMsNjQuMzQzOCBRNTkuMTU2Myw2NC4zNDM4IDU5Ljc1LDY0LjA3ODEgUTYwLjM0MzgsNjMuNzk2OSA2MC45Njg4LDYzLjIxODggTDYwLjk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSI3MiIgeT0iNjUuMTQzNiI+VmVoaWNhbDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI0NCIgeDI9IjEyMyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iNDQiIHgyPSIxMjMiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgQ2FyLS0+PGcgaWQ9ImVsZW1fQ2FyIj48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IkNhciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNTUiIHg9IjciIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuOTY4OCwxNzMuOTM3NSBRMjQuMzkwNiwxNzQuMjM0NCAyMy43NSwxNzQuMzc1IFEyMy4xMDk0LDE3NC41MzEzIDIyLjQwNjMsMTc0LjUzMTMgUTE5LjkwNjMsMTc0LjUzMTMgMTguNTc4MSwxNzIuODkwNiBRMTcuMjY1NiwxNzEuMjM0NCAxNy4yNjU2LDE2OC4xMDk0IFExNy4yNjU2LDE2NC45ODQ0IDE4LjU3ODEsMTYzLjMyODEgUTE5LjkwNjMsMTYxLjY3MTkgMjIuNDA2MywxNjEuNjcxOSBRMjMuMTA5NCwxNjEuNjcxOSAyMy43NSwxNjEuODI4MSBRMjQuNDA2MywxNjEuOTg0NCAyNC45Njg4LDE2Mi4yODEzIEwyNC45Njg4LDE2NSBRMjQuMzQzOCwxNjQuNDIxOSAyMy43NSwxNjQuMTU2MyBRMjMuMTU2MywxNjMuODc1IDIyLjUzMTMsMTYzLjg3NSBRMjEuMTg3NSwxNjMuODc1IDIwLjUsMTY0Ljk1MzEgUTE5LjgxMjUsMTY2LjAxNTYgMTkuODEyNSwxNjguMTA5NCBRMTkuODEyNSwxNzAuMjAzMSAyMC41LDE3MS4yODEzIFEyMS4xODc1LDE3Mi4zNDM4IDIyLjUzMTMsMTcyLjM0MzggUTIzLjE1NjMsMTcyLjM0MzggMjMuNzUsMTcyLjA3ODEgUTI0LjM0MzgsMTcxLjc5NjkgMjQuOTY4OCwxNzEuMjE4OCBMMjQuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIzIiB4PSIzNiIgeT0iMTczLjE0MzYiPkNhcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNjEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjYxIiB5MT0iMTkyLjI5NjkiIHkyPSIxOTIuMjk2OSIvPjwvZz48IS0tY2xhc3MgVHJ1Y2stLT48ZyBpZD0iZWxlbV9UcnVjayI+PHJlY3QgY29kZUxpbmU9IjYiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJUcnVjayIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzEiIHg9Ijk3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMTIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTQuOTY4OCwxNzMuOTM3NSBRMTE0LjM5MDYsMTc0LjIzNDQgMTEzLjc1LDE3NC4zNzUgUTExMy4xMDk0LDE3NC41MzEzIDExMi40MDYzLDE3NC41MzEzIFExMDkuOTA2MywxNzQuNTMxMyAxMDguNTc4MSwxNzIuODkwNiBRMTA3LjI2NTYsMTcxLjIzNDQgMTA3LjI2NTYsMTY4LjEwOTQgUTEwNy4yNjU2LDE2NC45ODQ0IDEwOC41NzgxLDE2My4zMjgxIFExMDkuOTA2MywxNjEuNjcxOSAxMTIuNDA2MywxNjEuNjcxOSBRMTEzLjEwOTQsMTYxLjY3MTkgMTEzLjc1LDE2MS44MjgxIFExMTQuNDA2MywxNjEuOTg0NCAxMTQuOTY4OCwxNjIuMjgxMyBMMTE0Ljk2ODgsMTY1IFExMTQuMzQzOCwxNjQuNDIxOSAxMTMuNzUsMTY0LjE1NjMgUTExMy4xNTYzLDE2My44NzUgMTEyLjUzMTMsMTYzLjg3NSBRMTExLjE4NzUsMTYzLjg3NSAxMTAuNSwxNjQuOTUzMSBRMTA5LjgxMjUsMTY2LjAxNTYgMTA5LjgxMjUsMTY4LjEwOTQgUTEwOS44MTI1LDE3MC4yMDMxIDExMC41LDE3MS4yODEzIFExMTEuMTg3NSwxNzIuMzQzOCAxMTIuNTMxMywxNzIuMzQzOCBRMTEzLjE1NjMsMTcyLjM0MzggMTEzLjc1LDE3Mi4wNzgxIFExMTQuMzQzOCwxNzEuNzk2OSAxMTQuOTY4OCwxNzEuMjE4OCBMMTE0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzOSIgeD0iMTI2IiB5PSIxNzMuMTQzNiI+VHJ1Y2s8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTgiIHgyPSIxNjciIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgVmVoaWNhbCB0byBDYXItLT48ZyBpZD0ibGlua19WZWhpY2FsX0NhciI+PHBhdGggY29kZUxpbmU9IjgiIGQ9Ik02My43MiwxMTIuMDg2OSBDNTcuNCwxMjUuNzQ2OSA1MC42NSwxNDAuMzU2OSA0NS4yMywxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJWZWhpY2FsLWJhY2t0by1DYXIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iNTcuMzcsMTA5LjE0NjksNzIuMTEsOTMuOTM2OSw3MC4wNywxMTUuMDI2OSw1Ny4zNywxMDkuMTQ2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgVmVoaWNhbCB0byBUcnVjay0tPjxnIGlkPSJsaW5rX1ZlaGljYWxfVHJ1Y2siPjxwYXRoIGNvZGVMaW5lPSI5IiBkPSJNMTAzLjI4LDExMi4wODY5IEMxMDkuNiwxMjUuNzQ2OSAxMTYuMzUsMTQwLjM1NjkgMTIxLjc3LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9IlZlaGljYWwtYmFja3RvLVRydWNrIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijk2LjkzLDExNS4wMjY5LDk0Ljg5LDkzLjkzNjksMTA5LjYzLDEwOS4xNDY5LDk2LjkzLDExNS4wMjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNF9ESW9yQXBDY2lJWXA5cENfWnVhaEVJSW1rTFdYQnBTWENKaW8xeWZtSll3MmlhQUJJdjZta0JnWXFXYXNEaFl2TzVhSzBlV1cwXS0tPjwvZz48L3N2Zz4="><h3 id="实现关系-Realization">实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjE1OXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxNTkgMjA3IiB3aWR0aD0iMTU5cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODUiIHg9IjMwIiB5PSIyMi45OTUxIj5SZWFsaXphdGlvbjwvdGV4dD48IS0tY2xhc3MgTW92ZUJlaGF2aW9yLS0+PGcgaWQ9ImVsZW1fTW92ZUJlaGF2aW9yIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTMxIiB4PSIxMS41IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI2LjUiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIyLjQyMTksNTYuMDYyNSBMMjIuNDIxOSw1My45MDYzIEwyOS44MTI1LDUzLjkwNjMgTDI5LjgxMjUsNTYuMDYyNSBMMjcuMzQzOCw1Ni4wNjI1IEwyNy4zNDM4LDY0LjE0MDYgTDI5LjgxMjUsNjQuMTQwNiBMMjkuODEyNSw2Ni4yOTY5IEwyMi40MjE5LDY2LjI5NjkgTDIyLjQyMTksNjQuMTQwNiBMMjQuODkwNiw2NC4xNDA2IEwyNC44OTA2LDU2LjA2MjUgTDIyLjQyMTksNTYuMDYyNSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBmb250LXN0eWxlPSJpdGFsaWMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9IjQwLjUiIHk9IjY1LjE0MzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMi41IiB4Mj0iMTQxLjUiIHkxPSI3Ni4yOTY5IiB5Mj0iNzYuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyLjUiIHgyPSIxNDEuNSIgeTE9Ijg0LjI5NjkiIHkyPSI4NC4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBGbHktLT48ZyBpZD0iZWxlbV9GbHkiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRmx5IiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI1MCIgeD0iNyIgeT0iMTUyLjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNC45Njg4LDE3My45Mzc1IFEyNC4zOTA2LDE3NC4yMzQ0IDIzLjc1LDE3NC4zNzUgUTIzLjEwOTQsMTc0LjUzMTMgMjIuNDA2MywxNzQuNTMxMyBRMTkuOTA2MywxNzQuNTMxMyAxOC41NzgxLDE3Mi44OTA2IFExNy4yNjU2LDE3MS4yMzQ0IDE3LjI2NTYsMTY4LjEwOTQgUTE3LjI2NTYsMTY0Ljk4NDQgMTguNTc4MSwxNjMuMzI4MSBRMTkuOTA2MywxNjEuNjcxOSAyMi40MDYzLDE2MS42NzE5IFEyMy4xMDk0LDE2MS42NzE5IDIzLjc1LDE2MS44MjgxIFEyNC40MDYzLDE2MS45ODQ0IDI0Ljk2ODgsMTYyLjI4MTMgTDI0Ljk2ODgsMTY1IFEyNC4zNDM4LDE2NC40MjE5IDIzLjc1LDE2NC4xNTYzIFEyMy4xNTYzLDE2My44NzUgMjIuNTMxMywxNjMuODc1IFEyMS4xODc1LDE2My44NzUgMjAuNSwxNjQuOTUzMSBRMTkuODEyNSwxNjYuMDE1NiAxOS44MTI1LDE2OC4xMDk0IFExOS44MTI1LDE3MC4yMDMxIDIwLjUsMTcxLjI4MTMgUTIxLjE4NzUsMTcyLjM0MzggMjIuNTMxMywxNzIuMzQzOCBRMjMuMTU2MywxNzIuMzQzOCAyMy43NSwxNzIuMDc4MSBRMjQuMzQzOCwxNzEuNzk2OSAyNC45Njg4LDE3MS4yMTg4IEwyNC45Njg4LDE3My45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTgiIHg9IjM2IiB5PSIxNzMuMTQzNiI+Rmx5PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSI1NiIgeTE9IjE4NC4yOTY5IiB5Mj0iMTg0LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iNTYiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBSdW4tLT48ZyBpZD0iZWxlbV9SdW4iPjxyZWN0IGNvZGVMaW5lPSI2IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iUnVuIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI2MCIgeD0iOTIiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEwNyIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEwOS45Njg4LDE3My45Mzc1IFExMDkuMzkwNiwxNzQuMjM0NCAxMDguNzUsMTc0LjM3NSBRMTA4LjEwOTQsMTc0LjUzMTMgMTA3LjQwNjMsMTc0LjUzMTMgUTEwNC45MDYzLDE3NC41MzEzIDEwMy41NzgxLDE3Mi44OTA2IFExMDIuMjY1NiwxNzEuMjM0NCAxMDIuMjY1NiwxNjguMTA5NCBRMTAyLjI2NTYsMTY0Ljk4NDQgMTAzLjU3ODEsMTYzLjMyODEgUTEwNC45MDYzLDE2MS42NzE5IDEwNy40MDYzLDE2MS42NzE5IFExMDguMTA5NCwxNjEuNjcxOSAxMDguNzUsMTYxLjgyODEgUTEwOS40MDYzLDE2MS45ODQ0IDEwOS45Njg4LDE2Mi4yODEzIEwxMDkuOTY4OCwxNjUgUTEwOS4zNDM4LDE2NC40MjE5IDEwOC43NSwxNjQuMTU2MyBRMTA4LjE1NjMsMTYzLjg3NSAxMDcuNTMxMywxNjMuODc1IFExMDYuMTg3NSwxNjMuODc1IDEwNS41LDE2NC45NTMxIFExMDQuODEyNSwxNjYuMDE1NiAxMDQuODEyNSwxNjguMTA5NCBRMTA0LjgxMjUsMTcwLjIwMzEgMTA1LjUsMTcxLjI4MTMgUTEwNi4xODc1LDE3Mi4zNDM4IDEwNy41MzEzLDE3Mi4zNDM4IFExMDguMTU2MywxNzIuMzQzOCAxMDguNzUsMTcyLjA3ODEgUTEwOS4zNDM4LDE3MS43OTY5IDEwOS45Njg4LDE3MS4yMTg4IEwxMDkuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSIxMjEiIHk9IjE3My4xNDM2Ij5SdW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOTMiIHgyPSIxNTEiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgTW92ZUJlaGF2aW9yIHRvIEZseS0tPjxnIGlkPSJsaW5rX01vdmVCZWhhdmlvcl9GbHkiPjxwYXRoIGNvZGVMaW5lPSI4IiBkPSJNNTguODQsMTEyLjA4NjkgQzUzLjAzLDEyNS43NDY5IDQ2LjgzLDE0MC4zNTY5IDQxLjg1LDE1Mi4wODY5ICIgZmlsbD0ibm9uZSIgaWQ9Ik1vdmVCZWhhdmlvci1iYWNrdG8tRmx5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSI1Mi4yNywxMDkuNjI2OSw2Ni41Myw5My45NTY5LDY1LjE2LDExNS4wOTY5LDUyLjI3LDEwOS42MjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBNb3ZlQmVoYXZpb3IgdG8gUnVuLS0+PGcgaWQ9ImxpbmtfTW92ZUJlaGF2aW9yX1J1biI+PHBhdGggY29kZUxpbmU9IjkiIGQ9Ik05NS4xNiwxMTIuMDg2OSBDMTAwLjk3LDEyNS43NDY5IDEwNy4xNywxNDAuMzU2OSAxMTIuMTUsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iTW92ZUJlaGF2aW9yLWJhY2t0by1SdW4iIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijg4Ljg0LDExNS4wOTY5LDg3LjQ3LDkzLjk1NjksMTAxLjczLDEwOS42MjY5LDg4Ljg0LDExNS4wOTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkwyNGZEcENjaUlZcDlwQ19adWloQ0FxYWpJYWpDSmJObXBJekJUS2hESTJwQnAyX1lJaXY5QjJ2TVNDa2ZYQkEySWU1Z2FMS2VzREpld080TE84ZzI1MEMwXS0tPjwvZz48L3N2Zz4="><h3 id="聚合关系-Aggregation">聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM0MXB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNDEgMjA3IiB3aWR0aD0iMzQxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTciIHg9IjExNSIgeT0iMjIuOTk1MSI+QWdncmVnYXRpb248L3RleHQ+PCEtLWNsYXNzIENvbXB1dGVyLS0+PGcgaWQ9ImVsZW1fQ29tcHV0ZXIiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcHV0ZXIiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEwMSIgeD0iMTI4IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjE0MyIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTQ1Ljk2ODgsNjUuOTM3NSBRMTQ1LjM5MDYsNjYuMjM0NCAxNDQuNzUsNjYuMzc1IFExNDQuMTA5NCw2Ni41MzEzIDE0My40MDYzLDY2LjUzMTMgUTE0MC45MDYzLDY2LjUzMTMgMTM5LjU3ODEsNjQuODkwNiBRMTM4LjI2NTYsNjMuMjM0NCAxMzguMjY1Niw2MC4xMDk0IFExMzguMjY1Niw1Ni45ODQ0IDEzOS41NzgxLDU1LjMyODEgUTE0MC45MDYzLDUzLjY3MTkgMTQzLjQwNjMsNTMuNjcxOSBRMTQ0LjEwOTQsNTMuNjcxOSAxNDQuNzUsNTMuODI4MSBRMTQ1LjQwNjMsNTMuOTg0NCAxNDUuOTY4OCw1NC4yODEzIEwxNDUuOTY4OCw1NyBRMTQ1LjM0MzgsNTYuNDIxOSAxNDQuNzUsNTYuMTU2MyBRMTQ0LjE1NjMsNTUuODc1IDE0My41MzEzLDU1Ljg3NSBRMTQyLjE4NzUsNTUuODc1IDE0MS41LDU2Ljk1MzEgUTE0MC44MTI1LDU4LjAxNTYgMTQwLjgxMjUsNjAuMTA5NCBRMTQwLjgxMjUsNjIuMjAzMSAxNDEuNSw2My4yODEzIFExNDIuMTg3NSw2NC4zNDM4IDE0My41MzEzLDY0LjM0MzggUTE0NC4xNTYzLDY0LjM0MzggMTQ0Ljc1LDY0LjA3ODEgUTE0NS4zNDM4LDYzLjc5NjkgMTQ1Ljk2ODgsNjMuMjE4OCBMMTQ1Ljk2ODgsNjUuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSIxNTciIHk9IjY1LjE0MzYiPkNvbXB1dGVyPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyOSIgeDI9IjIyOCIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTI5IiB4Mj0iMjI4IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWNsYXNzIEtleWJvYXJkLS0+PGcgaWQ9ImVsZW1fS2V5Ym9hcmQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iS2V5Ym9hcmQiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijk3IiB4PSI3IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsMTczLjkzNzUgUTI0LjM5MDYsMTc0LjIzNDQgMjMuNzUsMTc0LjM3NSBRMjMuMTA5NCwxNzQuNTMxMyAyMi40MDYzLDE3NC41MzEzIFExOS45MDYzLDE3NC41MzEzIDE4LjU3ODEsMTcyLjg5MDYgUTE3LjI2NTYsMTcxLjIzNDQgMTcuMjY1NiwxNjguMTA5NCBRMTcuMjY1NiwxNjQuOTg0NCAxOC41NzgxLDE2My4zMjgxIFExOS45MDYzLDE2MS42NzE5IDIyLjQwNjMsMTYxLjY3MTkgUTIzLjEwOTQsMTYxLjY3MTkgMjMuNzUsMTYxLjgyODEgUTI0LjQwNjMsMTYxLjk4NDQgMjQuOTY4OCwxNjIuMjgxMyBMMjQuOTY4OCwxNjUgUTI0LjM0MzgsMTY0LjQyMTkgMjMuNzUsMTY0LjE1NjMgUTIzLjE1NjMsMTYzLjg3NSAyMi41MzEzLDE2My44NzUgUTIxLjE4NzUsMTYzLjg3NSAyMC41LDE2NC45NTMxIFExOS44MTI1LDE2Ni4wMTU2IDE5LjgxMjUsMTY4LjEwOTQgUTE5LjgxMjUsMTcwLjIwMzEgMjAuNSwxNzEuMjgxMyBRMjEuMTg3NSwxNzIuMzQzOCAyMi41MzEzLDE3Mi4zNDM4IFEyMy4xNTYzLDE3Mi4zNDM4IDIzLjc1LDE3Mi4wNzgxIFEyNC4zNDM4LDE3MS43OTY5IDI0Ljk2ODgsMTcxLjIxODggTDI0Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NSIgeD0iMzYiIHk9IjE3My4xNDM2Ij5LZXlib2FyZDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTAzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMDMiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBNb3VzZS0tPjxnIGlkPSJlbGVtX01vdXNlIj48cmVjdCBjb2RlTGluZT0iNiIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ik1vdXNlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI3OSIgeD0iMTM5IiB5PSIxNTIuMjk2OSIvPjxlbGxpcHNlIGN4PSIxNTQiIGN5PSIxNjguMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xNTYuOTY4OCwxNzMuOTM3NSBRMTU2LjM5MDYsMTc0LjIzNDQgMTU1Ljc1LDE3NC4zNzUgUTE1NS4xMDk0LDE3NC41MzEzIDE1NC40MDYzLDE3NC41MzEzIFExNTEuOTA2MywxNzQuNTMxMyAxNTAuNTc4MSwxNzIuODkwNiBRMTQ5LjI2NTYsMTcxLjIzNDQgMTQ5LjI2NTYsMTY4LjEwOTQgUTE0OS4yNjU2LDE2NC45ODQ0IDE1MC41NzgxLDE2My4zMjgxIFExNTEuOTA2MywxNjEuNjcxOSAxNTQuNDA2MywxNjEuNjcxOSBRMTU1LjEwOTQsMTYxLjY3MTkgMTU1Ljc1LDE2MS44MjgxIFExNTYuNDA2MywxNjEuOTg0NCAxNTYuOTY4OCwxNjIuMjgxMyBMMTU2Ljk2ODgsMTY1IFExNTYuMzQzOCwxNjQuNDIxOSAxNTUuNzUsMTY0LjE1NjMgUTE1NS4xNTYzLDE2My44NzUgMTU0LjUzMTMsMTYzLjg3NSBRMTUzLjE4NzUsMTYzLjg3NSAxNTIuNSwxNjQuOTUzMSBRMTUxLjgxMjUsMTY2LjAxNTYgMTUxLjgxMjUsMTY4LjEwOTQgUTE1MS44MTI1LDE3MC4yMDMxIDE1Mi41LDE3MS4yODEzIFExNTMuMTg3NSwxNzIuMzQzOCAxNTQuNTMxMywxNzIuMzQzOCBRMTU1LjE1NjMsMTcyLjM0MzggMTU1Ljc1LDE3Mi4wNzgxIFExNTYuMzQzOCwxNzEuNzk2OSAxNTYuOTY4OCwxNzEuMjE4OCBMMTU2Ljk2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0NyIgeD0iMTY4IiB5PSIxNzMuMTQzNiI+TW91c2U8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTQwIiB4Mj0iMjE3IiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE0MCIgeDI9IjIxNyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLWNsYXNzIFNjcmVlbi0tPjxnIGlkPSJlbGVtX1NjcmVlbiI+PHJlY3QgY29kZUxpbmU9IjciIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJTY3JlZW4iIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjgxIiB4PSIyNTMiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjI2OCIgY3k9IjE2OC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI3MC45Njg4LDE3My45Mzc1IFEyNzAuMzkwNiwxNzQuMjM0NCAyNjkuNzUsMTc0LjM3NSBRMjY5LjEwOTQsMTc0LjUzMTMgMjY4LjQwNjMsMTc0LjUzMTMgUTI2NS45MDYzLDE3NC41MzEzIDI2NC41NzgxLDE3Mi44OTA2IFEyNjMuMjY1NiwxNzEuMjM0NCAyNjMuMjY1NiwxNjguMTA5NCBRMjYzLjI2NTYsMTY0Ljk4NDQgMjY0LjU3ODEsMTYzLjMyODEgUTI2NS45MDYzLDE2MS42NzE5IDI2OC40MDYzLDE2MS42NzE5IFEyNjkuMTA5NCwxNjEuNjcxOSAyNjkuNzUsMTYxLjgyODEgUTI3MC40MDYzLDE2MS45ODQ0IDI3MC45Njg4LDE2Mi4yODEzIEwyNzAuOTY4OCwxNjUgUTI3MC4zNDM4LDE2NC40MjE5IDI2OS43NSwxNjQuMTU2MyBRMjY5LjE1NjMsMTYzLjg3NSAyNjguNTMxMywxNjMuODc1IFEyNjcuMTg3NSwxNjMuODc1IDI2Ni41LDE2NC45NTMxIFEyNjUuODEyNSwxNjYuMDE1NiAyNjUuODEyNSwxNjguMTA5NCBRMjY1LjgxMjUsMTcwLjIwMzEgMjY2LjUsMTcxLjI4MTMgUTI2Ny4xODc1LDE3Mi4zNDM4IDI2OC41MzEzLDE3Mi4zNDM4IFEyNjkuMTU2MywxNzIuMzQzOCAyNjkuNzUsMTcyLjA3ODEgUTI3MC4zNDM4LDE3MS43OTY5IDI3MC45Njg4LDE3MS4yMTg4IEwyNzAuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSIyODIiIHk9IjE3My4xNDM2Ij5TY3JlZW48L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMjU0IiB4Mj0iMzMzIiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjI1NCIgeDI9IjMzMyIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBLZXlib2FyZC0tPjxnIGlkPSJsaW5rX0NvbXB1dGVyX0tleWJvYXJkIj48cGF0aCBjb2RlTGluZT0iOSIgZD0iTTE0MC42LDEwMS45NTY5IEMxMjEuNzgsMTE4LjE3NjkgOTkuNDgsMTM3LjM5NjkgODIuNDMsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLUtleWJvYXJkIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9IjE1MC4zNiw5My41NDY5LDE0My4yMDM4LDk0LjQzNTEsMTQxLjI3MTMsMTAxLjM4MjQsMTQ4LjQyNzUsMTAwLjQ5NDIsMTUwLjM2LDkzLjU0NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tcmV2ZXJzZSBsaW5rIENvbXB1dGVyIHRvIE1vdXNlLS0+PGcgaWQ9ImxpbmtfQ29tcHV0ZXJfTW91c2UiPjxwYXRoIGNvZGVMaW5lPSIxMCIgZD0iTTE3OC41LDEwNi44MzY5IEMxNzguNSwxMjEuOTI2OSAxNzguNSwxMzguODQ2OSAxNzguNSwxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJDb21wdXRlci1iYWNrdG8tTW91c2UiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iMTc4LjUsOTQuMDc2OSwxNzQuNSwxMDAuMDc2OSwxNzguNSwxMDYuMDc2OSwxODIuNSwxMDAuMDc2OSwxNzguNSw5NC4wNzY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLXJldmVyc2UgbGluayBDb21wdXRlciB0byBTY3JlZW4tLT48ZyBpZD0ibGlua19Db21wdXRlcl9TY3JlZW4iPjxwYXRoIGNvZGVMaW5lPSIxMSIgZD0iTTIxNC4xOCwxMDIuMTg2OSBDMjMxLjczLDExOC4zNTY5IDI1Mi40NiwxMzcuNDY2OSAyNjguMzIsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcHV0ZXItYmFja3RvLVNjcmVlbiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIyMDQuODUsOTMuNTg2OSwyMDYuNTU0NCwxMDAuNTkzNywyMTMuNjc3OCwxMDEuNzE1MywyMTEuOTczMyw5NC43MDg1LDIwNC44NSw5My41ODY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNG5GQnFmREpvcDlwQ19adWFoRUlJbWtMZDNFcG9xZUJLYWpXZEF6S29rSnlYRUJLZzFTdF9wSXViR2VFcFl2QTNLTGcwLWNHbzVWTG5VWDdhS0tlV3I1MkFlUjAwMDBdLS0+PC9nPjwvc3ZnPg=="><h3 id="组合关系-Composition">组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMDdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjI5OHB4O2hlaWdodDoyMDdweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyOTggMjA3IiB3aWR0aD0iMjk4cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTgiIHg9IjkzLjI1IiB5PSIyMi45OTUxIj5Db21wb3NpdGlvbjwvdGV4dD48IS0tY2xhc3MgQ29tcGFueS0tPjxnIGlkPSJlbGVtX0NvbXBhbnkiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iQ29tcGFueSIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iOTciIHg9IjEwMC41IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjExNS41IiBjeT0iNjAuMjk2OSIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTguNDY4OCw2NS45Mzc1IFExMTcuODkwNiw2Ni4yMzQ0IDExNy4yNSw2Ni4zNzUgUTExNi42MDk0LDY2LjUzMTMgMTE1LjkwNjMsNjYuNTMxMyBRMTEzLjQwNjMsNjYuNTMxMyAxMTIuMDc4MSw2NC44OTA2IFExMTAuNzY1Niw2My4yMzQ0IDExMC43NjU2LDYwLjEwOTQgUTExMC43NjU2LDU2Ljk4NDQgMTEyLjA3ODEsNTUuMzI4MSBRMTEzLjQwNjMsNTMuNjcxOSAxMTUuOTA2Myw1My42NzE5IFExMTYuNjA5NCw1My42NzE5IDExNy4yNSw1My44MjgxIFExMTcuOTA2Myw1My45ODQ0IDExOC40Njg4LDU0LjI4MTMgTDExOC40Njg4LDU3IFExMTcuODQzOCw1Ni40MjE5IDExNy4yNSw1Ni4xNTYzIFExMTYuNjU2Myw1NS44NzUgMTE2LjAzMTMsNTUuODc1IFExMTQuNjg3NSw1NS44NzUgMTE0LDU2Ljk1MzEgUTExMy4zMTI1LDU4LjAxNTYgMTEzLjMxMjUsNjAuMTA5NCBRMTEzLjMxMjUsNjIuMjAzMSAxMTQsNjMuMjgxMyBRMTE0LjY4NzUsNjQuMzQzOCAxMTYuMDMxMyw2NC4zNDM4IFExMTYuNjU2Myw2NC4zNDM4IDExNy4yNSw2NC4wNzgxIFExMTcuODQzOCw2My43OTY5IDExOC40Njg4LDYzLjIxODggTDExOC40Njg4LDY1LjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NSIgeD0iMTI5LjUiIHk9IjY1LjE0MzYiPkNvbXBhbnk8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTAxLjUiIHgyPSIxOTYuNSIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTAxLjUiIHgyPSIxOTYuNSIgeTE9Ijg0LjI5NjkiIHkyPSI4NC4yOTY5Ii8+PC9nPjwhLS1jbGFzcyBEZXBhcnRtZW50QS0tPjxnIGlkPSJlbGVtX0RlcGFydG1lbnRBIj48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IkRlcGFydG1lbnRBIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxMjQiIHg9IjciIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuOTY4OCwxNzMuOTM3NSBRMjQuMzkwNiwxNzQuMjM0NCAyMy43NSwxNzQuMzc1IFEyMy4xMDk0LDE3NC41MzEzIDIyLjQwNjMsMTc0LjUzMTMgUTE5LjkwNjMsMTc0LjUzMTMgMTguNTc4MSwxNzIuODkwNiBRMTcuMjY1NiwxNzEuMjM0NCAxNy4yNjU2LDE2OC4xMDk0IFExNy4yNjU2LDE2NC45ODQ0IDE4LjU3ODEsMTYzLjMyODEgUTE5LjkwNjMsMTYxLjY3MTkgMjIuNDA2MywxNjEuNjcxOSBRMjMuMTA5NCwxNjEuNjcxOSAyMy43NSwxNjEuODI4MSBRMjQuNDA2MywxNjEuOTg0NCAyNC45Njg4LDE2Mi4yODEzIEwyNC45Njg4LDE2NSBRMjQuMzQzOCwxNjQuNDIxOSAyMy43NSwxNjQuMTU2MyBRMjMuMTU2MywxNjMuODc1IDIyLjUzMTMsMTYzLjg3NSBRMjEuMTg3NSwxNjMuODc1IDIwLjUsMTY0Ljk1MzEgUTE5LjgxMjUsMTY2LjAxNTYgMTkuODEyNSwxNjguMTA5NCBRMTkuODEyNSwxNzAuMjAzMSAyMC41LDE3MS4yODEzIFEyMS4xODc1LDE3Mi4zNDM4IDIyLjUzMTMsMTcyLjM0MzggUTIzLjE1NjMsMTcyLjM0MzggMjMuNzUsMTcyLjA3ODEgUTI0LjM0MzgsMTcxLjc5NjkgMjQuOTY4OCwxNzEuMjE4OCBMMjQuOTY4OCwxNzMuOTM3NSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkyIiB4PSIzNiIgeT0iMTczLjE0MzYiPkRlcGFydG1lbnRBPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMzAiIHkxPSIxODQuMjk2OSIgeTI9IjE4NC4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjEzMCIgeTE9IjE5Mi4yOTY5IiB5Mj0iMTkyLjI5NjkiLz48L2c+PCEtLWNsYXNzIERlcGFydG1lbnRCLS0+PGcgaWQ9ImVsZW1fRGVwYXJ0bWVudEIiPjxyZWN0IGNvZGVMaW5lPSI2IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iRGVwYXJ0bWVudEIiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEyNSIgeD0iMTY2LjUiIHk9IjE1Mi4yOTY5Ii8+PGVsbGlwc2UgY3g9IjE4MS41IiBjeT0iMTY4LjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTg0LjQ2ODgsMTczLjkzNzUgUTE4My44OTA2LDE3NC4yMzQ0IDE4My4yNSwxNzQuMzc1IFExODIuNjA5NCwxNzQuNTMxMyAxODEuOTA2MywxNzQuNTMxMyBRMTc5LjQwNjMsMTc0LjUzMTMgMTc4LjA3ODEsMTcyLjg5MDYgUTE3Ni43NjU2LDE3MS4yMzQ0IDE3Ni43NjU2LDE2OC4xMDk0IFExNzYuNzY1NiwxNjQuOTg0NCAxNzguMDc4MSwxNjMuMzI4MSBRMTc5LjQwNjMsMTYxLjY3MTkgMTgxLjkwNjMsMTYxLjY3MTkgUTE4Mi42MDk0LDE2MS42NzE5IDE4My4yNSwxNjEuODI4MSBRMTgzLjkwNjMsMTYxLjk4NDQgMTg0LjQ2ODgsMTYyLjI4MTMgTDE4NC40Njg4LDE2NSBRMTgzLjg0MzgsMTY0LjQyMTkgMTgzLjI1LDE2NC4xNTYzIFExODIuNjU2MywxNjMuODc1IDE4Mi4wMzEzLDE2My44NzUgUTE4MC42ODc1LDE2My44NzUgMTgwLDE2NC45NTMxIFExNzkuMzEyNSwxNjYuMDE1NiAxNzkuMzEyNSwxNjguMTA5NCBRMTc5LjMxMjUsMTcwLjIwMzEgMTgwLDE3MS4yODEzIFExODAuNjg3NSwxNzIuMzQzOCAxODIuMDMxMywxNzIuMzQzOCBRMTgyLjY1NjMsMTcyLjM0MzggMTgzLjI1LDE3Mi4wNzgxIFExODMuODQzOCwxNzEuNzk2OSAxODQuNDY4OCwxNzEuMjE4OCBMMTg0LjQ2ODgsMTczLjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MyIgeD0iMTk1LjUiIHk9IjE3My4xNDM2Ij5EZXBhcnRtZW50QjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxNjcuNSIgeDI9IjI5MC41IiB5MT0iMTg0LjI5NjkiIHkyPSIxODQuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjE2Ny41IiB4Mj0iMjkwLjUiIHkxPSIxOTIuMjk2OSIgeTI9IjE5Mi4yOTY5Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcGFueSB0byBEZXBhcnRtZW50QS0tPjxnIGlkPSJsaW5rX0NvbXBhbnlfRGVwYXJ0bWVudEEiPjxwYXRoIGNvZGVMaW5lPSI4IiBkPSJNMTIyLjc5LDEwNC4wMjY5IEMxMTAuODksMTE5Ljc5NjkgOTcuMTQsMTM4LjAxNjkgODYuNTIsMTUyLjA4NjkgIiBmaWxsPSJub25lIiBpZD0iQ29tcGFueS1iYWNrdG8tRGVwYXJ0bWVudEEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iMTMwLjUzLDkzLjc2NjksMTIzLjcyMjYsOTYuMTQ1OSwxMjMuMzAwNSwxMDMuMzQ0NywxMzAuMTA3OCwxMDAuOTY1NiwxMzAuNTMsOTMuNzY2OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1yZXZlcnNlIGxpbmsgQ29tcGFueSB0byBEZXBhcnRtZW50Qi0tPjxnIGlkPSJsaW5rX0NvbXBhbnlfRGVwYXJ0bWVudEIiPjxwYXRoIGNvZGVMaW5lPSI5IiBkPSJNMTc1LjIxLDEwNC4wMjY5IEMxODcuMTEsMTE5Ljc5NjkgMjAwLjg2LDEzOC4wMTY5IDIxMS40OCwxNTIuMDg2OSAiIGZpbGw9Im5vbmUiIGlkPSJDb21wYW55LWJhY2t0by1EZXBhcnRtZW50QiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxNjcuNDcsOTMuNzY2OSwxNjcuODkyMiwxMDAuOTY1NiwxNzQuNjk5NSwxMDMuMzQ0NywxNzQuMjc3NCw5Ni4xNDU5LDE2Ny40Nyw5My43NjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTQ3hGQlNXbHBZcDlwQ19adWFoRUlJbWsxV2lidmJMMlVJd2YxT2I1OVJjZlVJTUU2MjlFTjVuR25HZlFraGVlSWg2QkV0NDEwMDAwXS0tPjwvZz48L3N2Zz4="><h3 id="关联关系-Association">关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSI5OXB4IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiBzdHlsZT0id2lkdGg6MjE1cHg7aGVpZ2h0Ojk5cHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjE1IDk5IiB3aWR0aD0iMjE1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTEiIHg9IjU1IiB5PSIyMi45OTUxIj5Bc3NvY2lhdGlvbjwvdGV4dD48IS0tY2xhc3MgU2Nob29sLS0+PGcgaWQ9ImVsZW1fU2Nob29sIj48cmVjdCBjb2RlTGluZT0iNCIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IlNjaG9vbCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzkiIHg9IjciIHk9IjQ0LjI5NjkiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI0Ljk2ODgsNjUuOTM3NSBRMjQuMzkwNiw2Ni4yMzQ0IDIzLjc1LDY2LjM3NSBRMjMuMTA5NCw2Ni41MzEzIDIyLjQwNjMsNjYuNTMxMyBRMTkuOTA2Myw2Ni41MzEzIDE4LjU3ODEsNjQuODkwNiBRMTcuMjY1Niw2My4yMzQ0IDE3LjI2NTYsNjAuMTA5NCBRMTcuMjY1Niw1Ni45ODQ0IDE4LjU3ODEsNTUuMzI4MSBRMTkuOTA2Myw1My42NzE5IDIyLjQwNjMsNTMuNjcxOSBRMjMuMTA5NCw1My42NzE5IDIzLjc1LDUzLjgyODEgUTI0LjQwNjMsNTMuOTg0NCAyNC45Njg4LDU0LjI4MTMgTDI0Ljk2ODgsNTcgUTI0LjM0MzgsNTYuNDIxOSAyMy43NSw1Ni4xNTYzIFEyMy4xNTYzLDU1Ljg3NSAyMi41MzEzLDU1Ljg3NSBRMjEuMTg3NSw1NS44NzUgMjAuNSw1Ni45NTMxIFExOS44MTI1LDU4LjAxNTYgMTkuODEyNSw2MC4xMDk0IFExOS44MTI1LDYyLjIwMzEgMjAuNSw2My4yODEzIFEyMS4xODc1LDY0LjM0MzggMjIuNTMxMyw2NC4zNDM4IFEyMy4xNTYzLDY0LjM0MzggMjMuNzUsNjQuMDc4MSBRMjQuMzQzOCw2My43OTY5IDI0Ljk2ODgsNjMuMjE4OCBMMjQuOTY4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDciIHg9IjM2IiB5PSI2NS4xNDM2Ij5TY2hvb2w8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9Ijg1IiB5MT0iNzYuMjk2OSIgeTI9Ijc2LjI5NjkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iODUiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjwvZz48IS0tY2xhc3MgU3R1ZGVudC0tPjxnIGlkPSJlbGVtX1N0dWRlbnQiPjxyZWN0IGNvZGVMaW5lPSI1IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iU3R1ZGVudCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iODciIHg9IjEyMSIgeT0iNDQuMjk2OSIvPjxlbGxpcHNlIGN4PSIxMzYiIGN5PSI2MC4yOTY5IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEzOC45Njg4LDY1LjkzNzUgUTEzOC4zOTA2LDY2LjIzNDQgMTM3Ljc1LDY2LjM3NSBRMTM3LjEwOTQsNjYuNTMxMyAxMzYuNDA2Myw2Ni41MzEzIFExMzMuOTA2Myw2Ni41MzEzIDEzMi41NzgxLDY0Ljg5MDYgUTEzMS4yNjU2LDYzLjIzNDQgMTMxLjI2NTYsNjAuMTA5NCBRMTMxLjI2NTYsNTYuOTg0NCAxMzIuNTc4MSw1NS4zMjgxIFExMzMuOTA2Myw1My42NzE5IDEzNi40MDYzLDUzLjY3MTkgUTEzNy4xMDk0LDUzLjY3MTkgMTM3Ljc1LDUzLjgyODEgUTEzOC40MDYzLDUzLjk4NDQgMTM4Ljk2ODgsNTQuMjgxMyBMMTM4Ljk2ODgsNTcgUTEzOC4zNDM4LDU2LjQyMTkgMTM3Ljc1LDU2LjE1NjMgUTEzNy4xNTYzLDU1Ljg3NSAxMzYuNTMxMyw1NS44NzUgUTEzNS4xODc1LDU1Ljg3NSAxMzQuNSw1Ni45NTMxIFExMzMuODEyNSw1OC4wMTU2IDEzMy44MTI1LDYwLjEwOTQgUTEzMy44MTI1LDYyLjIwMzEgMTM0LjUsNjMuMjgxMyBRMTM1LjE4NzUsNjQuMzQzOCAxMzYuNTMxMyw2NC4zNDM4IFExMzcuMTU2Myw2NC4zNDM4IDEzNy43NSw2NC4wNzgxIFExMzguMzQzOCw2My43OTY5IDEzOC45Njg4LDYzLjIxODggTDEzOC45Njg4LDY1LjkzNzUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NSIgeD0iMTUwIiB5PSI2NS4xNDM2Ij5TdHVkZW50PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyMiIgeDI9IjIwNyIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTIyIiB4Mj0iMjA3IiB5MT0iODQuMjk2OSIgeTI9Ijg0LjI5NjkiLz48L2c+PCEtLWxpbmsgU2Nob29sIHRvIFN0dWRlbnQtLT48ZyBpZD0ibGlua19TY2hvb2xfU3R1ZGVudCI+PHBhdGggY29kZUxpbmU9IjciIGQ9Ik04Ni4xNCw2OC4yOTY5IEM5Ny42Nyw2OC4yOTY5IDEwOS4yLDY4LjI5NjkgMTIwLjczLDY4LjI5NjkgIiBmaWxsPSJub25lIiBpZD0iU2Nob29sLVN0dWRlbnQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgiIHg9IjkzLjkxMzQiIHk9IjY0LjAzOTciPjE8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOCIgeD0iMTA1LjExNjciIHk9IjY0LjE3OSI+bjwvdGV4dD48L2c+PCEtLVNSQz1bQXlhaW9LYkxTMm1rcGFfRUoycDlwQ19adWFoRUlJbWtMV1hFcGlaRnB1NW5JYWZKS2xEQWtCV1dlV2ZBWGFlQWtXZkFVS2ZtNkcwMF0tLT48L2c+PC9zdmc+"><h3 id="依赖关系-Dependency">依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:</p><ul><li>A 类是 B 类中的(某中方法的)局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><img class="kroki" src="/data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMzlweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM0MXB4O2hlaWdodDoyMzlweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNDEgMjM5IiB3aWR0aD0iMzQxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9IjExNCIgeT0iMjIuOTk1MSI+RGVwZW5kZW5jeTwvdGV4dD48IS0tY2xhc3MgVmVoaWNsZS0tPjxnIGlkPSJlbGVtX1ZlaGljbGUiPjxyZWN0IGNvZGVMaW5lPSI0IiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjY0LjI5NjkiIGlkPSJWZWhpY2xlIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxNTciIHg9Ijg0IiB5PSI0NC4yOTY5Ii8+PGVsbGlwc2UgY3g9IjEzMy4yNSIgY3k9IjYwLjI5NjkiIGZpbGw9IiNBREQxQjIiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTM2LjIxODgsNjUuOTM3NSBRMTM1LjY0MDYsNjYuMjM0NCAxMzUsNjYuMzc1IFExMzQuMzU5NCw2Ni41MzEzIDEzMy42NTYzLDY2LjUzMTMgUTEzMS4xNTYzLDY2LjUzMTMgMTI5LjgyODEsNjQuODkwNiBRMTI4LjUxNTYsNjMuMjM0NCAxMjguNTE1Niw2MC4xMDk0IFExMjguNTE1Niw1Ni45ODQ0IDEyOS44MjgxLDU1LjMyODEgUTEzMS4xNTYzLDUzLjY3MTkgMTMzLjY1NjMsNTMuNjcxOSBRMTM0LjM1OTQsNTMuNjcxOSAxMzUsNTMuODI4MSBRMTM1LjY1NjMsNTMuOTg0NCAxMzYuMjE4OCw1NC4yODEzIEwxMzYuMjE4OCw1NyBRMTM1LjU5MzgsNTYuNDIxOSAxMzUsNTYuMTU2MyBRMTM0LjQwNjMsNTUuODc1IDEzMy43ODEzLDU1Ljg3NSBRMTMyLjQzNzUsNTUuODc1IDEzMS43NSw1Ni45NTMxIFExMzEuMDYyNSw1OC4wMTU2IDEzMS4wNjI1LDYwLjEwOTQgUTEzMS4wNjI1LDYyLjIwMzEgMTMxLjc1LDYzLjI4MTMgUTEzMi40Mzc1LDY0LjM0MzggMTMzLjc4MTMsNjQuMzQzOCBRMTM0LjQwNjMsNjQuMzQzOCAxMzUsNjQuMDc4MSBRMTM1LjU5MzgsNjMuNzk2OSAxMzYuMjE4OCw2My4yMTg4IEwxMzYuMjE4OCw2NS45Mzc1IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTAiIHg9IjE1My43NSIgeT0iNjUuMTQzNiI+VmVoaWNsZTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4NSIgeDI9IjI0MCIgeTE9Ijc2LjI5NjkiIHkyPSI3Ni4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iODUiIHgyPSIyNDAiIHkxPSI4NC4yOTY5IiB5Mj0iODQuMjk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0NSIgeD0iOTAiIHk9IjEwMS4yOTIiPm1vdmUoTW92ZUJlaGF2aW9yKTwvdGV4dD48L2c+PCEtLWNsYXNzIE1vdmVCZWhhdmlvci0tPjxnIGlkPSJlbGVtX01vdmVCZWhhdmlvciI+PHJlY3QgY29kZUxpbmU9IjgiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNjQuMjk2OSIgaWQ9Ik1vdmVCZWhhdmlvciIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTMxIiB4PSI3IiB5PSIxNjguMjk2OSIvPjxlbGxpcHNlIGN4PSIyMiIgY3k9IjE4NC4yOTY5IiBmaWxsPSIjQjRBN0U1IiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTE3LjkyMTksMTgwLjA2MjUgTDE3LjkyMTksMTc3LjkwNjMgTDI1LjMxMjUsMTc3LjkwNjMgTDI1LjMxMjUsMTgwLjA2MjUgTDIyLjg0MzgsMTgwLjA2MjUgTDIyLjg0MzgsMTg4LjE0MDYgTDI1LjMxMjUsMTg4LjE0MDYgTDI1LjMxMjUsMTkwLjI5NjkgTDE3LjkyMTksMTkwLjI5NjkgTDE3LjkyMTksMTg4LjE0MDYgTDIwLjM5MDYsMTg4LjE0MDYgTDIwLjM5MDYsMTgwLjA2MjUgTDE3LjkyMTksMTgwLjA2MjUgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC1zdHlsZT0iaXRhbGljIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk5IiB4PSIzNiIgeT0iMTg5LjE0MzYiPk1vdmVCZWhhdmlvcjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTM3IiB5MT0iMjAwLjI5NjkiIHkyPSIyMDAuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjgiIHgyPSIxMzciIHkxPSIyMDguMjk2OSIgeTI9IjIwOC4yOTY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDgiIHg9IjEzIiB5PSIyMjUuMjkyIj5tb3ZlKCk8L3RleHQ+PC9nPjxnIGlkPSJlbGVtX04iPjxwYXRoIGQ9Ik0xNzMsMTg3Ljc5NjkgTDE3MywyMTIuOTI5NyBBMCwwIDAgMCAwIDE3MywyMTIuOTI5NyBMMzM0LDIxMi45Mjk3IEEwLDAgMCAwIDAgMzM0LDIxMi45Mjk3IEwzMzQsMTk3Ljc5NjkgTDMyNCwxODcuNzk2OSBMMjQ4LjYzLDE4Ny43OTY5IEwxODUuOTMsMTA4LjcxNjkgTDI0MC42MywxODcuNzk2OSBMMTczLDE4Ny43OTY5IEEwLDAgMCAwIDAgMTczLDE4Ny43OTY5ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTMyNCwxODcuNzk2OSBMMzI0LDE5Ny43OTY5IEwzMzQsMTk3Ljc5NjkgTDMyNCwxODcuNzk2OSAiIGZpbGw9IiNGRUZGREQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0MCIgeD0iMTc5IiB5PSIyMDQuODYzOCI+TW92ZUJlaGF2aW9yLm1vdmUoKTwvdGV4dD48L2c+PCEtLWxpbmsgVmVoaWNsZSB0byBNb3ZlQmVoYXZpb3ItLT48ZyBpZD0ibGlua19WZWhpY2xlX01vdmVCZWhhdmlvciI+PHBhdGggY29kZUxpbmU9IjE0IiBkPSJNMTM5LjMyLDEwOC43MTY5IEMxMjcuMTUsMTI1LjIyNjkgMTEyLjE1LDE0NS41NDY5IDk5LjQ2LDE2Mi43NTY5ICIgZmlsbD0ibm9uZSIgaWQ9IlZlaGljbGUtdG8tTW92ZUJlaGF2aW9yIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSI5Ni41LDE2Ni43NjY5LDEwNS4wNjk2LDE2MS45MTI5LDk5LjQ3NDgsMTYyLjc0ODEsOTguNjM5NSwxNTcuMTUzMiw5Ni41LDE2Ni43NjY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48L2c+PCEtLVNSQz1bQXlhaW9LYkxTNGFqSUNyQklTckJoa0pZSWl2OUIydk0yNGxEbzRtNm9iSHBBRzExUmR2UGdlT2xhNzFBcEtXaW95bWxxa0lndlVCQXAyajlCS2ZCSjR2TEc5UDJyVzlNYmZUVmFnZ1dYQW40M29BZmY5MU9oRTM3bkdNcElxX0YzaUthUDFjV0VXMDBdLS0+PC9nPjwvc3ZnPg=="><h2 id="面向对象设计的-SOLID-原则">面向对象设计的 SOLID 原则</h2><table><thead><tr><th>缩写</th><th>全名</th><th>中文</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr></tbody></table><h3 id="SRP-单一责任原则">SRP 单一责任原则</h3><p>当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是<mark style="background: #FF5582A6;">让一个类只做一种类型责任</mark>，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</p><h3 id="OCP-开放封闭原则">OCP 开放封闭原则</h3><p>软件实体应该是<mark style="background: #FF5582A6;">可扩展，而不可修改的</mark>。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。</p><h3 id="LSP-里氏替换原则">LSP 里氏替换原则</h3><p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有 is-A 关系</p><h3 id="DIP-依赖倒置原则">DIP 依赖倒置原则</h3><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ol><h3 id="ISP-接口分离原则">ISP 接口分离原则</h3><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用<mark style="background: #FF5582A6;">多个专门的接口比使用单一的总接口总要好</mark>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/java/java-ji-chu/java-ji-chu/"/>
      <url>/java/java-ji-chu/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1>Java 基础</h1><h2 id="Metadata-15">Metadata</h2><pre><code class="language-yml">title: Java 基础date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 基础</code></pre><h2 id="【Java-基础】-面向对象">【Java 基础】 面向对象</h2><p><a href="../java-ji-chu-mian-xiang-dui-xiang/">【Java 基础】 面向对象</a></p><h2 id="【Java-基础】数据类型">【Java 基础】数据类型</h2><p><a href="../java-ji-chu-shu-ju-lei-xing/">【Java 基础】数据类型</a></p><h2 id="【Java-基础】-泛型">【Java 基础】 泛型</h2><p><a href="../java-ji-chu-fan-xing/">【Java 基础】 泛型</a></p><h2 id="【Java-基础】-注解">【Java 基础】 注解</h2><p><a href="../java-ji-chu-zhu-jie/">【Java 基础】 注解</a></p><h2 id="【Java-基础】-反射">【Java 基础】 反射</h2><p><a href="../java-ji-chu-fan-she/">【Java 基础】 反射</a></p><h2 id="【Java-基础】-异常">【Java 基础】 异常</h2><p><a href="../java-ji-chu-yi-chang/">【Java 基础】 异常</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】数据类型</title>
      <link href="/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/"/>
      <url>/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】数据类型</h1><h2 id="Metadata-25">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】数据类型date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/数据类型categories:  - Javakeywords:  - Java/基础  - 数据类型description: 数据类型</code></pre><h2 id="String">String</h2><h4 id="概览">概览</h4><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h4 id="不可变的好处">不可变的好处</h4><ol><li>可以缓存 hash 值</li><li>String Pool 的需要</li><li>安全性</li><li>线程安全</li></ol><h4 id="String-StringBuffer-and-StringBuilder">String, StringBuffer and StringBuilder</h4><ol><li>可变性</li></ol><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><ol start="2"><li>线程安全</li></ol><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="Object">Object</h2><h3 id="概览-2">概览</h3><pre><code class="language-java">public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable {}</code></pre><h3 id="Equals">Equals()</h3><h4 id="等价关系">等价关系</h4><p><strong>自反性</strong><br><strong>对称性</strong><br><strong>传递性</strong><br><strong>一致性</strong><br><strong>与 null 的比较</strong></p><h4 id="equals-与">equals() 与 ==</h4><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><h4 id="实现">实现</h4><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><h3 id="hashCode">hashCode()</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><h3 id="toString">toString()</h3><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 <code>@</code> 后面的数值为散列码的无符号十六进制表示。</p><h3 id="clone">clone()</h3><h4 id="cloneable">cloneable</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><h4 id="浅拷贝">浅拷贝</h4><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><h4 id="深拷贝">深拷贝</h4><p>拷贝对象和原始对象的引用类型引用不同对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/language/java/java-ji-chu/java-ji-chu/"/>
      <url>/language/java/java-ji-chu/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1>Java 基础</h1><h2 id="Metadata-43">Metadata</h2><pre><code class="language-yml">title: Java 基础date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java 基础</code></pre><h2 id="【Java-基础】-面向对象">【Java 基础】 面向对象</h2><p>undefined</p><h2 id="【Java-基础】数据类型">【Java 基础】数据类型</h2><p>undefined</p><h2 id="【Java-基础】-泛型">【Java 基础】 泛型</h2><p>undefined</p><h2 id="【Java-基础】-注解">【Java 基础】 注解</h2><p>undefined</p><h2 id="【Java-基础】-反射">【Java 基础】 反射</h2><p>undefined</p><h2 id="【Java-基础】-异常">【Java 基础】 异常</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java 基础】数据类型</title>
      <link href="/language/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/"/>
      <url>/language/java/java-ji-chu/java-ji-chu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1>【Java 基础】数据类型</h1><h2 id="Metadata-49">Metadata</h2><pre><code class="language-yml">title: 【Java 基础】数据类型date: 2022-12-14 14:05tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Java/基础  - 细化主题/数据类型categories:  - Javakeywords:  - Java/基础  - 数据类型description: 数据类型</code></pre><h2 id="String">String</h2><h4 id="概览">概览</h4><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h4 id="不可变的好处">不可变的好处</h4><ol><li>可以缓存 hash 值</li><li>String Pool 的需要</li><li>安全性</li><li>线程安全</li></ol><h4 id="String-StringBuffer-and-StringBuilder">String, StringBuffer and StringBuilder</h4><ol><li>可变性</li></ol><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><ol start="2"><li>线程安全</li></ol><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="Object">Object</h2><h3 id="概览-2">概览</h3><pre><code class="language-java">public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable {}</code></pre><h3 id="Equals">Equals()</h3><h4 id="等价关系">等价关系</h4><p><strong>自反性</strong><br><strong>对称性</strong><br><strong>传递性</strong><br><strong>一致性</strong><br><strong>与 null 的比较</strong></p><h4 id="equals-与">equals() 与 ==</h4><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><h4 id="实现">实现</h4><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><h3 id="hashCode">hashCode()</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><h3 id="toString">toString()</h3><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 <code>@</code> 后面的数值为散列码的无符号十六进制表示。</p><h3 id="clone">clone()</h3><h4 id="cloneable">cloneable</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><h4 id="浅拷贝">浅拷贝</h4><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><h4 id="深拷贝">深拷贝</h4><p>拷贝对象和原始对象的引用类型引用不同对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java/基础 </tag>
            
            <tag> 细化主题/数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/java/java/"/>
      <url>/java/java/</url>
      
        <content type="html"><![CDATA[<h1>Java</h1><h2 id="Metadata-2">Metadata</h2><pre><code class="language-yml">title: Javadate: 2022-12-14 14:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</code></pre><h2 id="Java-基础">Java 基础</h2><p><a href="../java-ji-chu/java-ji-chu/">Java 基础</a></p><h2 id="Java-集合">Java 集合</h2><p><a href="../java-ji-he/java-ji-he/">Java 集合</a></p><h2 id="Java-多线程并发">Java 多线程并发</h2><p><a href="../java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa/">Java 多线程并发</a></p><h2 id="Java-JVM">Java JVM</h2><p><a href="../java-jvm/java-jvm/">Java JVM</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/language/java/java/"/>
      <url>/language/java/java/</url>
      
        <content type="html"><![CDATA[<h1>Java</h1><h2 id="Metadata-33">Metadata</h2><pre><code class="language-yml">title: Javadate: 2022-12-14 14:00tags:  - 行动阶段/完成  - 主题场景/编程  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace  - 细化主题/Javacategories:  - Javakeywords:  - Javadescription: Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</code></pre><h2 id="Java-基础">Java 基础</h2><p>undefined</p><h2 id="Java-集合">Java 集合</h2><p>undefined</p><h2 id="Java-多线程并发">Java 多线程并发</h2><p>undefined</p><h2 id="Java-JVM">Java JVM</h2><p>undefined</p><h2 id="Java-Web">Java Web</h2><p>undefined</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/编程 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace </tag>
            
            <tag> 细化主题/Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解 -Assertions 断言</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-assertions-duan-yan/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-assertions-duan-yan/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解 -Assertions 断言</h1><h2 id="Metadata-5">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解 -Assertions 断言date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/断言categories:  - JMeterkeywords:  - JMeter  - 组件  - 断言description: 断言用于对采样器执行额外的检查，并在相同范围内的每个采样器之后进行处理。要确保Assertion只应用于特定的采样器，请将其添加为该采样器的子元素。</code></pre><h2 id="Assertions-断言">Assertions | 断言</h2><p>断言用于对采样器执行额外的检查，并在相同范围内的每个采样器之后进行处理。要确保Assertion只应用于特定的采样器，请将其添加为该采样器的子元素。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:除非另有说明，断言不应用于子样本(子样本)—只应用于父样本。对于JSR223和BeanShell断言，脚本可以使用prev.getSubResults()方法检索子示例，该方法返回一个samplerresults数组。如果没有，则数组为空。</p></div><p>断言可以应用于主样例、子样例，也可以同时应用于两者。默认情况是只对主示例应用断言。如果Assertion支持此选项，那么GUI上会出现如下条目:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C43dcd57acadeb98ecb2d1d0e5096a5e3.png" alt></p></div><p>如果子采样器失败而主样本成功，则主样本将被设置为失败状态，并将添加断言结果。如果使用了JMeter变量选项，则假定它与主示例有关，任何失败都将只应用于主示例。</p><h3 id="Response-Assertion-响应断言">Response Assertion | 响应断言</h3><p>响应断言控制面板允许您添加模式字符串，以便与请求或响应的各种字段进行比较。模式字符串是:</p><ul><li><code>Contains, Matches</code>: Perl5-style正则表达式</li><li><code>Equals, Substring</code>: 纯文本,区分大小写</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cd48cec173c79631705b5dc72f79918af.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Apply to:</td><td>这是用于可以生成子样本的采样器，例如带有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。</td><td>Yes</td></tr><tr><td>Field to Test</td><td>指示JMeter测试请求或响应的哪个字段。</td><td>Yes</td></tr><tr><td>Ignore status</td><td>指示JMeter将初始状态设置为成功。</td><td>Yes</td></tr><tr><td>Pattern Matching Rules</td><td>指示如何根据模式检查被测试的文本。</td><td>Yes</td></tr><tr><td>Patterns to Test</td><td>要测试的模式列表。每个模式都是单独测试的。如果一个模式失败，则不会检查其他模式。使用多个模式设置一个断言与使用每个模式设置多个断言之间没有区别(假设其他选项相同)。</td><td>Yes</td></tr><tr><td>Custom failure message</td><td>允许您定义将替换生成的失败消息的失败消息</td><td>No</td></tr></tbody></table></div><h3 id="Duration-Assertion-断言持续时间">Duration Assertion | 断言持续时间</h3><p>持续时间断言测试是否在给定的时间内收到每个响应。任何超过给定毫秒数(由用户指定)的响应都被标记为失败的响应。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6848b3fb438834313ee585358d5ea3d7.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Duration in Milliseconds</td><td>在被标记为失败之前，允许每个响应的最大毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Size-Assertion-大小断言">Size Assertion | 大小断言</h3><p>大小断言测试每个响应中包含正确的字节数。可以指定大小等于、大于、小于或不等于给定字节数。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C16813019eccbc6c7461bd5122168683f.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Size in bytes</td><td>用于测试响应大小(或JMeter变量的值)的字节数。</td><td>Yes</td></tr><tr><td>Type of Comparison</td><td>是否测试响应是否等于、大于、小于或不等于指定的字节数。</td><td>Yes</td></tr></tbody></table></div><h3 id="XML-Assertion-XML-断言">XML Assertion | XML 断言</h3><p>XML断言测试响应数据由形式上正确的XML文档组成。它不基于DTD或模式验证XML，也不做任何进一步的验证。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C813fb287b364bfa545c3d3a8ec1c060a.png" alt></p></div><h3 id="BeanShell-Assertion-BeanShell-断言">BeanShell Assertion | BeanShell 断言</h3><p>BeanShell断言允许用户使用BeanShell脚本执行断言检查。</p><p>请注意，在测试脚本的每个线程中，断言的每个独立出现都使用不同的解释器，但后续调用使用相同的解释器。这意味着变量将在对断言的调用之间持久化。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C39526932dc308f283bd5884807864725.png" alt></p></div><h3 id="MD5Hex-Assertion-MD5Hex-断言">MD5Hex Assertion | MD5Hex 断言</h3><p>MD5Hex断言允许用户检查响应数据的MD5哈希值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca12d5ee2fc45124ba60f1b43f18685fc.png" alt></p></div><h3 id="HTML-Assertion-HTML-断言">HTML Assertion | HTML 断言</h3><p>HTML断言允许用户使用JTidy检查响应数据的HTML语法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C2526877b0515200861c2c2950455cca9.png" alt></p></div><h3 id="XPath-Assertion-XPath-断言">XPath Assertion | XPath 断言</h3><p>XPath断言测试文档的格式是否良好，可以根据DTD进行验证，也可以通过JTidy对文档进行XPath测试。如果XPath存在，断言为真。使用“<code>/</code>”将匹配任何格式良好的文档，并且是默认的XPath表达式。该断言还支持布尔表达式，如“<code>count(//*error)=2</code>”。有关XPath的更多信息，请参见http://www.w3.org/TR/xpath。</p><h3 id="Compare-Assertion-比较断言">Compare Assertion | 比较断言</h3><p>比较断言可用于在其范围内比较样本结果。可以比较内容或运行时间，并且可以在比较之前过滤内容。可以在比较断言可视化工具中看到断言比较。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C837dc552d4a8b425c36abd68d45351ac.png" alt></p></div><h3 id="JSON-Assertion-JSON-断言">JSON Assertion | JSON 断言</h3><p>该组件允许您执行JSON文档的验证。首先，它将解析JSON，如果数据不是JSON，则会失败。其次，它将搜索指定的路径，使用来自Jayway JsonPath 1.2.0的语法。如果没有找到路径，它将失败。第三，如果在文档中找到了JSON路径，并且请求对预期值进行验证，它将执行验证。对于空值，GUI中有一个特殊的复选框。注意，如果路径将返回数组对象，则将对其进行迭代，如果找到预期值，则断言将成功。要验证空数组，请使用<code>[]</code>string。此外，如果patch将返回字典对象，它将在比较之前被转换为字符串。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ccbc9c846557f6aa5e44884c749538fd3.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/断言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Logic Controllers 逻辑控制器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Logic Controllers 逻辑控制器</h1><h2 id="Metadata-6">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Logic Controllers 逻辑控制器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/控制器categories:  - JMeterkeywords:  - JMeter  - 组件  - 控制器description: 逻辑控制器决定了采样器被处理的顺序。</code></pre><h2 id="Logic-Controllers-逻辑控制器">Logic Controllers | 逻辑控制器</h2><p>逻辑控制器决定了采样器被处理的顺序。</p><h3 id="Simple-Controller-简单逻辑控制器">Simple Controller | 简单逻辑控制器</h3><p>简单逻辑控制器让你组织你的采样器和其他逻辑控制器。与其他逻辑控制器不同，此控制器除了存储设备之外不提供任何功能。</p><p>简单控制器可以将在其之下的所有组件，作为一个整体。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5b75893a30784a65622306cdd5eee7e5.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Loop-Controller-循环控制器">Loop Controller | 循环控制器</h3><p>如果你将生成或逻辑控制器添加到一个循环控制器，JMeter将通过它们循环一定的次数，除了你为线程组指定的循环值。例如，如果您添加一个循环次数为2的HTTP请求到一个循环控制器，并配置Thread Group循环次数为3,JMeter将总共发送2 * 3 = 6个HTTP请求。</p><p>JMeter将把循环索引作为一个名为<code>__jm__&lt;元素名&gt;__idx</code>的变量公开。例如，如果你的循环控制器名为LC，那么你可以通过<code>${__jm__LC__idx}</code>访问循环索引。索引从0开始</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cf2f9ef537a2838592a6a22213705163f.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Loop Count</td><td>这个控制器的子元素在每次测试运行中迭代的次数。&lt;/br&gt; 值-1相当于检查永远切换。</td><td>Yes, unless "Forever" is checked</td></tr></tbody></table></div><h3 id="Once-Only-Controller-仅一次控制器">Once Only Controller | 仅一次控制器</h3><p>Once Only逻辑控制器告诉JMeter每个线程只处理它内部的控制器一次，并在测试计划的进一步迭代期间传递它下面的任何请求。</p><p>Once Only控制器现在将始终在任何循环父控制器的第一次迭代期间执行。因此，如果Once Only控制器被放置在一个指定循环5次的环路控制器下，那么Once Only控制器将只在通过环路控制器的第一次迭代时执行(即每5次)。</p><p>注意，这意味着Once Only控制器的行为仍将与之前预期的一样</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca518627998462bc10d3a24c5274f70d5.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Interleave-Controller-交替控制器">Interleave Controller | 交替控制器</h3><p>如果你将生成或逻辑控制器添加到交错控制器中，JMeter将在每个循环迭代中交替使用其他控制器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">交替控制器</p><p><img src="/attachment%5C5c85cc68f4017a652e96d46c4efc05ef.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>ignore sub-controller blocks</td><td>如果选中此项，交错控制器将把子控制器当作单个请求元素来处理，并且每次只允许每个控制器一个请求。</td><td>No</td></tr><tr><td>交错跨线程</td><td>如果勾选，交错控制器将在每个循环迭代中交替使用其子控制器，但在所有线程中，例如，在4个线程和3个子控制器的配置中，在第一次迭代中，线程1将运行第一个子控制器，线程2第二子控制器，线程3第三子控制器，线程4第一个子控制器，在下一次迭代中，每个线程将运行下面的子控制器</td><td>No</td></tr></tbody></table></div><blockquote><p>注： 外部交错控制器在两个内部交错控制器之间交替。然后，每个内部交错控制器在每个HTTP请求之间交替。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p><img src="https://jmeter.apache.org/images/screenshots/logic-controller/interleave2.png" alt></p><p>如果交错控制器下 是两个交错控制器</p><p>Home Page, Interleaved, Bug Page, Interleaved, CVS Page, Interleaved, and FAQ Page, Interleaved.</p><p>如果交错主控制器下的两个交错控制器是简单控制器，那么顺序就是: Home Page, CVS Page, Interleaved, Bug Page, FAQ Page, Interleaved.</p></div><h3 id="Random-Controller-随机控制器">Random Controller | 随机控制器</h3><p>随机逻辑控制器的行为类似于交错控制器，不同的是，它不是按顺序通过其子控制器和采样器，而是在每次经过时随机选择一个。</p><blockquote><p>多个控制器之间的交互可以产生复杂的行为。随机控制器尤其如此。在你假设任何给定的相互作用会带来什么结果之前，先进行实验</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C267d5a22a02335f1421605825fb15764.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>ignore sub-controller blocks</td><td>如果选中此项，交错控制器将把子控制器当作单个请求元素来处理，并且每次只允许每个控制器一个请求。</td><td>No</td></tr></tbody></table></div><h3 id="Random-Order-Controller-随机顺序控制器">Random Order Controller | 随机顺序控制器</h3><p>Random Order Controller很像Simple Controller，因为它最多只执行每个子元素一次，但节点的执行顺序是随机的。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6330929ffafcc3c4a18de57586014b18.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Throughput-Controller-吞吐量控制器">Throughput Controller | 吞吐量控制器</h3><p>吞吐量控制器允许用户控制它的执行频率。有两种模式:</p><ul><li>百分比执行<ul><li>使控制器通过测试计划执行一定百分比的迭代。</li></ul></li><li>总数执行<ul><li>使控制器在执行了一定的次数后停止执行。</li></ul></li></ul><p>与Once Only控制器一样，当父回路控制器重启时，此设置将被重置。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C9f431050da107da7416d467b37b34adb.png" alt></p></div><blockquote><p>当与其他控制器组合时，吞吐量控制器可以产生非常复杂的行为——特别是与交错或随机控制器作为父控制器(也非常有用)。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Execution Style</td><td>控制器将以百分比执行模式还是总执行模式运行。</td><td>Yes</td></tr><tr><td>Throughput</td><td>一个数字。对于百分比执行模式，一个0-100的数字，表示控制器执行时间的百分比。"50"表示控制器将在测试计划的一半迭代中执行。对于总执行模式，number表示控制器将执行的总次数。</td><td>Yes</td></tr><tr><td>Per User</td><td>如果选中此选项，则per user将导致控制器计算是否应该以每个用户(每个线程)为基础执行。如果未选中，则计算将对所有用户是全局的。例如，如果使用总执行模式，而不选中"per user"，则给出的吞吐量数将是执行的总次数。如果检查了"每个用户"，那么执行的总数量将是用户数量乘以给定的吞吐量。</td><td>No</td></tr></tbody></table></div><h3 id="Runtime-Controller-运行时间控制器">Runtime Controller | 运行时间控制器</h3><p>运行时控制器控制其子程序的运行时间。控制器将运行其子控制器，直到超过配置的运行时为止。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3762bea8a2a37cdebb442a2309981c85.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>Yes</td></tr><tr><td>Runtime (seconds)</td><td>所需的运行时间(以秒为单位)。0表示不运行。</td><td>Yes</td></tr></tbody></table></div><h3 id="If-Controller-If-控制器">If Controller | If 控制器</h3><p>If控制器允许用户控制是否运行它(其子元素)下面的test元素。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C64b180d15fefb537f4d7776e828003f8.png" alt></p></div><p>默认情况下，条件只在初始条目上计算一次，但是您可以选择对控制器中包含的每个可运行元素进行计算。</p><p>最好的选项(默认选项)是检查 <code>Interpret Condition as Variable Expression?</code>，然后在条件字段中有两个选项:</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">选项1:使用包含true或false的变量</p><p>如果你想测试最后一个样本是否成功，你可以使用 <code>${JMeterThread.last_sample_ok}</code></p><p><img src="https://jmeter.apache.org/images/screenshots/if_controller_variable.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">选项2:使用函数(建议使用`${__jexl3()}`)来计算必须返回true或false的表达式</p><p><img src="https://jmeter.apache.org/images/screenshots/if_controller_expression.png" alt></p></div><p>例如，以前可以使用条件:<code>${__jexl3(${VAR} == 23)}</code>，这将被评估为true/false，然后将结果传递给JavaScript，然后返回true/false。如果选择了变量表达式，那么表达式将被计算并与"true"进行比较，而不需要使用JavaScript。</p><p>如果取消选择<code>Interpret Condition as Variable Expression?</code>， If Controller将在内部使用javascript来评估条件，这可能会造成非常大的性能损失，并使您的测试不太可伸缩。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Condition (default JavaScript)</td><td>默认情况下，该条件被解释为返回"true"或"false"的JavaScript代码，但这可以被重写(见下文)</td><td>Yes</td></tr><tr><td>Interpret Condition as Variable Expression?</td><td>如果选中此选项，那么条件必须是一个计算结果为"<code>true</code>"的表达式(忽略大小写)。例如，<code>${FOUND}</code>或<code>${__jexl3(${VAR} &amp;gt;100)}</code>。与JavaScript的大小写不同，只检查条件是否匹配"true"(大小写被忽略)。</td><td>Yes</td></tr><tr><td>Evaluate for all children</td><td>是否应该对所有 Children 进行状况评估?如果没有选中，则只在进入时对条件进行计算。</td><td>Yes</td></tr></tbody></table></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><ul><li><code>${__groovy(vars.get("myVar") != "Invalid" )}</code> (Groovy check myVar is not equal to Invalid)</li><li><code>${__groovy(vars.get("myInt").toInteger() &lt;=4 )}</code> (Groovy check myInt is less then or equal to 4)</li><li><code>${__groovy(vars.get("myMissing") != null )}</code> (Groovy check if the myMissing variable is not set)</li><li><code>${__jexl3(${COUNT} &lt; 10)}</code></li><li><code>${RESULT}</code></li><li><code>${JMeterThread.last_sample_ok}</code> (check if the last sample succeeded)</li></ul></div><h3 id="While-Controller-While-控制器">While Controller | While 控制器</h3><p>While控制器运行它的子控制器，直到条件为"false"。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb6ab801f14714f9176c2af3babdfb1d2.png" alt></p></div><p>JMeter将把循环索引作为一个名为<code>__jm__&lt;元素名&gt;__idx</code>的变量公开。例如，如果你的While控制器名为WC，那么你可以通过<code>${__jm__WC__idx}</code>访问循环索引。索引从0开始</p><p>可能的条件值:</p><ul><li>blank - 当循环中的最后一个样本失败时退出循环</li><li>LAST - 当循环中的最后一个样本失败时退出循环。如果循环之前的最后一个样本失败了，就不要进入循环。</li><li>Otherwise - 当条件等于字符串"false"时退出(或不进入)循环</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p>举例</p><ul><li><code>${VAR}</code> - VAR被其他测试元素设置为false</li><li><code>$ {__jexl3 ($ {C} = = 10)}</code></li><li><code>$ {__jexl3 (" $ {VAR2} " = = " abcd ")}</code></li><li><code>${_P(property)}</code> - property在其他地方设置为"false"</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>No</td></tr><tr><td>Condition</td><td>blank, LAST, or variable/function</td><td>No</td></tr></tbody></table></div><h3 id="Switch-Controller-选择控制器">Switch Controller | 选择控制器</h3><p>Switch Controller的行为类似于Interleave Controller，它在每次迭代中运行一个从属元素，但不是按顺序运行它们，而是运行由Switch值定义的元素。</p><blockquote><p>switch的值也可以是名称。</p></blockquote><p>如果开关值超出范围，它将运行第0个元素，因此充当数值情况的默认值。如果值是空字符串，它还运行第0个元素。<br>如果该值是非数字(且非空)，则Switch Controller查找同名元素(大小写重要)。如果名称都不匹配，则选择名为"<code>default</code>"的元素(大小写不重要)。如果没有默认值，则没有选择任何元素，控制器将不运行任何东西。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb8db55fa62d65dcfd7db3650b5ff12bd.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Switch Value</td><td>要调用的从属元素的编号(或名称)。元素从0开始编号。默认值为0</td><td>No</td></tr></tbody></table></div><h3 id="ForEach-Controller-ForEach控制器">ForEach Controller | ForEach控制器</h3><p>ForEach控制器循环遍历一组相关变量的值。当您向ForEach控制器添加采样器(或控制器)时，每个采样器(或控制器)将执行一次或多次，在每次循环期间，变量都有一个新值。输入应该由几个变量组成，每个变量都有一个下划线和一个数字。每个这样的变量都必须有一个值。例如，当输入变量名为<code>inputVar</code>时，应该定义以下变量:</p><ul><li>inputVar_1 = wendy</li><li>inputVar_2 = charles</li><li>inputVar_3 = peter</li><li>inputVar_4 = john</li></ul><p>当返回变量给定为"<code>returnVar</code>"时，ForEach控制器下的采样器和控制器的集合将连续执行4次，返回变量分别具有上述值，然后可以在采样器中使用。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cadd5994075ef8e32743f10bb4a63e643.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr><tr><td>Input variable prefix</td><td>用作输入的变量名的前缀。默认为一个空字符串作为前缀。</td><td>No</td></tr><tr><td>Start index for loop</td><td>循环遍历变量的起始索引(独占)(第一个元素在起始索引+ 1处)</td><td>No</td></tr><tr><td>End index for loop</td><td>结束变量循环索引(包括)</td><td>No</td></tr><tr><td>Output variable</td><td>变量的名称，该变量可以在循环中用于在采样器中替换。默认为空变量名，这很可能是不需要的。</td><td>No</td></tr><tr><td>Use Separator</td><td>如果不勾选，则省略"<code>_</code>"分隔符。</td><td>Yes</td></tr></tbody></table></div><h3 id="Module-Controller-模块控制器">Module Controller | 模块控制器</h3><p>模块控制器提供了一种在运行时将测试计划片段替换为当前测试计划的机制。</p><p>一个测试计划片段由一个控制器和它包含的所有测试元素(采样器等)组成。片段可以位于任何线程组中。如果片段位于一个线程组中，那么它的控制器可以被禁用，以防止除了模块控制器之外的片段运行。或者您可以将片段存储在一个虚拟线程组中，并禁用整个线程组。</p><p>可以有多个碎片，每个碎片下都有不同系列的采样器。通过在下拉框中选择适当的控制器，模块控制器就可以轻松地在这些多个测试用例之间切换。这为快速轻松地运行许多备用测试计划提供了便利。</p><p><strong>模块控制器使用的任何片段都必须有一个唯一的名称</strong>，因为该名称用于在重新加载测试计划时找到目标控制器。由于这个原因，最好确保Controller名称从默认更改为Controller名称，否则在向测试计划添加新元素时可能会意外创建副本。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5923e6dbb68b425da6d5685f2918c08a.png" alt></p></div><h3 id="Transaction-Controller-事务控制器">Transaction Controller | 事务控制器</h3><p>事务控制器生成一个额外的示例，用于度量执行嵌套测试元素所花费的总时间。</p><blockquote><p>注意:当勾选"包含生成样本中定时器和前后处理器的持续时间"复选框时，该时间包括控制器范围内的所有处理，而不仅仅是样本。</p></blockquote><p>有两种操作模式:</p><ul><li>在嵌套样例之后添加附加样例</li><li>附加样例作为嵌套样例的父类添加</li></ul><p>生成的采样时间包括所有嵌套采样的时间，不包括默认的(自2.11起)计时器和前后处理器的处理时间，除非选中了 <code>Include duration of timer and pre-post processors in generated sample</code> (包括生成样本中的计时器和前后处理器的持续时间)复选框。根据时钟分辨率的不同，它可能比单个采样器加计时器的总和稍长。时钟可能在控制器记录开始时间后滴答作响，但在第一个样本开始之前。最后也是一样。</p><p>只有在所有子样本都成功的情况下，生成的样本才被认为是成功的。</p><blockquote><p>在父模式中，断言(等等)可以添加到事务控制器。但是默认情况下，它们将同时应用于单个示例和整个事务示例。为了限制断言的范围，可以使用一个简单控制器来包含示例，并将断言添加到简单控制器。父模式控制器目前不支持任何类型的嵌套事务控制器。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cad75c9a98968eb36d939f9c9a7996ebb.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称，用于命名事务。</td><td>Yes</td></tr><tr><td>Generate Parent Sample</td><td>生成父样本</td><td>Yes</td></tr><tr><td>Include duration of timer and pre-post processors in generated sample</td><td>是否在生成的样本中包括定时器、预处理和后处理延迟。默认的是假的</td><td>Yes</td></tr></tbody></table><h3 id="Recording-Controller-记录控制器">Recording Controller | 记录控制器</h3><p>记录控制器是一个占位符，指示代理服务器应该将样本记录到何处。在测试运行期间，它没有效果，类似于简单控制器。但是在使用HTTP(S)测试脚本记录器进行记录的过程中，所有记录的样本将默认保存在记录控制器下。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C949ce70f7f1c76f11507f448576da701.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的控制器的描述性名称。</td><td>No</td></tr></tbody></table></div><h3 id="Critical-Section-Controller-临界区控制器">Critical Section Controller | 临界区控制器</h3><p>临界区控制器确保它的子元素(采样/控制器等)将只被一个线程执行，因为在执行控制器的子元素之前会获取一个命名锁。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C4a78d82bcdd498f4c60ceae7fd93685c.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Listeners 监听器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Listeners 监听器</h1><h2 id="Metadata-7">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Listeners 监听器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/监听器categories:  - JMeterkeywords:  - JMeter  - 组件  - 监听器description: 监听结果，还提供了查看、保存和读取保存的测试结果的方法。</code></pre><h2 id="Listeners-监听器">Listeners | 监听器</h2><p>除了"听"测试结果之外，大多数监听器还扮演着几个角色。它们还提供了查看、保存和读取保存的测试结果的方法。</p><p>注意，侦听器在找到它们的范围的末尾处理。</p><p>测试结果的保存和读取是通用的。各种侦听器都有一个面板，可以通过该面板指定将结果写入(或读取)的文件。默认情况下，结果存储为XML文件，通常带有 <code>.jtl</code> 扩展。将其存储为CSV是最有效的选项，但没有XML(另一种可用选项)详细。</p><p>**侦听器不会在CLI模式下处理示例数据，但是如果配置了输出文件，则会保存原始数据。**为了分析CLI运行生成的数据，您需要将文件加载到适当的Listener中。</p><blockquote><p>要读取现有结果并显示它们，请使用文件面板Browse按钮打开文件。</p></blockquote><p>如果您想在加载一个新文件之前清除任何当前数据，请在加载文件之前使用菜单项<code>Run→clear (Ctrl + Shift + E)</code>或<code>Run→clear All (Ctrl + E)</code>。</p><p>结果可以从XML或CSV格式文件中读取。当读取CSV结果文件时，使用头(如果存在)来确定存在哪些字段。为了正确地解释<code>无头CSV</code>文件，必须在<code>jmeter.properties</code>中设置适当的属性。</p><p><strong>如果样本很多，监听器会占用大量内存</strong>。为尽量减少所需的内存，请使用<code>Simple Data Writer</code>，并使用<code>CSV</code>格式。</p><h3 id="Simple-Data-Writer-简单数据写入器">Simple Data Writer | 简单数据写入器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3d0ba23ab6cc18a90fd6043e33bda676.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Filename</td><td>包含示例结果的文件的名称。可以使用相对路径名或绝对路径名指定文件名。相对路径是相对于当前工作目录解析的(默认为bin/目录)。JMeter还支持相对于包含当前测试计划(JMX文件)的目录的路径。如果路径名以"~/"(或jmeter.save.saveservice。base_prefix JMeter属性)，则假定路径相对于JMX文件位置。</td><td>No</td></tr><tr><td>Browse</td><td>文件浏览按钮</td><td>No</td></tr><tr><td>Errors</td><td>选择此选项将导致只写/读的结果带有错误</td><td>No</td></tr><tr><td>Success</td><td>选择这个选项，只写/读结果，不出错。如果既没有选择Errors也没有选择successful，那么将处理所有结果。</td><td>No</td></tr><tr><td>Configure</td><td>配置按钮，参见下面</td><td>No</td></tr></tbody></table><h3 id="Graph-Results-图结果">Graph Results  | 图结果</h3><blockquote><p>图结果绝对不能在负载测试期间使用，因为它会消耗大量资源(内存和CPU)。只在功能测试或测试计划调试和验证期间使用它。</p></blockquote><p>Graph Results侦听器生成一个简单的图来绘制所有样本时间。在图的底部，以毫秒为单位显示当前样本(黑色)、所有样本的当前平均值(蓝色)、当前标准差(红色)和当前吞吐量率(绿色)。</p><p>吞吐量数字表示服务器每分钟处理的实际请求数。这个计算包括您添加到测试中的任何延迟和JMeter自己的内部处理时间。这样计算的好处是，这个数字代表真实的东西—您的服务器所在的东西</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C70bba1717e63c269deee6df4487e92de.png" alt></p></div><p>下表简要描述了图表中的项目。关于统计术语的精确含义的进一步细节可以在网上找到，如维基百科，或通过查阅统计书籍。</p><p>Data - 绘制实际数据值<br>Average - 绘制平均值<br>Median - 绘制中位数(中间值)<br>Deviation - 绘制标准差(一种变化的度量)<br>Throughput - 绘制出单位时间内的样本数量</p><h3 id="Assertion-Results-断言结果">Assertion Results | 断言结果</h3><blockquote><p>在负载测试期间绝对不能使用断言结果，因为它会消耗大量资源(内存和CPU)。只在功能测试或测试计划调试和验证期间使用它。</p></blockquote><p>Assertion Results可视化工具显示每个样本的Label。它还报告测试计划中任何断言的失败。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C65fc9b6fb51159cbd447672860b3b5f3.png" alt></p></div><h3 id="View-Results-Tree-查看结果树">View Results Tree | 查看结果树</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C331167fcf04e16b77e624fa176f61cb5.png" alt></p></div><p>视图结果树显示所有示例响应的树，允许您查看任何示例的响应。除了显示响应之外，您还可以看到获取此响应所需的时间和一些响应代码。请注意，请求面板只显示JMeter添加的标题。它不显示HTTP协议实现可能添加的任何报头(如Host)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Renderer</th><th>Description</th></tr></thead><tbody><tr><td>CSS/JQuery Tester</td><td>CSS/JQuery测试器只适用于文本响应。它在上面的面板中显示纯文本。"测试"按钮允许用户将CSS/JQuery应用到上面的面板，结果将显示在下面的面板。CSS/JQuery表达式引擎可以是JSoup或Jodd，这两种实现的语法略有不同。&lt;/br&gt; 例如，将href属性应用到当前JMeter函数页面的Selector a[class=sectionlink]会给出如下输出: &lt;/br&gt; Match count: 74 &lt;/br&gt; Match[1]=<code>#functions</code> &lt;/br&gt; Match[2]=<code>#what_can_do</code> &lt;/br&gt; Match[3]=<code>#where</code> &lt;/br&gt; Match[4]=<code>#how</code> &lt;/br&gt; Match[5]=<code>#function_helper</code> &lt;/br&gt; Match[6]=<code>#functions</code> &lt;/br&gt; Match[7]=<code>#__regexFunction</code> Match[8]=<code>#__regexFunction_parms</code> &lt;/br&gt; Match[9]=<code>#__counter</code> &lt;/br&gt; … and so on …</td></tr><tr><td>Document</td><td>文档视图将显示从各种类型的文档中提取的文本，如Microsoft Office(Word, Excel, PowerPoint 97-2003, 2007-2010 (openxml)， Apache OpenOffice (writer, calc, impress)， HTML, gzip, jar/zip文件(内容列表)，以及一些"多媒体"文件的元数据，如mp3, mp4, flv等。完整的支持格式列表可以在Apache Tika格式页面上找到。&lt;/br&gt; &gt; Document视图的一个要求是下载Apache Tika二进制包(Tika -app-x.x.jar)，并将其放在JMETER_HOME/lib目录中。&lt;/br&gt;如果文档大于10mb，则不显示。要更改此限制，请设置JMeter属性文档。Max_size(单位为字节)或设置为0以删除限制。</td></tr><tr><td>HTML</td><td>HTML视图试图将响应呈现为HTML。渲染的HTML很可能比较差，一个人会在任何web浏览器获得的视图;然而，它确实提供了一个快速的近似值，有助于初步结果的评估。不下载图像、样式表等。</td></tr><tr><td>HTML (download resources)</td><td>如果选择了 HTML（下载资源）视图选项，则渲染器可以下载 HTML 代码引用的图像、样式表等。</td></tr><tr><td>HTML Source formatted</td><td>如果选择了 HTML Source formatted view 选项，渲染器将显示由 Jsoup 格式化和清理的 HTML 源代码。</td></tr><tr><td>JSON</td><td>JSON 视图将以树形样式显示响应（也处理嵌入在 JavaScript 中的 JSON）。</td></tr><tr><td>JSON Path Tester</td><td>JSON Path Tester 视图将让您测试您的 JSON-PATH 表达式并查看从特定响应中提取的数据。</td></tr><tr><td>JSON JMESPath Tester</td><td>JSON JMESPath Tester 视图将让您测试 JMESPath 表达式并查看从特定响应中提取的数据。</td></tr><tr><td>Regexp Tester</td><td>Regexp Tester 视图仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将正则表达式应用到上面板，结果将显示在下面板中。 正则表达式引擎与正则表达式提取器中使用的引擎相同。 例如，应用于当前 JMeter 主页的 <code>RE (JMeter\w*).*</code> 会给出以下输出： &lt;/br&gt; <code>Match count: 26</code> &lt;/br&gt; <code>Match[1][0]=JMeter - Apache JMeter &lt;/title&gt;</code> &lt;/br&gt; <code>Match[1][1]=JMeter</code> &lt;/br&gt; <code>Match[2][0]=JMeter" title="JMeter" border="0"&gt;&lt;/a&gt;</code> &lt;/br&gt; <code>Match[2][1]=JMeter</code> &lt;/br&gt; <code>Match[3][0]=JMeterCommitters"&gt;Contributors&lt;/a&gt;</code> &lt;/br&gt; <code>Match[3][1]=JMeterCommitters</code> &lt;/br&gt;… and so on … &lt;/br&gt; []中的第一个数字是匹配号； 第二个数字是组。 组 [0] 是与整个 RE 匹配的任何内容。 组 [1] 是与第一组匹配的任何内容，即在这种情况下为 <code>(JMeter\w*)</code>。</td></tr><tr><td>Text</td><td>默认文本视图显示响应中包含的所有文本。 请注意，这仅在响应内容类型被视为文本时才有效。 如果 content-type 以下列任何一种开头，则认为是二进制，否则认为是文本。 &lt;/br&gt; image/ &lt;/br&gt; audio/ &lt;/br&gt; video/</td></tr><tr><td>XML</td><td>XML 视图将以树形样式显示响应。 任何 DTD 节点或 Prolog 节点都不会出现在树中； 但是，响应可能包含这些节点。 您可以右键单击任何节点并展开或折叠其下方的所有节点。</td></tr><tr><td>XPath Tester</td><td>XPath 测试器仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将 XPath 查询应用到上面板，结果将显示在下面板中。</td></tr><tr><td>Boundary Extractor Tester</td><td>边界提取器测试器仅适用于文本响应。 它在上面板中显示纯文本。 "测试"按钮允许用户将边界提取器查询应用到上面板，结果将显示在下面板中。</td></tr></tbody></table></div><p>使用Search选项，大多数视图还允许搜索显示的数据;搜索结果将在上面的显示中高亮显示。例如下面的控制面板截图显示了搜索"Java"的结果。注意，搜索对可见文本进行操作，因此在搜索text和HTML视图时，您可能会得到不同的结果。</p><p>注意:正则表达式使用Java引擎(而不是像正则表达式提取器或Regexp Tester视图那样的ORO引擎)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">举例</p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_xml.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_regex.png" alt></p><p><img src="https://jmeter.apache.org/images/screenshots/view_results_tree_document.png" alt></p></div><h3 id="Aggregate-Report-汇总报告">Aggregate Report | 汇总报告</h3><p>聚合报告为测试中的每个不同名称的请求创建一个表行。对于每个请求，它汇总响应信息，并提供请求计数、最小、最大、平均、错误率、大致吞吐量(请求/秒)和每秒千字节吞吐量。一旦测试完成，吞吐量就是整个测试期间的实际吞吐量。</p><p>吞吐量是从采样器目标的角度计算的(例如，在HTTP采样的情况下，远程服务器)。JMeter会考虑生成请求的总时间。如果其他采样器和计时器在同一个线程中，这将增加总时间，从而降低吞吐量值。所以两个名称不同的相同采样器的吞吐量是两个名称相同的采样器的一半。正确选择采样器名称以从聚合报告中获得最佳结果是很重要的。</p><p>计算中位数和90 % Line(第90百分位)值需要额外的内存。JMeter现在结合了具有相同运行时间的示例，因此使用的内存更少。然而，对于花费超过几秒的样本，概率是更少的样本将有相同的时间，在这种情况下，将需要更多的内存。注意，您可以在之后使用这个侦听器重新加载CSV或XML结果文件，这是避免性能影响的推荐方法。参见摘要报告了解类似的监听器，该监听器不存储单个示例，因此需要固定的内存。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca64d56f2914c2724d59c566b94769543.png" alt></p></div><ul><li><code>Label</code> - 样品的标签。如果选择<code>Include group name in label?</code>，则将线程组的名称作为前缀添加。这允许在需要时分别对来自不同线程组的相同标签进行排序。</li><li><code># Samples</code> - 相同标签的样品数量</li><li><code>Average</code> - 一组结果的平均时间</li><li><code>Median</code> - 中位数是一组结果中间的时间。50 %的样本不超过这次;剩下的至少花了同样长的时间。</li><li><code>90% Line</code> - 90 %的样本不超过这次。剩下的样本至少花了这么长时间。(90)</li><li><code>95% Line</code> - 95 %的样本不超过这次。剩下的样本至少花了这么长时间。(95)</li><li><code>99% Line</code> - 99% %的样本不超过这次。剩下的样本至少花了这么长时间。(99)</li><li><code>Min</code> - 相同标签的样品时间最短</li><li><code>Max</code> - 相同标签的样品时间最长</li><li><code>Error %</code> - 请求错误的百分比</li><li><code>Throughput</code> - 吞吐量以每秒/分钟/小时的请求数来衡量。选择时间单位使显示的速率至少为1.0。当吞吐量被保存到一个CSV文件时，它被表示为请求/秒，即30.0请求/分钟被保存为0.5。</li><li><code>Received KB/sec</code> - 以每秒接收千字节为单位的吞吐量</li><li><code>Sent KB/sec</code> - 以每秒发送千字节为单位的吞吐量</li></ul><p>Times are in milliseconds.</p><h3 id="View-Results-in-Table-用表格查看结果">View Results in Table | 用表格查看结果</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cdc2cf9f66bfeb7ce18f87d258912228a.png" alt></p></div><p>这个可视化工具为每个示例结果创建一行。与View Results Tree一样，这个可视化工具也使用大量内存。</p><p>默认情况下，它只显示主(父)样例;它不显示子样本(子样本)。JMeter有一个"Child Samples?"复选框。如果选中此选项，则显示子样本而不是主样本。</p><h3 id="Simple-Data-Writer-简单数据写入器-2">Simple Data Writer | 简单数据写入器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfd590e5f3b82b4b58e0765ca686ad7bd.png" alt></p></div><p>这个侦听器可以将结果记录到文件中，但不能记录到UI中。它旨在通过消除GUI开销来提供记录数据的有效方法。在CLI模式下运行时，可以使用<code>-l</code>标志创建数据文件。要保存的字段是由JMeter属性定义的。看到 <code>jmeter.properties</code> 查看详细信息。</p><h3 id="Aggregate-Graph-汇总图">Aggregate Graph | 汇总图</h3><p>聚合图类似于聚合报告。主要的区别是聚合图提供了一种简单的方法来生成条形图并将图保存为PNG文件。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7f01d0b57ce976023f98bd370d6c84c4.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Column settings</td><td>- <code>Columns to display:</code> 选择要在图形中显示的列。 &lt;/br&gt; - <code>Rectangles color:</code> 点击右边的颜色矩形打开一个弹出对话框，为列选择一个自定义的颜色。 &lt;/br&gt; - <code>Foreground color</code> 允许改变值文本颜色。 &lt;/br&gt; - <code>Value font:</code> 允许定义文本的字体设置。 &lt;/br&gt; - <code>Draw outlines bar?</code> 在柱状图上画或不画边线 &lt;/br&gt; - <code>Show number grouping?</code> 是否显示Y轴标签中的数字分组。 &lt;/br&gt;  - <code>Value labels vertical?</code> 更改值标签的方向。(默认是水平) &lt;/br&gt; - <code>Column label selection:</code> 根据结果标签进行筛选。可以使用正则表达式，例如: <code>.*Transaction.*</code> 在显示图形之前，单击<code>Apply filter</code>按钮以刷新内部数据。</td><td>Yes</td></tr><tr><td>Title</td><td>在图表的头部定义图表的标题。空值为默认值:"聚合图"。Synchronize with name按钮用监听器的标签定义标题。并定义图形标题的字体设置</td><td>No</td></tr><tr><td>Graph size</td><td>根据当前JMeter窗口大小的宽度和高度计算图形大小。使用宽度和高度字段定义自定义大小。单位为像素。</td><td>No</td></tr><tr><td>X Axis settings</td><td>定义X轴标签的最大长度(像素)。</td><td>No</td></tr><tr><td>Y Axis settings</td><td>为Y轴定义一个自定义最大值。</td><td>No</td></tr><tr><td>Legend</td><td>定义图表图例的位置和字体设置</td><td>Yes</td></tr></tbody></table></div><h3 id="Response-Time-Graph-响应时间图">Response Time Graph | 响应时间图</h3><p>响应时间图绘制了一个折线图，显示了测试期间每个标记的请求响应时间的演变。如果同一时间戳存在多个样本，则显示平均值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cad233a5e67ca717331f26c4c3033e4d6.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Interval (ms)</td><td>X轴间隔的时间，以毫秒为单位。样本根据这个值分组。在显示图形之前，单击应用间隔按钮来刷新内部数据。</td><td>Yes</td></tr><tr><td>Sampler label selection</td><td>根据结果标签进行筛选。可以使用正则表达式，例如:<code>*Transaction.*</code>。在显示图形之前，单击Apply filter按钮以刷新内部数据。</td><td>No</td></tr><tr><td>Title</td><td>在图表的头部定义图表的标题。空值为默认值:"响应时间图"。Synchronize with name按钮用监听器的标签定义标题。并定义图形标题的字体设置</td><td>No</td></tr><tr><td>Line settings</td><td>定义线的宽度。定义每个值点的类型。选择none将有一条没有标记的线</td><td>Yes</td></tr><tr><td>Graph size</td><td>根据当前JMeter窗口大小的宽度和高度计算图形大小。使用宽度和高度字段定义自定义大小。单位为像素。</td><td>No</td></tr><tr><td>X Axis settings</td><td>定制X轴标签的日期格式。语法是Java SimpleDateFormat API。</td><td>No</td></tr><tr><td>Y Axis settings</td><td>以毫秒为单位定义Y轴的自定义最大值。显示或不显示Y轴标签中的数字分组。</td><td>No</td></tr><tr><td>Legend</td><td>定义图表图例的位置和字体设置</td><td>Yes</td></tr></tbody></table></div><h3 id="Summary-Report-汇总报告">Summary Report | 汇总报告</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb55b93e85bb21e37fd31f53c9422e9fb.png" alt></p></div><p>摘要报告为测试中的每个不同名称的请求创建一个表行。这类似于聚合报告，只是它使用更少的内存。</p><p>吞吐量是从采样器目标的角度计算的(例如，在HTTP采样的情况下，远程服务器)。JMeter会考虑生成请求的总时间。如果其他采样器和计时器在同一个线程中，这将增加总时间，从而降低吞吐量值。所以两个名称不同的相同采样器的吞吐量是两个名称相同的采样器的一半。正确选择取样器标签是很重要的，以便从报告中得到最好的结果。</p><ul><li><code>Label</code> - 样品的标签。如果选择<code>Include group name in label?</code>，则将线程组的名称作为前缀添加。这允许在需要时分别对来自不同线程组的相同标签进行排序。</li><li><code># Samples</code> - 相同标签的样品数量</li><li><code>Average</code> - 一组结果的平均时间</li><li><code>Min</code> - 相同标签的样品时间最短</li><li><code>Max</code> - 相同标签的样品时间最长</li><li><code>Std. Dev.</code> - 样本运行时间的标准偏差</li><li><code>Error %</code> - 请求错误的百分比</li><li><code>Throughput</code> - 吞吐量以每秒/分钟/小时的请求数来衡量。选择时间单位使显示的速率至少为1.0。当吞吐量被保存到一个CSV文件时，它被表示为请求/秒，即30.0请求/分钟被保存为0.5。</li><li><code>Received KB/sec</code> - 以每秒接收千字节为单位的吞吐量</li><li><code>Sent KB/sec</code> - 以每秒发送千字节为单位的吞吐量</li><li><code>Avg. Bytes</code> - 样本响应的平均大小(以字节为单位)。</li></ul><h3 id="Save-Responses-to-a-file-保存响应到文件">Save Responses to a file | 保存响应到文件</h3><p>这个测试元素可以放置在测试计划中的任何地方。对于其范围内的每个示例，它将创建一个响应Data文件。它的主要用途是创建功能测试，但当响应太大而无法在"视图结果树侦听器"中显示时，它也很有用。文件名是从指定的前缀加上一个数字创建的(除非禁用了这个前缀，请参阅下面的内容)。文件扩展名根据文档类型创建(如果已知的话)。如果不知道，文件扩展名设置为’unknown’。如果禁用了编号，并且禁用了添加后缀，那么文件前缀将被用作整个文件名。这允许在需要时生成一个固定的文件名。生成的文件名存储在示例响应中，如果需要，可以保存在测试日志输出文件中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb01b3cb405edec2c42945587bbc5a86a.png" alt></p></div><h3 id="Generate-Summary-Results-生成概要结果">Generate Summary Results | 生成概要结果</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7f24cca56183626429571f7c033363ca.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/监听器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Pre-Processors 前置处理器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Pre-Processors 前置处理器</h1><h2 id="Metadata-8">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Pre-Processors 前置处理器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/处理器categories:  - JMeterkeywords:  - JMeter  - 组件  - 处理器description: 预处理器用于在其范围内修改采样器。</code></pre><h2 id="Pre-Processors-前置处理器">Pre Processors | 前置处理器</h2><p>预处理器用于在其范围内修改采样器。</p><h3 id="HTML-Link-Parser-HTML-链接解析器">HTML Link Parser | HTML 链接解析器</h3><p>这个修饰符解析来自服务器的HTML响应并提取链接和表单。通过此修饰符的URL测试示例将被检查，以确定它是否“匹配”从上一个立即响应中提取的任何链接或表单。然后，它将用匹配链接或表单中的适当值替换URL测试示例中的值。perl类型的正则表达式用于查找匹配。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ceaa6a9fdad32bfe0dd77ac9b87804da4.png" alt></p></div><p>使用协议、主机、路径和参数名称进行匹配。目标采样器不能包含响应链接中没有的参数。</p><h3 id="HTTP-URL-Re-writing-Modifier-HTTP-重写修饰符">HTTP URL Re-writing Modifier | HTTP 重写修饰符</h3><p>这个修饰符的工作原理与HTML Link Parser类似，只是它有一个特定的用途，它比HTML Link Parser更容易使用，而且更高效。对于使用URL重写来存储会话id而不是Cookie的web应用程序，这个元素可以附加在ThreadGroup级别，就像HTTP Cookie Manager一样。只需给它指定会话id参数的名称，它就会在页面上找到它，并将该参数添加到该ThreadGroup的每个请求中。</p><p>或者，这个修饰符可以附加到选择请求，它将只修改它们。聪明的用户甚至会确定这个修饰符可以用来获取避开HTML链接解析器的值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C7deb56f9f97a3e9528764e2af1912256.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>测试树中这个元素的描述性名称。</td><td>No</td></tr><tr><td>Session Argument Name</td><td>要从以前的响应中获取的参数的名称。该修饰符将在页面上任何存在参数的地方找到参数，并获取分配给它的值，无论它是在HREF或表单中。</td><td>Yes</td></tr><tr><td>Path Extension</td><td>一些web应用程序通过添加分号和会话id参数来重写url。如果是这样，请勾选此框。</td><td>No</td></tr><tr><td>Do not use equals in path extension</td><td>一些web应用程序重写url时不需要在参数名和值之间使用"="符号(如Intershop Enfinity)。</td><td>No</td></tr><tr><td>Do not use questionmark in path extension</td><td>防止查询字符串结束在路径扩展(如Intershop Enfinity)。</td><td>No</td></tr><tr><td>Cache Session Id?</td><td>当会话Id不存在时，是否应该保存会话Id的值以备以后使用?</td><td>Yes</td></tr><tr><td>URL Encode</td><td>URL写入参数时的编码值</td><td>No</td></tr></tbody></table></div><h3 id="User-Parameters-用户参数">User Parameters | 用户参数</h3><p>允许用户指定特定于单个线程的用户变量值。</p><p>用户变量也可以在Test Plan中指定，但不是特定于单个线程。此面板允许您为任意用户变量指定一系列值。对于每个线程，将按顺序为变量分配序列中的一个值。如果线程比值多，则重用值。例如，这可以用来为每个线程分配一个不同的用户id。用户变量可以在任何JMeter组件的任何字段中引用。</p><p>通过单击面板底部的“添加变量”按钮，并在“name:”列中填写变量名称，可以指定变量。要向系列添加新值，请单击“添加用户”按钮，并在新添加的列中填写所需的值。</p><p>可以使用函数语法:<code>${variable}</code>在同一线程组中的任何测试组件中访问值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">参数</p><p><img src="/attachment%5Ca3098c8fa35a478a9efda43f7869bfa4.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Post-Processors 后置处理器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Post-Processors 后置处理器</h1><h2 id="Metadata-9">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Post-Processors 后置处理器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/处理器categories:  - JMeterkeywords:  - JMeter  - 组件  - 处理器description: 后处理器应用于采样器之后。请注意，它们应用于相同范围内的所有采样器，因此要确保后处理器只应用于特定的采样器，请将其添加为该采样器的子级。</code></pre><h2 id="Post-Processors-后置处理器">Post Processors | 后置处理器</h2><p>顾名思义，后处理器应用于采样器之后。请注意，它们应用于相同范围内的所有采样器，因此要确保后处理器只应用于特定的采样器，请将其添加为该采样器的子级。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:除非另有说明，否则后处理程序不会应用于子样本(子样本)-只适用于父样本。对于JSR223和BeanShell后处理器，脚本可以使用prev.getSubResults()方法检索子示例，该方法返回一个samplerresults数组。如果没有，则数组为空。</p></div><p>后处理器在断言之前运行，因此它们不能访问任何断言结果，示例状态也不能反映任何断言的结果。如果您需要访问断言结果，请尝试使用侦听器。还要注意变量JMeterThread。在运行所有断言之后，last_sample_ok设置为“true”或“false”。</p><h3 id="Regular-Expression-Extractor-正则表达式提取器">Regular Expression Extractor | 正则表达式提取器</h3><p>允许用户使用perl类型的正则表达式从服务器响应中提取值。作为一个后处理器，该元素将在其范围内的每个Sample请求之后执行，应用正则表达式，提取请求的值，生成模板字符串，并将结果存储到给定的变量名中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C63a8726b7e5b75834e0dcefadfce8b6a.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称</td><td>No</td></tr><tr><td>Apply to:</td><td>这是用于可以生成子样本的采样器，例如带有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。</td><td>Yes</td></tr><tr><td>Field to check</td><td><code>Body</code>  <code>Body (unescaped)</code> <code>Body as a Document</code>   <code>Request Headers</code>        <code>Response Headers</code>   <code>URL</code>   <code>Response Code</code>  <code>Response Message</code></td><td>Yes</td></tr><tr><td>Name of created variable</td><td>要在其中存储结果的JMeter变量的名称。还要注意，每个组都存储为<code>[refname]_g#</code>，其中<code>[refname]</code>是作为引用名输入的字符串，<code>#</code>是组号，其中<code>组0</code>是整个匹配，<code>组1</code>是来自第一组圆括号的匹配，等等。</td><td>Yes</td></tr><tr><td>Regular Expression</td><td>用于解析响应数据的正则表达式。这必须包含至少一组圆括号“()”来捕获字符串的一部分，除非使用组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。不要将表达式包含在/ /中——当然，除非您也想匹配这些字符。</td><td>Yes</td></tr><tr><td>Template</td><td>用于根据找到的匹配项创建字符串的模板。这是一个任意字符串，其中包含用于引用正则表达式中的组的特殊元素。表示组的语法是:'<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>'表示组1，'<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>'表示组2，等等。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>表示整个表达式匹配的任何内容。</td><td>Yes</td></tr><tr><td>Match No. (0 for Random)</td><td>指示要使用哪个匹配。正则表达式可以匹配多次。 -1表示全部</td><td>Yes</td></tr><tr><td>Default Value</td><td>如果正则表达式不匹配，那么引用变量将被设置为默认值。这对于调试测试特别有用。如果没有提供缺省值，那么很难判断是正则表达式不匹配，还是没有处理RE元素，或者可能使用了错误的变量。</td><td>No, but recommended</td></tr><tr><td>Use empty default value</td><td>如果复选框被选中并且默认值为空，那么JMeter将把变量设置为空字符串，而不是不设置它。因此，当你在你的测试计划中使用<code>${var}</code>(如果引用名称是var)时，如果没有找到提取的值，那么<code>${var}</code>将等于空字符串，而不是包含<code>${var}</code>，如果提取的值是可选的，它可能是有用的。</td><td>No</td></tr></tbody></table></div><h3 id="CSS-JQuery-Extractor-CSS-JQuery-提取器">CSS/JQuery Extractor  | CSS/JQuery 提取器</h3><p>允许用户使用CSS选择器语法从服务器HTML响应中提取值。作为一个后处理器，该元素将在其范围内的每个Sample请求之后执行，应用CSS/JQuery表达式，提取被请求的节点，提取节点作为文本或属性值，并将结果存储到给定的变量名中。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C11a88c2a90612ebd0679902ccc96a469.png" alt></p></div><h3 id="Result-Status-Action-Handler-结果状态处理器">Result Status Action Handler | 结果状态处理器</h3><p>如果相关的采样器失败，这个test元素允许用户停止线程或整个测试。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C5eb30e766f2119f8ff0da88fd90c4cbd.png" alt></p></div><h3 id="JSON-Extractor-JSON-提取器">JSON Extractor | JSON 提取器</h3><p>JSON PostProcessor允许您使用JSON- path语法从JSON响应中提取数据。这个后处理器非常类似于正则表达式提取器。它必须被放置为HTTP采样器或任何其他有响应的采样器的子级。它将允许您以非常简单的方式提取文本内容，请参阅JSON路径语法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cae263477a4ba574f58c7dbea086aa0f6.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Configuration 配置元件</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Configuration 配置元件</h1><h2 id="Metadata-10">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Configuration 配置元件date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/配置categories:  - JMeterkeywords:  - JMeter  - 组件  - 配置description: 配置元素可用于设置默认值和变量，供采样器稍后使用。注意，这些元素在找到它们的范围的开始处处理，即在同一范围内的任何采样器之前处理。</code></pre><h2 id="Configuration-配置元件">Configuration | 配置元件</h2><p>配置元素可用于设置默认值和变量，供采样器稍后使用。注意，这些元素在找到它们的范围的开始处处理，即在同一范围内的任何采样器之前处理。</p><h3 id="CSV-Data-Set-Config-CSV-数据集配置">CSV Data Set Config | CSV 数据集配置</h3><p>CSV数据集配置用于从文件中读取行，并将它们分割为变量。它比<code>__CSVRead()</code>和<code>__StringFromFile()</code>函数更容易使用。它非常适合处理大量变量，并且对于使用"随机"和惟一值进行测试也很有用。</p><p>就CPU和内存而言，在运行时生成唯一的随机值非常昂贵，所以只需在测试之前创建数据。如果有必要，文件中的"随机"数据可以与运行时参数结合使用，从而在每次运行中创建不同的值集——例如使用串联——这比在运行时生成所有值要便宜得多。</p><p>JMeter允许值被引用;这允许值包含分隔符。如果启用了 “<code>allow quoted data</code>”(“允许引用数据”)，值可以用双引号括起来。这些都是删除。要在带引号的字段中包含双引号，请使用两个双引号。</p><p>JMeter支持用标题行定义列名的CSV文件。要启用此功能，请将 “<code>Variable Names</code>” "变量名称"字段保留为空。必须提供正确的分隔符。</p><p>默认情况下，文件只打开一次，每个线程将使用文件中的不同行。但是，将行传递给线程的顺序取决于它们的执行顺序，这在迭代之间可能会有所不同。在每个测试迭代的开始读取行。在第一次迭代中解析文件名和模式。</p><p>有关其他选项，请参阅下面对共享模式的描述。如果希望每个线程都有自己的一组值，那么需要创建一组文件，每个线程一个文件。例如test1.csv, test2.csv，…，testn.csv。使用文件名<code>test${__threadNum}.csv</code>，将"<code>Sharing mode</code>"(“共享模式”)设置为 “<code>Current thread</code>”(“当前线程”)。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cce47f39f5ccee667dcd4f0ef5d3b0baf.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。<br> 要读取的文件的名称。相对文件名根据活动测试计划的路径进行解析。对于分布式测试，CSV文件必须存储在服务器主机系统中启动JMeter服务器的正确相对目录中。也支持绝对文件名，但是请注意，它们不太可能在远程模式下工作，除非远程服务器具有相同的目录结构。如果以两种不同的方式引用同一个物理文件——例如csvdata.txt和./csvdata.txt——那么这些文件将被视为不同的文件。如果操作系统不区分大小写，也会单独打开csvData.TXT。</td><td>Yes</td></tr><tr><td>File Encoding</td><td>用于读取文件的编码，如果不是平台默认值的话。</td><td>No</td></tr><tr><td>Variable Names</td><td>变量名列表。名称必须由分隔符分隔。它们可以用双引号引用。JMeter支持CSV标题行:如果变量名字段为空，那么文件的第一行将被读取并解释为列名列表。</td><td>No</td></tr><tr><td>Use first line as Variable Names</td><td>忽略CSV文件的第一行，它只会在变量名不为空时使用，如果变量名为空，第一行必须包含标题。</td><td>No</td></tr><tr><td>Delimiter</td><td>分隔符，用于分割文件中的记录。如果行上的值比变量的值少，那么剩余的变量将不会更新——因此它们将保留以前的值(如果有的话)。</td><td>Yes</td></tr><tr><td>Allow quoted data?</td><td>CSV文件是否允许值被引用?如果启用，值可以括在 <code>"</code>-双引号-允许值包含分隔符。</td><td>Yes</td></tr><tr><td>Recycle on EOF?</td><td>文件是否应该在到达EOF时从头重新读取?(默认是<code>true</code>的)</td><td>Yes</td></tr><tr><td>Stop thread on EOF?</td><td>如果循环是假的，线程应该停止在EOF ?(默认是假的)</td><td>Yes</td></tr><tr><td>Sharing mode</td><td>- All threads - (the default) 该文件在所有线程之间共享。<br> - Current thread group - 对于出现该元素的每个线程组，每个文件都会打开一次 <br> - Current thread - 每个文件为每个线程分别打开 <br> - Identifier - 共享相同标识符的所有线程共享相同的文件。例如，如果您有4个线程组，您可以为两个或多个组使用一个公共id来在它们之间共享文件。或者可以使用线程号在不同线程组中的相同线程号之间共享文件。</td><td>Yes</td></tr></tbody></table><h3 id="DNS-Cache-Manager-DNS缓存管理器">DNS Cache Manager | DNS缓存管理器</h3><p>DNS缓存管理器元素允许测试应用程序，当用户从不同的IP接收内容时，负载均衡器(CDN等)后面有多个服务器。JMeter默认使用JVM DNS缓存。这就是为什么集群中只有一个服务器接收负载的原因。DNS缓存管理器在每次迭代时分别为每个线程解析名称，并将解析结果保存到其内部DNS缓存中，该缓存独立于JVM和OS的DNS缓存。</p><p>静态主机的映射可以用来模拟类似于<code>/etc/hosts</code>文件的内容。这些条目将优先于自定义解析器。如果要使用此映射，必须启用自定义DNS解析器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C6a3ba849bb5754e150f44e07fc37eeed.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>DNS缓存管理器设计用于在线程组或测试计划的根目录中使用。不把它作为子元素的特定HTTP采样</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>DNS缓存管理器只适用于使用HTTPClient4实现的HTTP请求。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear cache each Iteration</td><td>如果选中，每次新的迭代开始时，每个线程的DNS缓存都会被清除。</td><td>No</td></tr><tr><td>Use system DNS resolver</td><td>系统DNS解析器将被使用。对于正确的工作编辑 <code>$JAVA_HOME/jre/lib/security/java.security</code> 并且添加 <code>networkaddress.cache.ttl=0</code></td><td>N/A</td></tr><tr><td>Use custom DNS resolver</td><td>将使用自定义DNS解析器(来自dnsjava库)。</td><td>N/A</td></tr><tr><td>Hostname or IP address</td><td>使用的DNS服务器列表。如果为空，则使用网络配置DNS。</td><td>No</td></tr><tr><td>Add Button</td><td>在DNS服务器表中添加一条表项。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Host and Hostname or IP address</td><td>将主机名映射到静态主机条目，该条目将使用自定义DNS解析器进行解析。</td><td>No</td></tr><tr><td>Add static host Button</td><td>在静态主机表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete static host Button</td><td>删除表中当前选择的静态主机。</td><td>N/A</td></tr></tbody></table></div><h3 id="HTTP-Authorization-Manager-HTTP授权管理器">HTTP Authorization Manager | HTTP授权管理器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cbc7857565fd9ff73dbe5e04ea209b160.png" alt></p></div><p>授权管理器允许您为使用服务器身份验证限制的网页指定一个或多个用户登录。当您使用浏览器访问受限制的页面，并且浏览器显示登录对话框时，您会看到这种类型的身份验证。JMeter在遇到这种类型的页面时传输登录信息。</p><p>授权标头可能不会显示在树视图侦听器的"请求"选项卡中。Java实现执行了先发制人的身份验证，但是当JMeter获取授权报头时，它不返回授权报头。HttpComponents (HC 4.5.X)实现自3.2开始默认为先发制人，头部将显示。要禁用此功能，请设置以下值，在这种情况下，身份验证将只在响应质询时执行。</p><p>在 <code>jmeter.properties</code> 文件中 设置 <code>httpclient4.auth.preemptive=false</code></p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意:上述设置仅适用于HttpClient采样器。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>当针对URL查找匹配项时，JMeter依次检查每个条目，并在找到第一个匹配项时停止。因此，最特定的url应该出现在列表的最前面，其次是不那么特定的url。重复的url将被忽略。如果你想为不同的线程使用不同的用户名/密码，你可以使用变量。这些可以使用CSV数据集配置元素(例如)来设置。</p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear auth on each iteration?</td><td>用于Kerberos认证。如果勾选此项，将对每一次主线程组循环的迭代进行身份验证，即使它已经在前一次循环中完成了。如果每个主线程组迭代代表一个虚拟用户的行为，这通常是有用的。</td><td>Yes</td></tr><tr><td>Base URL</td><td>匹配一个或多个HTTP请求URL的部分或完整URL。例如，您指定一个Base URL为 “<code>http://localhost/restricted/</code>”，用户名为"<code>jmeter</code>"，密码为"<code>jmeter</code>"。如果您向URL"<code>http://localhost/restricted/ant/myPage.html</code>"发送HTTP请求，授权管理器将发送名为"jmeter"的用户的登录信息。</td><td>yES</td></tr><tr><td>Username</td><td>需要授权的用户名。</td><td>Yes</td></tr><tr><td>Password</td><td>用户的密码。(注意，此数据未加密存储在测试计划中)</td><td>Yes</td></tr><tr><td>Domain</td><td>用于NTLM的域。</td><td>No</td></tr><tr><td>Realm</td><td>用于NTLM的领域。</td><td>No</td></tr><tr><td>Mechanism</td><td>执行的认证类型。JMeter可以基于使用的Http采样器执行不同类型的认证:</td><td>No</td></tr></tbody></table><h3 id="HTTP-Cache-Manager-HTTP-缓存控制器">HTTP Cache Manager | HTTP 缓存控制器</h3><p>HTTP缓存管理器用于在其作用域内向HTTP请求添加缓存功能，以模拟浏览器缓存特性。每个虚拟用户线程都有自己的缓存。默认情况下，缓存管理器将使用LRU算法在每个虚拟用户线程的缓存中存储最多5000个条目。使用属性"maxSize"来修改这个值。请注意，这个值增加越多，HTTP缓存管理器消耗的内存就越多，因此一定要相应地调整-Xmx JVM选项。</p><p>如果一个样本是成功的(即有响应代码2xx)，然后最后修改和Etag(和过期，如果相关)的值为URL保存。在执行下一个示例之前，采样器检查缓存中是否有条目，如果有，则为请求设置if - last - modified和if - none - match条件报头。</p><p>此外，如果"使用Cache-Control/Expires头"选项被选中，那么Cache-Control/Expires值将根据当前时间进行检查。如果请求是一个GET请求，并且时间戳在将来，那么采样器将立即返回，而不需要从远程服务器请求URL。这是为了模拟浏览器的行为。注意，如果cache - control报头为"no-cache"，响应将被存储在缓存中，因此将生成一个有条件的GET请求。如果Cache-Control有其他值，则处理"max-age"过期选项来计算条目的生存期，如果缺少则使用过期头，如果也缺少条目将使用RFC 2616章节13.2.4中指定的Last-Modified time和response Date进行缓存。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果所请求的文档自缓存以来没有更改，那么响应体将为空。同样，如果过期日期在未来。这可能会给断言带来问题。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C431a1b16f59e2a2a78ff45601e41b2fa.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear cache each iteration</td><td>如果选择该选项，则在线程开始时清除缓存。</td><td>Yes</td></tr><tr><td>Use Cache Control/Expires header when processing GET requests</td><td>参见上面的描述。</td><td>Yes</td></tr><tr><td>Max缓存中的元素个数</td><td>参见上面的描述。</td><td>Yes</td></tr></tbody></table></div><h3 id="HTTP-Cookie-Manager-HTTP-Cookie-管理器">HTTP Cookie Manager | HTTP Cookie 管理器</h3><p>Cookie Manager元素有两个功能:</p><p>首先，它像网络浏览器一样存储和发送cookie。如果您有一个HTTP请求和响应包含一个cookie, cookie管理器自动存储该cookie，并将使用它为所有未来的请求，以特定的网站。每个JMeter线程都有自己的“cookie存储区域”。因此，如果您正在测试一个使用cookie存储会话信息的网站，那么每个JMeter线程将拥有自己的会话。注意，这样的Cookie不会出现在Cookie Manager的显示中，但是可以使用View Results Tree Listener查看它们。</p><p>JMeter检查接收到的cookie对URL是否有效。这意味着不存储跨域cookie。如果您有错误行为或希望使用跨域cookie，定义JMeter属性 “<code>CookieManager.check.cookies=false</code>”</p><p>接收到的cookie可以存储为JMeter线程变量。要将cookie保存为变量，需要定义属性"<code>CookieManager.save.cookies=true</code>"。此外，cookie名称在存储之前会以“COOKIE_”作为前缀(这可以避免局部变量的意外损坏)。要恢复到原来的行为，需要定义属性"<code>CookieManager.name.prefix=</code>"(一个或多个空格)。如果启用，一个名为TEST的cookie的值可以被引用为<code>${COOKIE_TEST}</code>。</p><p>其次，您可以手动添加cookie到cookie管理器。但是，如果您这样做，cookie将被所有JMeter线程共享。</p><p>注意，这样的cookie创建时的过期时间较远</p><p>默认情况下，具有<strong>空值</strong>的cookie将被忽略。这可以通过设置JMeter属性来改变:<code>CookieManager.delete_null_cookies=false</code>。注意，这也适用于手动定义的cookie -任何这样的cookie在更新时将从显示中删除。还要注意cookie名称必须是唯一的——如果第二个cookie定义为相同的名称，它将替换第一个cookie。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C230dad077b303fe9551fe423dc86b965.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果在一个采样器的范围内有多个Cookie Manager，目前没有办法指定要使用哪个。另外，存储在一个cookie管理器中的cookie对任何其他管理器都不可用，所以要小心使用多个cookie管理器。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Clear Cookies each Iteration</td><td>如果选中该选项，则在每次执行主线程组循环时清除所有服务器定义的cookie。在GUI中定义的cookie不会被清除。</td><td>Yes</td></tr><tr><td>Cookie Policy</td><td>用于管理cookie的cookie策略。"standard"是3.0之后的默认设置，应该在大多数情况下都可以使用。参见Cookie规范和CookieSpec实现<code>[注:"ignoreCookies"等价于省略CookieManager。]</code></td><td>Yes</td></tr><tr><td>Implementation</td><td>HC4CookieHandler (HttpClient 4.5。X的API)。从3.0开始默认为HC4CookieHandler。 <code>[注:如果你有一个网站来测试IPv6地址，选择HC4CookieHandler (IPv6兼容)]</code></td><td>Yes</td></tr><tr><td>User-Defined Cookies</td><td>这使您有机会使用将在测试执行期间被所有线程使用的硬编码cookie。 <code>域</code>是服务器的主机名(没有http://);端口当前被忽略。</td><td>N/A</td></tr><tr><td>Add Button</td><td>向cookie表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Load Button</td><td>加载之前保存的cookie表，并将条目添加到现有的cookie表条目中。</td><td>N/A</td></tr><tr><td>Save As Button</td><td>将当前cookie表保存到一个文件中(不保存从HTTP响应中提取的任何cookie)。</td><td>N/A</td></tr></tbody></table></div><h3 id="HTTP-Request-Defaults-HTTP-请求默认值">HTTP Request Defaults | HTTP 请求默认值</h3><p>这个元素允许你设置HTTP请求控制器使用的默认值。例如，如果您正在使用25个HTTP请求控制器创建一个Test Plan，并且所有的请求都被发送到相同的服务器，您可以添加一个单独的HTTP Request Defaults元素，填充“服务器名称或IP”字段。然后，当您添加25个HTTP请求控制器时，<mark style="background: #ABF7F7A6;">将“服务器名称或IP”字段保留为空</mark> 。控制器将从HTTP Request Defaults元素继承这个字段值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C4b94edb137f5ce1ac2fc7f273c5b352c.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>所有端口值都被同等对待;一个没有指定端口的采样器将使用HTTP请求默认端口(如果提供了)。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attibute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Server</td><td>web服务器的域名或IP地址。例如,www.example.com。<code>[不包含http://前缀。</code></td><td>No</td></tr><tr><td>Port</td><td>web服务器正在监听的端口。</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时。等待连接打开的毫秒数。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时。等待响应的毫秒数。</td><td>No</td></tr><tr><td>Implementation</td><td>Java, HttpClient4。如果没有指定，默认值取决于JMeter属性JMeter的值。httpsampler，如果失败，则使用Java实现。</td><td>No</td></tr><tr><td>Protocol</td><td>HTTP or HTTPS.</td><td>No</td></tr><tr><td>Content encoding</td><td>用于请求的编码。</td><td>No</td></tr><tr><td>Path</td><td>资源的路径(例如/servlets/myServlet)。如果资源需要查询字符串参数，在下面的“发送请求参数”部分添加它们。注意，该路径是完整路径的默认值，而不是应用于HTTP请求屏幕上指定的路径的前缀。</td><td>No</td></tr><tr><td>Send Parameters With the Request</td><td>查询字符串将从您提供的参数列表中生成。每个参数都有一个名称和值。查询字符串将以正确的方式生成，取决于你所做的“方法”的选择(即，如果你选择了GET，查询字符串将被附加到URL，如果是POST，那么它将被单独发送)。此外，如果您正在使用多部分表单发送文件，那么查询字符串将使用多部分表单规范创建。</td><td>No</td></tr><tr><td>Server (proxy)</td><td>执行请求的代理服务器的主机名或IP地址。<code>[不包含http://前缀。]</code></td><td>No</td></tr><tr><td>Port</td><td>代理服务器正在监听的端口。不能，除非指定了代理主机名</td><td>No</td></tr><tr><td>Username</td><td>代理服务器的用户名(可选)。</td><td>No</td></tr><tr><td>Password</td><td>代理服务器密码(可选)。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Retrieve All Embedded Resources from HTML Files</td><td>告诉JMeter解析HTML文件，并对文件中引用的所有图像、Java小程序、JavaScript文件、css等发送HTTP/HTTPS请求。</td><td>No</td></tr><tr><td>Use concurrent pool</td><td>使用并发连接池来获得嵌入式资源。</td><td>No</td></tr><tr><td>Size</td><td>用于获取嵌入式资源的并发连接的池大小。</td><td>No</td></tr><tr><td>URLs must match:</td><td>如果存在，则必须是一个正则表达式，用于匹配找到的任何嵌入式url。因此，如果您只想从<code>http://example.invalid/</code>下载嵌入式资源，请使用表达式:<code>http://example\.invalid/.*</code></td><td>No</td></tr><tr><td>URLs must not match:</td><td>如果存在，则必须是一个正则表达式，用于过滤掉找到的任何嵌入的url。所以，如果你不想从任何来源下载PNG或SVG文件，使用表达式:<code>.*\.(?i: SVG | PNG)</code></td><td>No</td></tr></tbody></table></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注:单选按钮只有两种状态-开或关。这使得不可能始终如一地覆盖设置——关闭意味着关闭，还是意味着使用当前的默认值?JMeter使用后者(否则默认值根本不起作用)。因此，如果按钮是关闭的，那么后面的元素可以将其设置为开启，但如果按钮是开启的，后面的元素就不能将其设置为关闭。</p></div><h3 id="HTTP-Header-Manager-HTTP-头信息管理器">HTTP Header Manager | HTTP 头信息管理器</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C0333bdcf912b8486049febc4d746f591.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Name (Header)</td><td>请求头的名称。您可能想要试验的两个常见请求头是"<code>User-Agent</code>"和"<code>Referer</code>"。</td><td>No (You should have at least one, however)</td></tr><tr><td>Value</td><td>请求头的值</td><td>No (You should have at least one, however)</td></tr><tr><td>Add Button</td><td>向标题表中添加一个条目。</td><td>N/A</td></tr><tr><td>Delete Button</td><td>删除当前选择的表项。</td><td>N/A</td></tr><tr><td>Load Button</td><td>加载先前保存的头表，并将条目添加到现有的头表条目中。</td><td>N/A</td></tr><tr><td>Save As Button</td><td>将当前头表保存到一个文件中。</td><td>N/A</td></tr></tbody></table></div><h3 id="Java-Request-Defaults-java-请求默认值">Java Request Defaults | java 请求默认值</h3><p>Java Request Defaults组件允许您为Java测试设置默认值。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C18f4c033bd431c9dd7b76f52ce282a52.png" alt></p></div><h3 id="JDBC-Connection-Configuration-JDBC-连接-配置">JDBC Connection Configuration | JDBC 连接 配置</h3><p>从提供的JDBC connection设置创建一个数据库连接(由JDBC RequestSampler使用)。连接可以在线程之间选择性地池化。否则，每个线程将获得自己的连接。JDBC Sampler使用连接配置名称来选择适当的连接。已用池为DBCP，请参见BasicDataSource配置参数</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C1833bb3bf3831447c387e587824ac09a.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的连接配置的描述性名称。</td><td>No</td></tr><tr><td>Variable Name for created pool</td><td>连接绑定到的变量的名称。可以使用多个连接，每个连接绑定到不同的变量，从而允许JDBC sampler选择适当的连接。</td><td>Yes</td></tr><tr><td>Max Number of Connections</td><td>池中允许的最大连接数。在大多数情况下，设置为0(0)。这意味着每个线程将得到它自己的池，其中有一个连接，即连接不是线程之间共享的。</td><td>Yes</td></tr><tr><td>Max Wait (ms)</td><td>如果在尝试检索连接的过程中超过了超时时间，池将抛出一个错误</td><td>Yes</td></tr><tr><td>Time Between Eviction Runs (ms)</td><td>空闲对象回收器线程运行之间休眠的毫秒数。当非正值时，不会运行空闲的对象驱逐符线程。(默认为60000,1分钟)。看到</td><td>Yes</td></tr><tr><td>Auto Commit</td><td>打开或关闭连接的自动提交。</td><td>Yes</td></tr><tr><td>Transaction isolation</td><td>事务隔离</td><td>Yes</td></tr><tr><td>Pool Prepared Statements</td><td>每个连接池中准备语句的最大数量。“-1”禁用池，“0”表示不限制准备语句池的数量。(默认为“1”)</td><td>Yes</td></tr><tr><td>Preinit Pool</td><td>可以立即初始化连接池。如果设置为False(默认值)，使用该池的JDBC请求采样器可能会为第一次查询度量更高的响应时间—因为包括了整个池的连接建立时间。</td><td>No</td></tr><tr><td>Init SQL statements separated by new line</td><td>一组SQL语句，在第一次创建物理连接时，这些SQL语句将用于初始化它们。这些语句只执行一次—当配置的连接工厂创建连接时。</td><td>No</td></tr><tr><td>Test While Idle</td><td>测试池的空闲连接</td><td>Yes</td></tr><tr><td>Soft Min Evictable Idle Time(ms)</td><td>在空闲对象回收器有资格回收连接之前，连接在池中空闲的最短时间，附加条件是至少有minIdle连接保留在池中。 默认值为5000(5秒)</td><td>Yes</td></tr><tr><td>Validation Query</td><td>一个简单的查询，用于确定数据库是否仍在响应。这默认是jdbc驱动程序的’isValid()'方法，它适用于许多数据库。然而，有些可能需要不同的查询;例如，Oracle类似于“SELECT 1 FROM DUAL”可以使用。</td><td>No</td></tr><tr><td>Database URL</td><td>JDBC数据库连接字符串。</td><td>Yes</td></tr><tr><td>JDBC Driver class</td><td>驱动程序类的完全限定名称。(必须在JMeter的类路径-最容易复制.jar文件到JMeter的/lib目录)。</td><td>Yes</td></tr><tr><td>Username</td><td>要连接的用户名。</td><td>No</td></tr><tr><td>Password</td><td>连接的密码。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Connection Properties</td><td>建立连接时设置的连接属性(例如Oracle的internal_logon=sysdba)</td><td>No</td></tr></tbody></table><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">Some examples for databases and their parameters are given below.</p><p>MySQLDriver classcom.mysql.jdbc.DriverDatabase URLjdbc:mysql://host[:port]/dbnamePostgreSQLDriver classorg.postgresql.DriverDatabase URLjdbc:postgresql:{dbname}OracleDriver classoracle.jdbc.OracleDriverDatabase URLjdbc:oracle:thin:@//host:port/service OR jdbc:oracle:thin:@(description=(address=(host={mc-name})(protocol=tcp)(port={port-no}))(connect_data=(sid={sid})))Ingress (2006)Driver classingres.jdbc.IngresDriverDatabase URLjdbc:ingres://host:port/db[;attr=value]Microsoft SQL Server (MS JDBC driver)Driver classcom.microsoft.sqlserver.jdbc.SQLServerDriverDatabase URLjdbc:sqlserver://host:port;DatabaseName=dbnameApache DerbyDriver classorg.apache.derby.jdbc.ClientDriverDatabase URLjdbc:derby://server[:port]/databaseName[;URLAttributes=value[;…]]MariaDBDriver classorg.mariadb.jdbc.DriverDatabase URLjdbc:mariadb://host[:port]/dbname[;URLAttributes=value[;…]]Exasol (see also JDBC driver documentation)Driver classcom.exasol.jdbc.EXADriverDatabase URLjdbc:exa:host[:port][;schema=SCHEMA_NAME][;prop_x=value_x]</p></div><h3 id="Keystore-Configuration-密钥库配置">Keystore Configuration | 密钥库配置</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfc1e3f1718138d5076fed611399657fd.png" alt></p></div><h3 id="Login-Config-Element-登录配置">Login Config Element | 登录配置</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C2b3e839344fae2210caac4697f84f470.png" alt></p></div><h3 id="TCP-Sampler-Config-TCP-采样器-配置">TCP Sampler Config | TCP 采样器 配置</h3><p>TCP采样器配置为TCP采样器提供缺省数据</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3149a737279a4e4563260c1d0fac8e54.png" alt></p></div><h3 id="User-Defined-Variables-用户定义变量">User Defined Variables | 用户定义变量</h3><p>User Defined Variables元素允许您定义一组初始变量，就像在Test Plan中一样。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cfe2292d00bd006cbb0a5b6d2fa7b0d5e.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意，测试计划中的所有UDV元素—无论它们在哪里—都在开始时处理。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td></td></tr><tr><td>User Defined Variables</td><td>变量名称/值对。"<code>Name</code>"列下的字符串是您需要放在<code>${…}</code>构造中方括号内的内容，以便稍后使用变量。整个<code>${…}</code>将被"Value"列中的字符串替换。</td><td></td></tr></tbody></table></div><h3 id="Random-Variable-随机变量">Random Variable | 随机变量</h3><p>随机变量配置元素用于生成随机数字字符串，并将它们存储在变量中以备以后使用。它比使用用户定义变量和<code>__Random()</code>函数更简单。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Ca323effcee9ceb4d9e663ed1674deb4c.png" alt></p></div><table><thead><tr><th>Attibute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>Yes</td></tr><tr><td>Variable Name</td><td>存储随机字符串的变量的名称。</td><td>Yes</td></tr><tr><td>Format String</td><td>要使用的<code>java.text.DecimalFormat</code>格式字符串。例如，"000"将生成至少3位的数字，或"<code>USER_000</code>"将生成形式为<code>USER_nnn</code>的输出。如果未指定，则默认使用<code>Long.toString()</code>生成数字。</td><td>No</td></tr><tr><td>Minimum Value</td><td>生成的随机数的最小值(长)。</td><td>Yes</td></tr><tr><td>Maximum Value</td><td>生成的随机数的最大值(长)。</td><td>Yes</td></tr><tr><td>Random Seed</td><td>随机数生成器的种子。如果您使用相同的种子值，将Per Thread设置为true，您将为每个Thread获得与每个Random类相同的值。如果没有设置种子，将使用Random的默认构造函数。</td><td>No</td></tr><tr><td>Per Thread(User)?</td><td>如果为False，则线程组中的所有线程共享生成器。如果为True，则每个线程都有自己的随机生成器。</td><td>Yes</td></tr></tbody></table><h3 id="Counter-计数器">Counter | 计数器</h3><p>允许用户创建一个计数器，该计数器可以在线程组的任何位置引用。计数器配置允许用户配置起始点、最大值和增量。计数器将从开始循环到最大，然后重新开始，像这样继续下去，直到测试结束。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C1b0a8607c0781b426f35bd5043f77014.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>Starting value</td><td>计数器的起始值。计数器将在第一次迭代期间等于这个值(默认为0)。</td><td>Yes</td></tr><tr><td>Increment</td><td>在每次迭代之后计数器增加多少(默认为0，表示没有增加)。</td><td>No</td></tr><tr><td>Maximum value</td><td>如果计数器超过最大值，则将其重置为起始值。默认是长。MAX_VALUE</td><td>No</td></tr><tr><td>Format</td><td>可选的格式，例如000将格式为001、002等。它被传递给DecimalFormat，因此可以使用任何有效的格式。如果解释格式有问题，就会忽略它。<code>[默认格式是使用Long.toString()生成的]</code></td><td>No</td></tr><tr><td>Exported Variable Name</td><td>这将是计数器值可用的变量名。如果你把它命名为counterA，你可以使用用户定义值中的<code>${counterA}</code>来访问它(默认情况下，它会创建一个空的字符串变量，可以使用<code>${}</code>来访问，但这是非常不鼓励的)</td><td>No</td></tr><tr><td>Track Counter Independently for each User</td><td>换句话说，这是一个全局计数器，还是每个用户都有自己的计数器?如果未选中，计数器是全局的(即，用户#1将在第一次迭代中获得值“1”，用户#2将获得值“2”)。如果勾选此项，每个用户都有一个独立的计数器。</td><td>No</td></tr><tr><td>Reset counter on each Thread Group Iteration</td><td>此选项仅在每个用户跟踪计数器时可用，如果选中，计数器将在每次线程组迭代时重置为Start值。当计数器在循环控制器中时，这是很有用的。</td><td>No</td></tr></tbody></table><h3 id="Simple-Config-Element-简单配置元件">Simple Config Element | 简单配置元件</h3><p>简单配置元素允许您在采样器中添加或重写任意值。您可以选择值的名称和值本身。尽管一些喜欢冒险的用户可能会找到这个元素的用途，但它主要是供开发人员在开发新的JMeter组件时作为基本GUI使用的。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C57794dfe00c7db8952e1c7cef2f3d50a.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Name</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>Yes</td></tr><tr><td>Parameter Name</td><td>每个参数的名称。这些值是JMeter工作的内部值，通常没有文档记录。只有熟悉代码的人才知道这些值。</td><td>Yes</td></tr><tr><td>Parameter Value</td><td>应用于该参数的值。</td><td>Yes</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Timers 定时器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-timers-ding-shi-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-timers-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Timers 定时器</h1><h2 id="Metadata-11">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Timers 定时器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/定时器categories:  - JMeterkeywords:  - JMeter  - 组件  - 定时器description: 通过设置属性计时器，可以对随机计时器计算的睡眠延迟应用乘数。</code></pre><h2 id="Timer-定时器">Timer | 定时器</h2><p>通过设置属性计时器，可以对随机计时器计算的睡眠延迟应用乘数。Factor =float number，其中float number为十进制正数。</p><p>JMeter将这个因子乘以计算出来的睡眠延迟。此功能可由:</p><p>注意，计时器在它们被发现的范围内的每个采样器之前被处理;如果在同一个作用域中有多个计时器，那么所有的计时器都会在每个采样器之前被处理。</p><p>定时器只能与采样器一起处理。与采样器不在同一范围内的计时器根本不会被处理。</p><p>若要将计时器应用于单个采样器，请将计时器添加为采样器的子元素。计时器将在采样器执行之前应用。要在采样器之后应用计时器，可以将它添加到下一个采样器，或者将它添加为流量控制动作采样器的子程序。</p><h3 id="Constant-Timer-固定定时器">Constant Timer | 固定定时器</h3><p>如果您想让每个线程在请求之间暂停相同的时间，可以使用这个计时器。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C670da2d843541dc22ef5d6feeca8ec2c.png" alt></p></div><h3 id="Gaussian-Random-Timer-高斯随机定时器">Gaussian Random Timer | 高斯随机定时器</h3><p>这个计时器将每个线程请求暂停一段随机的时间，大多数时间间隔发生在某个特定值附近。总延迟是高斯分布值(平均值为0.0，标准差为1.0)乘以指定的偏差值和偏移值的总和。另一种解释方法是，在高斯随机计时器中，恒定偏移量附近的变化具有高斯曲线分布。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C3c2a5923af3be03ea63fa1f53da2a0c4.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称</td><td>No</td></tr><tr><td>Deviation</td><td>偏差,以毫秒为单位</td><td>Yes</td></tr><tr><td>Constant Delay Offset</td><td>除了随机延迟外，暂停的毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Uniform-Random-Timer-统一随机定时器">Uniform Random Timer | 统一随机定时器</h3><p>这个计时器将每个线程请求暂停一段随机的时间，每个时间间隔发生的概率相同。总延迟是随机值和偏移值的总和。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cda68c0ac317482db8700f3886b7beceb.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称</td><td>No</td></tr><tr><td>Random Delay Maximun</td><td>暂停的最大随机毫秒数。</td><td>Yes</td></tr><tr><td>Constant Delay Offset</td><td>除了随机延迟外，暂停的毫秒数。</td><td>Yes</td></tr></tbody></table></div><h3 id="Constant-Throughput-Timer-常量吞吐计时器">Constant Throughput Timer | 常量吞吐计时器</h3><p>这个计时器引入了可变的暂停，计算的目的是保持总吞吐量(以每分钟的样本为单位)尽可能接近给定的数字。当然，如果服务器不能处理它，或者其他计时器或耗时的测试元素阻止它，那么吞吐量将会更低。</p><p>注意:虽然Timer被称为常量吞吐量计时器，但吞吐量值不需要是常量。它可以根据变量或函数调用来定义，并且可以在测试期间更改值。可以通过多种方式改变该值:</p><ul><li>使用计数器变量</li><li>使用<code>__jexl3</code>， <code>__groovy</code>函数提供一个更改值</li><li>使用远程<code>BeanShell</code>服务器来更改JMeter属性</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>注意，在测试期间不应该太频繁地更改吞吐量值—新值需要一段时间才能生效。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C91688733433a106a2b6503cf51fc93b7.png" alt></p></div><h3 id="Synchronizing-Timer-同步定时器">Synchronizing Timer | 同步定时器</h3><p>SyncTimer的目的是阻塞线程，直到X个线程被阻塞，然后它们一次被释放。因此，SyncTimer可以在测试计划的各个点上创建大的即时负载。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C61e29042423f8a1f484e68ff183bee51.png" alt></p></div><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的此计时器的描述性名称。</td><td>No</td></tr><tr><td>Number of Simultaneous Users to Group by</td><td>一次释放的线程数。将其设置为0相当于将其设置为Thread Group中的线程数。</td><td>Yes</td></tr><tr><td>Timeout in milliseconds</td><td>如果设置为0,Timer将等待线程的数量达到“number of Simultaneous Users to Group”中的值。如果高于0，则计时器将在最大“Timeout in毫秒”等待线程数。如果超时时间未达到等待用户数量，则停止等待。默认值为0</td><td>No</td></tr></tbody></table><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>如果timeout(以毫秒为单位)设置为0，并且线程数永远不会达到“number of Simultaneous Users to Group by”，那么Test将无限暂停。只有强行阻止才能阻止它。在这种情况下，可以考虑将Timeout设置为毫秒。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition attention"><p class="admonition-title"></p><p>只在一个JVM中同步计时器块，因此如果使用分布式测试，请确保不要将“Number of Simultaneous Users to Group by”设置为比只考虑1个注入器的线程组的用户数高的值。</p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 组件详解-Samplers 采样器</title>
      <link href="/jmeter/jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi/"/>
      <url>/jmeter/jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi/</url>
      
        <content type="html"><![CDATA[<h1>JMeter 组件详解-Samplers 采样器</h1><h2 id="Metadata-12">Metadata</h2><pre><code class="language-yml">title: JMeter 组件详解-Samplers 采样器date: 2022-12-13 13:20tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/JMeter  - 细化主题/组件  - 细化主题/采样器categories:  - JMeterkeywords:  - JMeter  - 组件  - 采样器description: 采样器执行JMeter的实际工作。每个采样器(流量控制动作除外)产生一个或多个采样结果。示例结果具有各种属性(成功/失败、运行时间、数据大小等)，可以在各种侦听器中查看。</code></pre><h2 id="Samplers-采样器">Samplers 采样器</h2><p>采样器执行JMeter的实际工作。每个采样器(流量控制动作除外)产生一个或多个采样结果。示例结果具有各种属性(成功/失败、运行时间、数据大小等)，可以在各种侦听器中查看。</p><h3 id="FTP-Request-FTP请求">FTP Request | FTP请求</h3><p>这个控制器允许你向FTP服务器发送一个FTP"检索文件"或"上传文件"请求。如果你打算向同一个FTP服务器发送多个请求，考虑使用FTP请求默认配置元素，这样你就不必为每个FTP请求生成控制器输入相同的信息。当下载一个文件时，它可以存储在磁盘(本地文件)或响应数据中，或两者都有。</p><p>延迟时间设置为登录所需的时间。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C119383d6ef62fda8d58e5c22b8881e21.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Server Name or IP</td><td>FTP服务器的域名或IP地址。</td><td>Yes</td></tr><tr><td>Port</td><td>端口使用。如果是&gt;0，则使用这个特定的端口，否则JMeter使用默认的FTP端口。</td><td>No</td></tr><tr><td>Remote File:</td><td>要检索的文件或要上传的目标文件的名称。</td><td>Yes</td></tr><tr><td>Local File:</td><td>要上传的文件或下载的目标文件(默认为远程文件名)。</td><td>"Yes, if uploading (*)"</td></tr><tr><td>Local File Contents:</td><td>提供上传的内容，重写"本地文件"属性。</td><td>"Yes, if uploading (*)"</td></tr><tr><td>get(RETR) / put(STOR)</td><td>是否检索或上传文件。</td><td>Yes</td></tr><tr><td>Use Binary mode?</td><td>检查此选项以使用二进制模式(默认ASCII)</td><td>Yes</td></tr><tr><td>Save File in Response?</td><td>是否在响应数据中存储检索到的文件的内容。如果模式是ASCII，则内容将在视图结果树中可见。</td><td>"Yes, if downloading"</td></tr><tr><td>Username</td><td>FTP帐户的用户名。</td><td>Usually</td></tr><tr><td>Password</td><td>FTP帐户密码。注意:这将在测试计划中可见。</td><td>Usually</td></tr></tbody></table></div><h3 id="HTTP-Request-HTTP请求">HTTP Request | HTTP请求</h3><p>这个示例程序允许您向web服务器发送HTTP/HTTPS请求。它还允许您控制JMeter是否解析图像和其他嵌入资源的HTML文件，并发送HTTP请求来检索它们。可以检索以下类型的嵌入式资源:</p><ul><li>图片</li><li>小应用程序</li><li>样式表(CSS)和从这些文件引用的资源</li><li>外部脚本</li><li>框架,iframes</li><li>背景图片(主体，表，TD, TR)</li><li>背景声音</li></ul><p>默认的解析器是 <code>org.apache.jmeter.protocol.http.parser.LagartoBasedHtmlParser</code>。这可以通过使用 <code>htmlparser.className</code> 属性来改变。-参见jmeter.properties 的细节。</p><p>如果你打算向同一个web服务器发送多个请求，考虑使用HTTP请求默认配置元素，这样你就不必为每个HTTP请求输入相同的信息。</p><p>或者，代替手动添加HTTP请求，您可能想使用JMeter的HTTP(S)测试脚本记录器来创建它们。如果您有很多HTTP请求或带有许多参数的请求，这可以节省您的时间。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C10fa23d3cd01ba4376173c9450dfa1ab.png" alt></p><p>Screenshot of Control-Panel of HTTP Request</p><p><img src="/attachment%5C8614d4e8dba9153e66454d0393117cbb.png" alt>HTTP Request Advanced config fields</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Server</td><td>web服务器的域名或IP地址，如 <code>www.example.com</code> 。不包含<code>http://</code>前缀。注意:如果"Host"头是在header Manager中定义的，那么它将被用作虚拟主机名。</td><td>No</td></tr><tr><td>Port</td><td>web服务器正在监听的端口。默认值:80</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时。等待连接打开的毫秒数。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时。等待响应的毫秒数。注意，这适用于每次等待响应。如果服务器响应是在几个块中发送的，那么总的运行时间可能会比超时时间长。&lt;/br&gt; 持续时间断言可用于检测需要太长时间才能完成的响应。</td><td>No</td></tr><tr><td>Server (proxy)</td><td>执行请求的代理服务器的主机名或IP地址。不包含http://前缀。</td><td>No</td></tr><tr><td>Port (proxy)</td><td>代理服务器正在监听的端口。</td><td>No, unless proxy hostname is specified</td></tr><tr><td>Username</td><td>代理服务器的用户名(可选)。</td><td>No</td></tr><tr><td>Password</td><td>代理服务器密码(可选)。(注意，此数据未加密存储在测试计划中)</td><td>No</td></tr><tr><td>Implementation</td><td>Java, HttpClient4。如果没有指定(也没有由HTTP请求默认值定义)，默认值取决于JMeter属性JMeter的值。httpsampler，如果失败，就使用HttpClient4实现。</td><td>No</td></tr><tr><td>Protocol</td><td>HTTP, HTTPS或文件。默认值:HTTP</td><td>No</td></tr><tr><td>Method</td><td>GET, POST, HEAD, TRACE, OPTIONS, PUT, DELETE, PATCH (JAVA实现不支持)。使用HttpClient4，以下与WebDav相关的方法也被允许:COPY, LOCK, MKCOL, MOVE, PROPFIND, PROPPATCH, UNLOCK, REPORT, MKCALENDAR, SEARCH。 &lt;/br&gt; 通过使用JMeter属性httpsampler.user_defined_methods，可以为HttpClient4预定义更多方法。</td><td>Yes</td></tr><tr><td>Content Encoding</td><td>要使用的内容编码(用于POST、PUT、PATCH和FILE)。这是要使用的字符编码，与内容编码HTTP报头无关。</td><td>No</td></tr><tr><td>Redirect Automatically</td><td>将底层http协议处理程序设置为自动遵循重定向，因此它们不会被JMeter看到，因此不会显示为示例。应该只用于GET和HEAD请求。HttpClient采样器将拒绝将其用于POST或PUT的尝试。</td><td>No</td></tr><tr><td>Follow Redirects</td><td>这只有在"自动重定向"未启用的情况下才有效。如果设置了，JMeter采样器将检查响应是否是重定向，如果是，则跟踪它。初始重定向和进一步的响应将作为额外的样本显示。父样例的URL和数据字段将取自最终样例(未重定向)，但父样例的字节计数和运行时间包括所有样例。延迟是从初始响应中提取的。注意HttpClient采样器可能会记录以下消息: &lt;/br&gt; <code>"Redirect requested but followRedirects is disabled"</code></td><td>No</td></tr><tr><td>Use KeepAlive</td><td>JMeter设置Connection: keep-alive头。这在默认HTTP实现中不能正常工作，因为连接重用不在用户控制之下。它与Apache HttpComponents HttpClient实现一起工作。</td><td>No</td></tr><tr><td>Use multipart/form-data for HTTP POST</td><td>使用multipart/form-data或application/x-www-form-urlencoded post请求</td><td>No</td></tr><tr><td>Browser-compatible headers</td><td>当使用multipart/form-data时，这会抑制Content-Type和Content-Transfer-Encoding头;只发送Content-Disposition头部。</td><td>No</td></tr><tr><td>Path</td><td>资源的路径(例如/servlets/myServlet)。如果资源需要查询字符串参数，在下面的"发送请求参数"部分添加它们。 &lt;/br&gt; 在这种情况下，服务器、端口和协议字段被忽略;参数对于GET和DELETE方法也会被忽略。另外请注意，该路径没有被编码——除了用%20替换空格之外——因此可能需要对不安全字符进行编码，以避免出现URISyntaxException等错误。</td><td>No</td></tr><tr><td>Send Parameters With the Request</td><td>查询字符串将从您提供的参数列表中生成。每个参数都有一个名称和值，编码参数的选项，以及包含或排除等号的选项(一些应用程序在值为空字符串时不希望有等号)。查询字符串将以正确的方式生成，取决于你所做的"方法"的选择(即，如果你选择了GET或DELETE，查询字符串将被附加到URL，如果POST或PUT，那么它将被单独发送)。此外，如果您正在使用多部分表单发送文件，那么查询字符串将使用多部分表单规范创建。</td><td>No</td></tr><tr><td>File Path</td><td>要发送的文件的名称。如果留空，JMeter不发送文件，如果填写，JMeter自动发送请求作为一个多部分表单请求。</td><td>No</td></tr><tr><td>Parameter name</td><td>"name"web请求参数的值。</td><td>No</td></tr><tr><td>MIME Type</td><td>MIME类型(例如，文本/普通)。如果是一个POST、PUT或PATCH请求，并且省略了"name"属性(下面)或者请求正文仅由参数值构造，那么该字段的值将被用作内容类型请求头的值。</td><td>No</td></tr><tr><td>从HTML文件中检索所有嵌入式资源</td><td>告诉JMeter解析HTML文件，并对文件中引用的所有图像、Java小程序、JavaScript文件、css等发送HTTP/HTTPS请求。详见下文。</td><td>No</td></tr><tr><td>Save response as MD5 hash?</td><td>如果选择此选项，则响应不会存储在示例结果中。相反，计算并存储数据的32个字符的MD5哈希值。这是为了测试大量数据。</td><td>No</td></tr><tr><td>URLs must match</td><td>如果存在，则必须是一个正则表达式，用于匹配找到的任何嵌入式url。因此，如果您只想从<code>http://example.invalid/</code>下载嵌入式资源，请使用表达式:<code>http://example\.invalid/.*</code></td><td>No</td></tr><tr><td>URLs must not match</td><td>如果存在，则必须是一个正则表达式，用于过滤掉找到的任何嵌入的url。所以，如果你不想从任何来源下载PNG或SVG文件，使用表达式:<code>.*\.(?i: SVG | PNG)</code></td><td>No</td></tr><tr><td>Use concurrent pool</td><td>使用并发连接池来获得嵌入式资源。</td><td>No</td></tr><tr><td>Size</td><td>用于获取嵌入式资源的并发连接的池大小。</td><td>No</td></tr><tr><td>Source address type</td><td>只适用于HTTPClient实现的HTTP请求 &lt;/br&gt;要区分源地址值</td><td>No</td></tr><tr><td>Source address field</td><td>只适用于HTTPClient实现的HTTP请求&lt;/br&gt;此属性用于启用IP欺骗。它覆盖了这个示例的默认本地IP地址。JMeter主机必须有多个IP地址(即IP别名、网络接口、设备)。取值为主机名、IP地址或网口设备，如"eth0"、"lo"、"wlan0"。&lt;/br&gt;如果属性httpclient。定义了localaddress，用于所有HttpClient请求。</td><td>No</td></tr></tbody></table></div><h3 id="JDBC-Request-JDBC-请求">JDBC Request | JDBC 请求</h3><p>这个示例程序允许向数据库发送JDBC请求(一个SQL查询)。</p><p>在使用它之前，您需要设置一个[JDBC Connection Configuration] Configuration元素</p><p>如果提供了Variable Names列表，那么对于Select语句返回的每一行，将使用相应列的值设置变量(如果提供了变量名)，并设置行数。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C9c9ae2a4f9139da9cf540c698bfaf715.png" alt>Screenshot of Control-Panel of JDBC Request</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Variable Name of Pool declared in JDBC Connection Configuration</td><td>连接池绑定到的JMeter变量的名称。这必须与 [JDBC Connection Configuration] 中的 <code>Variable Name</code> 字段一致。</td><td>No</td></tr><tr><td>Query Type</td><td>根据语句类型设置 &lt;/br&gt; - Select Statement&lt;/br&gt; - Update Statement - use this for Inserts and Deletes as well&lt;/br&gt; - Callable Statement&lt;/br&gt;Prepared Select Statement&lt;/br&gt; - Prepared Update Statement - use this for Inserts and Deletes as well&lt;/br&gt; - Commit&lt;/br&gt; - Rollback&lt;/br&gt; - Autocommit(false)&lt;/br&gt; - Autocommit(true)&lt;/br&gt; - Edit - this should be a variable reference that evaluates to one of the above &lt;/br&gt; &lt;/br&gt; <strong>Commit、Rollback、Autocommit(false)和Autocommit(true)类型是特殊的，因为它们只会忽略给定的SQL语句并改变连接的状态。</strong></td><td>Yes</td></tr><tr><td>SQL Query</td><td>SQL query.    &lt;/br&gt;&lt;/br&gt;  <strong>Do not enter a trailing semi-colon.</strong></td><td>Yes</td></tr><tr><td>Parameter values</td><td>逗号分隔的参数值列表。使用<code>]NULL[</code>来表示<code>NULL</code>参数。(如果需要，可以通过定义属性"<code>jdbcsampler.nullmarker</code>"来更改空字符串。)例如，如果任何值包含逗号或双引号，列表必须用双引号括起来，并且任何嵌入的双引号必须是双引号</td><td>Yes, if a prepared or callable statement has parameters</td></tr><tr><td>Parameter types</td><td>逗号分隔的SQL参数类型列表(例如INTEGER, DATE, VARCHAR, DOUBLE)或Constants的整数值。当您使用驱动程序建议的自定义数据库类型(例如OracleTypes。CURSOR可以用其整数值-10表示)。 它们被定义为java.sql类中的字段。</td><td>Yes, if a prepared or callable statement has parameters</td></tr><tr><td>Variable Names</td><td>逗号分隔的变量名列表，用于保存Select语句、Prepared Select语句或CallableStatement返回的值。注意，当与CallableStatement一起使用时，变量列表必须与调用返回的OUT参数的顺序相同。如果变量名比OUT参数少，那么在线程上下文变量中存储的结果与提供的变量名相同。如果存在比OUT参数更多的变量名，则会忽略额外的变量</td><td>No</td></tr><tr><td>Result Variable Name</td><td>如果指定，这将创建一个包含行映射列表的Object变量。每个映射都包含列名作为键，列数据作为值。</td><td>No</td></tr><tr><td>Query timeout(s)</td><td>设置以秒为单位的查询超时时间，空值表示0，表示无穷大。-1意味着不设置任何查询超时，这可能需要用例或当某些驱动程序不支持超时。默认值为0。</td><td>No</td></tr><tr><td>Limit ResultSet</td><td>限制遍历ResultSet的行数。空值意味着-1，例如没有限制，这也是默认值。这可以帮助减少通过JDBC驱动程序从数据库中获取的数据量，但会分别影响Handle ResultSet的所有可能选项——例如:incomplete ResultSet和记录计数≤限制。</td><td>No</td></tr><tr><td>Handle ResultSet</td><td>定义如何处理可调用语句返回的ResultSet &lt;/br&gt; &lt;/br&gt; - <strong>Store As String</strong> (默认)——变量名列表中的所有变量都存储为字符串，当出现在列表中时，不会遍历ResultSet。clob将被转换为string。blob将被转换为string，就像它们是UTF-8编码的字节数组一样。在jdbcsampler之后，clob和blob都将被切断。max_retain_result_size字节。 &lt;/br&gt; - <strong>Store As Object</strong>——变量名称列表中的ResultSet类型的变量将存储为对象，可以在后续的测试/脚本中访问和迭代，不会遍历ResultSet。将像选择Store as String一样处理clob。blob将存储为字节数组。在jdbcsampler之后，clob和blob都将被切断。max_retain_result_size字节。 &lt;/br&gt; - <strong>Count Records</strong>——ResultSet类型的变量将通过显示作为结果的记录计数进行迭代。变量将被存储为string。对于blob，将存储对象的大小。</td><td>No</td></tr></tbody></table></div><h3 id="Java-Request-Java-请求">Java Request | Java 请求</h3><p>这个采样器允许您控制一个实现<code>org.apache.jmeter.protocol.java.sampler.JavaSamplerClient</code>接口的java类。通过编写您自己的这个接口的实现，您可以使用JMeter来利用多线程、输入参数控制和数据收集。</p><p>下拉菜单提供了JMeter在其类路径中找到的所有此类实现的列表。然后可以在下表中指定参数—由您的实现定义。提供了两个简单的示例(JavaTest和SleepTest)。</p><p>JavaTest示例采样器对于检查测试计划很有用，因为它允许在几乎所有字段中设置值。然后，断言等可以使用它们。字段允许使用变量，因此可以很容易地看到这些变量的值。</p><blockquote><p>如果方法teardownTest没有被AbstractJavaSamplerClient的子类覆盖，它的teardownTest方法将不会被调用。这减少了JMeter的内存需求。这不会对现有的Test计划产生任何影响。</p></blockquote><blockquote><p>添加/删除按钮目前没有任何作用。</p></blockquote><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cd1de1a1316e90d2ccc3756391c82334d.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。</td><td>No</td></tr><tr><td>Classname</td><td>要采样的JavaSamplerClient接口的具体实现。</td><td>Yes</td></tr><tr><td>Send Parameters with Request</td><td>将传递给采样类的参数列表。所有参数都作为字符串发送。具体设置见下文。</td><td>No</td></tr></tbody></table></div><h3 id="BeanShell-Sampler-BeanShell-采样器">BeanShell Sampler | BeanShell 采样器</h3><p>这个采样器允许您使用BeanShell脚本语言编写一个采样器。</p><p>test元素支持ThreadListener和TestListener接口方法。它们必须在初始化文件中定义。请参阅文件BeanShellListeners。示例定义为BSHRC。BeanShell采样器还支持可中断接口。可以在脚本或init文件中定义interrupt()方法。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cceb6514c12ffddbf2784b0088cd6b460.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个采样器的描述性名称。名称存储在脚本变量Label中</td><td>No</td></tr><tr><td>Reset bsh.Interpreter before each call</td><td>如果选择此选项，则将为每个示例重新创建解释器。对于一些长期运行的脚本来说，这可能是必要的。有关更多信息，请参阅最佳实践—BeanShell脚本。</td><td>Yes</td></tr><tr><td>Parameters</td><td>传递给BeanShell脚本的参数。这是为了与脚本文件一起使用;对于在GUI中定义的脚本，您可以使用脚本本身中需要的任何变量和函数引用。</td><td>No</td></tr><tr><td>Script file</td><td>包含要运行的BeanShell脚本的文件。文件名存储在脚本变量FileName中</td><td>No</td></tr><tr><td>Script</td><td>要运行的BeanShell脚本。返回值(如果不是null)存储为采样结果。</td><td>Yes (unless script file is provided)</td></tr></tbody></table></div><h3 id="TCP-Sampler-TCP采样器">TCP Sampler | TCP采样器</h3><p>TCP采样器打开一个TCP/IP连接到指定的服务器。然后它发送文本，并等待响应。</p><p>如果选择 “Re-use connection”，在相同线程中的sampler之间共享连接，前提是使用完全相同的主机名字符串和端口。不同的主机/端口组合将使用不同的连接，就像不同的线程一样。如果"Re-use connection"和 “Close connection” 都被选中，套接字将在运行采样器后关闭。在下一个采样器上，将创建另一个 socket。您可能希望在每个线程循环结束时关闭一个 socket。</p><p>以下属性可用于控制其操作:</p><ul><li><code>tcp.status.prefix</code> 文本在状态号之前</li><li><code>tcp.status.suffix</code>文本在状态号之后</li><li><code>tcp.status.properties</code>属性文件的名称，用于将状态码转换为消息</li><li><code>tcp.handler</code> TCP处理程序类的名称(默认TCPClientImpl) -仅在GUI上没有指定时使用</li></ul><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5Cb4fe9d427f42f3072c562649e012e20e.png" alt></p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition note"><p class="admonition-title">参数说明</p><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>Name</td><td>树中显示的这个元素的描述性名称。</td><td>No</td></tr><tr><td>TCPClient classname</td><td>TCPClient类的名称。默认为 <code>tcp.handler</code>。处理程序，<code>TCPClientImpl</code>失败。</td><td>Yes</td></tr><tr><td>ServerName or IP</td><td>TCP服务器的名称或IP</td><td>Yes</td></tr><tr><td>Port Number</td><td>使用的端口</td><td>Yes</td></tr><tr><td>Re-use connection</td><td>如果选中，连接将保持打开状态。否则在读取数据时关闭。</td><td>Yes</td></tr><tr><td>Close connection</td><td>如果选择，则在运行采样器后将关闭连接。</td><td>No</td></tr><tr><td>SO_LINGER</td><td>在创建 <code>socket</code> 时使用指定的延迟时间(秒)启用/禁用SO_LINGER。如果你设置"SO_LINGER"值为0，你可能会阻止大量带有TIME_WAIT状态的套接字闲置。</td><td>No</td></tr><tr><td>End of line(EOL) byte value</td><td>行尾的字节值，将其设置为范围<code>-128</code>到<code>+127</code>以外的值，以跳过<code>eol</code>检查。你可以在 <code>jmeter.properties</code> 中设置这个以及eolByte属性。如果你在TCP采样配置和jmeter中设置这个。属性文件的同时，将使用TCP采样器配置中的设置值。</td><td>No</td></tr><tr><td>Connect Timeout</td><td>连接超时(毫秒，0禁用)。</td><td>No</td></tr><tr><td>Response Timeout</td><td>响应超时(毫秒，0禁用)。</td><td>Yes</td></tr><tr><td>Set NoDelay</td><td>看<code>java.net.Socket.setTcpNoDelay()</code>。如果选中，将禁用Nagle的算法，否则将使用Nagle的算法。</td><td>Yes</td></tr><tr><td>Text to Send</td><td>要发送的文本</td><td>Yes</td></tr><tr><td>Login User</td><td>用户名-默认实现中未使用</td><td>No</td></tr><tr><td>Password</td><td>密码-默认实现中不使用(注意，这个未加密存储在测试计划中)</td><td>No</td></tr></tbody></table></div><h3 id="Mail-Reader-Sampler-邮件阅读采样器">Mail Reader Sampler | 邮件阅读采样器</h3><p>邮件阅读器采样器可以使用POP3(S)或IMAP(S)协议读取(并可选地删除)邮件消息。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">界面</p><p><img src="/attachment%5C11aabe48e984000aa7f78cd7e353602f.png" alt></p></div>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/组件 </tag>
            
            <tag> 细化主题/采样器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter</title>
      <link href="/jmeter/jmeter/"/>
      <url>/jmeter/jmeter/</url>
      
        <content type="html"><![CDATA[<h1>JMeter</h1><h2 id="Metadata-14">Metadata</h2><pre><code class="language-yml">title: JMeterdate: 2022-12-13 13:16tags:   - 行动阶段/完成  - 主题场景/工具  - 笔记空间/KnowladgeSpace/ToolSpace  - 细化主题/测试工具  - 细化主题/JMetercategories:  - 工具keywords:  - 测试工具description: Apache JMeter™应用程序是开源软件，100%纯Java应用程序，用于加载测试功能行为和测量性能。它最初是为测试Web应用程序而设计的，但后来扩展到其他测试功能。</code></pre><h2 id="推荐指数：">推荐指数：</h2><ul><li>实用性： ⭐⭐⭐</li><li>稳定性： ⭐⭐⭐⭐⭐</li><li>复杂性：⭐⭐⭐⭐</li></ul><h2 id="文件结构">文件结构</h2><pre><code class="language-text">- bin - 启动jmeter的所有文件    - properties结尾的文件，都是jmeter的属性配置文件，最主要的是`jmeter.properties`    - create-rmi-keystore：创建证书    - jmeter.log：日志打印- docs  - 开发人员使用的api文档- extras  - 持续集成CI/CD使用- lib  - jmeter工具的源码二进制jar包    - `/ext`：使用第三方插件时，把第三方jar放到该目录- printable_docs  - jmeter工具，离线帮助文档</code></pre><h2 id="开发接口测试案例的整体方案">开发接口测试案例的整体方案</h2><ul><li>第一步：我们要分析出测试需求，并拿到开发提供的接口说明文档；</li><li>第二步：从接口说明文档中整理出接口测试案例，里面要包括详细的入参和出参数据以及明确的格式和检查点。</li><li>第三步：和开发一起对接口测试案例进行评审。</li><li>第四步：结合开发库，准备接口测试案例中的入参数据和出参数据，并整理成 csv 格式的文件。</li><li>第五步：结合接口测试案例文档和 csv 格式的数据文档，做接口测试案例的自动化案例开发。</li></ul><h2 id="接口自动化适用场景">接口自动化适用场景</h2><ol><li><p>测试前置、开发自测：一个新的自动化接口测试案例开发完成后，直接发给接口对应的开发，安排在开发本地环境执行，一旦开发确认完成接口开发，就开始执行接口测试案例，基本上可以实时拿到测试结果，方便开发快速做出判断。【开发本地运行的方式就是打开 JMeter 工具，导入 JMX 文件，开始执行可。】</p></li><li><p>回归测试：开发本地测试通过后，或整个需求手工测试通过后，把自动化的接口测试案例做分类整理，挑选出需要纳入到回归测试中的案例，在持续集成环境重新准备测试数据，并把案例纳入到持续集成的 job 中来，这些用于回归的接口测试案例需要配置到持续集成平台自动运行。</p></li></ol><h2 id="测试计划-元素">测试计划 元素</h2><h3 id="执行顺序">执行顺序</h3><ol start="0"><li>配置元素</li><li>预处理器</li><li>计时器</li><li>采样器</li><li>后处理器（除非 SampleResult 为null）</li><li>断言（除非 SampleResult 为null）</li><li>侦听器（除非 SampleResult 为null）</li></ol><h3 id="组件">组件</h3><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">测试计划</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">线程组</p><ul><li>线程组元素是任何测试计划的起点。</li><li>所有控制器和采样器都必须在一个线程组下。</li><li>线程组的控件允许您：<ul><li>设置线程数</li><li>设置加速周期</li><li>设置执行测试的次数</li></ul></li><li>设置完成时间</li><li>指定线程生命周期</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">采样器</p><p>采样器告诉 JMeter 向服务器发送请求并等待响应。它们按照它们在树中出现的顺序进行处理。控制器可用于修改采样器的重复次数。</p><p>采样器包括</p><ul><li>FTP 请求</li><li>HTTP 请求（也可用于 SOAP 或 REST Web 服务）</li><li>JDBC 请求</li><li>Java 对象请求</li><li>JMS 请求</li><li>JUnit 测试请求</li><li>LDAP 请求</li><li>邮件请求</li><li>操作系统进程请求</li><li>TCP 请求</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">逻辑控制器</p><p>允许您自定义 JMeter 用来决定何时发送请求的逻辑。逻辑控制器可以更改来自其子元素的请求的顺序。他们可以自己修改请求，导致 JMeter 重复请求等。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">监听器</p><ul><li>侦听器提供对 JMeter 在 JMeter 运行时收集的有关测试用例的信息的访问。</li><li>侦听器可以将数据定向到文件以供以后使用。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">计时器</p><p>添加到您的线程组来指定延迟</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">断言</p><p>断言允许您断言有关从正在测试的服务器收到的响应的事实。使用断言，您基本上可以“测试”您的应用程序正在返回您期望的结果。</p><p>断言适用于其<a href="#scoping_rules">范围内</a>的所有采样器。要将断言限制为单个采样器，请将断言添加为采样器的子级。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">配置元素</p><ul><li>配置元素与采样器密切合作。</li><li>只能从放置元素的树分支内部访问配置元素。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">预处理器</p><ul><li>预处理器在发出采样器请求之前执行一些操作。如果预处理器附加到采样器元素，则它将在该采样器元素运行之前执行。</li><li>预处理器最常用于在样本请求运行之前修改其设置，或更新未从响应文本中提取的变量。</li></ul></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">后处理器</p><ul><li>在发出采样器请求后，后处理器会执行一些操作。如果 Post-Processor 附加到 Sampler 元素，则它将在该 sampler 元素运行后立即执行。</li><li>后处理器最常用于处理响应数据，通常用于从中提取值。</li></ul></div><h2 id="构建测试计划">构建测试计划</h2><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">添加和删除元素</p><p>可以通过右键单击树中的元素并从“添加”列表中选择一个新元素来向测试计划添加元素。或者，可以通过选择“合并”或“打开”选项从文件中加载元素并添加元素。</p><p>要删除一个元素，请确保该元素已被选中，右键单击该元素，然后选择“删除”选项。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">加载和保存元素</p><p>要从文件加载元素，右键单击要添加加载元素的现有树元素，然后选择“合并”选项。选择保存元素的文件。JMeter 会将元素合并到树中。</p><p>要保存树元素，请右键单击一个元素并选择“将选择另存为... ”选项。JMeter 将保存选定的元素，以及它下面的所有子元素。这样，您可以保存测试树片段和单个元素以供以后使用。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">配置树元素</p><p>测试树中的任何元素都将在 JMeter 的右侧框架中显示控件。这些控件允许您配置该特定测试元素的行为。可以为元素配置什么取决于它是什么类型的元素。</p><p>测试树本身可以通过在测试树周围拖放组件来操作。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">保存测试计划</p><p>尽管不是必需的，但我们建议您在运行测试计划之前将其保存到文件中。要保存测试计划，请从文件菜单中选择“保存”或“将测试计划另存为... ”（对于最新版本，不再需要先选择测试计划元素）。</p><p>JMeter 允许您保存整个测试计划树或仅保存其中的一部分。要仅保存位于测试计划树的特定“分支”中的元素，请在树中选择“测试计划”元素以启动“分支”，然后单击鼠标右键访问“将选择另存为... " 菜单项。或者，选择适当的测试计划元素，然后从“编辑”菜单中 选择“将选择另存为... ”。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">运行测试计划</p><p>要运行您的测试计划，请从“运行”菜单项中选择“开始”（Control  +  r） 。当 JMeter 运行时，它会在菜单栏下方的部分右侧显示一个绿色小框。您还可以检查“运行”菜单。如果“开始”被禁用，并且“停止”被启用，那么 JMeter 正在运行您的测试计划（或者，至少，它认为是这样）。</p><p>绿色框左侧的数字是活动线程数/线程总数。这些仅适用于本地运行的测试；它们不包括使用客户端-服务器模式时在远程系统上启动的任何线程。</p><p>仅在调试测试计划时才应使用此处描述的 GUI 模式。要运行实际负载测试，请使用 CLI 模式。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">停止测试</p><p>菜单中有两种可用的停止命令：</p><p>Stop ( Control  +  . ) - 如果可能，立即停止线程。许多采样器是可中断的，这意味着活动采样可以提前终止。stop 命令将检查所有线程是否已在默认超时时间内停止，即 5000 ms = 5 秒。[这可以使用 JMeter 属性jmeterengine.threadstop.wait进行更改] 如果线程没有停止，则会显示一条消息。停止命令可以重试，但如果失败，则需要退出 JMeter 进行清理。Shutdown ( Control  +  , ) - 请求线程在任何当前工作结束时停止。不会中断任何活动样本。模式关闭对话框将保持活动状态，直到所有线程都停止。如果关机时间过长。关闭 Shutdown 对话框并选择Run / Stop，或者只需按Control  +  。.</p><p>在 CLI 模式下运行 JMeter 时，没有菜单，并且 JMeter 不会对诸如Control  + 等按键做出反应。. 因此 JMeter CLI 模式将监听特定端口上的命令（默认4445，请参阅 JMeter 属性jmeterengine.nongui.port）。如果正在使用默认端口（例如由另一个 JMeter 实例），JMeter 支持自动选择备用端口。在这种情况下，JMeter 将尝试下一个更高的端口，一直持续到它到达默认为 4455 的JMeter属性<code>jmeterengine.nongui.maxport</code>。如果<code>maxport</code>小于或等于port，则不会进行端口扫描。</p><p>所选端口显示在控制台窗口中。</p><p>目前支持的命令有：</p><ul><li>shotdown - 优雅关机</li><li>StopTestNow - 立即关闭</li></ul><p>这些命令可以分别使用<code>shutdown[.cmd|.sh]</code>或<code>stoptest[.cmd|.sh]</code>脚本发送。这些脚本可以在 JMeter bin目录中找到。仅当脚本从同一主机运行时，才会接受这些命令。</p></div><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">错误报告</p><p>JMeter 向jmeter.log文件 报告警告和错误，以及测试运行本身的一些信息。JMeter 在其窗口右侧的警告图标（三角形）旁边显示在jmeter.log文件中发现的警告/错误的数量。单击警告图标以在 JMeter 窗口的底部显示jmeter.log文件。只是偶尔可能会出现一些 JMeter 无法捕获和记录的错误；这些将出现在命令控制台上。如果测试没有按预期进行，请检查日志文件以防报告任何错误（例如，可能是函数调用中的语法错误）。</p><p>日志文件中通常不会报告采样错误（例如 HTTP 404 - 未找到文件）。相反，这些被存储为样本结果的属性。可以在各种不同的侦听器中看到样本结果的状态。</p></div><h2 id="命令行选项的完整列表">命令行选项的完整列表</h2><p>调用JMeter作为<code>JMeter -?</code>将打印所有命令行选项的列表。它们如下所示。</p><style>.admonition {  margin: 1.5625em 0;  padding: .6rem;  overflow: hidden;  font-size: 1.00rem;  page-break-inside: avoid;  border-left: .3rem solid #42b983;  border-radius: .3rem;  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);  background-color: #fafafa;}p.admonition-title {  position: relative;  margin: -.6rem -.6rem .8em -.6rem !important;  padding: .4rem .6rem .4rem 2.5rem;  font-weight: 700;  background-color:rgba(66, 185, 131, .1);}.admonition-title::before {  position: absolute;  top: .9rem;  left: 1rem;  width: 12px;  height: 12px;  background-color: #42b983;  border-radius: 50%;  content: ' ';}.info>.admonition-title, .todo>.admonition-title {  background-color: rgba(0,184,212,.1);}.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {  background-color: rgba(255,145,0,.1);}.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {  background-color: rgba(255,82,82,.1);}.admonition.info, .admonition.todo {  border-color: #00b8d4;}.admonition.warning, .admonition.attention, .admonition.caution {  border-color: #ff9100;}.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {  border-color: #ff5252;}.info>.admonition-title::before, .todo>.admonition-title::before {  background-color: #00b8d4;  border-radius: 50%;}.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {  background-color: #ff9100;  border-radius: 50%;}.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{  background-color: #ff5252;;  border-radius: 50%;}.admonition>:last-child {  margin-bottom: 0 !important;}</style><div class="admonition info"><p class="admonition-title">JMeter 命令行列表</p><pre><code class="language-shell">    --?        print command line options and exit    -h, --help        print usage information and exit    -v, --version        print the version information and exit    -p, --propfile &lt;argument&gt;        the jmeter property file to use    -q, --addprop &lt;argument&gt;        additional JMeter property file(s)    -t, --testfile &lt;argument&gt;        the jmeter test(.jmx) file to run    -l, --logfile &lt;argument&gt;        the file to log samples to    -i, --jmeterlogconf &lt;argument&gt;        jmeter logging configuration file (log4j2.xml)    -j, --jmeterlogfile &lt;argument&gt;        jmeter run log file (jmeter.log)    -n, --nongui        run JMeter in nongui mode    -s, --server        run the JMeter server    -H, --proxyHost &lt;argument&gt;        Set a proxy server for JMeter to use    -P, --proxyPort &lt;argument&gt;        Set proxy server port for JMeter to use    -N, --nonProxyHosts &lt;argument&gt;        Set nonproxy host list (e.g. *.apache.org|localhost)    -u, --username &lt;argument&gt;        Set username for proxy server that JMeter is to use    -a, --password &lt;argument&gt;        Set password for proxy server that JMeter is to use    -J, --jmeterproperty &lt;argument&gt;=&lt;value&gt;        Define additional JMeter properties    -G, --globalproperty &lt;argument&gt;=&lt;value&gt;        Define Global properties (sent to servers)        e.g. -Gport=123         or -Gglobal.properties    -D, --systemproperty &lt;argument&gt;=&lt;value&gt;        Define additional system properties    -S, --systemPropertyFile &lt;argument&gt;        additional system property file(s)    -f, --forceDeleteResultFile        force delete existing results files and web report folder if present before starting the test    -L, --loglevel &lt;argument&gt;=&lt;value&gt;        [category=]level e.g. jorphan=INFO, jmeter.util=DEBUG or com.example.foo=WARN    -r, --runremote        Start remote servers (as defined in remote_hosts)    -R, --remotestart &lt;argument&gt;        Start these remote servers (overrides remote_hosts)    -d, --homedir &lt;argument&gt;        the jmeter home directory to use    -X, --remoteexit        Exit the remote servers at end of test (CLI mode)    -g, --reportonly &lt;argument&gt;        generate report dashboard only, from a test results file    -e, --reportatendofloadtests        generate report dashboard after load test    -o, --reportoutputfolder &lt;argument&gt;        output folder for report dashboard</code></pre></div><h2 id="JMeter-配置">JMeter 配置</h2><table><thead><tr><th>Attribute</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>ssl.provider</td><td>如果不想使用内置Java实现，可以为SSL实现指定类。</td><td>No</td></tr><tr><td>xml.parser</td><td>您可以指定一个实现作为XML解析器。默认值为: <code>org.apache.xerces.parser . saxparser</code></td><td>No</td></tr><tr><td>remote_hosts</td><td>以逗号分隔的远程JMeter主机列表(如果需要，可以选择主机:端口)。如果您在分布式环境中运行JMeter，请列出运行JMeter远程服务器的机器。这将允许您从这台机器的GUI控制这些服务器</td><td>No</td></tr><tr><td>not_in_menu</td><td>不希望在JMeter菜单中看到的组件列表。随着JMeter添加了越来越多的组件，您可能希望自定义JMeter以只显示您感兴趣的那些组件。您可以在这里列出它们的类名或类标签(出现在JMeter UI中的字符串)，它们将不再出现在菜单中。</td><td>No</td></tr><tr><td>search_paths</td><td>JMeter将搜索JMeter插件类的路径列表(以;分隔)，例如额外的采样器。路径项可以是jar文件或目录。在这样一个目录中的任何jar文件将自动包含在search_path中，子目录中的jar文件将被忽略。给定的值是在lib/ext目录中找到的任何jar之外的值。</td><td>No</td></tr><tr><td>user.classpath</td><td>JMeter将搜索实用程序和插件依赖类的路径列表。使用平台路径分隔符分隔多个路径。路径项可以是jar文件或目录。这样一个目录中的任何jar文件都将自动包含在user中。类路径，子目录中的jar文件将被忽略。给定的值是在lib目录中找到的任何jar之外的值。所有条目都将添加到系统类装入器的类路径中，也会添加到JMeter内部装入器的路径中。</td><td>No</td></tr><tr><td>plugin_dependency_paths</td><td>JMeter将搜索实用程序和插件依赖类的路径列表(以;分隔)。路径项可以是jar文件或目录。在这样一个目录中的任何jar文件将自动包含在plugin_dependency_paths中，子目录中的jar文件将被忽略。给定的值是在lib目录中找到的jar文件之外的，或者是用户给出的。类路径属性。所有条目将只被添加到JMeter内部加载器的路径中。对于插件依赖，使用plugin_dependency_paths应该优于user.classpath。</td><td>No</td></tr><tr><td>user.properties</td><td>包含附加JMeter属性的文件的名称。它们添加在初始属性文件之后，但在处理-q和-J选项之前。</td><td>No</td></tr><tr><td>system.properties</td><td>包含附加系统属性的文件的名称。在处理-S和-D选项之前添加这些选项。</td><td>No</td></tr></tbody></table><p>命令行选项和属性文件的处理顺序如下:</p><ol><li>-p propfile</li><li>jmeter.properties (or the file from the -p option) is then loaded</li><li>-j logfile</li><li>Logging is initialised</li><li>user.properties is loaded</li><li>system.properties is loaded</li><li>all other command-line options are processed</li></ol><h2 id="组件详解">组件详解</h2><ul><li><a href="../jmeter-zu-jian-xiang-jie-assertions-duan-yan">Assertions 断言</a></li><li><a href="../jmeter-zu-jian-xiang-jie-configuration-pei-zhi-yuan-jian">Configuration 配置原件</a></li><li><a href="../jmeter-zu-jian-xiang-jie-listeners-jian-ting-qi">Listeners 监听器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-logic-controllers-luo-ji-kong-zhi-qi">Logic Controller 控制器</a></li><li><a href="jmeter-zu-jian-xiang-jie-pre-processors-qian-zhi-chu-li-qi">Pre-Processors 前置处理器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-post-processors-hou-zhi-chu-li-qi">Post Processors 后置处理器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-samplers-cai-yang-qi">Samplers 采样器</a></li><li><a href="../jmeter-zu-jian-xiang-jie-timers-ding-shi-qi">Timers 定时器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JMeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行动阶段/完成 </tag>
            
            <tag> 主题场景/工具 </tag>
            
            <tag> 笔记空间/KnowladgeSpace/ToolSpace </tag>
            
            <tag> 细化主题/JMeter </tag>
            
            <tag> 细化主题/测试工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-个人博客-索引</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-suo-yin/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1>hexo-个人博客-索引</h1><h2 id="Metadata-3">Metadata</h2><pre><code class="language-yml">- title: hexo-个人博客-索引- date: 2022-08-09 14:42- version: Version 1.1.0- updated: 2022-08-09 14:42- aside: true- top_img: - comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - Blog  - index- categories:  - hexo- keyword:  - 索引- description: hexo的个人博客的相关文章索引</code></pre><h2 id="索引">索引</h2><h3 id="hexo-个人博客-构建教程">hexo-个人博客-构建教程</h3><p><a href="../hexo-ge-ren-bo-ke-gou-jian-jiao-cheng">点我跳转</a></p><p><strong>TOC</strong></p><ul><li>安装及配置</li><li>hexo 的相关命令</li></ul><h3 id="hexo-个人博客-个性化-matery主题">hexo-个人博客-个性化-matery主题</h3><p><a href="../hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti">点我跳转</a></p><p><strong>TOC</strong></p><ul><li>简介</li><li>下载</li><li>配置</li><li>文章 Front-matter 介绍</li><li>效果截图</li><li>自定制修改</li><li>版本变更记录</li><li>更多部署方式</li></ul><h2 id="更新日志-2">更新日志</h2><h3 id="Version-1-0-0-2">Version 1.0.0</h3><p><strong>Done</strong></p><ul><li>hexo-个人博客-构建教程</li><li>hexo-个人博客-个性化-matery主题</li></ul><p><strong>TODO</strong></p><ul><li></li></ul><h3 id="Version-1-1-0-2">Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02_hexo-个人博客-个性化-matery主题</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-ge-xing-hua-matery-zhu-ti/</url>
      
        <content type="html"><![CDATA[<h1>hexo-个人博客-个性化-matery主题</h1><h2 id="Metadata">Metadata</h2><pre><code class="language-yml">- title: hexo-个人博客-个性化-matery主题- date: 2022-08-09 11:02- version: Version 1.1.0- updated: 2022-08-09 11:02- aside: true- top_img:- comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - hexo-theme  - Blog  - matery- categories:  - hexo- keywords:  - matery 主题- description: hexo-theme-matery主题的相关介绍和配置</code></pre><h2 id="简介">简介</h2><blockquote><p>这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。</p></blockquote><h3 id="跳转链接">跳转链接</h3><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery">github hexo-theme-matery</a></li><li><a href="http://blinkfox.com/">国内访问示例</a></li></ul><h3 id="特性">特性</h3><ul><li>简单漂亮，文章内容美观易读</li><li>Material Design 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 Banner 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li>词云的标签页和雷达图的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 MathJax</li><li>TOC 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li>Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk）</li><li>集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li><li>支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。</li><li>支持 DaoVoice、Tidio 在线聊天功能。</li></ul><h2 id="下载">下载</h2><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。</p><p>当然你也可以在你的 themes 文件夹下使用 git clone 命令来下载:</p><pre><code class="language-git">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置">配置</h2><h3 id="切换主题">切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 theme 的值：<code>theme: hexo-theme-matery</code></p><p><strong>_config.yml 文件的其它修改建议:</strong></p><ul><li>请修改 <code>_config.yml</code> 的 url 的值为你的网站主 URL（如：<a href="http://xxx.github.io">http://xxx.github.io</a>）。</li><li>建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 language 的值为 zh-CN。</li></ul><h3 id="相关页面">相关页面</h3><h4 id="新建分类-categories-页">新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "categories"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h4 id="新建标签-tags-页">新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "tags"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h4 id="新建关于我-about-页">新建关于我 about 页</h4><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "about"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---</code></pre><h4 id="新建留言板-contact-页（可选的）">新建留言板 contact 页（可选的）</h4><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "contact"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: contactdate: 2018-09-30 17:25:30type: "contact"layout: "contact"---</code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h4 id="新建友情链接-friends-页（可选的）">新建友情链接 friends 页（可选的）</h4><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="language-bash">hexo new page "friends"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---</code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre><code class="language-json">[{    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",    "name": "码酱",    "introduction": "我不是大佬，只是在追寻大佬的脚步",    "url": "http://luokangyuan.com/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/4027734.jpeg",    "name": "闪烁之狐",    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",    "url": "https://blinkfox.github.io/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/avatar.jpg",    "name": "ja_rome",    "introduction": "平凡的脚步也可以走出伟大的行程",    "url": "https://me.csdn.net/jlh912008548",    "title": "前去学习"}]</code></pre><h4 id="新建-404-页">新建 404 页</h4><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre><code class="language-bash">hexo new page 404</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre><code class="language-yaml">---title: 404date: 2018-09-30 17:25:30type: "404"layout: "404"description: "Oops～，我崩溃了！找不到你想要的页面 :("---</code></pre><h3 id="菜单导航配置">菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon">配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找</p><pre><code class="language-yaml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle  Friends:    url: /friends    icon: fas fa-address-book</code></pre><h4 id="二级菜单配置方法">二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)</li><li>在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.</li><li>注意每个二级菜单模块前要加 <code>-</code>.</li><li>注意缩进格式</li></ol><pre><code class="language-yaml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle-o  Friends:    url: /friends    icon: fas fa-address-book  Medias:    icon: fas fa-list    children:      - name: Music        url: /music        icon: fas fa-music      - name: Movies        url: /movies        icon: fas fa-film      - name: Books        url: /books        icon: fas fa-book      - name: Galleries        url: /galleries        icon: fas fa-image</code></pre><h3 id="代码高亮">代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre><code class="language-yaml">highlight:  enable: false  line_number: true  auto_detect: false  tab_replace: ''  wrap: true  hljs: falseprismjs:  enable: true  preprocess: true  line_number: true  tab_replace: ''</code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索">搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre><code class="language-bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="language-yaml">search:  path: search.xml  field: post</code></pre><h3 id="中文链接转拼音（建议安装）">中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre><code class="language-bash">npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="language-yaml">permalink_pinyin:  enable: true  separator: '-' # default: '-'</code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）">文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre><code class="language-bash">npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre><code class="language-yaml">postInfo:  date: true  update: false  wordCount: false # 设置文章字数统计为 true.  totalCount: false # 设置站点文章总字数统计为 true.  min2read: false # 阅读时长.  readCount: false # 阅读次数.</code></pre><h3 id="添加emoji表情支持（可选的）">添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre><code class="language-bash">npm install hexo-filter-github-emojis --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="language-yaml">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h3 id="添加-RSS-订阅支持（可选的）">添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre><code class="language-bash">npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="language-yaml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）">添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）">添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚">修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接">修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre><code class="language-html">&lt;% if (theme.socialLink.github) { %&gt;    &lt;a href="&lt;%= theme.socialLink.github %&gt;" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt;        &lt;i class="fab fa-github"&gt;&lt;/i&gt;    &lt;/a&gt;&lt;% } %&gt;</code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片">修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）">配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre><code class="language-yaml"># 是否在首页显示音乐music:  enable: true  title:         # 非吸底模式有效    enable: true    show: 听听音乐  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 503838841     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠</code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="添加note">添加note</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-note"></a></p></blockquote><h4 id="Usage">Usage</h4><pre><code>{% note [class] [no-icon] [summary] %}Any content (support inline tags too).{% endnote %}</code></pre><ul><li><code>[class]</code> : <em>Optional parameter.</em> Supported values: default | primary | success | info | warning | danger.</li><li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon in note.</li><li><code>[summary]</code> : <em>Optional parameter.</em> Optional summary of the note.</li></ul><p>All parameters are optional.</p><h4 id="example">example</h4><pre><code>{% note %}#### Header(without define class style){% endnote %}</code></pre><h3 id="添加button">添加button</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-button"></a></p></blockquote><h4 id="Usage-2">Usage</h4><pre><code>{% button url, text, icon [class], [title] %}</code></pre><p>or</p><pre><code>{% btn url, text, icon [class], [title] %}</code></pre><ul><li><code>url</code> : Absolute or relative path to URL.</li><li><code>text</code> : Button text. Required if no icon specified.</li><li><code>icon</code> : Font Awesome icon name. Required if no text specified.</li><li><code>[class]</code> : <em>Optional parameter.</em> Font Awesome class(es): <code>fa-fw</code> | <code>fa-lg</code> | <code>fa-2x</code> | <code>fa-3x</code> | <code>fa-4x</code> | <code>fa-5x</code></li><li><code>[title]</code> : <em>Optional parameter.</em> Tooltip at mouseover.</li></ul><h4 id="Examples">Examples</h4><pre><code>{% button #, Text %}</code></pre><h2 id="文章-Front-matter-介绍">文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解">Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例">最简示例</h3><pre><code class="language-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例">最全示例</h3><pre><code class="language-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="效果截图">效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改">自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色">修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre><code class="language-css">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="修改-banner-图和文章特色图">修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre><code class="language-javascript">$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');</code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本变更记录">版本变更记录</h2><p>参见 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/CHANGELOG.md">CHANGELOG.md</a></p><h2 id="更多部署方式">更多部署方式</h2><blockquote><p>Jsdelivr 已经被封了，这两个可以加速访问快一点</p></blockquote><ul><li><p><a href="https://blog.17lai.site/posts/5311b619/#vercel-%E9%83%A8%E7%BD%B2"></a></p></li><li><p><a href="https://blog.17lai.site/posts/5311b619/#cloudflare-Pages-%E9%83%A8%E7%BD%B2"></a></p></li></ul><h2 id="BUG-及-解决">BUG 及 解决</h2><ul><li></li></ul><h2 id="更新日志">更新日志</h2><h3 id="Version-1-0-0">Version 1.0.0</h3><p><strong>Done</strong></p><ul><li>文章的创建</li><li>matery 主题的介绍及下载配置</li></ul><p><strong>TODO</strong></p><ul><li></li></ul><h3 id="Version-1-1-0">Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul><h2 id="参考文献">参考文献</h2><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a><ul><li>README_CN.md</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo-theme </tag>
            
            <tag> Blog </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01_hexo-个人博客-构建教程</title>
      <link href="/hexo/hexo-ge-ren-bo-ke-gou-jian-jiao-cheng/"/>
      <url>/hexo/hexo-ge-ren-bo-ke-gou-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1>hexo-个人博客-构建教程</h1><h2 id="Metadata-4">Metadata</h2><pre><code class="language-yml">- title: hexo-个人博客 构建教程- date: 2022-08-07 15:44- version: Version 1.1.0- updated: 2022-08-07 15:44- aside: true- top_img: - comments: true- cover: - toc: true- toc_number: true- toc_style_simple: false- katex: false- highlight_shrink: false- tags:  - hexo  - gitlab  - Blog- categories:  - hexo- keywords:  - 构建教程- description: hexo的个人博客搭建教程 - 包括基础的配置，bug的修复，与github的连接以及 matery主题的简记</code></pre><h2 id="安装及配置">安装及配置</h2><h3 id="安装-Node-js">安装 Node.js</h3><ol><li>下载Node.js。</li><li>安装选项全部默认，一路点击Next。</li><li>输入node -v和npm -v，如果出现版本号，那么就安装成功了。</li></ol><h3 id="安装-git">安装 git</h3><p>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入git --version验证是否安装成功。</p><h3 id="Github-配置">Github 配置</h3><p>打开 <code>https://github.com/</code> ，新建一个项目。</p><p>然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的github名字完全一样，比如你github名字叫abc，<a href="http://xn--abc-p18dxmy1av1ys8ojraw1vmswd20h9mta.github.io">那么仓库名字一定要是abc.github.io</a>。</p><p>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages。</p><p>点击那个链接，就会出现自己的网页。</p><h3 id="安装-Hexo">安装 Hexo</h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件。</p><p>在终端中，定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<code>http://localhost:4000/</code>。</p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h3 id="连接-Github-与-本地">连接 Github 与 本地</h3><h4 id="git-SSH-配置">git SSH 配置</h4><p>可参考其他教程，暂不赘述。</p><h4 id="hexo-连接-github">hexo 连接 github</h4><p>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><pre><code class="language-yml">deploy:  type: git  repository: https://github.com/【username】/【username】.github.io  branch: master</code></pre><ul><li>【username】:  替换成 github 的 username</li></ul><h2 id="hexo-的-相关命令">hexo 的 相关命令</h2><h3 id="init">init</h3><pre><code class="language-bash">$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js"></a> 安装。</li></ol><h3 id="new">new</h3><pre><code class="language-bash">$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code class="language-bash">$ hexo new "post title with whitespace"</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, --path</td><td>自定义新文章的路径</td></tr><tr><td>-r, --replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, --slug</td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code class="language-bash">hexo new page --path about/me "About me"</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>"About me"</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre><code class="language-bash">hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>"page"</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h3 id="generate">generate</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d, --deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, --watch</td><td>监视文件变动</td></tr><tr><td>-b, --bail</td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td>-f, --force</td><td>强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td>-c, --concurrency</td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><pre><code class="language-bash">$ hexo g</code></pre><h3 id="publish">publish</h3><pre><code class="language-bash">$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><h3 id="server">server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p, --port</td><td>重设端口</td></tr><tr><td>-s, --static</td><td>只使用静态文件</td></tr><tr><td>-l, --log</td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="deploy">deploy</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-g, --generate</td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><pre><code class="language-bash">$ hexo d</code></pre><h3 id="render">render</h3><pre><code class="language-bash">$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-o, --output</td><td>设置输出路径</td></tr></tbody></table><h3 id="migrate">migrate</h3><pre><code class="language-bash">$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h3 id="clean">clean</h3><pre><code class="language-bash">$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list">list</h3><pre><code class="language-bash">$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><h3 id="version">version</h3><pre><code class="language-bash">$ hexo version</code></pre><p>显示 Hexo 版本。</p><h3 id="选项">选项</h3><h4 id="安全模式">安全模式</h4><pre><code class="language-bash">$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="调试模式">调试模式</h4><pre><code class="language-bash">$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。</p><h4 id="简洁模式">简洁模式</h4><pre><code class="language-bash">$ hexo --silent</code></pre><p>隐藏终端信息。</p><h4 id="自定义配置文件的路径">自定义配置文件的路径</h4><pre><code class="language-bash">$ hexo server --config custom.yml$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><pre><code class="language-bash">$ hexo server --config custom.yml$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h4 id="显示草稿">显示草稿</h4><pre><code class="language-bash">$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h4 id="自定义-CWD">自定义-CWD</h4><pre><code class="language-bash">$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p><h2 id="BUG-及-解决-2">BUG 及 解决</h2><ul><li></li></ul><h2 id="更新日志-3">更新日志</h2><h3 id="Version-1-0-1">Version 1.0.1</h3><p><strong>Done</strong></p><ul><li>创建笔记</li><li>hexo 的安装及配置</li><li>笔记的拆分</li></ul><h3 id="Version-1-1-0-3">Version 1.1.0</h3><p><strong>Done</strong></p><ul><li>修改成 <code>Butterfly</code> 样式</li></ul><h2 id="参考文献-2">参考文献</h2><ul><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-1"></a><ul><li>韦阳的博客</li><li>笔记的安装及配置</li></ul></li><li><a href="https://hexo.io/zh-cn/docs/commands">指令</a><ul><li>hexo 官网</li><li>hexo 的指令</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
