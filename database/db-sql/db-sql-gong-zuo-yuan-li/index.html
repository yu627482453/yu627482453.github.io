<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【DB SQL】 工作原理 | 蝶梦庄生</title><meta name="keywords" content="数据存储"><meta name="author" content="Bill Cypher"><meta name="copyright" content="Bill Cypher"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【DB SQL】 工作原理">
<meta property="og:type" content="article">
<meta property="og:title" content="【DB SQL】 工作原理">
<meta property="og:url" content="https://yu627482453.github.io/database/db-sql/db-sql-gong-zuo-yuan-li/index.html">
<meta property="og:site_name" content="蝶梦庄生">
<meta property="og:description" content="【DB SQL】 工作原理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-12-20T07:06:00.000Z">
<meta property="article:modified_time" content="2022-12-20T07:06:00.000Z">
<meta property="article:author" content="Bill Cypher">
<meta property="article:tag" content="行动阶段&#x2F;完成">
<meta property="article:tag" content="笔记空间&#x2F;KnowladgeSpace&#x2F;ProgramSpace&#x2F;BasicsSpace">
<meta property="article:tag" content="主题场景&#x2F;数据存储">
<meta property="article:tag" content="细化主题&#x2F;数据存储&#x2F;DB_SQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yu627482453.github.io/database/db-sql/db-sql-gong-zuo-yuan-li/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bill Cypher","link":"链接: ","source":"来源: 蝶梦庄生","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【DB SQL】 工作原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-20 15:06:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">蝶梦庄生</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【DB SQL】 工作原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-20T07:06:00.000Z" title="发表于 2022-12-20 15:06:00">2022-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-20T07:06:00.000Z" title="更新于 2022-12-20 15:06:00">2022-12-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">数据存储</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【DB SQL】 工作原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>【DB SQL】 工作原理</h1>
<h2 id="Metadata-2">Metadata</h2>
<pre><code class="language-yml">title: 【DB SQL】 工作原理
date: 2022-12-20 15:06
tags:
  - 行动阶段/完成
  - 主题场景/数据存储
  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace
  - 细化主题/数据存储/DB_SQL
categories:
  - 数据存储
keywords:
  - 数据存储
description: 【DB SQL】 工作原理
</code></pre>
<h2 id="知识点">知识点</h2>
<p><img src="/attachment%5Cfbbcd1449b2c0742f5a638c62466f90e.png" alt></p>
<h2 id="数据结构及算法">数据结构及算法</h2>
<h3 id="归并排序">归并排序</h3>
<p>归并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。</p>
<p><strong>为什么是归并排序？</strong></p>
<ul>
<li>你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。注：这种算法叫『原地算法』(in-place algorithm)</li>
<li>你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。注：这种算法叫『外部排序』(external sorting)。</li>
<li>你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。比如，分布式合并排序是Hadoop（那个著名的大数据框架）的关键组件之一。</li>
</ul>
<h3 id="二叉搜索树">二叉搜索树</h3>
<blockquote>
<p>数据库中查询的时间复杂度，是我们无法使用矩阵，转而使用二叉搜索树(BST)，具体请参考： 树 - 二叉搜索树(BST)</p>
</blockquote>
<ul>
<li>二叉搜索树只需 log(N) 次运算，而如果你直接使用阵列则需要 N 次运算</li>
</ul>
<h3 id="B-树索引">B+树索引</h3>
<blockquote>
<p>查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法。</p>
</blockquote>
<p><strong>如果你在数据库中增加或删除一行</strong></p>
<ul>
<li>你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。</li>
<li>你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。</li>
</ul>
<p>换句话说，B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以有些人听到过使用太多索引不是个好主意这类说法。没错，你减慢了快速插入/更新/删除表中的一个行的操作，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷（在本文结尾我们会探讨这个管理器）。</p>
<h3 id="哈希表">哈希表</h3>
<p><strong>为什么不用阵列呢？</strong></p>
<ul>
<li>如果有了好的哈希函数，在哈希表里搜索的时间复杂度是 O(1)。</li>
<li>一个哈希表可以只装载一半到内存，剩下的哈希桶可以留在硬盘上。</li>
<li>用阵列的话，你需要一个连续内存空间。如果你加载一个大表，很难分配足够的连续内存空间。</li>
</ul>
<h2 id="全局概览">全局概览</h2>
<p>数据库一般可以用如下图形来理解：</p>
<p><img src="/attachment%5C50a3eec5e9f087f44b1b09c60f04293b.png" alt></p>
<h3 id="核心组件">核心组件</h3>
<ul>
<li><strong>进程管理器（process manager）</strong>：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。</li>
<li><strong>网络管理器（network manager）</strong>：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。</li>
<li><strong>文件系统管理器（File system manager）</strong>：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</li>
<li><strong>内存管理器（memory manager）</strong>：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。</li>
<li><strong>安全管理器（Security Manager）</strong>：用于对用户的验证和授权。</li>
<li><strong>客户端管理器（Client manager）</strong>：用于管理客户端连接。</li>
</ul>
<h3 id="查询管理器">查询管理器</h3>
<ul>
<li><strong>查询解析器（Query parser）</strong>：用于检查查询是否合法</li>
<li><strong>查询重写器（Query rewriter）</strong>：用于预优化查询</li>
<li><strong>查询优化器（Query optimizer）</strong>：用于优化查询</li>
<li><strong>查询执行器（Query executor）</strong>：用于编译和执行查询</li>
</ul>
<h3 id="数据管理器">数据管理器</h3>
<ul>
<li><strong>事务管理器（Transaction manager）</strong>：用于处理事务</li>
<li><strong>缓存管理器（Cache manager）</strong>：数据被使用之前置于内存，或者数据写入磁盘之前置于内存</li>
<li><strong>数据访问管理器（Data access manager）</strong>：访问磁盘中的数据</li>
</ul>
<h3 id="数据查询的流程">数据查询的流程</h3>
<p>本章集中探讨数据库如何通过如下进程管理SQL查询的：</p>
<ul>
<li>客户端管理器</li>
<li>查询管理器</li>
<li>数据管理器（含恢复管理器）</li>
</ul>
<h2 id="客户端管理器">客户端管理器</h2>
<p>客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB …）提供不同的方式来访问数据库。客户端管理器也提供专有的数据库访问API。</p>
<p><img src="/attachment%5C163228c4e655734050a80d177d6e9857.png" alt></p>
<p><strong>当你连接到数据库时：</strong></p>
<ul>
<li>管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。</li>
<li>然后，管理器检查是否有空闲进程（或线程）来处理你对查询。</li>
<li>管理器还会检查数据库是否负载很重。</li>
<li>管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。</li>
<li>然后管理器会把你的查询送给查询管理器来处理。</li>
<li>因为查询处理进程不是『不全则无』的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。</li>
<li>如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。</li>
</ul>
<h2 id="查询管理器-2">查询管理器</h2>
<p><img src="/attachment%5C5d4489d9412056b3d5aa6fbcc76a9596.png" alt></p>
<p>这个多步骤操作过程如下：</p>
<ul>
<li>查询首先被解析并判断是否合法</li>
<li>然后被重写，去除了无用的操作并且加入预优化部分</li>
<li>接着被优化以便提升性能，并被转换为可执行代码和数据访问计划。</li>
<li>然后计划被编译</li>
<li>最后，被执行<br>
这里我不会过多探讨最后两步，因为它们不太重要。</li>
</ul>
<h3 id="查询解析器">查询解析器</h3>
<p>但这还不算完，解析器还会检查关键字是否使用正确的顺序，比如 WHERE 写在 SELECT 之前会被拒绝。</p>
<p>然后，解析器要分析查询中的表和字段，使用数据库元数据来检查：</p>
<ul>
<li>表是否存在</li>
<li>表的字段是否存在</li>
<li>对某类型字段的 运算 是否 可能（比如，你不能将整数和字符串进行比较，你不能对一个整数使用 substring() 函数）<br>
接着，解析器检查在查询中你是否有权限来读取（或写入）表。再强调一次：这些权限由DBA分配。<br>
在解析过程中，SQL 查询被转换为内部表示（通常是一个树）。<br>
如果一切正常，内部表示被送到查询重写器。</li>
</ul>
<h3 id="查询重写器">查询重写器</h3>
<p>在这一步，我们已经有了查询的内部表示，重写器的目标是：</p>
<ul>
<li>预优化查询</li>
<li>避免不必要的运算</li>
<li>帮助优化器找到合理的最佳解决方案<br>
重写器按照一系列已知的规则对查询执行检测。如果查询匹配一种模式的规则，查询就会按照这条规则来重写。下面是（可选）规则的非详尽的列表：</li>
<li>视图合并：如果你在查询中使用视图，视图就会转换为它的 SQL 代码。</li>
<li>子查询扁平化：子查询是很难优化的，因此重写器会尝试移除子查询</li>
<li>去除不必要的运算符：比如，如果你用了 DISTINCT，而其实你有 UNIQUE 约束（这本身就防止了数据出现重复），那么 DISTINCT 关键字就被去掉了。</li>
<li>排除冗余的联接：如果相同的 JOIN 条件出现两次，比如隐藏在视图中的 JOIN 条件，或者由于传递性产生的无用 JOIN，都会被消除。</li>
<li>常数计算赋值：如果你的查询需要计算，那么在重写过程中计算会执行一次。比如 WHERE AGE &gt; 10+2 会转换为 WHERE AGE &gt; 12 ， TODATE(“日期字符串”) 会转换为 datetime 格式的日期值。</li>
<li>（高级）分区裁剪（Partition Pruning）：如果你用了分区表，重写器能够找到需要使用的分区。</li>
<li>（高级）物化视图重写（Materialized view rewrite）：如果你有个物化视图匹配查询谓词的一个子集，重写器将检查视图是否最新并修改查询，令查询使用物化视图而不是原始表。</li>
<li>（高级）自定义规则：如果你有自定义规则来修改查询（就像 Oracle policy），重写器就会执行这些规则。</li>
<li>（高级）OLAP转换：分析/加窗 函数，星形联接，ROLLUP 函数……都会发生转换（但我不确定这是由重写器还是优化器来完成，因为两个进程联系很紧，必须看是什么数据库）。</li>
</ul>
<h3 id="统计">统计</h3>
<ul>
<li>这些统计信息会帮助优化器估计查询所需的磁盘 I/O、CPU、和内存使用</li>
<li>统计信息必须及时更新。</li>
</ul>
<h3 id="查询优化器">查询优化器</h3>
<blockquote>
<p>所有的现代数据库都在用基于成本的优化（即CBO）来优化查询。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。</p>
</blockquote>
<p>对于这些联接操作，我会专注于它们的时间复杂度，但是，数据库优化器计算的是它们的 CPU 成本、磁盘 I/O 成本、和内存需求。</p>
<p>大多数时候瓶颈在于磁盘 I/O 而不是 CPU 使用。</p>
<h4 id="索引">索引</h4>
<h4 id="存取路径">存取路径</h4>
<p>在应用联接运算符（join operators）之前，你首先需要获得数据。以下就是获得数据的方法。</p>
<ul>
<li>全扫描</li>
<li>范围扫描</li>
<li>唯一扫描</li>
<li>根据 ROW ID 存取</li>
<li>其它路径</li>
</ul>
<h4 id="联接运算符">联接运算符</h4>
<p>3个个常用联接运算符：合并联接（Merge join），哈希联接（Hash Join）和嵌套循环联接（Nested Loop Join）。</p>
<style>.admonition {
  margin: 1.5625em 0;
  padding: .6rem;
  overflow: hidden;
  font-size: 1.00rem;
  page-break-inside: avoid;
  border-left: .3rem solid #42b983;
  border-radius: .3rem;
  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);
  background-color: #fafafa;
}

p.admonition-title {
  position: relative;
  margin: -.6rem -.6rem .8em -.6rem !important;
  padding: .4rem .6rem .4rem 2.5rem;
  font-weight: 700;
  background-color:rgba(66, 185, 131, .1);
}

.admonition-title::before {
  position: absolute;
  top: .9rem;
  left: 1rem;
  width: 12px;
  height: 12px;
  background-color: #42b983;
  border-radius: 50%;
  content: ' ';
}

.info>.admonition-title, .todo>.admonition-title {
  background-color: rgba(0,184,212,.1);
}

.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {
  background-color: rgba(255,145,0,.1);
}

.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {
  background-color: rgba(255,82,82,.1);
}

.admonition.info, .admonition.todo {
  border-color: #00b8d4;
}

.admonition.warning, .admonition.attention, .admonition.caution {
  border-color: #ff9100;
}

.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {
  border-color: #ff5252;
}

.info>.admonition-title::before, .todo>.admonition-title::before {
  background-color: #00b8d4;
  border-radius: 50%;
}

.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {
  background-color: #ff9100;
  border-radius: 50%;
}

.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{
  background-color: #ff5252;;
  border-radius: 50%;
}

.admonition>:last-child {
  margin-bottom: 0 !important;
}
</style>
<div class="admonition note"><p class="admonition-title">内关系和外关系（ inner relation and outer relation）</p><ul>
<li>一个表</li>
<li>一个索引</li>
<li>上一个运算的中间结果（比如上一个联接运算的结果）</li>
</ul>
<p>当你联接两个关系时，联接算法对两个关系的处理是不同的。在本文剩余部分，我将假定：</p>
<ul>
<li>外关系是左侧数据集</li>
<li>内关系是右侧数据集</li>
</ul>
<p>比如， A JOIN B 是 A 和 B 的联接，这里 A 是外关系，B 是内关系。</p>
<p>多数情况下， A JOIN B 的成本跟 B JOIN A 的成本是不同的。</p>
</div>
<h5 id="嵌套循环联接">嵌套循环联接</h5>
<blockquote>
<p>嵌套循环联接是最简单的。</p>
</blockquote>
<p><img src="/attachment%5C9a73596fb97e95c90a2df623dc60d5dd.png" alt></p>
<style>.admonition {
  margin: 1.5625em 0;
  padding: .6rem;
  overflow: hidden;
  font-size: 1.00rem;
  page-break-inside: avoid;
  border-left: .3rem solid #42b983;
  border-radius: .3rem;
  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);
  background-color: #fafafa;
}

p.admonition-title {
  position: relative;
  margin: -.6rem -.6rem .8em -.6rem !important;
  padding: .4rem .6rem .4rem 2.5rem;
  font-weight: 700;
  background-color:rgba(66, 185, 131, .1);
}

.admonition-title::before {
  position: absolute;
  top: .9rem;
  left: 1rem;
  width: 12px;
  height: 12px;
  background-color: #42b983;
  border-radius: 50%;
  content: ' ';
}

.info>.admonition-title, .todo>.admonition-title {
  background-color: rgba(0,184,212,.1);
}

.warning>.admonition-title, .attention>.admonition-title, .caution>.admonition-title {
  background-color: rgba(255,145,0,.1);
}

.failure>.admonition-title, .missing>.admonition-title, .fail>.admonition-title, .error>.admonition-title {
  background-color: rgba(255,82,82,.1);
}

.admonition.info, .admonition.todo {
  border-color: #00b8d4;
}

.admonition.warning, .admonition.attention, .admonition.caution {
  border-color: #ff9100;
}

.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {
  border-color: #ff5252;
}

.info>.admonition-title::before, .todo>.admonition-title::before {
  background-color: #00b8d4;
  border-radius: 50%;
}

.warning>.admonition-title::before, .attention>.admonition-title::before, .caution>.admonition-title::before {
  background-color: #ff9100;
  border-radius: 50%;
}

.failure>.admonition-title::before,.missing>.admonition-title::before,.fail>.admonition-title::before,.error>.admonition-title::before{
  background-color: #ff5252;;
  border-radius: 50%;
}

.admonition>:last-child {
  margin-bottom: 0 !important;
}
</style>
<div class="admonition note"><p class="admonition-title">算法实现</p><ul>
<li>针对外关系的每一行，查看内关系里的所有行来寻找匹配的行</li>
</ul>
<pre><code class="language-c">nested_loop_join(array outer, array inner)
  for each row a in outer
    for each row b in inner
      if (match_join_condition(a,b))
        write_result_in_output(a,b)
      end if
    end for
   end for
</code></pre>
<p>由于这是个双迭代，时间复杂度是 O(N*M)。</p>
<p>由于这个算法非常简单，下面这个版本在内关系太大无法装入内存时，对磁盘 I/O 更加有利。原因如下：</p>
<ul>
<li>为了避免逐行读取两个关系，</li>
<li>你可以成簇读取，把（两个关系里读到的）两簇数据行保存在内存里，</li>
<li>比较两簇数据，保留匹配的，</li>
<li>然后从磁盘加载新的数据簇来继续比较</li>
<li>直到加载了所有数据。</li>
</ul>
<pre><code class="language-c">// improved version to reduce the disk I/O.
nested_loop_join_v2(file outer, file inner)
  for each bunch ba in outer
  // ba is now in memory
    for each bunch bb in inner
        // bb is now in memory
        for each row a in ba
          for each row b in bb
            if (match_join_condition(a,b))
              write_result_in_output(a,b)
            end if
          end for
       end for
    end for
   end for
</code><p><code class="language-c"></code></p></pre><p></p>
</div>
<h4 id="哈希联接">哈希联接</h4>
<p>哈希联接更复杂，不过在很多场合比嵌套循环联接成本低。</p>
<p><img src="/attachment%5C918399908529d8ba5054b06dc01fd17b.png" alt></p>
<p>哈希联接的原理是：</p>
<ul>
<li>读取内关系的所有元素</li>
<li>在内存里建一个哈希表</li>
<li>逐条读取外关系的所有元素 +（用哈希表的哈希函数）计算每个元素的哈希值，来查找内关系里相关的哈希桶内</li>
<li>是否与外关系的元素匹配。</li>
</ul>
<p>在时间复杂度方面我需要做些假设来简化问题：</p>
<ul>
<li>内关系被划分成 X 个哈希桶</li>
<li>哈希函数几乎均匀地分布每个关系内数据的哈希值，就是说哈希桶大小一致。</li>
<li>外关系的元素与哈希桶内的所有元素的匹配，成本是哈希桶内元素的数量。</li>
</ul>
<p>时间复杂度是 (M/X) * N + 创建哈希表的成本(M) + 哈希函数的成本 * N 。如果哈希函数创建了足够小规模的哈希桶，那么复杂度就是 O(M+N)。</p>
<p>还有个哈希联接的版本，对内存有利但是对磁盘 I/O 不够有利。 这回是这样的：</p>
<ul>
<li>计算内关系和外关系双方的哈希表</li>
<li>保存哈希表到磁盘</li>
<li>然后逐个哈希桶比较（其中一个读入内存，另一个逐行读取）。</li>
</ul>
<h5 id="合并联接">合并联接</h5>
<blockquote>
<p>合并联接是唯一产生排序的联接算法。</p>
</blockquote>
<ol>
<li>（可选）排序联接运算：两个输入源都按照联接关键字排序。</li>
<li>合并联接运算：排序后的输入源合并到一起。</li>
</ol>
<ul>
<li>排序
<ul>
<li>如果表内部就是有序的，比如联接条件里一个索引组织表(index-organized table)</li>
<li>如果关系是联接条件里的一个索引</li>
<li>如果联接应用在一个查询中已经排序的中间结果</li>
</ul>
</li>
<li>合并联接</li>
</ul>
<p><img src="/attachment%5Cfe166576c0204dd204b132f689f31b6e.png" alt></p>
<p>这部分与我们研究过的合并排序中的合并运算非常相似。不过这一次呢，我们不是从两个关系里挑选所有元素，而是只挑选相同的元素。道理如下：</p>
<ul>
<li>在两个关系中，比较当前元素（当前=头一次出现的第一个）</li>
<li>如果相同，就把两个元素都放入结果，再比较两个关系里的下一个元素</li>
<li>如果不同，就去带有最小元素的关系里找下一个元素（因为下一个元素可能会匹配）</li>
<li>重复 1、2、3步骤直到其中一个关系的最后一个元素。</li>
</ul>
<p><strong>哪个算法最好</strong></p>
<ul>
<li>空闲内存：没有足够的内存的话就跟强大的哈希联接拜拜吧（至少是完全内存中哈希联接）。</li>
<li>两个数据集的大小。比如，如果一个大表联接一个很小的表，那么嵌套循环联接就比哈希联接快，因为后者有创建哈希的高昂成本；如果两个表都非常大，那么嵌套循环联接CPU成本就很高昂。</li>
<li>是否有索引：有两个 B+树索引的话，聪明的选择似乎是合并联接。</li>
<li>结果是否需要排序：即使你用到的是未排序的数据集，你也可能想用成本较高的合并联接（带排序的），因为最终得到排序的结果后，你可以把它和另一个合并联接串起来（或者也许因为查询用 ORDER BY/GROUP BY/DISTINCT 等操作符隐式或显式地要求一个排序结果）。</li>
<li>关系是否已经排序：这时候合并联接是最好的候选项。</li>
<li>联接的类型：是等值联接（比如 tableA.col1 = tableB.col2 ）？ 还是内联接？外联接？笛卡尔乘积？或者自联接？有些联接在特定环境下是无法工作的。</li>
<li>数据的分布：如果联接条件的数据是倾斜的（比如根据姓氏来联接人，但是很多人同姓），用哈希联接将是个灾难，原因是哈希函数将产生分布极不均匀的哈希桶。</li>
<li>如果你希望联接操作使用多线程或多进程。</li>
</ul>
<h4 id="查询计划缓存">查询计划缓存</h4>
<p>由于创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存，来避免重复计算。这个话题比较大，因为数据库需要知道什么时候更新过时的计划。办法是设置一个上限，如果一个表的统计变化超过了上限，关于该表的查询计划就从缓存中清除。</p>
<h3 id="查询执行器">查询执行器</h3>
<p>在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符 (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。为了获得和写入数据，查询执行器与数据管理器交互，本文下一部分来讨论数据管理器。</p>
<h2 id="数据管理器-2">数据管理器</h2>
<p><img src="/attachment%5Caf894784e841229c3fb6ca65f2310723.png" alt></p>
<p>在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。但是有 2 个问题：</p>
<ul>
<li>关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。</li>
<li>数据提取是数据库中速度最慢的操作，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。</li>
</ul>
<h3 id="缓存管理器">缓存管理器</h3>
<blockquote>
<p>数据库的主要瓶颈是磁盘 I/O。为了提高性能，现代数据库使用缓存管理器。</p>
</blockquote>
<p><img src="/attachment%5C81abc6005712f0dc391185442b6a5cd0.png" alt></p>
<p>查询执行器不会直接从文件系统拿数据，而是向缓存管理器要。缓存管理器有一个内存缓存区，叫做缓冲池，从内存读取数据显著地提升数据库性能。</p>
<h4 id="预读">预读</h4>
<p>缓存管理器在缓冲池里保存所有的这些数据。为了确定一条数据是否有用，缓存管理器给缓存的数据添加了额外的信息（叫闩锁）。</p>
<h4 id="缓冲区置换策略">缓冲区置换策略</h4>
<blockquote>
<p>多数现代数据库(至少 SQL Server, MySQL, Oracle 和 DB2)使用 LRU 算法。</p>
</blockquote>
<h4 id="写缓冲区">写缓冲区</h4>
<p>缓冲区保存的是页（最小的数据单位）而不是行（逻辑上/人类习惯的观察数据的方式）。</p>
<h3 id="事务管理器">事务管理器</h3>
<p>一个ACID事务是一个工作单元，它要保证4个属性：</p>
<ul>
<li>原子性（Atomicity）: 事务『要么全部完成，要么全部取消』，即使它持续运行10个小时。如果事务崩溃，状态回到事务之前（事务回滚）。</li>
<li>一致性（Consistency）: 只有合法的数据（依照关系约束和函数约束）能写入数据库，一致性与原子性和隔离性有关。</li>
<li>隔离性（Isolation）: 如果2个事务 A 和 B 同时运行，事务 A 和 B 最终的结果是相同的，不管 A 是结束于 B 之前/之后/运行期间。</li>
<li>持久性（Durability）: 一旦事务提交（也就是成功执行）,不管发生什么（崩溃或者出错），数据要保存在数据库中。</li>
</ul>
<h3 id="并发控制">并发控制</h3>
<p>确保隔离性、一致性和原子性的真正问题是对相同数据的写操作（增、更、删）：</p>
<ul>
<li>如果所有事务只是读取数据，它们可以同时工作，不会更改另一个事务的行为。</li>
<li>如果（至少）有一个事务在修改其他事务读取的数据，数据库需要找个办法对其它事务隐藏这种修改。而且，它还需要确保这个修改操作不会被另一个看不到这些数据修改的事务擦除。</li>
</ul>
<p>这个问题叫并发控制。</p>
<h3 id="锁管理器">锁管理器</h3>
<p>多数数据库使用锁和/或数据版本控制。</p>
<h3 id="日志管理器">日志管理器</h3>
<p>数据库把数据保存在内存缓冲区内。但如果当事务提交时服务器崩溃，崩溃时还在内存里的数据会丢失，这破坏了事务的持久性。你可以把所有数据都写在磁盘上，但是如果服务器崩溃，最终数据可能只有部分写入磁盘，这破坏了事务的原子性。</p>
<p>事务作出的任何修改必须是或者撤销，或者完成。</p>
<ul>
<li>影子副本/页（Shadow copies/pages）</li>
<li>事务日志（Transaction log）</li>
</ul>
<h4 id="WAL（预写式日志）">WAL（预写式日志）</h4>
<p>影子副本/页在运行较多事务的大型数据库时制造了大量磁盘开销，所以现代数据库使用事务日志。事务日志必须保存在稳定的存储上</p>
<p>多数数据库（至少是Oracle,SQL Server,DB2,PostgreSQL, MySQL 和SQLite) 使用预写日志协议（Write-Ahead Logging protocol ，WAL）来处理事务日志。WAL协议有 3 个规则：</p>
<ul>
<li>每个对数据库的修改都产生一条日志记录，在数据写入磁盘之前日志记录必须写入事务日志。</li>
<li>日志记录必须按顺序写入；记录 A 发生在记录 B 之前，则 A 必须写在 B 之前。</li>
<li>当一个事务提交时，在事务成功之前，提交顺序必须写入到事务日志。</li>
</ul>
<p><img src="/attachment%5C8e3558d83703552ed6f6388350cc4f2f.png" alt></p>
<h4 id="ARIES">ARIES</h4>
<blockquote>
<p>IBM 研究人员『发明』了WAL的增强版，叫 ARIES。ARIES 或多或少地在现代数据库中使用，逻辑未必相同，但AIRES背后的概念无处不在。ARIES 代表『数据库恢复原型算法』（Algorithms forRecovery andIsolationExploitingSemantics）。</p>
</blockquote>
<p>这个技术要达到一个双重目标：</p>
<ul>
<li>写日志的同时保持良好性能</li>
<li>快速和可靠的数据恢复</li>
</ul>
<p>有多个原因让数据库不得不回滚事务：</p>
<ul>
<li>因为用户取消</li>
<li>因为服务器或网络故障</li>
<li>因为事务破坏了数据库完整性（比如一个列有唯一性约束而事务添加了重复值）</li>
<li>因为死锁</li>
</ul>
<h4 id="日志">日志</h4>
<p>事务的每一个操作（增/删/改）产生一条日志，由如下内容组成：</p>
<ul>
<li>LSN：一个唯一的日志序列号（Log Sequence Number）。LSN是按时间顺序分配的，这意味着如果操作 A 先于操作 B，log A 的 LSN 要比 log B 的 LSN 小。</li>
<li>TransID：产生操作的事务ID。</li>
<li>PageID：被修改的数据在磁盘上的位置。磁盘数据的最小单位是页，所以数据的位置就是它所处页的位置。</li>
<li>PrevLSN：同一个事务产生的上一条日志记录的链接。</li>
<li>UNDO：取消本次操作的方法。比如，如果操作是一次更新，UNDO将或者保存元素更新前的值/状态（物理UNDO），或者回到原来状态的反向操作（逻辑UNDO, 只使用逻辑UNDO，因为处理物理UNDO太过混乱了)。</li>
<li>REDO：重复本次操作的方法。 同样的，有 2 种方法：或者保存操作后的元素值/状态，或者保存操作本身以便重复。</li>
<li>…：（供您参考，一个 ARIES 日志还有 2 个字段：UndoNxtLSN 和 Type）。</li>
</ul>
<p><img src="/attachment%5Cb1344a43d057400787187307301a1e47.png" alt></p>
<h4 id="日志缓冲区">日志缓冲区</h4>
<blockquote>
<p>为了防止写日志成为主要的瓶颈，数据库使用了日志缓冲区。</p>
</blockquote>
<p><img src="/attachment%5C8b05656facd850eee123d6e1b0793c58.png" alt></p>
<p>当查询执行器要求做一次修改：</p>
<ul>
<li>缓存管理器将修改存入自己的缓冲区；</li>
<li>日志管理器将相关的日志存入自己的缓冲区；</li>
<li>到了这一步，查询执行器认为操作完成了（因此可以请求做另一次修改）；</li>
<li>接着（不久以后）日志管理器把日志写入事务日志，什么时候写日志由某算法来决定。</li>
<li>接着（不久以后）缓存管理器把修改写入磁盘，什么时候写盘由某算法来决定。</li>
</ul>
<p>当事务提交，意味着事务每一个操作的5个步骤都完成了。</p>
<h4 id="STEAL-和-FORCE-策略">STEAL 和 FORCE 策略</h4>
<p>下面是这些策略对恢复的影响：</p>
<ul>
<li>STEAL/NO-FORCE 需要 UNDO 和 REDO: 性能高，但是日志和恢复过程更复杂 (比如 ARIES)。多数数据库选择这个策略。 注：这是我从多个学术论文和教程里看到的，但并没有看到官方文档里显式说明这一点。</li>
<li>STEAL/ FORCE 只需要 UNDO.</li>
<li>NO-STEAL/NO-FORCE 只需要 REDO.</li>
<li>NO-STEAL/FORCE 什么也不需要: 性能最差，而且需要巨大的内存。</li>
</ul>
<h4 id="关于恢复">关于恢复</h4>
<p>ARIES从崩溃中恢复有三个阶段：</p>
<ol>
<li>分析阶段：恢复进程读取全部事务日志，来重建崩溃过程中所发生事情的时间线，决定哪个事务要回滚（所有未提交的事务都要回滚）、崩溃时哪些数据需要写盘。</li>
<li>Redo阶段：这一关从分析中选中的一条日志记录开始，使用 REDO 来将数据库恢复到崩溃之前的状态。
<ul>
<li>在REDO阶段，REDO日志按照时间顺序处理（使用LSN）。</li>
<li>对每一条日志，恢复进程需要读取包含数据的磁盘页LSN。</li>
<li>如果LSN（磁盘页）&gt;= LSN（日志记录），说明数据已经在崩溃前写到磁盘（但是值已经被日志之后、崩溃之前的某个操作覆盖），所以不需要做什么。</li>
<li>如果LSN（磁盘页）&lt; LSN（日志记录），那么磁盘上的页将被更新。</li>
<li>即使将被回滚的事务，REDO也是要做的，因为这样简化了恢复过程（但是我相信现代数据库不会这么做的）。</li>
</ul>
</li>
<li>Undo阶段：这一阶段回滚所有崩溃时未完成的事务。回滚从每个事务的最后一条日志开始，并且按照时间倒序处理UNDO日志（使用日志记录的PrevLSN）。</li>
</ol>
<p>恢复过程中，事务日志必须留意恢复过程的操作，以便写入磁盘的数据与事务日志相一致。一个解决办法是移除被取消的事务产生的日志记录，但是这个太困难了。相反，ARIES在事务日志中记录补偿日志，来逻辑上删除被取消的事务的日志记录。</p>
<p>当事务被『手工』取消，或者被锁管理器取消（为了消除死锁），或仅仅因为网络故障而取消，那么分析阶段就不需要了。对于哪些需要 REDO 哪些需要 UNDO 的信息在 2 个内存表中：</p>
<ul>
<li>事务表（保存当前所有事务的状态）</li>
<li>脏页表（保存哪些数据需要写入磁盘）</li>
</ul>
<p>当新的事务产生时，这两个表由缓存管理器和事务管理器更新。因为是在内存中，当数据库崩溃时它们也被破坏掉了。</p>
<p>分析阶段的任务就是在崩溃之后，用事务日志中的信息重建上述的两个表。为了加快分析阶段，ARIES提出了一个概念：检查点（check point），就是不时地把事务表和脏页表的内容，还有此时最后一条LSN写入磁盘。那么在分析阶段当中，只需要分析这个LSN之后的日志即可。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/yu627482453">Bill Cypher</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yu627482453.github.io/database/db-sql/db-sql-gong-zuo-yuan-li/">https://yu627482453.github.io/database/db-sql/db-sql-gong-zuo-yuan-li/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yu627482453.github.io" target="_blank">蝶梦庄生</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%A1%8C%E5%8A%A8%E9%98%B6%E6%AE%B5-%E5%AE%8C%E6%88%90/">行动阶段/完成</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0%E7%A9%BA%E9%97%B4-KnowladgeSpace-ProgramSpace-BasicsSpace/">笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E9%A2%98%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">主题场景/数据存储</a><a class="post-meta__tags" href="/tags/%E7%BB%86%E5%8C%96%E4%B8%BB%E9%A2%98-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-DB-SQL/">细化主题/数据存储/DB_SQL</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-li-lun/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【DB SQL】 关系型数据库设计理论</div></div></a></div><div class="next-post pull-right"><a href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-final/"><img class="next-cover" src="/cover/java-cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Java 多线程并发】 final</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-liu-cheng/" title="【DB SQL】 关系型数据库设计流程"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">【DB SQL】 关系型数据库设计流程</div></div></a></div><div><a href="/database/db-sql/db-sql-guan-xi-xing-shu-ju-ku-she-ji-li-lun/" title="【DB SQL】 关系型数据库设计理论"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">【DB SQL】 关系型数据库设计理论</div></div></a></div><div><a href="/database/db-sql/db-sql-shu-ju-ku-xi-tong-he-xin-zhi-shi-dian/" title="【DB SQL】 数据库系统核心知识点"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">【DB SQL】 数据库系统核心知识点</div></div></a></div><div><a href="/database/mongodb/mongodb-java-api/" title="【MongoDB】 Java API"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">【MongoDB】 Java API</div></div></a></div><div><a href="/database/mongodb/mongodb-curd/" title="【MongoDB】 CURD"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">【MongoDB】 CURD</div></div></a></div><div><a href="/database/mongodb/mongodb-spring-ji-cheng/" title="【MongoDB】 Spring 集成"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">【MongoDB】 Spring 集成</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Bill Cypher</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yu627482453"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yu627482453" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/627482453@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">【DB SQL】 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Metadata-2"><span class="toc-number">1.1.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构及算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">B+树索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%A6%82%E8%A7%88"><span class="toc-number">1.4.</span> <span class="toc-text">全局概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">查询管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">数据管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">数据查询的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">客户端管理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%AE%A1%E7%90%86%E5%99%A8-2"><span class="toc-number">1.6.</span> <span class="toc-text">查询管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">查询解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">查询重写器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.6.3.</span> <span class="toc-text">统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">查询优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">存取路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">联接运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%81%94%E6%8E%A5"><span class="toc-number">1.6.4.3.1.</span> <span class="toc-text">嵌套循环联接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%81%94%E6%8E%A5"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">哈希联接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E8%81%94%E6%8E%A5"><span class="toc-number">1.6.4.4.1.</span> <span class="toc-text">合并联接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E7%BC%93%E5%AD%98"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">查询计划缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.6.5.</span> <span class="toc-text">查询执行器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%99%A8-2"><span class="toc-number">1.7.</span> <span class="toc-text">数据管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">缓存管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E8%AF%BB"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">预读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">缓冲区置换策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">写缓冲区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">事务管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">并发控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.7.4.</span> <span class="toc-text">锁管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">日志管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WAL%EF%BC%88%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">WAL（预写式日志）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARIES"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">ARIES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.7.5.4.</span> <span class="toc-text">日志缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STEAL-%E5%92%8C-FORCE-%E7%AD%96%E7%95%A5"><span class="toc-number">1.7.5.5.</span> <span class="toc-text">STEAL 和 FORCE 策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">1.7.5.6.</span> <span class="toc-text">关于恢复</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/database/redis/redis/" title="无题">无题</a><time datetime="2023-03-10T07:12:09.069Z" title="发表于 2023-03-10 15:12:09">2023-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/mysql/mysql/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/database/mysql/mysql/" title="无题">无题</a><time datetime="2023-03-10T07:11:51.168Z" title="发表于 2023-03-10 15:11:51">2023-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/db-sql/db-sql/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/database/db-sql/db-sql/" title="无题">无题</a><time datetime="2023-03-10T07:11:37.106Z" title="发表于 2023-03-10 15:11:37">2023-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/mongodb/mongodb/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/database/mongodb/mongodb/" title="无题">无题</a><time datetime="2023-03-10T07:11:15.318Z" title="发表于 2023-03-10 15:11:15">2023-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-function/" title="函数接口 Function"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="函数接口 Function"/></a><div class="content"><a class="title" href="/language/java/java-han-shu-shi-bian-cheng/han-shu-jie-kou-function/" title="函数接口 Function">函数接口 Function</a><time datetime="2023-02-21T02:52:00.000Z" title="发表于 2023-02-21 10:52:00">2023-02-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Bill Cypher</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c61a274b6f5aa26a58f6',
      clientSecret: '485a7761d321c8dcc5cae05d7256be9fb196d94a',
      repo: 'yu627482453.github.io',
      owner: 'yu627482453',
      admin: ['yu627482453'],
      id: 'df8212a818081c3dc217216711844ea0',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/c539_87.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":60,"vOffset":160},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>