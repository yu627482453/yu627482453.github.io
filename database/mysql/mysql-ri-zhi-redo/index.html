<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【MySQL】 日志 - redo | 蝶梦庄生</title><meta name="keywords" content="数据存储"><meta name="author" content="Bill Cipher"><meta name="copyright" content="Bill Cipher"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。">
<meta property="og:type" content="article">
<meta property="og:title" content="【MySQL】 日志 - redo">
<meta property="og:url" content="https://yu627482453.github.io/database/mysql/mysql-ri-zhi-redo/index.html">
<meta property="og:site_name" content="蝶梦庄生">
<meta property="og:description" content="redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.yimian.xyz/img?type=moe">
<meta property="article:published_time" content="2023-06-25T02:13:00.000Z">
<meta property="article:modified_time" content="2023-06-25T02:13:00.000Z">
<meta property="article:author" content="Bill Cipher">
<meta property="article:tag" content="行动阶段&#x2F;完成">
<meta property="article:tag" content="笔记空间&#x2F;KnowladgeSpace&#x2F;ProgramSpace&#x2F;BasicsSpace">
<meta property="article:tag" content="主题场景&#x2F;数据存储">
<meta property="article:tag" content="细化主题&#x2F;数据存储">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.yimian.xyz/img?type=moe"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yu627482453.github.io/database/mysql/mysql-ri-zhi-redo/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bill Cipher","link":"链接: ","source":"来源: 蝶梦庄生","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【MySQL】 日志 - redo',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-25 10:13:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">215</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.yimian.xyz/img?type=moe')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">蝶梦庄生</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【MySQL】 日志 - redo</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-25T02:13:00.000Z" title="发表于 2023-06-25 10:13:00">2023-06-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-25T02:13:00.000Z" title="更新于 2023-06-25 10:13:00">2023-06-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">数据存储</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【MySQL】 日志 - redo"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="【MySQL】-日志-redo"><a href="#【MySQL】-日志-redo" class="headerlink" title="【MySQL】 日志 - redo"></a>【MySQL】 日志 - redo</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【MySQL】 日志 - redo
date: 2023-06-25 10:13
tags:
  - 行动阶段/完成
  - 主题场景/数据存储
  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace
  - 细化主题/数据存储
categories:
  - 数据存储
keywords:
  - 数据存储
description: redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。
</code></pre>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。</li>
<li>redo日志的主要功能是<strong>保证数据库的持久性和恢复能力</strong>。</li>
<li>redo 日志本质上只是记录了一下<strong>事务对数据库做了哪些修改</strong>, 在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。<ul>
<li>type ：该条redo 日志的类型。</li>
<li>space ID ：表空间ID。</li>
<li>page number ：页号。</li>
<li>data ：该条redo 日志的具体内容。</li>
</ul>
</li>
</ul>
<p><img src="/attachment/95d39a797c7e8abe375c63e8bf4c9052.png"></p>
<ul>
<li>Mini-Transaction<ul>
<li>对底层页面中的一次原子访问的过程称之为一个Mini-Transaction ，简称mtr。</li>
<li>以组的形式写入redo日志 —  <strong>原子</strong></li>
<li>修改一次Max Row ID 的值算是一个Mini-Transaction</li>
<li>向某个索引对应的B+ 树中插入一条记录的过程也算是一个Mini-Transaction</li>
</ul>
</li>
</ul>
<p><img src="/attachment/9dc564aab6d3f1055f5b09bf9a4eebac.png"></p>
<ul>
<li><p>redo日志的写入过程</p>
<ul>
<li>redo log block<br>  <img src="/attachment/1d05f86aacee59136739ffecdf347977.png"></li>
<li>redo日志缓冲区<ul>
<li>redo日志写入log buffer<ul>
<li><strong>buf_free</strong> 的全局变量，该变量指明后续写入的redo 日志应该写入到log buffer 中的哪个位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>redo日志文件</p>
<ul>
<li>redo日志刷盘时机<ul>
<li>log buffer 空间不足时</li>
<li>事务提交时</li>
<li>后台线程不停的刷刷刷<ul>
<li>后台有一个线程，大约每秒都会刷新一次log buffer 中的redo 日志到磁盘。</li>
</ul>
</li>
<li>正常关闭服务器时</li>
<li>做所谓的checkpoint 时（我们现在没介绍过checkpoint 的概念，稍后会仔细唠叨，稍安勿躁）</li>
<li>其他的一些情况…</li>
</ul>
</li>
<li>redo日志文件格式<br>  <img src="/attachment/8e93c10b72701ec5752a42211bd479d4.png"></li>
</ul>
</li>
<li><p>Log Sequeue Number</p>
<ul>
<li>为记录已经写入的redo 日志量，设计了一个称之为Log Sequeue Number 的全局变量，日志序列号, 简称LSN</li>
<li>buf_next_to_write 标记当前log buffer 中已经有哪些日志被刷新到磁盘中了</li>
<li>flushed_to_disk_lsn   刷新到磁盘中的redo 日志量的全局变量</li>
<li>flush链表按照oldest_modification代表的LSN值进行排序</li>
<li>flush链表中的LSN<br>  <img src="/attachment/57704071c7325804ba415757ddcb41f6.png"></li>
</ul>
</li>
<li><p>checkpoint</p>
<ul>
<li><strong>判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。</strong></li>
<li>做一次checkpoint其实可以分为两个步骤：<ul>
<li>步骤一：计算一下当前系统中可以被覆盖的redo 日志对应的lsn 值最大是多少。<ul>
<li>凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的</li>
<li>把该脏页的oldest_modification 赋值给checkpoint_lsn 。</li>
</ul>
</li>
<li>步骤二：将checkpoint_lsn 和对应的redo 日志文件组偏移量以及此次checkpint 的编号写到日志文件的管理信息（就是checkpoint1 或者checkpoint2 ）中。</li>
</ul>
</li>
</ul>
</li>
<li><p>崩溃恢复</p>
<ul>
<li>确定恢复的起点</li>
<li>确定恢复的终点</li>
</ul>
</li>
</ul>
<h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>redo日志（Redo Log）是数据库管理系统（DBMS）中的一种重要的日志类型，用于记录数据库中发生的事务操作的变化。</p>
<p>redo日志的主要功能是<strong>保证数据库的持久性和恢复能力</strong>。当事务进行修改数据库的操作时，redo日志会记录这些操作的详细信息，包括修改的数据、修改前后的值等。通过redo日志，可以将事务的操作重新应用到数据库中，以实现事务的持久性。</p>
<h3 id="redo日志的特点如下："><a href="#redo日志的特点如下：" class="headerlink" title="redo日志的特点如下："></a>redo日志的特点如下：</h3><ul>
<li><strong>占用空间小</strong>: 存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间</li>
<li><strong>顺序记录</strong>：redo日志以顺序的方式记录事务的操作，而不是随机记录。这样可以提高日志的写入效率。</li>
<li><strong>非持久性</strong>：redo日志不需要永久保存在磁盘上，只需要在事务执行过程中保持在内存中和写入磁盘的缓冲区中。只有当事务提交后，才会将redo日志写入磁盘进行持久化保存。</li>
<li><strong>循环利用</strong>：当redo日志写满时，可以将最旧的日志覆盖掉，从而实现循环利用。这样可以节省存储空间，并保证日志文件的大小不会无限增长。</li>
</ul>
<h2 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h2><p>redo 日志本质上只是记录了一下<strong>事务对数据库做了哪些修改</strong></p>
<p><img src="/attachment/95d39a797c7e8abe375c63e8bf4c9052.png"></p>
<p>各个部分的详细释义如下：</p>
<ul>
<li>type ：该条redo 日志的类型。</li>
<li>space ID ：表空间ID。</li>
<li>page number ：页号。</li>
<li>data ：该条redo 日志的具体内容。</li>
</ul>
<h3 id="简单的redo日志类型"><a href="#简单的redo日志类型" class="headerlink" title="简单的redo日志类型"></a>简单的redo日志类型</h3><p>对页面的修改是极其简单的， redo 日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了，设计InnoDB 的大叔把这种极其简单的redo 日志称之为<strong>物理日志</strong></p>
<p>根据在页面中写入数据的多少划分了几种不同的redo 日志类型：</p>
<ul>
<li>MLOG_1BYTE （ type 字段对应的十进制数字为1 ）：表示在页面的某个偏移量处写入1个字节的redo 日志类型。</li>
<li>MLOG_2BYTE （ type 字段对应的十进制数字为2 ）：表示在页面的某个偏移量处写入2个字节的redo 日志类型。</li>
<li>MLOG_4BYTE （ type 字段对应的十进制数字为4 ）：表示在页面的某个偏移量处写入4个字节的redo 日志类型。</li>
<li>MLOG_8BYTE （ type 字段对应的十进制数字为8 ）：表示在页面的某个偏移量处写入8个字节的redo 日志类型。</li>
<li>MLOG_WRITE_STRING （ type 字段对应的十进制数字为30 ）：表示在页面的某个偏移量处写入一串数据。</li>
</ul>
<p><img src="/attachment/69cf44d08da23ebe909980205fd09e2e.png"></p>
<p>MLOG_WRITE_STRING 类型的redo 日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个len 字段：</p>
<p><img src="/attachment/8fe8edd4fa5ed6340e0cdc70f8e87812.png"></p>
<h3 id="复杂一些的redo日志类型"><a href="#复杂一些的redo日志类型" class="headerlink" title="复杂一些的redo日志类型"></a>复杂一些的redo日志类型</h3><p>语句对B+ 树所做更新：</p>
<ul>
<li><p>表中包含多少个索引，一条INSERT 语句就可能更新多少棵B+ 树。</p>
</li>
<li><p>针对某一棵B+ 树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在内节点页面中添加目录项记录）。</p>
</li>
<li><p>可能更新Page Directory 中的槽信息。</p>
</li>
<li><p>Page Header 中的各种页面统计信息，比如PAGE_N_DIR_SLOTS 表示的槽数量可能会更改， PAGE_HEAP_TOP代表的还未使用的空间最小地址可能会更改， PAGE_N_HEAP 代表的本页面中的记录数量可能会更改，吧啦吧啦，各种信息都可能会被修改。</p>
</li>
<li><p>我们知道在数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的next_record 属性来维护这个单向链表。</p>
</li>
<li><p>还有别的吧啦吧啦的更新的地方，就不一一唠叨了…</p>
</li>
</ul>
<p><img src="/attachment/353da489b21aa85f4bc415e560dba28c.png"></p>
<p>新的redo 日志类型:</p>
<ul>
<li>MLOG_REC_INSERT （对应的十进制数字为9 ）：表示插入一条使用非紧凑行格式的记录时的redo 日志类型。</li>
<li>MLOG_COMP_REC_INSERT （对应的十进制数字为38 ）：表示插入一条使用紧凑行格式的记录时的redo 日志类型。</li>
<li>MLOG_COMP_PAGE_CREATE （ type 字段对应的十进制数字为58 ）：表示创建一个存储紧凑行格式记录的页面的redo 日志类型。</li>
<li>MLOG_COMP_REC_DELETE （ type 字段对应的十进制数字为42 ）：表示删除一条使用紧凑行格式记录的redo 日志类型。</li>
<li>MLOG_COMP_LIST_START_DELETE （ type 字段对应的十进制数字为44 ）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的redo 日志类型。</li>
<li>MLOG_COMP_LIST_END_DELETE （ type 字段对应的十进制数字为43 ）：与MLOG_COMP_LIST_START_DELETE类型的redo 日志呼应，表示删除一系列记录直到MLOG_COMP_LIST_END_DELETE 类型的redo 日志对应的记录为止。</li>
</ul>
<pre><code class="line-numbers language-ad-tip">Redundant是一种比较原始的行格式，它就是非紧凑的。而Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。
</code></pre>
<p>这些类型的redo 日志既包含物理层面的意思，也包含逻辑层面的意思，具体指：</p>
<p>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。<br>逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。</p>
<p><img src="/attachment/3f5b621b58bec69fe578eb9bc1fbeb5b.png"></p>
<p>这个类型为MLOG_COMP_REC_INSERT 的redo 日志结构有几个地方需要大家注意：</p>
<ul>
<li>field1_len ~ fieldn_len 代表着该记录若干个字段占用存储空间的大小</li>
<li>offset 代表的是该记录的前一条记录在页面中的地址。</li>
<li>通过end_seg_len 的值可以间接的计算出一条记录占用存储空间的总大小</li>
<li>mismatch_index 的值也是为了节省redo 日志的大小而设立的，大家可以忽略。</li>
</ul>
<h3 id="redo日志格式小结"><a href="#redo日志格式小结" class="headerlink" title="redo日志格式小结"></a>redo日志格式小结</h3><p>redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。</p>
<h2 id="Mini-Transaction"><a href="#Mini-Transaction" class="headerlink" title="Mini-Transaction"></a>Mini-Transaction</h2><h3 id="以组的形式写入redo日志"><a href="#以组的形式写入redo日志" class="headerlink" title="以组的形式写入redo日志"></a>以组的形式写入redo日志</h3><p>在执行语句的过程中产生的redo 日志被设计InnoDB 的大叔人为的划分成了若干个不可分割的组，比如：</p>
<ul>
<li>更新Max Row ID 属性时产生的redo 日志是不可分割的。</li>
<li>向聚簇索引对应B+ 树的页面中插入一条记录时产生的redo 日志是不可分割的。</li>
<li>向某个二级索引对应B+ 树的页面中插入一条记录时产生的redo 日志是不可分割的。</li>
<li>还有其他的一些对页面的访问操作时产生的redo 日志是不可分割的。。。</li>
</ul>
<p><strong>不可分割的含义</strong></p>
<ul>
<li><p>我们以向某个索引对应的B+ 树插入一条记录为例，在向B+ 树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p>
</li>
<li><p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为MLOG_COMP_REC_INSERT 的redo 日志就好了，我们把这种情况称之为乐观插入。</p>
</li>
<li><p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的页分裂操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条目录项记录指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条redo 日志，我们把这种情况称之为悲观插入。</p>
</li>
</ul>
<p><img src="/attachment/71287f939b738feec0b12a85ffd153dc.png"></p>
<p>向某个索引对应的B+ 树中插入一条记录的这个过程必须是<strong>原子</strong>的</p>
<p>规定在执行这些需要保证原子性的操作时必须以组的形式来记录的redo 日志，在进行系统奔溃重启恢复时，针对某个组中的redo 日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？</p>
<ul>
<li>有的需要保证原子性的操作会生成多条redo 日志，比如向某个索引对应的B+ 树中进行一次悲观插入就需要生成许多条redo 日志。</li>
</ul>
<p>该组中的最后一条redo 日志后边加上一条特殊类型的redo 日志，该类型名称为MLOG_MULTI_REC_END ， type 字段对应的十进制数字为31 ，该类型的redo 日志结构很简单，只有一个type 字段：</p>
<p><img src="/attachment/3855e8a74e6878458e3752e1c9087c43.png"></p>
<p>所以某个需要保证原子性的操作产生的一系列redo 日志必须要以一个类型为MLOG_MULTI_REC_END 结尾，就像这样：<br><img src="/attachment/d61609ebe74a8f9dbb9f8934e231bbdf.png"></p>
<p>这样在系统奔溃重启进行恢复时，只有当解析到类型为MLOG_MULTI_REC_END 的redo 日志，才认为解析到了一组完整的redo 日志，才会进行恢复。否则的话直接放弃前边解析到的redo 日志。</p>
<ul>
<li>有的需要保证原子性的操作只生成一条redo 日志，比如更新Max Row ID 属性的操作就只会生成一条redo日志。</li>
</ul>
<p>用7个比特位就足以包括所有的redo 日志类型，而type 字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条redo 日志，<br><img src="/attachment/9734a9b9fbeff14ce4e3e19643c39999.png"></p>
<p>如果type 字段的第一个比特位为1 ，代表该需要保证原子性的操作只产生了单一的一条redo 日志，否则表示该需要保证原子性的操作产生了一系列的redo 日志。</p>
<h3 id="Mini-Transaction的概念"><a href="#Mini-Transaction的概念" class="headerlink" title="Mini-Transaction的概念"></a>Mini-Transaction的概念</h3><p>对底层页面中的一次原子访问的过程称之为一个Mini-Transaction ，简称mtr。</p>
<ul>
<li>修改一次Max Row ID 的值算是一个Mini-Transaction</li>
<li>向某个索引对应的B+ 树中插入一条记录的过程也算是一个Mini-Transaction</li>
</ul>
<p>一个所谓的mtr 可以包含一组redo 日志，在进行奔溃恢复时这一组redo 日志作为一个不可分割的整体。</p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr 组成，每一个mtr 又可以包含若干条redo 日志，画个图表示它们的关系就是这样：</p>
<p><img src="/attachment/9dc564aab6d3f1055f5b09bf9a4eebac.png"></p>
<h2 id="redo日志的写入过程"><a href="#redo日志的写入过程" class="headerlink" title="redo日志的写入过程"></a>redo日志的写入过程</h2><h3 id="redo-log-block"><a href="#redo-log-block" class="headerlink" title="redo log block"></a>redo log block</h3><p>为了更好的进行系统奔溃恢复，他们把通过mtr 生成的redo 日志都放在了大小为512字节的页中。</p>
<p>log buffer 本质上是一片连续的内存空间，被划分成了若干个512 字节大小的block 。</p>
<p>用来存储redo 日志的页称为block</p>
<p><strong>redo log block 的示意图如下：</strong></p>
<p><img src="/attachment/1d05f86aacee59136739ffecdf347977.png"></p>
<p>真正的redo 日志都是存储到占用496 字节大小的log block body 中，图中的log block header 和log block trailer 存储的是一些管理信息。</p>
<p><strong>管理信息示意图:</strong></p>
<p><img src="/attachment/f8cb74a8b560c202a167d8ef4b88bbc7.png"></p>
<p>其中log block header 的几个属性的意思分别如下：</p>
<ul>
<li>LOG_BLOCK_HDR_NO ：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li>
<li>LOG_BLOCK_HDR_DATA_LEN ：表示block中已经使用了多少字节，初始值为12 （因为log block body 从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果log block body已经被全部写满，那么本属性的值被设置为512 。</li>
<li>LOG_BLOCK_FIRST_REC_GROUP ：一条redo 日志也可以称之为一条redo 日志记录（ redo log record ），</li>
<li>一个mtr 会生产多条redo 日志记录，这些redo 日志记录被称之为一个redo 日志记录组（ redo logrecord group ）。LOG_BLOCK_FIRST_REC_GROUP 就代表该block中第一个mtr 生成的redo 日志记录组的偏移量（其实也就是这个block里第一个mtr 生成的第一条redo 日志的偏移量）。</li>
<li>LOG_BLOCK_CHECKPOINT_NO ：表示所谓的checkpoint 的序号， checkpoint 是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</li>
</ul>
<p>log block trailer 中属性的意思如下：</p>
<ul>
<li>LOG_BLOCK_CHECKSUM ：表示block的校验值，用于正确性校验，我们暂时不关心它。</li>
</ul>
<h3 id="redo日志缓冲区"><a href="#redo日志缓冲区" class="headerlink" title="redo日志缓冲区"></a>redo日志缓冲区</h3><p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer 的连续内存空间，翻译成中文就是redo日志缓冲区，我们也可以简称为log buffer 。</p>
<p>这片内存空间被划分成若干个连续的redo log block</p>
<p><img src="/attachment/8d197b0dcbbb096473c844ae946009d9.png"></p>
<p>默认值为16MB</p>
<h4 id="redo日志写入log-buffer"><a href="#redo日志写入log-buffer" class="headerlink" title="redo日志写入log buffer"></a>redo日志写入log buffer</h4><p>向log buffer 中写入redo 日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写</p>
<p>当我们想往log buffer 中写入redo 日志时，第一个遇到的问题就是应该写在哪个 block 的哪个偏移量处，所以设计InnoDB 的大叔特意提供了一个称之为<strong>buf_free</strong> 的全局变量，该变量指明后续写入的redo 日志应该写入到log buffer 中的哪个位置</p>
<p><img src="/attachment/7b62e9267e29b45a0d2259da7c5d96dc.png"></p>
<p>mtr 执行过程中可能产生若干条redo 日志，这些redo 日志是一个不可分割的组，<br>所以其实并不是每生成一条redo 日志，就将其插入到log buffer 中，<br>而是每个mtr 运行过程中产生的日志先暂时存到一个地方，<br>当该mtr 结束的时候，将过程中产生的一组redo 日志再全部复制到log buffer 中</p>
<p>假设<br>有两个名为T1 、T2 的事务，每个事务都包含2个mtr ，我们给这几个mtr 命名一下：</p>
<ul>
<li>事务T1 的两个mtr 分别称为mtr_T1_1 和mtr_T1_2 。</li>
<li>事务T2 的两个mtr 分别称为mtr_T2_1 和mtr_T2_2 。</li>
</ul>
<p>用示意图来描述一下这些mtr 产生的日志情况：</p>
<p><img src="/attachment/86ea507cc9ab069492f0ecea0409e987.png"></p>
<p>不同的事务可能是并发执行的，所以T1 、T2 之间的mtr 可能是交替执行的。</p>
<p>每当一个mtr 执行完成时，伴随该mtr 生成的一组redo 日志就需要被复制到log buffer 中，也就是说不同事务的mtr 可能是交替写入log buffer 的</p>
<p><img src="/attachment/3936f656aa6e353e47a4f05234d68999.png"></p>
<h2 id="redo日志文件"><a href="#redo日志文件" class="headerlink" title="redo日志文件"></a>redo日志文件</h2><h3 id="redo日志刷盘时机"><a href="#redo日志刷盘时机" class="headerlink" title="redo日志刷盘时机"></a>redo日志刷盘时机</h3><p>在一些情况下它们会被刷新到磁盘里</p>
<ul>
<li>log buffer 空间不足时</li>
<li>事务提交时</li>
<li>后台线程不停的刷刷刷<ul>
<li>后台有一个线程，大约每秒都会刷新一次log buffer 中的redo 日志到磁盘。</li>
</ul>
</li>
<li>正常关闭服务器时</li>
<li>做所谓的checkpoint 时（我们现在没介绍过checkpoint 的概念，稍后会仔细唠叨，稍安勿躁）</li>
<li>其他的一些情况…</li>
</ul>
<h3 id="redo日志文件组"><a href="#redo日志文件组" class="headerlink" title="redo日志文件组"></a>redo日志文件组</h3><p>MySQL 的数据目录（使用SHOW VARIABLES LIKE ‘datadir’ 查看）下默认有两个名为<code>ib_logfile0</code> 和<code>ib_logfile1</code> 的文件， log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中。</p>
<p>磁盘上的redo 日志文件是以一个日志文件组的形式出现的。</p>
<p>这些文件以ib_logfile[数字] （ 数字可以是0 、1 、2 …）的形式进行命名。</p>
<p><img src="/attachment/841ce5d38af1aa4690e5a8b8fb7cf4bf.png"></p>
<p>总共的redo 日志文件大小其实就是：<br>innodb_log_file_size × innodb_log_files_in_group 。</p>
<h3 id="redo日志文件格式"><a href="#redo日志文件格式" class="headerlink" title="redo日志文件格式"></a>redo日志文件格式</h3><p>将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中</p>
<p>redo 日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p>
<ul>
<li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li>
<li>从第2048字节往后是用来存储log buffer 中的block镜像的。</li>
</ul>
<p><img src="/attachment/8e93c10b72701ec5752a42211bd479d4.png"></p>
<p><strong>介绍一下每个redo 日志文件前2048个字节，也就是前4个特殊block的格式</strong></p>
<p><img src="/attachment/d7615b3b42ba54071280404008bb7f6b.png"></p>
<p>这4个block分别是：</p>
<ul>
<li>log file header ：描述该redo 日志文件的一些整体属性，看一下它的结构：<br><img src="/attachment/d3d42b092271e9fafc2b2525865d7a34.png"></li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">长度（单位：字节）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOG_HEADER_FORMAT</td>
<td align="center">4</td>
<td align="left">redo 日志的版本，在MySQL5.7.21 中该值永远为1</td>
</tr>
<tr>
<td align="center">LOG_HEADER_PAD1</td>
<td align="center">4</td>
<td align="left">做字节填充用的，没什么实际意义，忽略～</td>
</tr>
<tr>
<td align="center">LOG_HEADER_START_LSN</td>
<td align="center">8</td>
<td align="left">标记本redo 日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值（关于什么是LSN我们稍后再看哈，看不懂的先忽略）。</td>
</tr>
<tr>
<td align="center">LOG_HEADER_CREATOR</td>
<td align="center">32</td>
<td align="left">一个字符串，标记本redo 日志文件的创建者是谁。正常运行时该值为MySQL 的版本号，比如： “MySQL 5.7.21” ，使用mysqlbackup 命令创建的redo 日志文件的该值为”ibbackup” 和创建时间。</td>
</tr>
<tr>
<td align="center">LOG_BLOCK_CHECKSUM</td>
<td align="center">4</td>
<td align="left">本block的校验值，所有block都有，我们不关心</td>
</tr>
</tbody></table>
<ul>
<li>checkpoint1 ：记录关于checkpoint 的一些属性，看一下它的结构：<br><img src="/attachment/bb48c1b7b81b2c67d98200f113755e4b.png"></li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">长度（单位：字节）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOG_CHECKPOINT_NO</td>
<td align="center">8</td>
<td align="left">服务器做checkpoint 的编号，每做一次checkpoint ，该值就加1。</td>
</tr>
<tr>
<td align="center">LOG_CHECKPOINT_LSN</td>
<td align="center">8</td>
<td align="left">服务器做checkpoint 结束时对应的LSN 值，系统奔溃恢复时将从该值开始。</td>
</tr>
<tr>
<td align="center">LOG_CHECKPOINT_OFFSET</td>
<td align="center">8</td>
<td align="left">上个属性中的LSN 值在redo 日志文件组中的偏移量</td>
</tr>
<tr>
<td align="center">LOG_CHECKPOINT_LOG_BUF_SIZE</td>
<td align="center">8</td>
<td align="left">服务器在做checkpoint 操作时对应的log buffer 的大小</td>
</tr>
<tr>
<td align="center">LOG_BLOCK_CHECKSUM</td>
<td align="center">4</td>
<td align="left">本block的校验值，所有block都有，我们不关心</td>
</tr>
</tbody></table>
<ul>
<li>第三个block未使用，忽略～</li>
<li>checkpoint2 ：结构和checkpoint1 一样。</li>
</ul>
<h2 id="Log-Sequeue-Number"><a href="#Log-Sequeue-Number" class="headerlink" title="Log Sequeue Number"></a>Log Sequeue Number</h2><p>为记录已经写入的redo 日志量，设计了一个称之为Log Sequeue Number 的全局变量，日志序列号，简称LSN</p>
<p>规定初始的lsn 值为8704</p>
<p>在统计lsn 的增长量时，是按照实际写入的日志量加上占用的log block header 和log block trailer 来计算的</p>
<p>每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p>
<h3 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h3><p>redo 日志是首先写到log buffer 中，之后才会被刷新到磁盘上的redo 日志文件。所以设计InnoDB 的大叔提出了一个称之为 buf_next_to_write 的全局变量，标记当前log buffer 中已经有哪些日志被刷新到磁盘中了。</p>
<p><img src="/attachment/3b8a42e699920fe0a42680ac68939a94.png"></p>
<p>刷新到磁盘中的redo 日志量的全局变量，称之为 flushed_to_disk_lsn 。</p>
<p>系统第一次启动时，该变量的值和初始的lsn 值是相同的，都是8704</p>
<p>如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p>
<h3 id="lsn值和redo日志文件偏移量的对应关系"><a href="#lsn值和redo日志文件偏移量的对应关系" class="headerlink" title="lsn值和redo日志文件偏移量的对应关系"></a>lsn值和redo日志文件偏移量的对应关系</h3><p>lsn 的值是代表系统写入的redo 日志量的一个总和，一个mtr 中产生多少日志， lsn 的值就增加多少（当然有时候要加上log block header 和log block trailer 的大小），这样mtr 产生的日志写到磁盘中时，很容易计算某一个lsn 值在redo 日志文件组中的偏移量</p>
<h3 id="flush链表中的LSN"><a href="#flush链表中的LSN" class="headerlink" title="flush链表中的LSN"></a>flush链表中的LSN</h3><p>在mtr 结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表。</p>
<p><img src="/attachment/59448f56db4c485c66d2a1cdb0c8a789.png"></p>
<p>说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的</p>
<p>在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p>
<ul>
<li>oldest_modification ：如果某个页面被加载到Buffer Pool 后进行第一次修改，那么就将修改该页面的 mtr 开始时对应的lsn 值写入这个属性。</li>
<li>newest_modification ：每修改一次页面，都会将修改该页面的mtr 结束时对应的lsn 值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统lsn 值。</li>
</ul>
<p><strong>举例</strong></p>
<ul>
<li>假设mtr_1 执行过程中修改了页a ，那么在mtr_1 执行结束时，就会将页a 对应的控制块加入到flush链表的头部。并且将mtr_1 开始时对应的lsn ，也就是8716 写入页a 对应的控制块的oldest_modification 属性中，把mtr_1 结束时对应的lsn ，也就是8916写入页a 对应的控制块的newest_modification 属性中。画个图表示一下（为了让图片美观一些，我们把oldest_modification 缩写成了o_m ，把newest_modification 缩写成了n_m ）：</li>
</ul>
<p><img src="/attachment/67c7c0593ef4be8ecd71c88590fe4ad9.png"></p>
<ul>
<li>接着假设mtr_2 执行过程中又修改了页b 和页c 两个页面，那么在mtr_2 执行结束时，就会将页b 和页c对应的控制块都加入到flush链表的头部。并且将mtr_2 开始时对应的lsn ，也就是8916写入页b 和页c对应的控制块的oldest_modification 属性中，把mtr_2 结束时对应的lsn ，也就是9948写入页b 和页c对应的控制块的newest_modification 属性中。画个图表示一下：</li>
</ul>
<p><img src="/attachment/f94d1f76d0363cd140144eb40c3218e3.png"></p>
<p>每次新插入到flush链表中的节点都是被放在了头部，也就是说<strong>flush链表中前边的脏页修改的时间比较晚，后边的脏页修改时间比较早</strong>。</p>
<ul>
<li>接着假设mtr_3 执行过程中修改了页b 和页d ，不过页b 之前已经被修改过了，所以它对应的控制块已经被插入到了flush 链表，所以在mtr_3 执行结束时，只需要将页d 对应的控制块都加入到flush链表的头部即可。</li>
</ul>
<p><img src="/attachment/57704071c7325804ba415757ddcb41f6.png"></p>
<p>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</p>
<h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>redo日志只是为了系统奔溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统奔溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。</p>
<p><strong>判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。</strong></p>
<p><img src="/attachment/0da7360001348c19f9108658047c0fd1.png"></p>
<p>如果页a被刷新到了磁盘，那么它对应的控制块就会从flush链表中移除</p>
<p><img src="/attachment/e6e162cae4b971e6a2627708e262ea22.png"></p>
<p>这样mtr_1 生成的redo 日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。</p>
<p>提出了一个全局变量 <strong>checkpoint_lsn</strong> 来代表当前系统中可以被覆盖的redo 日志总量是多少，这个变量初始值也是8704 。</p>
<p>比方说现在页a被刷新到了磁盘，mtr_1生成的redo日志就可以被覆盖了，所以我们可以进行一个增加checkpoint_lsn的操作，我们把这个过程称之为做一次checkpoint。</p>
<p>做一次checkpoint其实可以分为两个步骤：</p>
<p>步骤一：计算一下当前系统中可以被覆盖的redo 日志对应的lsn 值最大是多少。</p>
<ul>
<li>凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的</li>
<li>把该脏页的oldest_modification 赋值给checkpoint_lsn 。</li>
</ul>
<p>步骤二：将checkpoint_lsn 和对应的redo 日志文件组偏移量以及此次checkpint 的编号写到日志文件的管理信息（就是checkpoint1 或者checkpoint2 ）中。</p>
<p>维护了一个目前系统做了多少次checkpoint 的变量checkpoint_no ，每做一次checkpoint ，该变量的值就加1。<br>上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。</p>
<p>undefined</p>
<h3 id="批量从flush链表中刷出脏页"><a href="#批量从flush链表中刷出脏页" class="headerlink" title="批量从flush链表中刷出脏页"></a>批量从flush链表中刷出脏页</h3><p>如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做checkpoint ，可能就需要用户线程同步的从flush链表中把那些最早修改的脏页（ oldest_modification 最小的脏页）刷新到磁盘，这样这些脏页对应的redo 日志就没用了，然后就可以去做checkpoint 了。</p>
<h3 id="查看系统中的各种LSN值"><a href="#查看系统中的各种LSN值" class="headerlink" title="查看系统中的各种LSN值"></a>查看系统中的各种LSN值</h3><pre><code class="line-numbers language-sql">SHOW ENGINE INNODB STATUS
</code></pre>
<ul>
<li>Log sequence number ：代表系统中的lsn 值，也就是当前系统已经写入的redo 日志量，包括写入logbuffer 中的日志。</li>
<li>Log flushed up to ：代表flushed_to_disk_lsn 的值，也就是当前系统已经写入磁盘的redo 日志量。</li>
<li>Pages flushed up to ：代表flush链表中被最早修改的那个页面对应的oldest_modification 属性值。</li>
<li>Last checkpoint at ：当前系统的checkpoint_lsn 值。</li>
</ul>
<h3 id="innodb-flush-log-at-trx-commit的用法"><a href="#innodb-flush-log-at-trx-commit的用法" class="headerlink" title="innodb_flush_log_at_trx_commit的用法"></a>innodb_flush_log_at_trx_commit的用法</h3><p>为了保证事务的持久性，用户线程在事务提交时需要将该事务执行过程中产生的所有redo 日志都刷新到磁盘上。</p>
<p><strong>innodb_flush_log_at_trx_commit</strong> 的系统变量</p>
<ul>
<li>0 ：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步redo 日志，这个任务是交给后台线程做的。这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将redo 日志刷新到磁盘，那么该事务对页面的修改会丢失。</li>
<li>1 ：当该系统变量值为1时，表示在事务提交时需要将redo 日志同步到磁盘，可以保证事务的持久性。1也是innodb_flush_log_at_trx_commit 的默认值。</li>
<li>2 ：当该系统变量值为2时，表示在事务提交时需要将redo 日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是操作系统也挂了的话，那就不能保证持久性了。</li>
</ul>
<h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><h3 id="确定恢复的起点"><a href="#确定恢复的起点" class="headerlink" title="确定恢复的起点"></a>确定恢复的起点</h3><p>redo 日志文件组的第一个文件的管理信息中有两个block都存储了checkpoint_lsn 的信息，我们当然是要选取最近发生的那次checkpoint的信息。</p>
<h3 id="确定恢复的终点"><a href="#确定恢复的终点" class="headerlink" title="确定恢复的终点"></a>确定恢复的终点</h3><p><img src="/attachment/cd81fa87dd718fed10415acc55ac175e.png"></p>
<p>普通block的log block header 部分有一个称之为LOG_BLOCK_HDR_DATA_LEN 的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为512 。如果该属性的值不为512 ，那么就是它了，它就是此次奔溃恢复中需要扫描的最后一个block。</p>
<h3 id="怎么恢复"><a href="#怎么恢复" class="headerlink" title="怎么恢复"></a>怎么恢复</h3><p>确定了需要扫描哪些redo 日志进行奔溃恢复之后，接下来就是怎么进行恢复了。</p>
<p>假设现在的redo 日志文件中有5条redo 日志，如图：</p>
<p><img src="/attachment/99f809bbdc1359a32f7be7d187f5efa3.png"></p>
<p>由于redo 0 在checkpoint_lsn 后边，恢复时可以不管它。我们现在可以按照redo 日志的顺序依次扫描checkpoint_lsn 之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。</p>
<ul>
<li>使用哈希表</li>
</ul>
<p>根据redo 日志的space ID 和page number 属性计算出散列值，把space ID 和page number 相同的redo日志放到哈希表的同一个槽里，如果有多个space ID 和page number 都相同的redo 日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，</p>
<p><img src="/attachment/37f0ae78d9f018981aa767d5c3700f6d.png"></p>
<ul>
<li>跳过已经刷新到磁盘的页面</li>
</ul>
<h2 id="LOG-BLOCK-HDR-NO是如何计算的"><a href="#LOG-BLOCK-HDR-NO是如何计算的" class="headerlink" title="LOG_BLOCK_HDR_NO是如何计算的"></a>LOG_BLOCK_HDR_NO是如何计算的</h2><p>对于实际存储redo 日志的普通的log block 来说，在log block header 处有一个称之为 LOG_BLOCK_HDR_NO 的属性</p>
<p>使用下边的公式计算该block的LOG_BLOCK_HDR_NO 值：</p>
<pre><code class="line-numbers language-sql">((lsn / 512) &amp; 0x3FFFFFFFUL) + 1
</code></pre>
<p><img src="/attachment/df91a46b5d15f3eec07ea9d95c5b1df2.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/yu627482453">Bill Cipher</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yu627482453.github.io/database/mysql/mysql-ri-zhi-redo/">https://yu627482453.github.io/database/mysql/mysql-ri-zhi-redo/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yu627482453.github.io" target="_blank">蝶梦庄生</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%A1%8C%E5%8A%A8%E9%98%B6%E6%AE%B5-%E5%AE%8C%E6%88%90/">行动阶段/完成</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0%E7%A9%BA%E9%97%B4-KnowladgeSpace-ProgramSpace-BasicsSpace/">笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E9%A2%98%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">主题场景/数据存储</a><a class="post-meta__tags" href="/tags/%E7%BB%86%E5%8C%96%E4%B8%BB%E9%A2%98-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">细化主题/数据存储</a></div><div class="post_share"><div class="social-share" data-image="https://api.yimian.xyz/img?type=moe" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/database/mysql/mysql-ri-zhi-undo/"><img class="prev-cover" src="https://api.yimian.xyz/img?type=moe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【MySQL】 日志 - undo</div></div></a></div><div class="next-post pull-right"><a href="/database/mysql/mysql-shi-wu/"><img class="next-cover" src="https://api.yimian.xyz/img?type=moe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【MySQL】 事务</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/database/mysql/mysql/" title="MySQL"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">MySQL</div></div></a></div><div><a href="/database/mysql/mysql-innodb-de-buffer-pool/" title="【MySQL】 InnoDB的Buffer Pool"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="title">【MySQL】 InnoDB的Buffer Pool</div></div></a></div><div><a href="/database/mysql/mysql-mysql-ji-yu-cheng-ben-de-you-hua/" title="【MySQL】 MySQL基于成本的优化"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">【MySQL】 MySQL基于成本的优化</div></div></a></div><div><a href="/database/mysql/mysql-explain-xiang-jie/" title="【MySQL】 Explain详解"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="title">【MySQL】 Explain详解</div></div></a></div><div><a href="/database/mysql/mysql-innodb-de-biao-kong-jian/" title="【MySQL】 InnoDB的表空间"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-22</div><div class="title">【MySQL】 InnoDB的表空间</div></div></a></div><div><a href="/database/mysql/mysql-optimizer-trace-biao/" title="【MySQL】 optimizer trace表"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="title">【MySQL】 optimizer trace表</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Bill Cipher</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">215</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yu627482453"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yu627482453" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/627482453@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90MySQL%E3%80%91-%E6%97%A5%E5%BF%97-redo"><span class="toc-number">1.</span> <span class="toc-text">【MySQL】 日志 - redo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Metadata"><span class="toc-number">1.1.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.</span> <span class="toc-text">redo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E7%9A%84%E7%89%B9%E7%82%B9%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">redo日志的特点如下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">redo日志格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84redo%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">简单的redo日志类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E4%B8%80%E4%BA%9B%E7%9A%84redo%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">复杂一些的redo日志类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">redo日志格式小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mini-Transaction"><span class="toc-number">1.5.</span> <span class="toc-text">Mini-Transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E7%BB%84%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%86%99%E5%85%A5redo%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.</span> <span class="toc-text">以组的形式写入redo日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mini-Transaction%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.2.</span> <span class="toc-text">Mini-Transaction的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">redo日志的写入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-block"><span class="toc-number">1.6.1.</span> <span class="toc-text">redo log block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.6.2.</span> <span class="toc-text">redo日志缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5log-buffer"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">redo日志写入log buffer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.</span> <span class="toc-text">redo日志文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">1.7.1.</span> <span class="toc-text">redo日志刷盘时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">redo日志文件组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">redo日志文件格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Log-Sequeue-Number"><span class="toc-number">1.8.</span> <span class="toc-text">Log Sequeue Number</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flushed-to-disk-lsn"><span class="toc-number">1.8.1.</span> <span class="toc-text">flushed_to_disk_lsn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsn%E5%80%BC%E5%92%8Credo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.2.</span> <span class="toc-text">lsn值和redo日志文件偏移量的对应关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flush%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84LSN"><span class="toc-number">1.8.3.</span> <span class="toc-text">flush链表中的LSN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checkpoint"><span class="toc-number">1.9.</span> <span class="toc-text">checkpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E4%BB%8Eflush%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%B7%E5%87%BA%E8%84%8F%E9%A1%B5"><span class="toc-number">1.9.1.</span> <span class="toc-text">批量从flush链表中刷出脏页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DLSN%E5%80%BC"><span class="toc-number">1.9.2.</span> <span class="toc-text">查看系统中的各种LSN值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb-flush-log-at-trx-commit%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.9.3.</span> <span class="toc-text">innodb_flush_log_at_trx_commit的用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-number">1.10.</span> <span class="toc-text">崩溃恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%81%A2%E5%A4%8D%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-number">1.10.1.</span> <span class="toc-text">确定恢复的起点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%81%A2%E5%A4%8D%E7%9A%84%E7%BB%88%E7%82%B9"><span class="toc-number">1.10.2.</span> <span class="toc-text">确定恢复的终点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%81%A2%E5%A4%8D"><span class="toc-number">1.10.3.</span> <span class="toc-text">怎么恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LOG-BLOCK-HDR-NO%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84"><span class="toc-number">1.11.</span> <span class="toc-text">LOG_BLOCK_HDR_NO是如何计算的</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java 多线程并发】 线程"/></a><div class="content"><a class="title" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程">【Java 多线程并发】 线程</a><time datetime="2023-07-10T06:15:00.000Z" title="发表于 2023-07-10 14:15:00">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java JVM】 直接内存"/></a><div class="content"><a class="title" href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存">【Java JVM】 直接内存</a><time datetime="2023-07-10T00:00:00.000Z" title="发表于 2023-07-10 08:00:00">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/" title="【Redis】 排序"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Redis】 排序"/></a><div class="content"><a class="title" href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/" title="【Redis】 排序">【Redis】 排序</a><time datetime="2023-07-09T06:07:00.000Z" title="发表于 2023-07-09 14:07:00">2023-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/" title="【Redis】 Lua脚本"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Redis】 Lua脚本"/></a><div class="content"><a class="title" href="/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/" title="【Redis】 Lua脚本">【Redis】 Lua脚本</a><time datetime="2023-07-09T05:56:00.000Z" title="发表于 2023-07-09 13:56:00">2023-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis-chong-dian-gong-neng/redis-fa-bu-he-ding-yue/" title="【Redis】 发布和订阅"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Redis】 发布和订阅"/></a><div class="content"><a class="title" href="/database/redis/redis-chong-dian-gong-neng/redis-fa-bu-he-ding-yue/" title="【Redis】 发布和订阅">【Redis】 发布和订阅</a><time datetime="2023-07-09T05:30:00.000Z" title="发表于 2023-07-09 13:30:00">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Bill Cipher</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c61a274b6f5aa26a58f6',
      clientSecret: '485a7761d321c8dcc5cae05d7256be9fb196d94a',
      repo: 'yu627482453.github.io',
      owner: 'yu627482453',
      admin: ['yu627482453'],
      id: '4e6dd6ac3c89d60147d7b9a0a25a82ad',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>