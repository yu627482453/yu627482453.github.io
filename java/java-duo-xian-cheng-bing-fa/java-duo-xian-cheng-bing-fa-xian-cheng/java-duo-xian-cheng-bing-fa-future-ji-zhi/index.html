<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【Java 多线程并发】 Future机制 | 蝶梦庄生</title><meta name="keywords" content="Java"><meta name="author" content="Bill Cipher"><meta name="copyright" content="Bill Cipher"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【Java 多线程并发】 Future机制">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java 多线程并发】 Future机制">
<meta property="og:url" content="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-future-ji-zhi/index.html">
<meta property="og:site_name" content="蝶梦庄生">
<meta property="og:description" content="【Java 多线程并发】 Future机制">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.yimian.xyz/img?type=moe">
<meta property="article:published_time" content="2023-07-05T01:54:00.000Z">
<meta property="article:modified_time" content="2023-07-05T01:54:00.000Z">
<meta property="article:author" content="Bill Cipher">
<meta property="article:tag" content="行动阶段&#x2F;完成">
<meta property="article:tag" content="笔记空间&#x2F;KnowladgeSpace&#x2F;ProgramSpace&#x2F;BasicsSpace">
<meta property="article:tag" content="细化主题&#x2F;Java">
<meta property="article:tag" content="主题场景&#x2F;程序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.yimian.xyz/img?type=moe"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-future-ji-zhi/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bill Cipher","link":"链接: ","source":"来源: 蝶梦庄生","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Java 多线程并发】 Future机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-05 09:54:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">600</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">147</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.yimian.xyz/img?type=moe')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">蝶梦庄生</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Java 多线程并发】 Future机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-05T01:54:00.000Z" title="发表于 2023-07-05 09:54:00">2023-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-05T01:54:00.000Z" title="更新于 2023-07-05 09:54:00">2023-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Java 多线程并发】 Future机制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="【Java-多线程并发】-Future机制"><a href="#【Java-多线程并发】-Future机制" class="headerlink" title="【Java 多线程并发】 Future机制"></a>【Java 多线程并发】 Future机制</h1><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><pre><code class="line-numbers language-yml">title: 【Java 多线程并发】 Future机制
date: 2023-07-05 09:54
tags:
  - 行动阶段/完成
  - 主题场景/程序
  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace
  - 细化主题/Java
categories:
  - Java
keywords:
  - Java
description: 【Java 多线程并发】 Future机制
</code></pre>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>核心思想</strong></p>
<p>一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去控制方法f的计算过程。</p>
<p><strong>方法</strong></p>
<ul>
<li>get方法：获取计算结果（如果还没计算完，也是必须等待的）</li>
<li>cancel方法：还没计算完，可以取消计算过程</li>
<li>isDone方法：判断是否计算完</li>
<li>isCancelled方法：判断计算是否被取消</li>
</ul>
<p><strong>FutureTask</strong></p>
<p>FutureTask是Future的具体实现。FutureTask实现了RunnableFuture接口。RunnableFuture接口又同时继承了Future 和 Runnable 接口。<br>FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。</p>
<p>state字段</p>
<ul>
<li>volatile修饰的state字段；表示FutureTask当前所处的状态。</li>
</ul>
<pre><code class="line-numbers language-java">/**
     * Possible state transitions:
     * NEW -&gt; COMPLETING -&gt; NORMAL（创建到正常运行结束的状态变化轨迹）
     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL（创建到异常运行结束的状态变化轨迹）
     * NEW -&gt; CANCELLED  （创建到取消的状态变化轨迹）
     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED（创建到中断结束的状态变化轨迹）
     */
    private volatile int state;
     // NEW 新建状态，表示这个 FutureTask还没有开始运行
    private static final int NEW          = 0;
       // COMPLETING 完成状态， 表示 FutureTask 任务已经计算完毕了
       // 但是还有一些后续操作，例如唤醒等待线程操作，还没有完成。
    private static final int COMPLETING   = 1;
       // FutureTask 任务完结，正常完成，没有发生异常
    private static final int NORMAL       = 2;
       // FutureTask 任务完结，因为发生异常。
    private static final int EXCEPTIONAL  = 3;
       // FutureTask 任务完结，因为取消任务
    private static final int CANCELLED    = 4;
       // FutureTask 任务完结，也是取消任务，不过发起了中断运行任务线程的中断请求
    private static final int INTERRUPTING = 5;
       // FutureTask 任务完结，也是取消任务，已经完成了中断运行任务线程的中断请求
    private static final int INTERRUPTED  = 6;
</code></pre>
<p><strong>CompletableFuture</strong></p>
<p>Future 不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。</p>
<ul>
<li>观察者模式</li>
<li>提供了更为好用和强大的 Future 特性</li>
<li>函数式编程</li>
<li>异步任务编排组合</li>
</ul>
<p><img src="/attachment/c5b2007f356169eb2402602bcec20625.png"></p>
<p><strong>CompletableFuture常用方法</strong></p>
<ul>
<li>获取结果<ul>
<li>public T get()</li>
<li>public T get(long timeout,TimeUnit unit)</li>
<li>public T join() —&gt;和get一样的作用，只是不需要抛出异常</li>
<li>public T getNow(T valuelfAbsent) —&gt;计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞</li>
</ul>
</li>
<li>主动触发计算<ul>
<li>public boolean complete(T value) —-&gt;是否打断get方法立即返回括号值</li>
</ul>
</li>
<li>接受任务的处理结果，并消费处理，无返回结果<ul>
<li>thenAccept</li>
</ul>
</li>
<li>对比补充<ul>
<li>thenRun(Runnable runnable) :任务A执行完执行B，并且不需要A的结果</li>
<li>thenAccept(Consumer action): 任务A执行完执行B，B需要A的结果，但是任务B没有返回值</li>
<li>thenApply(Function fn): 任务A执行完执行B，B需要A的结果，同时任务B有返回值</li>
</ul>
</li>
<li>谁快用谁<ul>
<li>applyToEither</li>
</ul>
</li>
<li>对计算结果进行合并<ul>
<li>两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理</li>
<li>先完成的先等着，等待其他分支任务</li>
</ul>
</li>
</ul>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>先上一个场景：假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。</p>
<p>实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。</p>
<p>但是，子线程执行的结果是要返回厨具的，而run方法是没有返回值的。所以，这才是难点，需要好好考虑一下。</p>
<h3 id="模拟代码1："><a href="#模拟代码1：" class="headerlink" title="模拟代码1："></a>模拟代码1：</h3><pre><code class="line-numbers language-java">package test;
public class CommonCook {
    public static void main(String[] args) throws InterruptedException {
        long startTime = System.currentTimeMillis();
        // 第一步 网购厨具
        OnlineShopping thread = new OnlineShopping();
        thread.start();
        thread.join();  // 保证厨具送到
 
        // 第二步 去超市购买食材
        Thread.sleep(2000);  // 模拟购买食材时间
        Shicai shicai = new Shicai();
        System.out.println("第二步：食材到位");
 
        // 第三步 用厨具烹饪食材
        System.out.println("第三步：开始展现厨艺");
        cook(thread.chuju, shicai);
        
        System.out.println("总共用时" + (System.currentTimeMillis() - startTime) + "ms");
    }
    
    // 网购厨具线程
    static class OnlineShopping extends Thread {
        
        private Chuju chuju;
        @Override
        public void run() {
            System.out.println("第一步：下单");
            System.out.println("第一步：等待送货");
            try {
                Thread.sleep(5000);  // 模拟送货时间
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("第一步：快递送到");
            chuju = new Chuju();
        }
        
    }
    //  用厨具烹饪食材
    static void cook(Chuju chuju, Shicai shicai) {}
    
    // 厨具类
    static class Chuju {}
    
    // 食材类
    static class Shicai {}
}
</code></pre>
<p>运行结果：</p>
<ul>
<li>第一步：下单</li>
<li>第一步：等待送货</li>
<li>第一步：快递送到</li>
<li>第二步：食材到位</li>
<li>第三步：开始展现厨艺</li>
</ul>
<p>总共用时7013ms</p>
<p>可以看到，多线程已经失去了意义。在厨具送到期间，我们不能干任何事。对应代码，就是调用join方法阻塞主线程。</p>
<p>有人问了，不阻塞主线程行不行？？？</p>
<p>不行！！！</p>
<p>从代码来看的话，run方法不执行完，属性chuju就没有被赋值，还是null，后面执行就会出现空指针异常。换句话说，没有厨具，怎么做饭。</p>
<p>Java现在的多线程机制，核心方法run是没有返回值的；如果要保存run方法里面的计算结果，必须等待run方法计算完，无论计算过程多么耗时。</p>
<p>面对这种尴尬的处境，程序员就会想：在子线程run方法计算的期间，能不能在主线程里面继续异步执行？？？</p>
<p>Where there is a will，there is a way！！！</p>
<p>这种想法的核心就是Future模式，下面先应用一下Java自己实现的Future模式。</p>
<h3 id="模拟代码2："><a href="#模拟代码2：" class="headerlink" title="模拟代码2："></a>模拟代码2：</h3><pre><code class="line-numbers language-java">package test;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
public class FutureCook {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        long startTime = System.currentTimeMillis();
        // 第一步 网购厨具
        Callable&lt;Chuju&gt; onlineShopping = new Callable&lt;Chuju&gt;() {
            @Override
            public Chuju call() throws Exception {
                System.out.println("第一步：下单");
                System.out.println("第一步：等待送货");
                Thread.sleep(5000);  // 模拟送货时间
                System.out.println("第一步：快递送到");
                return new Chuju();
            }
            
        };
        FutureTask&lt;Chuju&gt; task = new FutureTask&lt;Chuju&gt;(onlineShopping);
        new Thread(task).start();
        // 第二步 去超市购买食材
        Thread.sleep(2000);  // 模拟购买食材时间
        Shicai shicai = new Shicai();
        System.out.println("第二步：食材到位");
        // 第三步 用厨具烹饪食材
        if (!task.isDone()) {  // 联系快递员，询问是否到货
            System.out.println("第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）");
        }
        Chuju chuju = task.get();
        System.out.println("第三步：厨具到位，开始展现厨艺");
        cook(chuju, shicai);
        
        System.out.println("总共用时" + (System.currentTimeMillis() - startTime) + "ms");
    }
    
    //  用厨具烹饪食材
    static void cook(Chuju chuju, Shicai shicai) {}
    
    // 厨具类
    static class Chuju {}
    
    // 食材类
    static class Shicai {}
}
</code></pre>
<p>运行结果：</p>
<p>第一步：下单<br>第一步：等待送货<br>第二步：食材到位<br>第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）<br>第一步：快递送到<br>第三步：厨具到位，开始展现厨艺</p>
<p>总共用时5005ms</p>
<p>可以看见，在快递员送厨具的期间，我们没有闲着，可以去买食材；而且我们知道厨具到没到，甚至可以在厨具没到的时候，取消订单不要了。</p>
<p>好神奇，有没有。</p>
<p>当然你可能会说模拟代码1中，只要join在cook(thread.chuju, shicai);就可以了，但是用future应该来说从编程角度更加自然。</p>
<p>比如模拟二的逻辑：</p>
<pre><code class="line-numbers language-java">if (!task.isDone()) { // 联系快递员，询问是否到货
System.out.println("第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）");
}
Chuju chuju = task.get();
</code></pre>
<p>等价于模拟一：</p>
<pre><code class="line-numbers language-java">thread.start();
// 第二步 去超市购买食材
Thread.sleep(2000); // 模拟购买食材时间
Shicai shicai = new Shicai();
System.out.println("第二步：食材到位");
thread.join(); // 保证厨具送到 ---------------join应该在购买食材开始后，而不是之前
</code></pre>
<p>用join这种写法也可以达到future的效果，但是使用Future不仅仅是更自然，而且确实是增加了灵活性，比如任务完成与否的判断，任务的取消等。这些是join不能做到的。</p>
<p>下面具体分析一下第二段代码：</p>
<p>1）把耗时的网购厨具逻辑，封装到了一个Callable的call方法里面。</p>
<pre><code class="line-numbers language-java">public interface Callable&lt;V&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
</code></pre>
<p>Callable接口可以看作是Runnable接口的补充，call方法带有返回值，并且可以抛出异常。</p>
<p>2）把Callable实例当作参数，生成一个FutureTask的对象，然后把这个对象当作一个Runnable，作为参数另起线程。</p>
<p>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</p>
<p>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</p>
<pre><code class="line-numbers language-java">public interface Future&lt;V&gt; {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<p>这个继承体系中的核心接口是Future。Future的核心思想是：一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去控制方法f的计算过程。</p>
<p>这里的控制包括：</p>
<p>get方法：获取计算结果（如果还没计算完，也是必须等待的）<br>cancel方法：还没计算完，可以取消计算过程<br>isDone方法：判断是否计算完<br>isCancelled方法：判断计算是否被取消</p>
<p>这些接口的设计很完美，FutureTask的实现注定不会简单，后面再说。</p>
<p>3）在第三步里面，调用了isDone方法查看状态，然后直接调用task.get方法获取厨具，不过这时还没送到，所以还是会等待3秒。对比第一段代码的执行结果，这里我们节省了2秒。这是因为在快递员送货期间，我们去超市购买食材，这两件事在同一时间段内异步执行。</p>
<h2 id="为什么出现Future机制"><a href="#为什么出现Future机制" class="headerlink" title="为什么出现Future机制"></a>为什么出现Future机制</h2><p>常见的两种创建线程的方式。一种是直接继承Thread，另外一种就是实现Runnable接口。</p>
<p>这两种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p>
<p>从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<p>Future模式的核心思想是能够让主线程将原来需要同步等待的这段时间用来做其他的事情。（因为可以异步获得执行结果，所以不用一直同步等待去获得执行结果）</p>
<p><img src="/attachment/c2c554b65b2f796c180d0b705a278591.png"></p>
<p>上图简单描述了不使用Future和使用Future的区别，不使用Future模式，主线程在invoke完一些耗时逻辑之后需要等待，这个耗时逻辑在实际应用中可能是一次RPC调用，可能是一个本地IO操作等。B图表达的是使用Future模式之后，我们主线程在invoke之后可以立即返回，去做其他的事情，回头再来看看刚才提交的invoke有没有结果。</p>
<h3 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h3><p>Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
<p>这其实就是多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>
<p>在 Java 中，Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<ul>
<li>取消任务；</li>
<li>判断任务是否被取消;</li>
<li>判断任务是否已经执行完成;</li>
<li>获取任务执行结果。</li>
</ul>
<pre><code class="line-numbers language-java">// V 代表了Future执行的任务返回值的类型
public interface Future&lt;V&gt; {
    // 取消任务执行
    // 成功取消返回 true，否则返回 false
    boolean cancel(boolean mayInterruptIfRunning);
    // 判断任务是否被取消
    boolean isCancelled();
    // 判断任务是否已经执行完成
    boolean isDone();
    // 获取任务执行结果
    V get() throws InterruptedException, ExecutionException;
    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutExceptio
}
</code></pre>
<p>简单理解就是：我有一个任务，提交给了 Future 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 Future 那里直接取出任务执行结果。</p>
<h2 id="Future的相关类图"><a href="#Future的相关类图" class="headerlink" title="Future的相关类图"></a>Future的相关类图</h2><h3 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h3><p>首先，我们需要清楚，Futrue是个接口。Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p><img src="/attachment/b66232f729a217a8539994376b42dc53.png"></p>
<p>口定义行为，我们通过上图可以看到实现Future接口的子类会具有哪些行为：</p>
<ul>
<li>我们可以取消这个执行逻辑，如果这个逻辑已经正在执行，提供可选的参数来控制是否取消已经正在执行的逻辑。</li>
<li>我们可以判断执行逻辑是否已经被取消。</li>
<li>我们可以判断执行逻辑是否已经执行完成。</li>
<li>我们可以获取执行逻辑的执行结果。</li>
<li>我们可以允许在一定时间内去等待获取执行结果，如果超过这个时间，抛TimeoutException。</li>
</ul>
<h3 id="FutureTask-类"><a href="#FutureTask-类" class="headerlink" title="FutureTask 类"></a>FutureTask 类</h3><p>类图如下：</p>
<p><img src="/attachment/2c14b6b8976535d5ac251993e91d3055.png"></p>
<p>FutureTask是Future的具体实现。FutureTask实现了RunnableFuture接口。RunnableFuture接口又同时继承了Future 和 Runnable 接口。所以FutureTask既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<h2 id="FutureTask源码分析"><a href="#FutureTask源码分析" class="headerlink" title="FutureTask源码分析"></a>FutureTask源码分析</h2><h3 id="state字段"><a href="#state字段" class="headerlink" title="state字段"></a>state字段</h3><p>volatile修饰的state字段；表示FutureTask当前所处的状态。可能的转换过程见注释。</p>
<pre><code class="line-numbers language-java">/**
     * Possible state transitions:
     * NEW -&gt; COMPLETING -&gt; NORMAL（创建到正常运行结束的状态变化轨迹）
     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL（创建到异常运行结束的状态变化轨迹）
     * NEW -&gt; CANCELLED  （创建到取消的状态变化轨迹）
     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED（创建到中断结束的状态变化轨迹）
     */
    private volatile int state;
     // NEW 新建状态，表示这个 FutureTask还没有开始运行
    private static final int NEW          = 0;
       // COMPLETING 完成状态， 表示 FutureTask 任务已经计算完毕了
       // 但是还有一些后续操作，例如唤醒等待线程操作，还没有完成。
    private static final int COMPLETING   = 1;
       // FutureTask 任务完结，正常完成，没有发生异常
    private static final int NORMAL       = 2;
       // FutureTask 任务完结，因为发生异常。
    private static final int EXCEPTIONAL  = 3;
       // FutureTask 任务完结，因为取消任务
    private static final int CANCELLED    = 4;
       // FutureTask 任务完结，也是取消任务，不过发起了中断运行任务线程的中断请求
    private static final int INTERRUPTING = 5;
       // FutureTask 任务完结，也是取消任务，已经完成了中断运行任务线程的中断请求
    private static final int INTERRUPTED  = 6;
</code></pre>
<h3 id="其他变量"><a href="#其他变量" class="headerlink" title="其他变量"></a>其他变量</h3><pre><code class="line-numbers language-java">/** 任务 */
    private Callable&lt;V&gt; callable;
    /** 储存结果*/
    private Object outcome; // non-volatile, protected by state reads/writes
    /** 执行任务的线程*/
    private volatile Thread runner;
    /** get方法阻塞的线程队列 */
    private volatile WaitNode waiters;
    //FutureTask的内部类，get方法的等待队列
    static final class WaitNode {
        volatile Thread thread;
        volatile WaitNode next;
        WaitNode() { thread = Thread.currentThread(); }
    }
</code></pre>
<h3 id="CAS工具初始化"><a href="#CAS工具初始化" class="headerlink" title="CAS工具初始化"></a>CAS工具初始化</h3><pre><code class="line-numbers language-java"> 
    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long stateOffset;
    private static final long runnerOffset;
    private static final long waitersOffset;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class&lt;?&gt; k = FutureTask.class;
            stateOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField("state"));
            runnerOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField("runner"));
            waitersOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField("waiters"));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
</code></pre>
<p>这段代码是为了后面使用CAS而准备的。可以这么理解：</p>
<p>一个java对象可以看成是一段内存，各个字段都得按照一定的顺序放在这段内存里，同时考虑到对齐要求，可能这些字段不是连续放置的，用这个UNSAFE.objectFieldOffset（）方法能准确地告诉你某个字段相对于对象的起始内存地址的字节偏移量，因为是相对偏移量，所以它其实跟某个具体对象又没什么太大关系，跟class的定义和虚拟机的内存模型的实现细节更相关。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>FutureTask有两个构造函数：</p>
<pre><code class="line-numbers language-java">public FutureTask(Callable&lt;V&gt; callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}
    
public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
</code></pre>
<p>这两个构造函数区别在于，如果使用第一个构造函数最后获取线程实行结果就是callable的执行的返回结果；而如果使用第二个构造函数那么最后获取线程实行结果就是参数中的result，接下来让我们看一下FutureTask的run方法。</p>
<p>同时两个构造函数都把当前状态设置为NEW。</p>
<h3 id="jdk1-8和之前版本的区别"><a href="#jdk1-8和之前版本的区别" class="headerlink" title="jdk1.8和之前版本的区别"></a>jdk1.8和之前版本的区别</h3><p>1.8:</p>
<p>get方法的逻辑很简单，如果call方法的执行过程已完成，就把结果给出去；如果未完成，就将当前线程挂起等待。awaitDone方法里面死循环的逻辑，推演几遍就能弄懂；它里面挂起线程的主要创新是定义了WaitNode类，来将多个等待线程组织成队列，这是与JDK6的实现最大的不同。</p>
<p>1.6：</p>
<p>JDK6的FutureTask的基本操作都是通过自己的内部类Sync来实现的，而Sync继承自AbstractQueuedSynchronizer这个出镜率极高的并发工具类</p>
<p>也就是说<mark style="background: #FFB8EBA6;">1.8自己定义了一个WaitNode类，来将多个等待线程组织成队列，在以前使用AQS来实现的</mark></p>
<p>这个get方法里面处理等待线程队列的方式是调用了acquireSharedInterruptibly方法</p>
<h2 id="Callable-和-Future-有什么关系？"><a href="#Callable-和-Future-有什么关系？" class="headerlink" title="Callable 和 Future 有什么关系？"></a>Callable 和 Future 有什么关系？</h2><p>我们可以通过 FutureTask 来理解 Callable 和 Future 之间的关系。</p>
<p>FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask 。</p>
<pre><code class="line-numbers language-java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
Future&lt;?&gt; submit(Runnable task);
</code></pre>
<p>FutureTask 不光实现了 Future接口，还实现了Runnable 接口，因此可以作为任务直接被线程执行。</p>
<p><img src="/attachment/3d3c57f763724719950edfcac4916b13.png"></p>
<p>FutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象。</p>
<pre><code class="line-numbers language-java">public FutureTask(Callable&lt;V&gt; callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;
}
public FutureTask(Runnable runnable, V result) {
    // 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;
}
</code></pre>
<p>FutureTask相当于对Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。</p>
<h2 id="CompletableFuture-类"><a href="#CompletableFuture-类" class="headerlink" title="CompletableFuture 类"></a>CompletableFuture 类</h2><p>Future 在实际使用过程中存在一些局限性，比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。</p>
<p>Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p>
<p>下面我们来简单看看 CompletableFuture 类的定义。</p>
<pre><code class="line-numbers language-java">public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {

}
</code></pre>
<p>可以看到，CompletableFuture 同时实现了 Future 和 CompletionStage 接口。</p>
<p><img src="/attachment/2153a37f89c6c893af88403a2e25de0f.png"></p>
<p>CompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p>
<p>CompletionStage 接口中的方法比较多，CompletableFuture 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p>
<p><img src="/attachment/50e0a799c992f84724e04f98e453688c.png"></p>
<h3 id="CompletableFuture对Future的改进"><a href="#CompletableFuture对Future的改进" class="headerlink" title="CompletableFuture对Future的改进"></a>CompletableFuture对Future的改进</h3><h4 id="CompletableFuture为什么会出现"><a href="#CompletableFuture为什么会出现" class="headerlink" title="CompletableFuture为什么会出现"></a>CompletableFuture为什么会出现</h4><ol>
<li>get()方法在Future计算完成之前会一直处在<mark style="background: #FFB8EBA6;">阻塞</mark>状态下，<mark style="background: #BBFABBA6;">阻塞的方式和异步编程的设计理念相违背</mark>。</li>
<li>isDene()方法容易耗费cpu资源（cpu空转），</li>
<li>对于真正的异步处理我们希望是可以通过传入<mark style="background: #FFB8EBA6;">回调函数</mark>，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</li>
</ol>
<p>jdk8设计出CompletableFuture，CompletableFuture提供了一种<mark style="background: #FFB8EBA6;">观察者模式</mark>类似的机制，可以让任务执行完成后通知监听的一方。</p>
<h4 id="CompletableFuture和CompletionStage介绍"><a href="#CompletableFuture和CompletionStage介绍" class="headerlink" title="CompletableFuture和CompletionStage介绍"></a>CompletableFuture和CompletionStage介绍</h4><p>类架构说明：</p>
<p><img src="/attachment/c5b2007f356169eb2402602bcec20625.png"></p>
<ul>
<li>接口CompletionStage<ul>
<li>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。</li>
<li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li>
</ul>
</li>
<li>类CompletableFuture<ul>
<li>提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture的方法</li>
<li>它可能代表一个明确完成的Future，也可能代表一个完成阶段（CompletionStage），它支持在计算完成以后触发一些函数或执行某些动作</li>
</ul>
</li>
</ul>
<h4 id="核心的四个静态方法，来创建一个异步任务"><a href="#核心的四个静态方法，来创建一个异步任务" class="headerlink" title="核心的四个静态方法，来创建一个异步任务"></a>核心的四个静态方法，来创建一个异步任务</h4><p>四个静态构造方法</p>
<p><img src="/attachment/b858e4dffdcef27b0c3535c59972c76c.png"></p>
<p>对于上述Executor参数说明：若没有指定，则使用默认的ForkJoinPoolcommonPool（）作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</p>
<pre><code class="line-numbers language-java">/**
 * @author Guanghao Wei
 * @create 2023-04-10 12:16
 */
public class CompletableFutureBuildDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; {
            System.out.println(Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },executorService);

        System.out.println(completableFuture.get()); //null


        CompletableFuture&lt;String&gt; objectCompletableFuture = CompletableFuture.supplyAsync(()-&gt;{
            System.out.println(Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "hello supplyAsync";
        },executorService);

        System.out.println(objectCompletableFuture.get());//hello supplyAsync

        executorService.shutdown();

    }
}
</code></pre>
<p>CompletableFuture减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<pre><code class="line-numbers language-java">/**
 * @author Guanghao Wei
 * @create 2023-04-10 12:28
 */
public class CompletableFutureUseDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread().getName() + "---come in");
            int result = ThreadLocalRandom.current().nextInt(10);
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (result &gt; 5) { //模拟产生异常情况
                int i = 10 / 0;
            }
            System.out.println("----------1秒钟后出结果" + result);
            return result;
        }, executorService).whenComplete((v, e) -&gt; {
            if (e == null) {
                System.out.println("计算完成 更新系统" + v);
            }
        }).exceptionally(e -&gt; {
            e.printStackTrace();
            System.out.println("异常情况：" + e.getCause() + " " + e.getMessage());
            return null;
        });
        System.out.println(Thread.currentThread().getName() + "先去完成其他任务");
        executorService.shutdown();
    }
}

/**
 * 无异常情况
 * pool-1-thread-1---come in
 * main先去完成其他任务
 * ----------1秒钟后出结果9
 * 计算完成 更新系统9
 */

/**
 * 有异常情况
 *pool-1-thread-1---come in
 * main先去完成其他任务
 * java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero
 * 异常情况：java.lang.ArithmeticException: / by zero java.lang.ArithmeticException: / by zero
 */
</code></pre>
<p>CompletableFuture优点：</p>
<ul>
<li>异步任务结束时，会<mark style="background: #FFB8EBA6;">自动回调</mark>某个对象的方法</li>
<li>主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以<mark style="background: #FFB8EBA6;">顺序执行</mark></li>
<li>异步任务出错时，会<mark style="background: #FFB8EBA6;">自动回调</mark>某个对象的方法</li>
</ul>
<h3 id="CompletableFuture常用方法"><a href="#CompletableFuture常用方法" class="headerlink" title="CompletableFuture常用方法"></a>CompletableFuture常用方法</h3><h4 id="获得结果和触发计算"><a href="#获得结果和触发计算" class="headerlink" title="获得结果和触发计算"></a>获得结果和触发计算</h4><ul>
<li>获取结果<ul>
<li>public T get()</li>
<li>public T get(long timeout,TimeUnit unit)</li>
<li>public T join() —&gt;和get一样的作用，只是不需要抛出异常</li>
<li>public T getNow(T valuelfAbsent) —&gt;计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞</li>
</ul>
</li>
<li>主动触发计算<ul>
<li>public boolean complete(T value) —-&gt;是否打断get方法立即返回括号值</li>
</ul>
</li>
</ul>
<h4 id="对计算结果进行处理"><a href="#对计算结果进行处理" class="headerlink" title="对计算结果进行处理"></a>对计算结果进行处理</h4><ul>
<li>thenApply —&gt;计算结果存在依赖关系，这两个线程串行化—-&gt;由于存在依赖关系（当前步错，不走下一步），当前步骤有异常的话就叫停</li>
<li>handle —&gt;计算结果存在依赖关系，这两个线程串行化—-&gt;有异常也可以往下走一步</li>
</ul>
<pre><code class="line-numbers language-java">/**
 * @author Guanghao Wei
 * @create 2023-04-10 13:43
 */
public class CompletableFutureApiDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 1;
        }, threadPool).thenApply(f -&gt; {
            System.out.println("222");
            return f + 2;
        }).handle((f, e) -&gt; {
            System.out.println("3333");
            int i=10/0;
            return f + 2;

//             thenApply(f -&gt; {
//            System.out.println("3333");
//            return f + 2;
        }).whenComplete((v, e) -&gt; {
            if (e == null) {
                System.out.println("----计算结果" + v);
            }
        }).exceptionally(e -&gt; {
            e.printStackTrace();
            System.out.println(e.getCause());
            return null;
        });
        System.out.println(Thread.currentThread().getName() + "------主线程先去做其他事情");
    }
}
</code></pre>
<h4 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h4><ul>
<li>接受任务的处理结果，并消费处理，无返回结果<ul>
<li>thenAccept</li>
</ul>
</li>
</ul>
<pre><code class="line-numbers language-java">/**
 * @author Guanghao Wei
 * @create 2023-04-10 13:59
 */
public class CompletableFutureApi2Demo {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        CompletableFuture.supplyAsync(() -&gt; {
            return 1;
        }, threadPool).thenApply(f -&gt; {
            return f + 2;
        }).thenApply(f -&gt; {
            return f + 2;
        }).thenAccept(r -&gt; {
            System.out.println(r);//5
        });
    }
}
</code></pre>
<ul>
<li>对比补充<ul>
<li>thenRun(Runnable runnable) :任务A执行完执行B，并且不需要A的结果</li>
<li>thenAccept(Consumer action): 任务A执行完执行B，B需要A的结果，但是任务B没有返回值</li>
<li>thenApply(Function fn): 任务A执行完执行B，B需要A的结果，同时任务B有返回值</li>
</ul>
</li>
</ul>
<pre><code class="line-numbers language-java">/**
 * @author Guanghao Wei
 * @create 2023-04-10 13:59
 */
public class CompletableFutureApi2Demo {
    public static void main(String[] args) {
        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenRun(() -&gt; {}).join());//null
        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenAccept(r -&gt; System.out.println(r)).join());//result null
        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenApply(f -&gt; f + 2).join());//result2
    }
}
</code></pre>
<h4 id="对计算速度进行选用"><a href="#对计算速度进行选用" class="headerlink" title="对计算速度进行选用"></a>对计算速度进行选用</h4><ul>
<li>谁快用谁<ul>
<li>applyToEither</li>
</ul>
</li>
</ul>
<pre><code class="line-numbers language-java">/**
 * @author Guanghao Wei
 * @create 2023-04-10 14:11
 * 可以合并写在一起，不必拆分
 */
public class CompletableFutureApiDemo {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        CompletableFuture&lt;String&gt; playA = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println("A come in");
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "playA";
        }, threadPool);


        CompletableFuture&lt;String&gt; playB = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println("B come in");
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "playB";
        }, threadPool);

        CompletableFuture&lt;String&gt; result = playA.applyToEither(playB, f -&gt; {
            return f + " is winner";
        });

        /**
         * A come in
         * B come in
         * main-----------winner:playA is winner
         */
        System.out.println(Thread.currentThread().getName() + "-----------winner:" + result.join());
    }
}
</code></pre>
<h4 id="对计算结果进行合并"><a href="#对计算结果进行合并" class="headerlink" title="对计算结果进行合并"></a>对计算结果进行合并</h4><ul>
<li>两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理</li>
<li>先完成的先等着，等待其他分支任务</li>
</ul>
<pre><code class="line-numbers language-java">/**
 * @author Guanghao Wei
 * @create 2023-04-10 14:28
 * 可以合并写在一起，不必拆分
 */
public class CompletableFutureApi3Demo {
    public static void main(String[] args) {
        CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread().getName() + " 启动");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 10;
        });

        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread().getName() + " 启动");
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 20;
        });

        CompletableFuture&lt;Integer&gt; finalResult = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; {
            System.out.println("----------开始两个结果合并");
            return x + y;
        });
        System.out.println(finalResult.join());

    }
}
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/yu627482453">Bill Cipher</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-future-ji-zhi/">https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-future-ji-zhi/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yu627482453.github.io" target="_blank">蝶梦庄生</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%A1%8C%E5%8A%A8%E9%98%B6%E6%AE%B5-%E5%AE%8C%E6%88%90/">行动阶段/完成</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0%E7%A9%BA%E9%97%B4-KnowladgeSpace-ProgramSpace-BasicsSpace/">笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace</a><a class="post-meta__tags" href="/tags/%E7%BB%86%E5%8C%96%E4%B8%BB%E9%A2%98-Java/">细化主题/Java</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E9%A2%98%E5%9C%BA%E6%99%AF-%E7%A8%8B%E5%BA%8F/">主题场景/程序</a></div><div class="post_share"><div class="social-share" data-image="https://api.yimian.xyz/img?type=moe" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-xian-cheng-chi/"><img class="prev-cover" src="https://api.yimian.xyz/img?type=moe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Java 多线程并发】 线程池</div></div></a></div><div class="next-post pull-right"><a href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-zhong-duan/"><img class="next-cover" src="https://api.yimian.xyz/img?type=moe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Java 多线程并发】 线程中断</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/java/java-web/java-web/" title="Java Web"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">Java Web</div></div></a></div><div><a href="/java/java-web/java-listener/" title="【Java】 Listener"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Listener</div></div></a></div><div><a href="/java/java-web/java-filter/" title="【Java】 Filter"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Filter</div></div></a></div><div><a href="/java/java-web/java-servlet/" title="【Java】 Servlet"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Servlet</div></div></a></div><div><a href="/language/java/java-web/java-web/" title="Java Web"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">Java Web</div></div></a></div><div><a href="/language/java/java-web/java-filter/" title="【Java】 Filter"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Filter</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Bill Cipher</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">600</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">147</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yu627482453"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yu627482453" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/627482453@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E3%80%91-Future%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">【Java 多线程并发】 Future机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Metadata"><span class="toc-number">1.1.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.3.</span> <span class="toc-text">引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%BB%A3%E7%A0%811%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">模拟代码1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%BB%A3%E7%A0%812%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">模拟代码2：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0Future%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">为什么出现Future机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">Future 类有什么用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Future%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9B%BE"><span class="toc-number">1.5.</span> <span class="toc-text">Future的相关类图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.1.</span> <span class="toc-text">Future 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask-%E7%B1%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">FutureTask 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FutureTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">FutureTask源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#state%E5%AD%97%E6%AE%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">state字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">其他变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%B7%A5%E5%85%B7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.3.</span> <span class="toc-text">CAS工具初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk1-8%E5%92%8C%E4%B9%8B%E5%89%8D%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.5.</span> <span class="toc-text">jdk1.8和之前版本的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callable-%E5%92%8C-Future-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">Callable 和 Future 有什么关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CompletableFuture-%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">CompletableFuture 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CompletableFuture%E5%AF%B9Future%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">1.8.1.</span> <span class="toc-text">CompletableFuture对Future的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletableFuture%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">CompletableFuture为什么会出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletableFuture%E5%92%8CCompletionStage%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">CompletableFuture和CompletionStage介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">核心的四个静态方法，来创建一个异步任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CompletableFuture%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">CompletableFuture常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%9C%E5%92%8C%E8%A7%A6%E5%8F%91%E8%AE%A1%E7%AE%97"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">获得结果和触发计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">对计算结果进行处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%B6%88%E8%B4%B9"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">对计算结果进行消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%AE%A1%E7%AE%97%E9%80%9F%E5%BA%A6%E8%BF%9B%E8%A1%8C%E9%80%89%E7%94%A8"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">对计算速度进行选用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">对计算结果进行合并</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/module/flowable/flowable-zhuan-lan/flowable-zhuan-lan/" title="无题"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/module/flowable/flowable-zhuan-lan/flowable-zhuan-lan/" title="无题">无题</a><time datetime="2023-07-15T09:45:06.401Z" title="发表于 2023-07-15 17:45:06">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/module/consul/part/consul-tong-yong-pei-zhi-shu-xing/" title="无题"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/module/consul/part/consul-tong-yong-pei-zhi-shu-xing/" title="无题">无题</a><time datetime="2023-07-15T09:44:38.408Z" title="发表于 2023-07-15 17:44:38">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java 多线程并发】 线程"/></a><div class="content"><a class="title" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程">【Java 多线程并发】 线程</a><time datetime="2023-07-10T06:15:00.000Z" title="发表于 2023-07-10 14:15:00">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java JVM】 直接内存"/></a><div class="content"><a class="title" href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存">【Java JVM】 直接内存</a><time datetime="2023-07-10T00:00:00.000Z" title="发表于 2023-07-10 08:00:00">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/" title="【Redis】 排序"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Redis】 排序"/></a><div class="content"><a class="title" href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/" title="【Redis】 排序">【Redis】 排序</a><time datetime="2023-07-09T06:07:00.000Z" title="发表于 2023-07-09 14:07:00">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Bill Cipher</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c61a274b6f5aa26a58f6',
      clientSecret: '485a7761d321c8dcc5cae05d7256be9fb196d94a',
      repo: 'yu627482453.github.io',
      owner: 'yu627482453',
      admin: ['yu627482453'],
      id: '6d8ac3e08d7af0a1869d13915df7f4a8',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>