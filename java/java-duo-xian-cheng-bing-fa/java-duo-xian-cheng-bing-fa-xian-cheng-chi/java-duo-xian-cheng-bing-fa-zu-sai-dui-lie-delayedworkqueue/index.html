<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【Java 多线程并发】 阻塞队列DelayedWorkQueue | 蝶梦庄生</title><meta name="keywords" content="Java"><meta name="author" content="Bill Cipher"><meta name="copyright" content="Bill Cipher"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【Java 多线程并发】 阻塞队列DelayedWorkQueue">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java 多线程并发】 阻塞队列DelayedWorkQueue">
<meta property="og:url" content="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-zu-sai-dui-lie-delayedworkqueue/index.html">
<meta property="og:site_name" content="蝶梦庄生">
<meta property="og:description" content="【Java 多线程并发】 阻塞队列DelayedWorkQueue">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.yimian.xyz/img?type=moe">
<meta property="article:published_time" content="2023-07-05T04:58:00.000Z">
<meta property="article:modified_time" content="2023-07-05T04:58:00.000Z">
<meta property="article:author" content="Bill Cipher">
<meta property="article:tag" content="行动阶段&#x2F;完成">
<meta property="article:tag" content="笔记空间&#x2F;KnowladgeSpace&#x2F;ProgramSpace&#x2F;BasicsSpace">
<meta property="article:tag" content="细化主题&#x2F;Java">
<meta property="article:tag" content="主题场景&#x2F;程序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.yimian.xyz/img?type=moe"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-zu-sai-dui-lie-delayedworkqueue/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bill Cipher","link":"链接: ","source":"来源: 蝶梦庄生","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Java 多线程并发】 阻塞队列DelayedWorkQueue',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-05 12:58:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">215</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.yimian.xyz/img?type=moe')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">蝶梦庄生</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Java 多线程并发】 阻塞队列DelayedWorkQueue</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-05T04:58:00.000Z" title="发表于 2023-07-05 12:58:00">2023-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-05T04:58:00.000Z" title="更新于 2023-07-05 12:58:00">2023-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Java 多线程并发】 阻塞队列DelayedWorkQueue"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>【Java 多线程并发】 阻塞队列DelayedWorkQueue</h1>
<h2 id="Metadata-142">Metadata</h2>
<pre><code class="language-yml">title: 【Java 多线程并发】 阻塞队列DelayedWorkQueue
date: 2023-07-05 12:58
tags:
  - 行动阶段/完成
  - 主题场景/程序
  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace
  - 细化主题/Java
categories:
  - Java
keywords:
  - Java
description: 【Java 多线程并发】 阻塞队列DelayedWorkQueue
</code></pre>
<h2 id="前言-4">前言</h2>
<p>线程池运行时，会不断从任务队列中获取任务，然后执行任务。如果我们想实现延时或者定时执行任务，重要一点就是任务队列会根据任务延时时间的不同进行排序，延时时间越短的就排在队列的前面，先被获取执行。</p>
<p>队列是先进先出的数据结构，就是先进入队列的数据，先被获取。但是有一种特殊的队列叫做优先级队列，它会对插入的数据进行优先级排序，保证优先级越高的数据首先被获取，与数据的插入顺序无关。</p>
<p>实现优先级队列高效常用的一种方式就是使用堆。</p>
<h2 id="ScheduledThreadPoolExecutor线程池">ScheduledThreadPoolExecutor线程池</h2>
<p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以其内部的数据结构和ThreadPoolExecutor基本一样，并在其基础上增加了按时间调度执行任务的功能，分为延迟执行任务和周期性执行任务。</p>
<p>ScheduledThreadPoolExecutor的构造函数只能传3个参数corePoolSize、ThreadFactory、RejectedExecutionHandler，默认maximumPoolSize为Integer.MAX_VALUE。</p>
<p>工作队列是高度定制化的延迟阻塞队列DelayedWorkQueue，其实现原理和DelayQueue基本一样，核心数据结构是二叉最小堆的优先队列，队列满时会自动扩容，所以offer操作永远不会阻塞，maximumPoolSize也就用不上了，所以线程池中永远会保持至多有corePoolSize个工作线程正在运行。</p>
<pre><code class="language-java">public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory,
                                   RejectedExecutionHandler handler) {
    // 调用父类ThreadPoolExecutor的构造方法来创建定时任务线程池
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue(), threadFactory, handler); // 传入DelayedWorkQueue阻塞队列
}
</code></pre>
<h2 id="DelayedWorkQueue延迟阻塞队列">DelayedWorkQueue延迟阻塞队列</h2>
<p><img src="/attachment/0ae74fa0f8f40eb7a116ad968d9b0900.png" alt=""></p>
<p>DelayedWorkQueue 也是一种设计为定时任务的延迟队列，它的实现和DelayQueue一样，不过是将优先级队列和DelayQueue的实现过程迁移到本身方法体中，从而可以在该过程当中灵活的加入定时任务特有的方法调用。</p>
<h2 id="工作原理">工作原理</h2>
<p>ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，是因为 ScheduleThreadPoolExecutor 要求的工作队列有些特殊。</p>
<p>DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面（注意：<mark style="background: #FFB8EBA6;">这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的</mark>）。</p>
<p>堆结构如下图：</p>
<p><img src="/attachment/63d9e47e647b424426dc32422e56110e.png" alt=""></p>
<p>可见，DelayedWorkQueue是一个基于最小堆结构的队列。堆结构可以使用数组表示，可以转换成如下的数组：</p>
<p><img src="/attachment/b7819846345fdfc2a1d37a3309bbeb6c.png" alt=""></p>
<p>在这种结构中，可以发现有如下特性： 假设“第一个元素” 在数组中的索引为 0 的话，则父结点和子结点的位置关系如下：</p>
<ul>
<li>索引为  的左孩子的索引是 (2 * i + 1)；</li>
<li>索引为  的右孩子的索引是 (2 * i + 2)；</li>
<li>索引为  的父结点的索引是 floor((i−1)/2)；</li>
</ul>
<p>为什么要使用DelayedWorkQueue呢？</p>
<ul>
<li>定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。</li>
<li>DelayedWorkQueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。</li>
</ul>
<h2 id="源码分析-4">源码分析</h2>
<h3 id="定义">定义</h3>
<pre><code class="language-java">static class DelayedWorkQueue extends AbstractQueue&lt;Runnable&gt;
        implements BlockingQueue&lt;Runnable&gt; {
 
        /*
         * A DelayedWorkQueue is based on a heap-based data structure
         * like those in DelayQueue and PriorityQueue, except that
         * every ScheduledFutureTask also records its index into the
         * heap array. This eliminates the need to find a task upon
         * cancellation, greatly speeding up removal (down from O(n)
         * to O(log n)), and reducing garbage retention that would
         * otherwise occur by waiting for the element to rise to top
         * before clearing. But because the queue may also hold
         * RunnableScheduledFutures that are not ScheduledFutureTasks,
         * we are not guaranteed to have such indices available, in
         * which case we fall back to linear search. (We expect that
         * most tasks will not be decorated, and that the faster cases
         * will be much more common.)
         *
         * All heap operations must record index changes -- mainly
         * within siftUp and siftDown. Upon removal, a task's
         * heapIndex is set to -1. Note that ScheduledFutureTasks can
         * appear at most once in the queue (this need not be true for
         * other kinds of tasks or work queues), so are uniquely
         * identified by heapIndex.
         */
 
 
        /* 借助Google翻译：
        DelayedWorkQueue基于堆的数据结构，如DelayQueue和PriorityQueue中的数据结构，除了每个
        ScheduledFutureTask还将其索引记录到堆数组中。这消除了在取消时找到任务的需要，大大加快了移除（从
        O（n）到O（log n）），并减少了垃圾保留，否则通过等待元素在清除之前升至顶部而发生垃圾保留。但是因为
        队列也可能包含不是ScheduledFutureTasks的RunnableScheduledFutures，所以我们不能保证有这样的索引可
        用，在这种情况下我们会回到线性搜索。 （我们希望大多数任务都不会被装饰，而且更快的情况会更常见。）
        所有堆操作都必须记录索引更改 - 主要在siftUp和siftDown中。删除后，任务的heapIndex设置为-1。请注
        意，ScheduledFutureTasks最多可以出现在队列中一次（对于其他类型的任务或工作队列，这不一定是这样），
        因此由heapIndex唯一标识。
*/
</code></pre>
<p>DelayedWorkQueue 的类继承关系如下：</p>
<p>undefined</p>
<p>其包含的方法定义如下：</p>
<p><img src="/attachment/69de2bd87a9433f04b6ffb92e364c3bf.png" alt=""></p>
<h3 id="成员属性">成员属性</h3>
<pre><code class="language-java">// 初始时，数组长度大小。
private static final int INITIAL_CAPACITY = 16;        
// 使用数组来储存队列中的元素,根据初始容量创建RunnableScheduledFuture类型的数组
private RunnableScheduledFuture&lt;?&gt;[] queue =  new RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];        
// 使用ReentrantLock来保证多线程并发安全问题。
private final ReentrantLock lock = new ReentrantLock();        
// 队列中储存元素的大小
private int size = 0;        
// 特指队列头任务所在leader线程。也就是等待要去执行队列头任务的线程
private Thread leader = null;        
// 当队列头的任务延时时间到了，或者新线程可能需要成为leader，用来唤醒等待线程
private final Condition available = lock.newCondition();
</code></pre>
<p>DelayedWorkQueue是用数组来储存队列中的元素，数组类型为RunnableScheduledFuture，其实就类似于Runnable，只不过加了一些定时任务的属性，核心数据结构是二叉最小堆的优先队列，队列满时会自动扩容。</p>
<p>数组类型是一个接口，本质的实现还是Runnable：</p>
<pre><code class="language-java">public interface RunnableScheduledFuture&lt;V&gt; extends RunnableFuture&lt;V&gt;, ScheduledFuture&lt;V&gt; {
    // 该任务是否是周期性的
    boolean isPeriodic();
}
</code></pre>
<p>对于多线程的网络模型来说：所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>
<h3 id="构造函数-2">构造函数</h3>
<p>DelayedWorkQueue 是 ScheduledThreadPoolExecutor 的静态类部类，默认只有一个无参构造方法。</p>
<pre><code class="language-java">static class DelayedWorkQueue extends AbstractQueue&lt;Runnable&gt;
        implements BlockingQueue&lt;Runnable&gt; {
    // ...
}
</code></pre>
<h3 id="入队方法">入队方法</h3>
<pre><code class="language-java">public void put(Runnable e) {
    offer(e);
}     
   
public boolean add(Runnable e) {            
    return offer(e);
}  
 
// timeout和unit两个参数并没有用
public boolean offer(Runnable e, long timeout, TimeUnit unit) {            
    return offer(e);
}
</code></pre>
<p>DelayedWorkQueue 提供了三个插入元素方法：</p>
<ul>
<li>put(e)</li>
<li>add(e)</li>
<li>offer(e, t, u)</li>
</ul>
<p>通过源码我们发现与普通阻塞队列相比，这三个添加方法都是调用 offer 方法。那是因为它没有队列已满的条件，也就是说可以不断地向 DelayedWorkQueue 添加元素，当元素个数超过数组长度时，会进行数组扩容。</p>
<h4 id="offer添加元素">offer添加元素</h4>
<p>ScheduledThreadPoolExecutor提交任务时调用的是DelayedWorkQueue.add，而add、put等一些对外提供的添加元素的方法都调用了offer。</p>
<pre><code class="language-java">public boolean offer(Runnable x) {            
    if (x == null)                
        throw new NullPointerException();
       // 将要加入队列的任务转换为RunnableScheduledFuture类型，因为存储任务的堆数组就是这个类型
    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;) x;
    // 使用lock保证并发操作安全
    final ReentrantLock lock = this.lock;
    // 加锁
    lock.lock();            
    try {    
        // 获取当前队列中有多少个元素            
        int i = size;                
        // 如果要超过数组长度，就要进行数组扩容
        if (i &gt;= queue.length)                    
            // 数组扩容
            grow();                
        // 将队列中元素个数加一
        size = i + 1;                
        // 如果是第一个元素，那么就不需要排序，直接赋值就行了
        if (i == 0) {
            queue[0] = e;
            setIndex(e, 0);
        } else {                    
            // 调用siftUp方法，使插入的元素变得有序。
            siftUp(i, e);
        }                
        // 表示新插入的元素是队列头，那么就要唤醒正在等待获取任务的线程来获取这个队列头中的任务
        if (queue[0] == e) {
            // 准备设置新的队列头
            leader = null;                    
            // 唤醒正在等待获取任务的线程
            available.signal();
        }
    } finally {
        // 释放锁
        lock.unlock();
    }      
    // 成功入队则返回true      
    return true;
}
</code></pre>
<p>其基本流程如下：</p>
<ol>
<li>其作为生产者的入口，首先获取锁。</li>
<li>判断队列是否要满了（size &gt;= queue.length），满了就扩容grow()。</li>
<li>队列未满，size+1。</li>
<li>判断添加的元素是否是队列中的第一个元素，是则不需要堆化。</li>
<li>添加的元素不是队列中第一个元素，则需要堆化siftUp。</li>
<li>如果堆顶元素刚好是此时被添加的元素，则唤醒take线程来消费队列中的任务。</li>
<li>最终释放锁。</li>
</ol>
<p><strong>offer基本流程图如下：</strong></p>
<p><img src="/attachment/62140b4230c55ae3520ed701cc1becb8.png" alt=""></p>
<h4 id="扩容grow">扩容grow()</h4>
<p>可以看到，当队列满时，不会阻塞等待，而是继续扩容。新容量newCapacity在旧容量oldCapacity的基础上扩容50%（oldCapacity &gt;&gt; 1相当于oldCapacity /2）。最后Arrays.copyOf（将旧数组拷贝到一块新的数组空间中），Arrays.copyOf的作用就是先根据newCapacity创建一个新的空数组，然后将旧数组的数据复制到新数组中。</p>
<pre><code class="language-java">private void grow() {            
    int oldCapacity = queue.length;            
    // 每次扩容增加原来数组的一半数量。
    // grow 50%
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 
    if (newCapacity &lt; 0) // overflow
        newCapacity = Integer.MAX_VALUE;            
    // 使用Arrays.copyOf来复制一个新数组
    queue = Arrays.copyOf(queue, newCapacity);
}
</code></pre>
<h4 id="向上堆化siftUp">向上堆化siftUp</h4>
<p>新添加的元素先会加到堆底，然后一步步和上面的父亲节点比较，若小于父亲节点则和父亲节点互换位置，循环比较直至大于父亲节点才结束循环。通过循环，来查找元素key应该插入在堆二叉树哪个节点位置，并交互父节点的位置。</p>
<pre><code class="language-java">private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) {            
    // 当k==0时，就到了堆二叉树的根节点了，跳出循环
    while (k &gt; 0) {                
        // 父节点位置坐标, 相当于(k - 1) / 2
        int parent = (k - 1) &gt;&gt;&gt; 1;                
        // 获取父节点位置元素
        RunnableScheduledFuture&lt;?&gt; e = queue[parent];                
        // 如果key元素大于父节点位置元素，满足条件，那么跳出循环
        // 因为是从小到大排序的。
        if (key.compareTo(e) &gt;= 0)                    
            break;                
        // 否则就将父节点元素存放到k位置
        queue[k] = e;                
        // 这个只有当元素是ScheduledFutureTask对象实例才有用，用来快速取消任务。
        setIndex(e, k);                
        // 重新赋值k，寻找元素key应该插入到堆二叉树的那个节点
        k = parent;
    }            
    // 循环结束，k就是元素key应该插入的节点位置
    queue[k] = key;
    // 将key插入到k位置
    setIndex(key, k);
}
</code></pre>
<p>代码很好理解，就是循环的根据key节点与它的父节点来判断，如果key节点的执行时间早于父节点，则将两个节点交换，使执行时间靠前的节点排列在队列的前面。</p>
<p>可见，每次新增节点时，只是根据父节点来判断，而不会影响兄弟节点。</p>
<h3 id="出队方法">出队方法</h3>
<p>DelayedWorkQueue 提供了以下几个出队方法</p>
<ul>
<li>take()，等待获取队列头元素</li>
<li>poll() ，立即获取队列头元素</li>
<li>poll(long timeout, TimeUnit unit) ，超时等待获取队列头元素</li>
</ul>
<h4 id="take-消费元素">take() 消费元素</h4>
<p>Worker工作线程启动后就会循环消费工作队列中的元素，因为ScheduledThreadPoolExecutor的keepAliveTime=0，所以消费任务其只调用了DelayedWorkQueue.take。take()方法的基本流程如下：</p>
<ol>
<li>首先获取可中断锁，判断堆顶元素是否是空，空的则阻塞等待available.await()。</li>
<li>堆顶元素不为空，则获取其延迟执行时间delay，delay &lt;= 0说明到了执行时间，出队列finishPoll()。</li>
<li>delay &gt; 0还没到执行时间，判断leader线程是否为空，不为空则说明有其他take线程也在等待，当前take线程将无限期阻塞等待。</li>
<li>leader线程为空，当前take线程设置为leader，并阻塞等待delay时长。</li>
<li>当前leader线程等待delay时长自动唤醒或者被其他take线程唤醒，则最终将leader设置为null。</li>
<li>再循环一次判断delay &lt;= 0出队列。</li>
<li>跳出循环后判断leader为空并且堆顶元素不为空，则唤醒其他take线程，最后是否锁。</li>
</ol>
<pre><code class="language-java">public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException {            
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();            
    try {  
        // 自旋，只有任务到了要执行的时间才将任务出队返回              
        for (;;) {
            RunnableScheduledFuture&lt;?&gt; first = queue[0];                    
            // 如果没有任务，就让线程在available条件下等待。
            if (first == null)
                available.await();                    
            else {                        
                // 获取任务的剩余延时时间
                long delay = first.getDelay(NANOSECONDS);                        
                // 如果延时时间到了，就返回这个任务，用来执行。
                if (delay &lt;= 0)                            
                    return finishPoll(first);                        
                // 如果任务还没有到时间，则将first设置为null，当线程等待时，不持有first的引用
                first = null; // don't retain ref while waiting
           
                              // 如果前面有线程在等待，当前线程直接进入等待状态
                if (leader != null)
                    // 条件锁
                    available.await();      
                // 如果前面没有有线程在等待
                else {                            
                    // 记录一下当前等待队列头任务的线程
                    Thread thisThread = Thread.currentThread();
					   // 将当前线程作为leader
                    leader = thisThread;                            
                    try {                                
                        // 当任务的延时时间到了时，能够自动超时唤醒。
                        available.awaitNanos(delay);
                    } finally {                        
                                            // 唤醒后再次获得锁后把leader再置空     
                        if (leader == thisThread)
                            leader = null;
                    }
                }
            }
        }
    } finally {  
        // 唤醒等待任务的线程              
        if (leader == null &amp;&amp; queue[0] != null)                    
            available.signal();
        ock.unlock();
    }
}
</code></pre>
<p><strong>take基本流程图如下：</strong></p>
<p><img src="/attachment/4ec69962afbe8dc1945545829fc776da.png" alt=""></p>
<p>take线程阻塞等待：</p>
<p>可以看出这个生产者take线程会在两种情况下阻塞等待：</p>
<ul>
<li>堆顶元素为空。</li>
<li>堆顶元素的delay &gt; 0 。</li>
</ul>
<p><strong>take方法是什么时候调用的呢？</strong></p>
<p>在ThreadPoolExecutor中，getTask方法，工作线程会循环地从workQueue中取任务。但定时任务却不同，因为如果一旦getTask方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在take方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p>
<p><strong>leader线程</strong></p>
<p>再来说一下leader的作用，这里的leader是为了减少不必要的定时等待。leader线程的设计，是Leader-Follower模式的变种，旨在于为了不必要的时间等待。当一个take线程变成leader线程（可以最先拿到队列中弹出任务去执行的线程）时，只需要等待下一次的延迟时间，而不是leader线程的其他take线程则需要等leader线程拿到队列中任务后，才唤醒其他take线程，其他的take线程唤醒后再去争抢锁，谁抢到锁了，谁就是新的leader线程。</p>
<p>举例来说，如果没有leader，那么在执行take时，所有的线程都要执行available.awaitNanos(delay)，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。多个线程执行该段代码是没有作用的，因为只能有一个线程会从take中返回queue[0]（因为有lock），其他线程这时再返回for循环执行时取的queue[0]，已经不是之前的queue[0]了，然后又要继续阻塞。</p>
<p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在finally中调用了signal()来唤醒一个线程，而不是signalAll()）。也就是说我们保证只会有一个线程在等待队列中的任务出队即可，其他的线程直接全部阻塞，当第一个线程成功获取到队列中的任务后再去唤醒其他的线程，来成为新的leader线程。</p>
<h4 id="finishPoll-出队列">finishPoll() 出队列</h4>
<p>堆顶元素delay&lt;=0，执行时间到，出队列就是一个向下堆化的过程siftDown。</p>
<pre><code class="language-java">// 移除队列头元素
private RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) {            
    // 将队列中元素个数减一
    int s = --size;            
    // 获取队列末尾元素x
    RunnableScheduledFuture&lt;?&gt; x = queue[s];            
    // 原队列末尾元素设置为null
    queue[s] = null;            
    if (s != 0)                
        // 因为移除了队列头元素，所以进行重新排序。
        siftDown(0, x);
    setIndex(f, -1);            
    return f;
}
</code></pre>
<p>堆的删除方法主要分为三步：</p>
<ol>
<li>先将队列中元素个数减一；</li>
<li>将原队列末尾元素设置成为队列头元素，再将队列末尾元素设置为null；</li>
<li>调用setDown(O,x)方法，保证按照元素的优先级排序。</li>
</ol>
<h4 id="向下堆化siftDown">向下堆化siftDown</h4>
<p>由于堆顶元素出队列后，就破坏了堆的结构，需要组织整理下，将堆尾元素移到堆顶，然后向下堆化：</p>
<ol>
<li>从堆顶开始，父亲节点与左右子节点中较小的孩子节点比较（左孩子不一定小于右孩子）。</li>
<li>父亲节点小于等于较小孩子节点，则结束循环，不需要交换位置。</li>
<li>若父亲节点大于较小孩子节点，则交换位置。</li>
<li>继续向下循环判断父亲节点和孩子节点的关系，直到父亲节点小于等于较小孩子节点才结束循环。</li>
</ol>
<pre><code class="language-java">private void siftDown(int k, RunnableScheduledFuture&lt;?&gt; key) {     
    // 无符号右移，相当于size/2
    int half = size &gt;&gt;&gt; 1;            
    // 通过循环，保证父节点的值不能大于子节点。
    while (k &lt; half) {                
        // 左子节点, 相当于 (k * 2) + 1
        int child = (k &lt;&lt; 1) + 1;                
        // 左子节点位置元素
        RunnableScheduledFuture&lt;?&gt; c = queue[child];                
        // 右子节点, 相当于 (k * 2) + 2
        int right = child + 1;                
        // 如果左子节点元素值大于右子节点元素值，那么右子节点才是较小值的子节点。
        // 就要将c与child值重新赋值
        if (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; 0)
            c = queue[child = right];                
        // 如果父节点元素值小于较小的子节点元素值，那么就跳出循环
        if (key.compareTo(c) &lt;= 0)                    
            break;                
        // 否则，父节点元素就要和子节点进行交换
        queue[k] = c;
        setIndex(c, k);
        k = child;
    }            
    queue[k] = key;
    setIndex(key, k);
}
</code></pre>
<p>siftDown方法执行时包含两种情况，一种是没有子节点，一种是有子节点（根据half判断）。</p>
<h4 id="poll">poll()</h4>
<p>立即获取队列头元素，当队列头任务是null，或者任务延时时间没有到，表示这个任务还不能返回，因此直接返回null。否则调用finishPoll方法，移除队列头元素并返回。</p>
<pre><code class="language-java">public RunnableScheduledFuture&lt;?&gt; poll() {            
    final ReentrantLock lock = this.lock;
    lock.lock();            
    try {
        RunnableScheduledFuture&lt;?&gt; first = queue[0];                
        // 队列头任务是null，或者任务延时时间没有到，都返回null
        if (first == null || first.getDelay(NANOSECONDS) &gt; 0)                    
            return null;                
        else
            // 移除队列头元素
            return finishPoll(first);
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h4 id="poll-long-timeout-TimeUnit-unit">poll(long timeout, TimeUnit unit)</h4>
<p>超时等待获取队列头元素，与take方法相比较，就要考虑设置的超时时间，如果超时时间到了，还没有获取到有用任务，那么就返回null。其他的与take方法中逻辑一样。</p>
<pre><code class="language-java">public RunnableScheduledFuture&lt;?&gt; poll(long timeout, TimeUnit unit)            
    throws InterruptedException {            
    long nanos = unit.toNanos(timeout);            
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();            
    try {                
        for (;;) {
            RunnableScheduledFuture&lt;?&gt; first = queue[0];                    
            // 如果没有任务。
            if (first == null) {                        
                // 超时时间已到，那么就直接返回null
                if (nanos &lt;= 0)                            
                    return null;                        
                else
                    // 否则就让线程在available条件下等待nanos时间
                    nanos = available.awaitNanos(nanos);
            } else {                        
                // 获取任务的剩余延时时间
                long delay = first.getDelay(NANOSECONDS);                        
                // 如果延时时间到了，就返回这个任务，用来执行。
                if (delay &lt;= 0)                            
                    return finishPoll(first);                        
                // 如果超时时间已到，那么就直接返回null
                if (nanos &lt;= 0)                            
                    return null;                        
                // 将first设置为null，当线程等待时，不持有first的引用
                first = null; // don't retain ref while waiting
                // 如果超时时间小于任务的剩余延时时间，那么就有可能获取不到任务。
                // 在这里让线程等待超时时间nanos
                if (nanos &lt; delay || leader != null)
                    nanos = available.awaitNanos(nanos);                        
                else {
                    Thread thisThread = Thread.currentThread();
                    leader = thisThread;                            
                    try {                                
                        // 当任务的延时时间到了时，能够自动超时唤醒。
                        long timeLeft = available.awaitNanos(delay);                                
                        // 计算剩余的超时时间
                        nanos -= delay - timeLeft;
                    } finally {                                
                        if (leader == thisThread)
                            leader = null;
                    }
                }
            }
        }
    } finally {                
        if (leader == null &amp;&amp; queue[0] != null)                    
            // 唤醒等待任务的线程
            available.signal();
        lock.unlock();
    }
}
</code></pre>
<h4 id="remove-删除指定元素">remove() 删除指定元素</h4>
<p>删除指定元素一般用于取消任务时，任务还在阻塞队列中，则需要将其删除。当删除的元素不是堆尾元素时，需要做堆化处理。</p>
<pre><code class="language-java">public boolean remove(Object x) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        int i = indexOf(x);
        if (i &lt; 0)
            return false;
        //维护heapIndex
        setIndex(queue[i], -1);
        int s = --size;
        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];
        queue[s] = null;
        if (s != i) {
            //删除的不是堆尾元素，则需要堆化处理
            //先向下堆化
            siftDown(i, replacement);
            if (queue[i] == replacement)
                //若向下堆化后，i位置的元素还是replacement，说明四无需向下堆化的，
                //则需要向上堆化
                siftUp(i, replacement);
        }
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h2 id="总结-13">总结</h2>
<p>使用优先级队列DelayedWorkQueue，保证添加到队列中的任务，会按照任务的延时时间进行排序，延时时间少的任务首先被获取。</p>
<ol>
<li>DelayedWorkQueue的数据结构是基于堆实现的；</li>
<li>DelayedWorkQueue采用数组实现堆，根节点出队，用最后叶子节点替换，然后下推至满足堆成立条件；最后叶子节点入队，然后向上推至满足堆成立条件；</li>
<li>DelayedWorkQueue添加元素满了之后会自动扩容原来容量的1/2，即永远不会阻塞，最大扩容可达Integer.MAX_VALUE，所以线程池中至多有corePoolSize个工作线程正在运行；</li>
<li>DelayedWorkQueue 消费元素take，在堆顶元素为空和delay &gt;0 时，阻塞等待；</li>
<li>DelayedWorkQueue 是一个生产永远不会阻塞，消费可以阻塞的生产者消费者模式；</li>
<li>DelayedWorkQueue 有一个leader线程的变量，是Leader-Follower模式的变种。当一个take线程变成leader线程时，只需要等待下一次的延迟时间，而不是leader线程的其他take线程则需要等leader线程出队列了才唤醒其他take线程。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/yu627482453">Bill Cipher</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-zu-sai-dui-lie-delayedworkqueue/">https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-zu-sai-dui-lie-delayedworkqueue/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yu627482453.github.io" target="_blank">蝶梦庄生</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%A1%8C%E5%8A%A8%E9%98%B6%E6%AE%B5-%E5%AE%8C%E6%88%90/">行动阶段/完成</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0%E7%A9%BA%E9%97%B4-KnowladgeSpace-ProgramSpace-BasicsSpace/">笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace</a><a class="post-meta__tags" href="/tags/%E7%BB%86%E5%8C%96%E4%B8%BB%E9%A2%98-Java/">细化主题/Java</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E9%A2%98%E5%9C%BA%E6%99%AF-%E7%A8%8B%E5%BA%8F/">主题场景/程序</a></div><div class="post_share"><div class="social-share" data-image="https://api.yimian.xyz/img?type=moe" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/database/redis/redis-shu-ju-jie-gou-yu-dui-xiang/redis-shu-ju-jie-gou-yu-dui-xiang/"><img class="prev-cover" src="https://api.yimian.xyz/img?type=moe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Redis】 Redis 数据结构与对象</div></div></a></div><div class="next-post pull-right"><a href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-threadpoolexecutor/"><img class="next-cover" src="https://api.yimian.xyz/img?type=moe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Java 多线程并发】 ThreadPoolExecutor</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/java/java-web/java-web/" title="Java Web"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">Java Web</div></div></a></div><div><a href="/java/java-web/java-filter/" title="【Java】 Filter"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Filter</div></div></a></div><div><a href="/java/java-web/java-listener/" title="【Java】 Listener"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Listener</div></div></a></div><div><a href="/java/java-web/java-servlet/" title="【Java】 Servlet"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Servlet</div></div></a></div><div><a href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-jvm-yu-java-ti-xi-jie-gou/" title="【Java JVM】 JVM与Java体系结构"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="title">【Java JVM】 JVM与Java体系结构</div></div></a></div><div><a href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-10</div><div class="title">【Java JVM】 直接内存</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Bill Cipher</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">215</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yu627482453"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yu627482453" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/627482453@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">【Java 多线程并发】 阻塞队列DelayedWorkQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Metadata-142"><span class="toc-number">1.1.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-4"><span class="toc-number">1.2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ScheduledThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.</span> <span class="toc-text">ScheduledThreadPoolExecutor线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DelayedWorkQueue%E5%BB%B6%E8%BF%9F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">DelayedWorkQueue延迟阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4"><span class="toc-number">1.6.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">成员属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-2"><span class="toc-number">1.6.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%98%9F%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">入队方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#offer%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">offer添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9grow"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">扩容grow()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E5%A0%86%E5%8C%96siftUp"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">向上堆化siftUp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E9%98%9F%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.</span> <span class="toc-text">出队方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#take-%E6%B6%88%E8%B4%B9%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">take() 消费元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finishPoll-%E5%87%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">finishPoll() 出队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E5%A0%86%E5%8C%96siftDown"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">向下堆化siftDown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">poll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll-long-timeout-TimeUnit-unit"><span class="toc-number">1.6.5.5.</span> <span class="toc-text">poll(long timeout, TimeUnit unit)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove-%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.5.6.</span> <span class="toc-text">remove() 删除指定元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/design/she-ji-mo-shi/" title="无题"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/design/she-ji-mo-shi/" title="无题">无题</a><time datetime="2023-07-15T09:13:39.871Z" title="发表于 2023-07-15 17:13:39">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java 多线程并发】 线程"/></a><div class="content"><a class="title" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程">【Java 多线程并发】 线程</a><time datetime="2023-07-10T06:15:00.000Z" title="发表于 2023-07-10 14:15:00">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java JVM】 直接内存"/></a><div class="content"><a class="title" href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存">【Java JVM】 直接内存</a><time datetime="2023-07-10T00:00:00.000Z" title="发表于 2023-07-10 08:00:00">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/" title="【Redis】 排序"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Redis】 排序"/></a><div class="content"><a class="title" href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/" title="【Redis】 排序">【Redis】 排序</a><time datetime="2023-07-09T06:07:00.000Z" title="发表于 2023-07-09 14:07:00">2023-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/" title="【Redis】 Lua脚本"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Redis】 Lua脚本"/></a><div class="content"><a class="title" href="/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/" title="【Redis】 Lua脚本">【Redis】 Lua脚本</a><time datetime="2023-07-09T05:56:00.000Z" title="发表于 2023-07-09 13:56:00">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Bill Cipher</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c61a274b6f5aa26a58f6',
      clientSecret: '485a7761d321c8dcc5cae05d7256be9fb196d94a',
      repo: 'yu627482453.github.io',
      owner: 'yu627482453',
      admin: ['yu627482453'],
      id: '6d3f03dc4b912cfeb86ab4f7ac871e0f',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>