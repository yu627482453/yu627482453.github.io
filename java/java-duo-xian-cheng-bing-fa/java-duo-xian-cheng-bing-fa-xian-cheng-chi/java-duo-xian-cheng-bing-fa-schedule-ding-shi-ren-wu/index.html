<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【Java 多线程并发】 Schedule 定时任务 | 蝶梦庄生</title><meta name="keywords" content="Java"><meta name="author" content="Bill Cipher"><meta name="copyright" content="Bill Cipher"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【Java 多线程并发】 Schedule 定时任务">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java 多线程并发】 Schedule 定时任务">
<meta property="og:url" content="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-schedule-ding-shi-ren-wu/index.html">
<meta property="og:site_name" content="蝶梦庄生">
<meta property="og:description" content="【Java 多线程并发】 Schedule 定时任务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.seovx.com/?mom=302">
<meta property="article:published_time" content="2023-07-05T04:01:00.000Z">
<meta property="article:modified_time" content="2023-07-05T04:01:00.000Z">
<meta property="article:author" content="Bill Cipher">
<meta property="article:tag" content="行动阶段&#x2F;完成">
<meta property="article:tag" content="笔记空间&#x2F;KnowladgeSpace&#x2F;ProgramSpace&#x2F;BasicsSpace">
<meta property="article:tag" content="细化主题&#x2F;Java">
<meta property="article:tag" content="主题场景&#x2F;程序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.seovx.com/?mom=302"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-schedule-ding-shi-ren-wu/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bill Cipher","link":"链接: ","source":"来源: 蝶梦庄生","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Java 多线程并发】 Schedule 定时任务',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-05 12:01:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">240</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.seovx.com/?mom=302')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">蝶梦庄生</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Java 多线程并发】 Schedule 定时任务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-05T04:01:00.000Z" title="发表于 2023-07-05 12:01:00">2023-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-05T04:01:00.000Z" title="更新于 2023-07-05 12:01:00">2023-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Java 多线程并发】 Schedule 定时任务"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>【Java 多线程并发】 Schedule 定时任务</h1>
<h2 id="Metadata-76">Metadata</h2>
<pre><code class="language-yml">title: 【Java 多线程并发】 Schedule 定时任务
date: 2023-07-05 12:01
tags:
  - 行动阶段/完成
  - 主题场景/程序
  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace
  - 细化主题/Java
categories:
  - Java
keywords:
  - Java
description: 【Java 多线程并发】 Schedule 定时任务
</code></pre>
<h2 id="简介-5">简介</h2>
<p>在实现定时调度功能的时候，我们往往会借助于第三方类库来完成，比如：quartz、Spring Schedule等等。JDK从1.3版本开始，就提供了基于Timer的定时调度功能。在Timer中，任务的执行是串行的。这种特性在保证了线程安全的情况下，往往带来了一些严重的副作用，比如任务间相互影响、任务执行效率低下等问题。为了解决Timer的这些问题，JDK从1.5版本开始，提供了基于ScheduledExecutorService的定时调度功能。</p>
<p>虽然Java的定时调度可以通过Timer&amp;TimerTask来实现。但是由于其实现的方式为单线程，因此从JDK1.3发布之后就一直存在一些问题，大致如下：</p>
<ul>
<li>多个任务之间会相互影响</li>
<li>多个任务的执行是串行的，性能较低</li>
</ul>
<p>ScheduledExecutorService在设计之初就是为了解决Timer&amp;TimerTask的这些问题。因为天生就是基于多线程机制，所以任务之间不会相互影响（只要线程数足够。当线程数不足时，有些任务会复用同一个线程）。</p>
<p>除此之外，因为其内部使用的延迟队列，本身就是基于等待/唤醒机制实现的，所以CPU并不会一直繁忙。同时，多线程带来的CPU资源复用也能极大地提升性能。</p>
<h3 id="ScheduledExecutorService-和-Timer-的区别">ScheduledExecutorService 和 Timer 的区别</h3>
<ul>
<li>Timer 对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；</li>
<li>Timer 内部只有一个执行线程，因此长时间运行的任务会延迟其他任务，而且如果有多个任务的话就会顺序执行，这样我们的延迟时间和循环时间就会出现问题。 ScheduledThreadPoolExecutor 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程。所以在多线程环境下对延迟任务和循环任务要求严格的时候，就需要考虑使用ScheduledExecutorService了;</li>
<li>在TimerTask 中抛出的运行时异常会杀死一个线程，从而导致 Timer 死机，即计划任务将不再运行。ScheduledThreadExecutor 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 afterExecute 方法ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。</li>
</ul>
<p>综上，在 JDK1.5 之后，你没有理由再使用 Timer 进行任务调度了。当然，在实际项目中基本也不会用到ScheduledThreadPoolExecutor，所以对这部分大家只需要简单了解一下它的思想。</p>
<p>备注： Quartz 是一个由 Java 编写的任务调度库，由 OpenSymphony 组织开源出来。在实际项目开发中使用 Quartz 的还是居多，比较推荐使用 Quartz。因为 Quartz 理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等等。</p>
<h2 id="什么是ScheduledExecutorService？">什么是ScheduledExecutorService？</h2>
<p>ScheduledExecutorService接口是<mark style="background: #FFB8EBA6;">基于ExecutorService</mark>的功能实现的延迟和周期执行任务的功能。每个任务以及每个任务的每个周期都会提交到线程池中由线程去执行，所以任务在不同周期内执行它的线程可能是不同的。ScheduledExecutorService接口的默认实现类是ScheduledThreadPoolExecutor。在周期执行的任务中，如果任务执行时间大于周期时间，则会以任务时间优先，等任务执行完毕后才会进入下一次周期</p>
<p>ScheduledExecutorService接口中定义了一些方法：</p>
<pre><code class="language-java">public interface ScheduledExecutorService extends ExecutorService {
    // 在指定延时后执行一次
    public ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                       long delay, TimeUnit unit);
 
    // 在指定延时后执行一次
    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,
                                           long delay, TimeUnit unit);
                                           
    // 在指定延时后开始执行，并在之后以指定时间间隔重复执行（间隔不包含任务执行的时间）
    // 相当于之后的延时以任务开始计算
    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);
 
    // 在指定延时后开始执行，并在之后以指定延时重复执行（间隔包含任务执行的时间）
    // 相当于之后的延时以任务结束计算
    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);
}
</code></pre>
<h2 id="ScheduledThreadPoolExecutor中的方法">ScheduledThreadPoolExecutor中的方法</h2>
<p>之前我们讲的ThreadPoolExecutor是java的普通线程池。而ScheduledThreadPoolExecutor是java提供的定时任务线程池。</p>
<p>因为ScheduledThreadPoolExecutor类继承了ThreadPoolExecutor类，所以有很多方法都是来自ThreadPoolExecutor类，其本身是支持线程池的所有功能，它自己还额外提供了一些关于延迟执行和定时任务的方法。我们常用的有如下几种：</p>
<pre><code class="language-java">/**
 * 带延迟时间的调度，只执行一次
 * 调度之后可通过Future.get()阻塞直至任务执行完毕
 */
1. public ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                      long delay, TimeUnit unit);
/**
 * 带延迟时间的调度，只执行一次
 * 调度之后可通过Future.get()阻塞直至任务执行完毕，并且可以获取执行结果
 */
2. public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,
                                          long delay, TimeUnit unit);
/**
 * 带延迟时间的调度，循环执行，固定频率
 */
3. public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                 long initialDelay,
                                                 long period,
                                                 TimeUnit unit);
/**
 * 带延迟时间的调度，循环执行，固定延迟
 */
4. public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                    long initialDelay,
                                                    long delay,
                                                    TimeUnit unit);
 
</code></pre>
<h3 id="构造方法-3">构造方法</h3>
<pre><code class="language-java">ScheduledThreadPoolExecutor(int corePoolSize)
ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)
ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)
ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)
</code></pre>
<ul>
<li>corePoolSize：线程池核心线程数</li>
<li>threadFactory：线程工厂</li>
<li>handler：任务拒绝策略</li>
</ul>
<p>构造一个Schedule线程池，最大线程数为Integer的最大值，线程的空闲时间为0，队列采用的是DelayedWorkQueue。</p>
<h3 id="schedule方法">schedule方法</h3>
<pre><code class="language-java">// 延迟执行无返回值单个任务，该方法返回ScheduledFuture，就可以理解普通线程池中返回的Future
ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)
// 延迟执行有返回值单个任务，该方法返回ScheduledFuture
&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)
</code></pre>
<ul>
<li>command：要延迟执行的任务（Runnable / Callable）</li>
<li>delay：延时的时间</li>
<li>unit：时间单位</li>
</ul>
<p>延时delay时长执行Runnable或者Callable任务，只会执行一次。执行Runnable任务时是没有结果返回的，那为什么还会返回ScheduledFuture，因为我们可以通过Future做一些取消任务等操作。该方法会使任务在delay时间之后去执行。</p>
<p>调度之后还可以通过Future.get()阻塞直至任务执行完毕。</p>
<h3 id="scheduleAtFixedRate方法">scheduleAtFixedRate方法</h3>
<pre><code class="language-java">ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)

</code></pre>
<ul>
<li>command：Runnable任务</li>
<li>initialDelay：任务首次执行前的延迟时间</li>
<li>period：周期时间</li>
<li>unit：时间单位</li>
</ul>
<p>固定周期性执行任务，当任务的执行时长大于周期，那么下一个周期任务将在上一个执行完毕之后马上执行。</p>
<p><strong>作用：</strong> 指定的延迟时间（ initialDelay）调度第一次，后续以 period为一个时间周期进行调度，该方法并不 care 每次任务执行的耗时，如果某次耗时超过调度周期（period），则下一次调度从上一次任务结束时开始，然后接着按照period的间隔严格执行任务。</p>
<p>也就是说这个方法会严格按照周期间隔去执行，并不会管任务的执行时间。</p>
<p>任务的第一次会在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。意思是下一次执行任务的时间与任务执行过程花费的时间无关，只与period有关！</p>
<p>如果此任务的任何一个执行要花费比其周期更长的时间，则将推迟后续执行，但不会同时执行。</p>
<p>如果任务的任何一个执行遇到异常，则后续执行都会被取消。否则，只能通过执行程序的取消或终止方法来终止该任务。</p>
<h3 id="scheduleWithFixedDelay方法">scheduleWithFixedDelay方法</h3>
<pre><code class="language-java">ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)

</code></pre>
<ul>
<li>command：Runnable任务</li>
<li>initialDelay：任务首次执行前的延迟时间</li>
<li>delay：延时时间</li>
<li>unit：时间单位</li>
</ul>
<p>固定延时执行任务，也是周期性任务，和scheduleAtFixedRate不同的是：scheduleAtFixedRate当任务执行时间小于周期时间时，此时周期时间到了的时候会进入下一周期，这一点和scheduleWithFixedDelay是没有区别的；但是如果任务执行时间大于周期时间时，scheduleAtFixedRate的任务结束后会立即进入下一周期；而scheduleWithFixedDelay是无论你任务时间是否超过，都将会在你任务执行完毕后延迟固定时间（delay），才会进入下一周期。</p>
<p><strong>作用</strong>：在指定的延迟时间（ delay）调度第一次，后续以 period 为一个时间周期进行调度，该方法非常 care 上一次任务执行的耗时，如果某次耗时超过调度周期（period），则下一次调度时间为 上一次任务结束时间 + 调度周期时间</p>
<p>也就是说使用scheduleWithFixedDelay可以实现在每一次执行终止和下一次执行开始之间都存在给定的延迟（delay）。</p>
<h3 id="setContinueExistingPeriodicTasksAfterShutdownPolicy方法">setContinueExistingPeriodicTasksAfterShutdownPolicy方法</h3>
<pre><code class="language-java">void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)
</code></pre>
<p>默认为false。在线程池执行shutdown方法后是否继续执行scheduleAtFixedRate方法和scheduleWithFixedDelay方法提交的任务</p>
<h3 id="setExecuteExistingDelayedTasksAfterShutdownPolicy方法">setExecuteExistingDelayedTasksAfterShutdownPolicy方法</h3>
<pre><code class="language-java">void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)
</code></pre>
<p>默认为true，在线程池执行shutdown方法后，需要等待当前正在等待的任务的和正在运行的任务被执行完，然后进程被销毁。为false时，表示放弃等待的任务，正在运行的任务一旦完成，则进程被销毁。</p>
<h3 id="scheduleAtFixedRate和scheduleWithFixedDelay的区别">scheduleAtFixedRate和scheduleWithFixedDelay的区别</h3>
<p>直白地讲，scheduleAtFixedRate()为固定频率，scheduleWithFixedDelay()为固定延迟。固定频率是相对于任务执行的开始时间，而固定延迟是相对于任务执行的结束时间，这就是他们最根本的区别！</p>
<h2 id="练习">练习</h2>
<h3 id="schedule练习1">schedule练习1</h3>
<pre><code class="language-java">import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
 
public class ScheduledExecutorServiceExample {
    public static void main(String[] args) {
        // 创建定时任务线程池,核心线程数为2
        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);
        // 2秒后执行Runnable任务
        scheduledThreadPoolExecutor.schedule(() -&gt; {
            System.out.println("This is runable1 task");
        }, 2, TimeUnit.SECONDS);
        // 再提交一个2秒后才执行的Runnable任务
        // 既然Runnable无法返回结果,为什么还要有Future呢,因为我们可以通过Future进行取消任务等操作
        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.schedule(() -&gt; {
            System.out.println("This is runable2 task");
        }, 2, TimeUnit.SECONDS);
        // 取消任务
        runnableFuture.cancel(true);
        // 休眠3秒,确保上面的任务都被执行完
        mySleep(3);
        System.out.println("========================");
    }
 
    private static void mySleep(int seconds){
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code class="language-console">This is runable1 task
========================

</code></pre>
<h3 id="schedule练习2">schedule练习2</h3>
<pre><code class="language-java">@Test public void test_schedule4Runnable() throws Exception {
    // 创建定时任务线程池
    ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
    // 延迟执行任务
    ScheduledFuture future = service.schedule(() -&gt; {
        try {
            Thread.sleep(3000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("task finish time: " + format(System.currentTimeMillis()));
    }, 1000, TimeUnit.MILLISECONDS);
    System.out.println("schedule finish time: " + format(System.currentTimeMillis()));
    // 通过get方法阻塞当前线程，直到任务执行完毕
    System.out.println("Runnable future's result is: " + future.get() +
                       ", and time is: " + format(System.currentTimeMillis()));
}
</code></pre>
<p>上述代码达到的效果应该是这样的：延迟执行时间为1秒，任务执行3秒，任务只执行一次，同时通过Future.get()阻塞直至任务执行完毕。</p>
<p>我们运行看到的效果的确和我们猜想的一样，如下图所示。</p>
<p><img src="/attachment/7273a2feead5dcb70704b043b7e231ea.png" alt=""></p>
<p>在schedule Runnable的基础上，我们将Runnable改为Callable来看一下。</p>
<pre><code class="language-java">@Test public void test_schedule4Callable() throws Exception {
    // 创建定时任务线程池
    ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
    // 提交一个带返回值的Callable任务，延迟1秒执行
    ScheduledFuture&lt;String&gt; future = service.schedule(() -&gt; {
        try {
            Thread.sleep(3000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("task finish time: " + format(System.currentTimeMillis()));
        return "success";
    }, 1000, TimeUnit.MILLISECONDS);
    System.out.println("schedule finish time: " + format(System.currentTimeMillis()));
    // 通过future.get()方法获取任务执行结果，如果任务还没执行完，则会阻塞等待
    System.out.println("Callable future's result is: " + future.get() +
            ", and time is: " + format(System.currentTimeMillis()));
}
</code></pre>
<p>运行看到的结果和Runnable基本相同，唯一的区别在于future.get()能拿到Callable返回的真实结果。</p>
<p><img src="/attachment/77dc7be74d95175ed0b84379f410d585.png" alt=""></p>
<h3 id="scheduleAtFixedRate练习1">scheduleAtFixedRate练习1</h3>
<p>周期性执行某个任务，执行到一定时间后取消任务</p>
<pre><code class="language-java">import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
public class ScheduledExecutorServiceExample2 {
    public static void main(String[] args) {
        // 创建定时任务线程池
        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);
        // 提交延迟1秒执行,周期为2秒的runnable任务,虽然Runnable没有返回结果,但是可以通过runnableFuture取消任务
        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; {
            System.out.println("This is runable task running "+Thread.currentThread().getName());
        }, 1,2, TimeUnit.SECONDS);
        // 休眠8秒
        mySleep(8);
        // 取消该循坏任务
        runnableFuture.cancel(true);
    }
    
    private static void mySleep(int seconds){
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p>可以看出每个周期执行的任务并不是同一个线程，周期时间到的时候只是将任务扔到线程池的任务队列中由空闲线程获取它的执行权。</p>
<pre><code class="language-console">This is runable task running pool-1-thread-1
This is runable task running pool-1-thread-1
This is runable task running pool-1-thread-1
This is runable task running pool-1-thread-2
</code></pre>
<h3 id="scheduleAtFixedRate练习2">scheduleAtFixedRate练习2</h3>
<p>超时的周期性任务</p>
<pre><code class="language-java">import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
public class ScheduledExecutorServiceExample3 {
    public static void main(String[] args) {
        // 创建定时任务线程池
        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);
        // 创建一个原子计数器
        AtomicLong atomicLong = new AtomicLong(0L);
        // 提交初始延迟1秒执行,固定周期为2秒的Runnable任务
        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; {
            // 记录当前时间
            Long current = System.currentTimeMillis();
            // 判断是否为第一次运行
            if (atomicLong.get()==0) {
                atomicLong.set(current);
                System.out.printf("first running [%d]\n",atomicLong.get());
            } else {
                // 记录与上次的间隔时间
                System.out.printf("running time:[%d]\n",current-atomicLong.get());
            }
            // 将当前时间保存
            atomicLong.set(current);
            // 模拟超过固定周期时间，故意让任务晚结束，导致超过本轮周期时长了
            mySleep(5);
        }, 1,2, TimeUnit.SECONDS);
    }
    private static void mySleep(int seconds){
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p>可以看出，超出周期时间时，任务完成后立即就进入了下一周期</p>
<pre><code class="language-console">first running [1597659726690]
running time:[5042]
running time:[5001]
running time:[5000]
running time:[5001]
</code></pre>
<h3 id="scheduleWithFixedDelay练习">scheduleWithFixedDelay练习</h3>
<pre><code class="language-java">import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
 
public class ScheduledExecutorServiceExample4 {
    public static void main(String[] args) {
        // 创建定时任务线程池
        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);
        // 创建原子计数器
        AtomicLong atomicLong = new AtomicLong(0L);
        // 提交初始延迟1秒执行,延迟为2秒的runnable任务
        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; {
            // 记录当前时间
            Long current = System.currentTimeMillis();
            // 判断是否为第一次运行
            if (atomicLong.get() == 0){
                atomicLong.set(current);
                System.out.printf("first running [%d]\n",atomicLong.get());
            }else{
                //记录与上次的间隔时间
                System.out.printf("running time:[%d]\n",current-atomicLong.get());
            }
            // 将当前时间保存
            atomicLong.set(current);
            // 模拟超过固定周期时间   使其运行时间超过周期时间
            mySleep(5);
        }, 1,2, TimeUnit.SECONDS);
    }
    private static void mySleep(int seconds){
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p>可以看出来，无论你的任务执行多久，在任务执行完毕之后都会延迟一个调度周期时间才进入下一周期。</p>
<pre><code class="language-console">first running [1597659862349]
running time:[7047]
running time:[7002]
running time:[7023]
running time:[7002]
running time:[7003]
</code></pre>
<h3 id="setContinueExistingPeriodicTasksAfterShutdownPolicy练习">setContinueExistingPeriodicTasksAfterShutdownPolicy练习</h3>
<pre><code class="language-java">import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
public class ScheduledExecutorServiceExample5 {
    public static void main(String[] args) {
        // 创建定时任务线程池
        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(2);
        // 提交固定周期任务
        ScheduledFuture&lt;?&gt; runnableFuture = scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; {
            System.out.println("This is runable task running "+Thread.currentThread().getName());
        }, 1,2, TimeUnit.SECONDS);
        // 默认情况关闭线程池后是不允许继续执行固定周期任务的，所有输出false
        System.out.println(scheduledThreadPoolExecutor.getContinueExistingPeriodicTasksAfterShutdownPolicy());
        // 设置为true
        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);
        // 休眠1200毫秒，确保任务被执行
        mySleep(1200);
        // 关闭线程池
        scheduledThreadPoolExecutor.shutdown();
        // 休眠2000毫秒后查看线程池状态
        mySleep(2000);
        // 线程池的状态
        System.out.println("isShutdown:"+scheduledThreadPoolExecutor.isShutdown());
        System.out.println("isTerminating:"+scheduledThreadPoolExecutor.isTerminating());
        System.out.println("isTerminated:"+scheduledThreadPoolExecutor.isTerminated());
    }
    
    private static void mySleep(int milliSeconds){
        try {
            TimeUnit.MILLISECONDS.sleep(milliSeconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p>可以看出来，设置为true之后，即使线程池关闭了，定时任务仍然在执行</p>
<pre><code class="language-console">false
This is runable task running pool-1-thread-1
This is runable task running pool-1-thread-1
isShutdown:true
isTerminating:true
isTerminated:false
This is runable task running pool-1-thread-1
This is runable task running pool-1-thread-1
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/yu627482453">Bill Cipher</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-schedule-ding-shi-ren-wu/">https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-schedule-ding-shi-ren-wu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yu627482453.github.io" target="_blank">蝶梦庄生</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%A1%8C%E5%8A%A8%E9%98%B6%E6%AE%B5-%E5%AE%8C%E6%88%90/">行动阶段/完成</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0%E7%A9%BA%E9%97%B4-KnowladgeSpace-ProgramSpace-BasicsSpace/">笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace</a><a class="post-meta__tags" href="/tags/%E7%BB%86%E5%8C%96%E4%B8%BB%E9%A2%98-Java/">细化主题/Java</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E9%A2%98%E5%9C%BA%E6%99%AF-%E7%A8%8B%E5%BA%8F/">主题场景/程序</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.seovx.com/?mom=302" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-xian-cheng-chi-de-nei-bu-lei-worker/"><img class="prev-cover" src="https://cdn.seovx.com/?mom=302" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Java 多线程并发】 线程池的内部类Worker</div></div></a></div><div class="next-post pull-right"><a href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng-chi/java-duo-xian-cheng-bing-fa-executors-kuang-jia-chuang-jian-xian-cheng-chi/"><img class="next-cover" src="https://cdn.seovx.com/?mom=302" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Java 多线程并发】 Executors框架创建线程池</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/language/java/java-web/java-web/" title="Java Web"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">Java Web</div></div></a></div><div><a href="/language/java/java-web/java-filter/" title="【Java】 Filter"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Filter</div></div></a></div><div><a href="/language/java/java-web/java-listener/" title="【Java】 Listener"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Listener</div></div></a></div><div><a href="/language/java/java-web/java-servlet/" title="【Java】 Servlet"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Servlet</div></div></a></div><div><a href="/java/java-web/java-web/" title="Java Web"><img class="cover" src="https://cdn.seovx.com/?mom=302" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">Java Web</div></div></a></div><div><a href="/java/java-web/java-filter/" title="【Java】 Filter"><img class="cover" src="https://cdn.seovx.com/?mom=302" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Filter</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Bill Cipher</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">240</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yu627482453"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yu627482453" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/627482453@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">【Java 多线程并发】 Schedule 定时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Metadata-76"><span class="toc-number">1.1.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">1.2.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledExecutorService-%E5%92%8C-Timer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">ScheduledExecutorService 和 Timer 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFScheduledExecutorService%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">什么是ScheduledExecutorService？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ScheduledThreadPoolExecutor%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">ScheduledThreadPoolExecutor中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schedule%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">schedule方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleAtFixedRate%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">scheduleAtFixedRate方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleWithFixedDelay%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">scheduleWithFixedDelay方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setContinueExistingPeriodicTasksAfterShutdownPolicy%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.5.</span> <span class="toc-text">setContinueExistingPeriodicTasksAfterShutdownPolicy方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setExecuteExistingDelayedTasksAfterShutdownPolicy%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.6.</span> <span class="toc-text">setExecuteExistingDelayedTasksAfterShutdownPolicy方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleAtFixedRate%E5%92%8CscheduleWithFixedDelay%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.7.</span> <span class="toc-text">scheduleAtFixedRate和scheduleWithFixedDelay的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.5.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#schedule%E7%BB%83%E4%B9%A01"><span class="toc-number">1.5.1.</span> <span class="toc-text">schedule练习1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schedule%E7%BB%83%E4%B9%A02"><span class="toc-number">1.5.2.</span> <span class="toc-text">schedule练习2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleAtFixedRate%E7%BB%83%E4%B9%A01"><span class="toc-number">1.5.3.</span> <span class="toc-text">scheduleAtFixedRate练习1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleAtFixedRate%E7%BB%83%E4%B9%A02"><span class="toc-number">1.5.4.</span> <span class="toc-text">scheduleAtFixedRate练习2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleWithFixedDelay%E7%BB%83%E4%B9%A0"><span class="toc-number">1.5.5.</span> <span class="toc-text">scheduleWithFixedDelay练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setContinueExistingPeriodicTasksAfterShutdownPolicy%E7%BB%83%E4%B9%A0"><span class="toc-number">1.5.6.</span> <span class="toc-text">setContinueExistingPeriodicTasksAfterShutdownPolicy练习</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/design/she-ji-mo-shi/" title="无题"><img src="https://cdn.seovx.com/?mom=302" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/design/she-ji-mo-shi/" title="无题">无题</a><time datetime="2023-07-15T09:13:39.871Z" title="发表于 2023-07-15 17:13:39">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/design/xing-wei-mo-shi/xing-wei-mo-shi/" title="无题"><img src="https://cdn.seovx.com/?mom=302" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/design/xing-wei-mo-shi/xing-wei-mo-shi/" title="无题">无题</a><time datetime="2023-07-15T09:13:37.615Z" title="发表于 2023-07-15 17:13:37">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/design/jie-gou-mo-shi/jie-gou-mo-shi/" title="无题"><img src="https://cdn.seovx.com/?mom=302" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/design/jie-gou-mo-shi/jie-gou-mo-shi/" title="无题">无题</a><time datetime="2023-07-15T09:13:33.180Z" title="发表于 2023-07-15 17:13:33">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/design/chuang-jian-mo-shi/chuang-jian-mo-shi/" title="无题"><img src="https://cdn.seovx.com/?mom=302" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/design/chuang-jian-mo-shi/chuang-jian-mo-shi/" title="无题">无题</a><time datetime="2023-07-15T09:13:23.913Z" title="发表于 2023-07-15 17:13:23">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程"><img src="https://cdn.seovx.com/?mom=302" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java 多线程并发】 线程"/></a><div class="content"><a class="title" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程">【Java 多线程并发】 线程</a><time datetime="2023-07-10T06:15:00.000Z" title="发表于 2023-07-10 14:15:00">2023-07-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Bill Cipher</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c61a274b6f5aa26a58f6',
      clientSecret: '485a7761d321c8dcc5cae05d7256be9fb196d94a',
      repo: 'yu627482453.github.io',
      owner: 'yu627482453',
      admin: ['yu627482453'],
      id: '948f211f2615e26cc9fca9bcf102fccf',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>