<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【Java 多线程并发】 ReentrantReadWriteLock | 蝶梦庄生</title><meta name="keywords" content="Java"><meta name="author" content="Bill Cipher"><meta name="copyright" content="Bill Cipher"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【Java 多线程并发】 ReentrantReadWriteLock">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java 多线程并发】 ReentrantReadWriteLock">
<meta property="og:url" content="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantreadwritelock/index.html">
<meta property="og:site_name" content="蝶梦庄生">
<meta property="og:description" content="【Java 多线程并发】 ReentrantReadWriteLock">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.yimian.xyz/img?type=moe">
<meta property="article:published_time" content="2023-07-04T14:01:00.000Z">
<meta property="article:modified_time" content="2023-07-04T14:01:00.000Z">
<meta property="article:author" content="Bill Cipher">
<meta property="article:tag" content="行动阶段&#x2F;完成">
<meta property="article:tag" content="笔记空间&#x2F;KnowladgeSpace&#x2F;ProgramSpace&#x2F;BasicsSpace">
<meta property="article:tag" content="细化主题&#x2F;Java">
<meta property="article:tag" content="主题场景&#x2F;程序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.yimian.xyz/img?type=moe"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantreadwritelock/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bill Cipher","link":"链接: ","source":"来源: 蝶梦庄生","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Java 多线程并发】 ReentrantReadWriteLock',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-04 22:01:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">215</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.yimian.xyz/img?type=moe')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">蝶梦庄生</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Java 多线程并发】 ReentrantReadWriteLock</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-04T14:01:00.000Z" title="发表于 2023-07-04 22:01:00">2023-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-04T14:01:00.000Z" title="更新于 2023-07-04 22:01:00">2023-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Java 多线程并发】 ReentrantReadWriteLock"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>【Java 多线程并发】 ReentrantReadWriteLock</h1>
<h2 id="Metadata-134">Metadata</h2>
<pre><code class="language-yml">title: 【Java 多线程并发】 ReentrantReadWriteLock
date: 2023-07-04 22:01
tags:
  - 行动阶段/完成
  - 主题场景/程序
  - 笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace
  - 细化主题/Java
categories:
  - Java
keywords:
  - Java
description: 【Java 多线程并发】 ReentrantReadWriteLock
</code></pre>
<h2 id="概述-63">概述</h2>
<p>ReentrantReadWriteLock采用读写锁的思想，能提高并发的吞吐量；</p>
<p><strong>读写锁</strong></p>
<ul>
<li>读锁和写锁的占用（重入）次数都是共用state字段，高位记录读锁，地位记录写锁，所以读锁和写锁的最大占用次数为2^16；</li>
<li>读锁和写锁都是可重入的；</li>
<li>读锁是共享锁，允许多个线程获取，互相不会影响，即读读不互斥；</li>
<li>写锁是排他锁（互斥锁），只允许一个线程获取；</li>
<li>读写、写读和写写是会互斥的，前者占有着锁，后者需要进入AQS队列中排队；</li>
<li>读写锁都是悲观锁，在读多写少的情况下，可能会出现写线程“饿死”的情况，即写线程一直获取不到锁。</li>
</ul>
<p><strong>原理</strong></p>
<ul>
<li>ReentrantReadWriteLock中的NonfairSync和FairSync分别实现了两种阻塞的策略，writerShouldBlock和readerShouldBlock。</li>
<li>一个线程获取了读锁，在非公平锁的情况下，其他等待获取读锁的线程都可以尝试获取读锁，在公平锁的情况下，按照AQS同步队列的顺利来获取，如果队列前面有一个等待写锁的线程在排队，则后面所有等待获取读锁的线程都将无法获取读锁，也就是说多个连续的读线程是一个接着一个被唤醒的，而不是一次性唤醒所有读线程；</li>
<li>只有多个读锁都完全释放了才会唤醒下一个写线程；</li>
<li>只有写锁完全释放了才会唤醒下一个等待者，这个等待者有可能是读线程，也可能是写线程；</li>
</ul>
<p><strong>锁升级和锁降级</strong></p>
<p>读写锁允许锁降级，不允许锁升级</p>
<h2 id="【Java-多线程并发】-ReentrantReadWriteLock-2">【Java 多线程并发】 ReentrantReadWriteLock</h2>
<p>读写锁是一种特殊的锁，它把对共享资源的访问分为读访问和写访问，多个线程可以同时对共享资源进行读访问，但是同一时间只能有一个线程对共享资源进行写访问，使用读写锁可以极大地提高并发量。读锁是一个共享锁，写锁是一个互斥锁（排他锁）。</p>
<p>ReentrantReadWriteLock就是JUC中提供的读写锁工具类。之前我们学的ReentrantLock是一把互斥锁，而这个ReentrantReadWriteLock就可以实现共享锁（读锁）的功能。它是基于AQS提供的共享锁实现方法。</p>
<h2 id="特性-2">特性</h2>
<h3 id="互斥关系">互斥关系</h3>
<p>读写锁具有以下特性：</p>
<table>
<thead>
<tr>
<th>是否互斥</th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>写</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>可以看到，读写锁除了读读不互斥，其他的读写、写读、写写都是互斥的。</p>
<p>需要注意的是，上面都是基于不同线程对同一资源的操作来说的，因为相同的线程一定不互斥，ReentrantReadWriteLock是可重入的锁，相同的线程重复获取同一个锁是没有问题的，当然同一个线程的锁升级是不被允许的。</p>
<h3 id="锁升级和锁降级">锁升级和锁降级</h3>
<p>锁升级和锁降级主要是对同一个线程获取锁的规则限制，如果是不同线程获取锁的互斥规则就按照上一节讲的特性来执行。</p>
<p>读写锁允许锁降级，不允许锁升级，比如当一个线程持有读写锁，它先去获取了一个写锁，然后该线程再去获取读锁，这属于锁降级，是允许的，还有就是这个线程先获取了一个写锁，再去获取一个写锁，或者该线程先获取了一个读锁，再获取一个读锁，这种锁是平级变化的也是允许的。但是如果该线程获取了读锁，然后该线程再去获取写锁，这属于锁升级，是不允许的。</p>
<p>在讲解完源码之后，我们会在文章的最后基于源码，来举几个例子说明为什么ReentrantReadWriteLock不允许锁升级，只允许锁降级。</p>
<h2 id="ReentrantReadWriteLock的使用案例">ReentrantReadWriteLock的使用案例</h2>
<p>ReentrantReadWriteLock不同线程之间只允许读读并发，其他情况都是互斥的。</p>
<h3 id="关于读读并发需要注意的事项">关于读读并发需要注意的事项</h3>
<p>我们先用一个案例来文字说明一下ReentrantReadWriteLock的执行流程：</p>
<p>比如先有一个t1线程获取到写锁，等待队列中有一些其他线程的读锁或写锁在阻塞等待。</p>
<p>当t1释放锁之后会按照FIFO的原则去唤醒在等待队列中等待的线程；如果第一个被唤醒的线程t2是尝试获取写锁，则无可厚非，可以让t2获取写锁，因为现在已经没有线程持有读写锁了；但不会再跟着唤醒t3，只有等t2执行完成之后才会去唤醒t3；假设被唤醒的t3是尝试获取读锁，那么t3会去判断它在等待队列中的下一个t4线程是不是要获取读锁，如果是读锁则把t4唤醒；t4唤醒之后会判断后面的t5是不是读锁；如果t5也是则唤醒t5；依次类推；但是假设判断到了t6时，发现t6是要尝试获取写锁则就不会唤醒t6了；即使后面的t7是读锁也不会唤醒t7，唤醒过程就终止在t6了，t6和t6后面的线程继续在等待队列中等待；下面这个代码说明了这个现象</p>
<pre><code class="language-java">public class LockDemo {
    // 创建ReentrantReadWriteLock读写锁对象
    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    // 通过读写锁对象获取读锁
    static Lock r = rwl.readLock();
    // 通过读写锁对象获取写锁
    static Lock w = rwl.writeLock();
    public static void main(String[] args) throws InterruptedException {
        /**
         * t1  最先拿到写（W）锁，然后睡眠了5s
         * 等t1释放了锁之后才会叫醒别人
         */
        Thread t1 = new Thread(() -&gt; {
            w.lock();
            try {
                log.debug("t1 +");
                TimeUnit.SECONDS.sleep(5);
                log.debug("5s 之后");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                w.unlock();
            }
        }, "t1");
        t1.start();
        TimeUnit.SECONDS.sleep(1);
        /**
         * t1在睡眠的过程中，t2不能拿到锁读锁，因为读写互斥
         * t2就会一直阻塞等待t1释放写锁
         */
        Thread t2 = new Thread(() -&gt; {
            try {
                r.lock();
                log.debug("t2----+-------");
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                log.debug("t2-----jian-------");
                r.unlock();
            }
        }, "t2");
        t2.start();
        TimeUnit.SECONDS.sleep(1);
 
        /**
         * t1在睡眠的过程中，t3也不能拿到读锁，因为读写互斥
         * t3也一直阻塞等待
         *
         * 当t1释放写锁之后，t3和t2能同时拿到读锁，因为读读并发
         */
        Thread t3 = new Thread(() -&gt; {
            try {
                r.lock();
                log.debug("t3----+-------");
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                log.debug("t3----释放-------");
                r.unlock();
            }
        }, "t3");
        t3.start();
 
        /**
         * t4尝试获取写锁
         * t1睡眠的时候，t4也阻塞，在同步队列中的顺序应该 t2 t3  t4
         * 当t1将写锁释放之后，就会开始唤醒同步队列的锁，唤醒t2后因为t2是读锁，所以继续向后判断t3，
         * 发现t3也是读锁就也将t3唤醒，然后再去判断t4，发现t4是要获取写锁，则不再唤醒t4，也不再向后判断了，唤醒操作中止在t4线程
         */
        Thread t4 = new Thread(() -&gt; {
            try {
                w.lock();
                log.debug("t4--------+---");
                TimeUnit.SECONDS.sleep(10);
                log.debug("t4--------醒来---");
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                log.debug("t4--------jian---");
                w.unlock();
            }
        }, "t4");
        t4.start();
 
        /**
         * t5 是读锁
         * 因为唤醒操作中止在t4了，t5也不会被唤醒，继续在等待队列中等待
         */
        Thread t5 = new Thread(() -&gt; {
 
            try {
                r.lock();
                log.debug("t5--------+---");
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                log.debug("t5--------jian---");
                r.unlock();
            }
        }, "t5");
        t5.start();
    }
}
</code></pre>
<p>在了解了ReentrantReadWriteLock使用案例后，我们再来看是如何实现读写锁的。</p>
<h2 id="继承关系-2">继承关系</h2>
<p><img src="/attachment/cb5ba58e64389c5f5e32399df1977dd6.png" alt=""></p>
<p>ReentrantReadWriteLock中的类分成三个部分：</p>
<ol>
<li>ReentrantReadWriteLock本身实现了ReadWriteLock接口，这个接口只提供了两个方法readLock()和writeLock()；</li>
<li>同步器，包含一个继承了AQS的Sync内部类，以及其两个子类FairSync和NonfairSync；</li>
<li>ReadLock和WriteLock两个内部类实现了Lock接口，它们具有锁的一些特性。</li>
</ol>
<h2 id="读写锁的数据结构">读写锁的数据结构</h2>
<p><img src="/attachment/8fe9ffd62d7b97d47c0700abb69d8906.png" alt=""></p>
<h2 id="源码分析-3">源码分析</h2>
<h3 id="读写状态的设计">读写状态的设计</h3>
<p>在我们详细分析ReentrantReadWriteLock源码之前，需要先了解一下该类的读写锁设计，因为这里和以前其他的锁不太一样，需要单独拿出来讲一下。</p>
<p>ReentrantReadWriteLock仍然是基于AQS，也是依旧使用AQS的state字段来表示读写锁被持有的次数（同步状态），高16位用来标记读锁的同步状态，低16位用来标记写锁的同步状态。</p>
<pre><code class="language-java">// ReentrantReadWriteLock.Sync
abstract static class Sync extends AbstractQueuedSynchronizer {
    // 划分的边界线，用16位来划分
    static final int SHARED_SHIFT   = 16;
    // 读锁的基本单位，也就是读锁加1或者减1的基本单位（1左移16位后的值）
    static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);
    // 读锁的最大值（在计算读锁的时候需要先右移16位）
    static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;
    // 写锁的掩码，state值与掩码做与运算后得到写锁的真实值
    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;
 
    // 获取读锁被占用的次数
    static int sharedCount(int c){
        return c &gt;&gt;&gt; SHARED_SHIFT;
    }
 
    // 获取写锁被占用的次数
    static int exclusiveCount(int c){
        return c &amp; EXCLUSIVE_MASK;
    }
}
</code></pre>
<p>结构如下图所示：</p>
<p><img src="/attachment/adfe93bebcf38e63bfcbfaf6d42d5c83.png" alt=""></p>
<p>举个例子，比如state当前为</p>
<p>0010 1011 0001 1010 1110 1000 1011 0101</p>
<p>这个二进制数的前16位就标识读锁的同步状态，后16位就是写锁的同步状态</p>
<h4 id="使用sharedCount-计算读锁被占用的次数">使用sharedCount()计算读锁被占用的次数</h4>
<p>将state向右无符号移动16位，这个操作就会将后16位移除，然后前16位就移动到了后16位的位置上，并用0来补齐，结果如下：</p>
<p><mark style="background: #FFF3A3A6;">0010 1011 0001 1010</mark> 1110 1000 1011 0101</p>
<p>无符号位右移16位</p>
<p>0000 0000 0000 <mark style="background: #FFF3A3A6;">0000 0010 1011 0001 1010</mark></p>
<h4 id="使用exclusiveCount-计算写锁被占用的次数">使用exclusiveCount()计算写锁被占用的次数</h4>
<p>将state和写锁掩码按位取与，这样就能将前16位全部变为0，只保留后16位的数，计算过程如下：</p>
<p>SHARED_SHIFT = 16</p>
<p>将1左移16位，低位用0补齐</p>
<p>SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT) = 1 &lt;&lt; 16 = 0000 0000 0000 0001 0000 0000 0000 0000</p>
<p>将SHARED_UNIT减1得出写锁掩码</p>
<p>EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1 = 0000 0000 0000 0001 0000 0000 0000 0000 - 1 = 0000 0000 0000 0000 1111 1111 1111 1111</p>
<p>将state和写锁掩码按位取与</p>
<p>0010 1011 0001 1010 <mark style="background: #FFF3A3A6;">1110 1000 1011 0101</mark></p>
<p>0000 0000 0000 0000 1111 1111 1111 1111</p>
<p>结果得</p>
<p>0000 0000 0000 0000 <mark style="background: #FFF3A3A6;">1110 1000 1011 0101</mark></p>
<h4 id="记录每个线程持有读锁的重入次数">记录每个线程持有读锁的重入次数</h4>
<h5 id="实现方法">实现方法</h5>
<p>在统计读锁被每个线程持有重入的次数时，ReentrantReadWriteLock采用的是HoldCounter来实现的，具体如下：</p>
<pre><code class="language-java">// ReentrantReadWriteLock.Sync
abstract static class Sync extends AbstractQueuedSynchronizer {
    // 持有读锁的线程重入的次数。这个类的对象就是要存储到TreadLocal中的value
    // 初始化HoldCounter时，count默认设置为0，这个在后面的源码中是有用处的
    static final class HoldCounter {
        // 重入的次数
        int count = 0;
        // 持有读锁线程的线程id
        final long tid = getThreadId(Thread.currentThread());
    }
  
    /**
     * 采用ThreadLocal机制，做到线程之间的隔离
     * 每个线程都持有自己独有的ThreadLock，用来存储自己持有读锁的重入次数
     * 
     * 这个ThreadLocalHoldCounter就是存储在ThreadLocalMap中ThreadLocal的key,ThreadLocal的value就是HoldCounter
     * 可以理解为每一个线程都持有一个自己的ThreadLocalHoldCounter，里面存储着自己持有读锁的重入次数
     */
    static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; {
        // 重写ThreadLocal的初始化方法，这样在第一次调用ThreadLocal的get()方法是就可以自动将其初始化
        public HoldCounter initialValue() {
                       // 初始化一个HoldCounter对象，并存入ThreadLocal中
            return new HoldCounter();
        }
    }
 
    /**
     * 线程持有可重入读锁的次数，这里就是记录下当前线程的ThreadLocalHoldCounter
     * readHolds就可以理解为绑定在当前线程上的ThreadLocal
     */
    private transient ThreadLocalHoldCounter readHolds;
 
    /**
     * 缓存最后一个成功获取读锁的线程的重入次数，这样做的好处：
     *    避免了通过访问ThreadLocal来获取读锁的信息，相对于直接从本地缓存中获取，从ThreadLocal中获取数据效率更低。
     *    这个优化的前提是假设多数情况下，一个获取读锁的线程，使用完以后就会释放读锁，也就是说最后获取读锁的线程和最先释放读锁的线程大多数情况下是同一个线程，获取了读锁用完之后马上就释放。
     *    这样就能保证一个线程获取了读锁，后续如果再重入获取读锁，就不需要去从ThreadLocal中获取持有次数了，直接就能从本地缓存cachedHoldCounter中获取
     *    而且用完了锁之后就会马上释放，这样在执行释放锁方法的时候，当前要释放读锁的线程仍然是最后一个获取读锁的线程，所以修改持有次数就可以直接操作cachedHoldCounter变量而不用使用ThreadLocal了，提高了执行效率
     * 
     */
    private transient HoldCounter cachedHoldCounter;
 
    /**
     * 第一个获取读锁的线程，这里直接用的是Thread线程对象记录。单独记录第一个获取读锁线程的作用：
     * 1、记录将共享数量从0变成1的线程
     * 2、对于无竞争的读锁来说进行线程重入次数数据的追踪的成本是比较低的，省去了去ThreadLocal中查找而性能高效
     * 3、在一定程度上确实可以减少ThreadLocal的使用，降低一些内存消耗
     * 4、获取当前线程的读锁重入次数时，若是当前线程时第一个获取读锁的线程则可以免去ThreadLocal中查找，也能提高一点性能
     * 
     * 虽然看起来性能提高不是很多的，但是JUC正是在这一点点的代码优化中将性能提高到极致的，能优化一点是一点
     */
    private transient Thread firstReader = null;
 
    /**
     * 第一个获取读锁线程的重入次数，直接用int来记录重入次数
     */
    private transient int firstReaderHoldCount;
 
    Sync() {
        // 在构造函数中就初始化创建了一个ThreadLocalHoldCounter对象
        readHolds = new ThreadLocalHoldCounter();
        setState(getState()); // ensures visibility of readHolds
    }
}
</code></pre>
<p>通过源码我们就可以看出，记录每个线程持有读锁的重入次数，主要应用到三个数据结构</p>
<ol>
<li><strong>ThreadLocalHoldCounter readHolds</strong>：这个对象就是绑定在每个线程上的ThreadLocal，也就是说readHolds在每个线程上都存有一份，并且在线程间独立，由绑定的线程独享。存在该ThreadLocal中的value就是HoldCounter类对象，通过HoldCounter对象来记录当前线程持有读锁的重入次数。</li>
<li><strong>HoldCounter cachedHoldCounter</strong>：<mark style="background: #BBFABBA6;">记录最后一个成功获取读锁的线程及其获取读锁的重入次数</mark>，需要注意的是最后一个成功获取读锁是指在所有成功获取到过该读锁的线程当中，不管线程是否已经中止，只要是在时间上最后一个获取读锁的线程，就会被记录在cachedHoldCounter中。比如此时有t1、t2、t3依次成功获取读锁，当前cachedHoldCounter指向的是t3，然后t3将读锁全部释放了，后面t2不再尝试获取读锁，那么此时cachedHoldCounter中记录的ThreadId就还是t3的，而不会修改为指向t2，因为在时间上t2获取锁的时间就是比当时t3晚，但是如果t2再次尝试获取读锁，那么cachedHoldCounter就会更新指向t2，因为t2成了在时间上最后一次成功获取锁的线程。</li>
<li><strong>Thread firstReader 和 int firstReaderHoldCount</strong>：<mark style="background: #BBFABBA6;">分别用来记录第一个成功获取读锁的线程和该线程持有读锁的重入次数。</mark>这里的第一个成功获取读锁是指当一个线程成功持有读锁后，该读锁总的被线程持有的次数从0变为1，那么这个线程就被记录位该读锁的firstReader。比如此时有t1、t2、t3依次成功获取读锁，t1是被记录为firstReader，然后t1将读锁释放了，firstReader就会被设置为null，而不会更新指向为t2，因为t2获取读锁的时候，该读锁总的被线程持有数并不是从0变为1的，所以就不算是firstReader。只有当t2和t3将自己的读锁全部释放，然后再来一个t4成功获取读锁，这个t4才会被认为是firstReader，因为t4持有读锁时该读锁总的被线程持有的次数从0变为1。</li>
</ol>
<p>第一个获取读锁的线程的重入次数信息会被记录在firstReader和firstReaderHoldCount中，并不会使用这个线程的ThreadLocal来记录重入次数信息。但是最后一个获取读锁的线程的重入次数信息仍然会存储在该线程的ThreadLocal中，并且会单独拿出一个本地缓存变量cachedHoldCounter来只想存储在ThreadLocal中的重入次数计数器，这样就可以直接通过本地缓存变量来获得HoldCounter，不需要通过ThreadLocal来查询获取了，提高了效率。</p>
<p>至于在使用过程中，这三个数据结构的具体变化和使用流程，我们在后面讲解获取释放读锁源码的时候会举例讲解，这里我们来讲解一下为什么使用三个数据结构来分别记录不同线程锁持有读锁的重入次数，这样设计到底有什么作用和好处。</p>
<h5 id="为什么这样设计">为什么这样设计</h5>
<p>其实最开始读写锁只是使用了ThreadLocalHoldCounter来记录每个线程持有读锁的重入次数，因为这个方法是最简单方便的，直接将每个线程持有读锁的重入次数存入到该线程独享的ThreadLocal中，非常方便存取。但是在后续的时候过程当中，他们就逐渐发现了问题：</p>
<ol>
<li>当读锁的数量很大，持有读锁的线程数量很多的时候，就会导致需要使用大量的ThreadLocal来存储线程锁持有读锁的重入次数，比方说m是锁的个数，n是每个锁持有的线程数，每个线程有一个内部有一个ThreadLocal来记录锁重入，这样就会有m*n个内存占用，这就造成了内存占用率过高。而且在jdk1.6的时候，ReentrantReadWriteLock还有一个小bug就是在ThreadLocal使用完之后没有调用remove()，这样就会造成ThreadLocal内存泄露的问题，更增加了内存占用率。</li>
<li>当大量使用ThreadLocal的时候，效率就会变慢，因为相对于直接从本地缓存对象中取出数据，从ThreadLocal中查找获取数据性能开销更大，如果能尽量避免使用ThreadLocal有助于提高性能。<br>
基于以上两点原因，所以在后续的版本中就添加了cachedHoldCounter、firstReader、firstReader。并且也修复了使用完ThreadLocal后不调用remove()的bug。</li>
</ol>
<h5 id="添加cachedHoldCounter的原因：">添加cachedHoldCounter的原因：</h5>
<p>在一些情况下，线程在拿到读锁使用完之后会马上释放锁，这就可能释放锁的线程就是最后一个获取到读锁的线程，这样我们单独创建一个对象来存储最后一个拿到读锁的线程的重入次数信息，每次释放锁的时候就可以直接从本地缓存对象中获取数据，不需要通过线程的ThreadLocal了，提高了效率。而且在最后一个获取读锁的线程马上又重入读锁时，也可以直接操作cachedHoldCounter，避免使用ThreadLocal，并且也能保证cachedHoldCounter和ThreadLocal数据是同步变化的，因为cachedHoldCounter指向的重入次数计数器和最后一个获取到读锁线程的ThreadLocal存储的重入次数计数器实际上是同一个对象。</p>
<h5 id="添加firstReader-和-firstReaderHoldCount的原因：">添加firstReader 和  firstReaderHoldCount的原因：</h5>
<ol>
<li>如果第一次获取读锁的线程来执行获取锁和释放锁，就可以直接使用firstReader和firstReaderHoldCount来修改线程的重入次数信息。在一定程度上确实减少ThreadLocal的使用，免去了去ThreadLocal中查找，能提高一些性能。并且也可以降低一些内存的使用，假设一个线程需要获取50000个不同的读锁，就可以减少50000个ThreadLocal的内存使用。</li>
<li>对于无竞争时，只有一个线程获取读锁的计数省去了去ThreadLocal中查找而性能高效。但是一般情况都是有竞争的，所以实际收效甚微。</li>
</ol>
<h3 id="内部类">内部类</h3>
<p>ReentrantReadWriteLock 一共有5个内部类，具体如下：</p>
<ul>
<li>Sync：公平锁和非公平锁的抽象类</li>
<li>NonfairSync：非公平锁的具体实现</li>
<li>FairSync：公平锁的具体实现</li>
<li>ReadLock：读锁的具体实现</li>
<li>WriteLock：写锁的具体实现</li>
</ul>
<h3 id="主要属性-2">主要属性</h3>
<pre><code class="language-java">// 读锁
private final ReentrantReadWriteLock.ReadLock readerLock;
// 写锁
private final ReentrantReadWriteLock.WriteLock writerLock;
// 同步器
final Sync sync;
</code></pre>
<p>维护了读锁、写锁和同步器。</p>
<p>属性中的读锁和写锁是私有属性，需要通过这两个方法来获取读锁和写锁：</p>
<pre><code class="language-java">public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
 
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
</code></pre>
<h3 id="主要构造方法-2">主要构造方法</h3>
<pre><code class="language-java">// 默认构造方法
public ReentrantReadWriteLock() {
    this(false);
}
// 是否使用公平锁的构造方法
public ReentrantReadWriteLock(boolean fair) {
    // 设置同步器实现公平锁还是非公平锁
    sync = fair ? new FairSync() : new NonfairSync();
    // 初始化读锁和线索对象
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
</code></pre>
<p>它提供了两个构造方法，默认构造方法使用的是非公平锁模式，在构造方法中初始化了读锁和写锁。</p>
<p>我们从读锁ReadLock和写锁WriteLock的源码开始分析，然后顺着这个思路将整个ReentrantReadWriteLock中所有的核心源码（所有的包括内部类）进行分析。</p>
<h3 id="ReadLock类源码解析">ReadLock类源码解析</h3>
<pre><code class="language-java">// ReentrantReadWriteLock.ReadLock
public static class ReadLock implements Lock, java.io.Serializable {
    // 同步器
    private final Sync sync;
    /**
     * 通过ReentrantReadWriteLock中的公平锁或非公平锁来初始化sync变量
     */
    protected ReadLock(ReentrantReadWriteLock lock) {
          sync = lock.sync;
    }
    /**
     * 阻塞的方式获取锁，因为读锁是共享锁，所以调用acquireShared方法
     */
    public void lock() {
          sync.acquireShared(1);
    }
    /**
     * 可中断且阻塞的方式获取锁
     */
    public void lockInterruptibly() throws InterruptedException {
          sync.acquireSharedInterruptibly(1);
    }
    /**
     * 超时尝试获取锁，非阻塞的方式
     */
    public boolean tryLock(long timeout, TimeUnit unit)
          throws InterruptedException {
          return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
    /**
     * 尝试获取读锁，非阻塞的方式
     */
    public boolean tryLock() {
          return sync.tryReadLock();
    }
    /**
     * 释放锁
     */
    public void unlock() {
          sync.releaseShared(1);
    }
}
</code></pre>
<h4 id="读锁共享锁">读锁共享锁</h4>
<h5 id="源码-2">源码</h5>
<pre><code class="language-java">// ReentrantReadWriteLock.ReadLock.lock()
public void lock() {
    // 获取读锁（共享锁）
    sync.acquireShared(1);
}
 
// AbstractQueuedSynchronizer.acquireShared()
// AQS中提供了获取共享锁的模板方法，供用户调用
public final void acquireShared(int arg) {
    // 该方法是在ReentrantReadWriteLock的内部类Sync中实现的
    // 尝试获取共享锁（返回1表示成功，返回-1表示失败）
    if (tryAcquireShared(arg) &lt; 0)
        // 获取读锁失败了就可能要排队
        doAcquireShared(arg);
}
 
// ReentrantReadWriteLock.Sync.tryAcquireShared()
protected final int tryAcquireShared(int unused) {
    // 获取当前线程
    Thread current = Thread.currentThread();
    // 状态变量的值
    // 在读写锁模式下，高16位存储的是共享锁（读锁）被获取的次数，低16位存储的是互斥锁（写锁）被获取的次数
    int c = getState();
    /**
     * 条件1：获取互斥锁（读锁）的被持有的次数，判断是否不等于0
     * 条件2：判断当前线程是否持有互斥锁（写锁）
     * 
     * 如果条件1和条件2同时成立，表明其它线程获得了写锁，因为读写和写读互斥，直接返回-1，该线程获取读锁失败
     */
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    // 读锁被获取的次数
    int r = sharedCount(c);
    
    // 执行到这里说明此时还没有线程获取写锁，尝试去更新state的值获取读锁
    /**
     * 条件1：读者是否需要排队（是否是公平模式），readerShouldBlock()返回true说明需要排队
     * 条件2：读锁被持有次数是否小于上限
     * 条件3：尝试CAS更新读锁state值是否成功
     * 
     * 如果三个条件均成立，则说明当前线程尝试获取读锁成功，就可以执行后续的修改当前线程持有读锁重入次数的操作了
     */
    if (!readerShouldBlock() &amp;&amp;
        r &lt; MAX_COUNT &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        // 获取读锁成功
        // 判断之前是否有线程持有该读锁
        if (r == 0) {
            // 如果之前还没有线程获取读锁，记录第一个读者为当前线程，直接使用firstReader和firstReaderHoldCount进行记录，不适用ThreadLocal
            firstReader = current;
            // 第一个读者重入的次数为1
            firstReaderHoldCount = 1;
        // 如果有线程获取了读锁且是当前线程就是第一个读者
        } else if (firstReader == current) {
            // 则把其重入次数加1
            firstReaderHoldCount++;
        } else {
            // 如果执行到了这里，说明有线程获取了读锁且当前线程不是第一个读者
            // 这种情况我们先从本地缓存中获取最后一个获取该读锁线程的重入次数保存器
            HoldCounter rh = cachedHoldCounter;
          
            /**
             * 条件1：本地缓存cachedHoldCounter是否存有数据
             * 条件2：当前线程是否为记录在cachedHoldCounter中最后一次获取该读锁的线程
             * 
             * 条件1和条件2只要有任意一个成立，就说明此时cachedHoldCounter还未记录数据或者当前线程并不是最后一个获取读锁的线程
             * 则进入到该if分支中去从readHolds中获取当前线程的重入次数保存器，并且更新cachedHoldCounter的记录，因为当前线程已经成了最新的（也就是最后一次）获取读锁的线程了
             * readHolds本身是一个ThreadLocal，它和当前线程绑定在一起，里面存储的是HoldCounter
             */
            if (rh == null || rh.tid != getThreadId(current))
                /**
                 * 如果当前线程的readHolds是第一次调用get()，就会给该线程创建一个ThreadLocalMap，然后初始化一个ThreadLocalHoldCounter存入该线程的ThreadLocalMap中，并将这个ThreadLocalHoldCounter返回
                 * 如果不是第一调用get()，就会直接将与该线程绑定的ThreadLocalHoldCounter返回
                 * 
                 * 这里就将rh引用指向该线程的ThreadLocalHoldCounter，同时更新cachedHoldCounter指向该线程的cachedHoldCounter，也就是说最后一个获取读锁的线程的重入保存器会存储在本地缓存cachedHoldCounter变量中一份，还会存储在该线程的ThreadLocalHoldCounter一份，一共存量份。这九个firstReader有所不同，firstReader的重入信息只会存储在本地缓存变量中，不会存储在ThreadLocal中
                 * 这里需要注意一下rh是一个引用地址，这个引用指向当前线程的ThreadLocalHoldCounter对象，也就是说修改rh，就相当于将该线程的ThreadLocalHoldCounter对象也修改了
                 */
                cachedHoldCounter = rh = readHolds.get();
            // 如果没有进入上面的if分支，说明当前线程就是存储在cachedHoldCounter中的线程，也就是最后一个成功获取到该读锁的线程    
            // 判断该线程重入该读锁的次数是否为0
            else if (rh.count == 0)
                // 如果rh的次数为0，把它放到ThreadLocal中去
                /**
                 * 如果进入到这个分支，说明当前cachedHoldCounter中存储的线程id就是当前线程
                 * 但是这个线程已经将之前自己持有的该读锁全部释放了，我们知道在最后一个成功获取到该读锁的线程完全释放掉持有的读锁后，
                 * cachedHoldCounter并不会跟着清空，只是会其中存储的该线程的读锁冲入次数清零，但是记录的线程id还是以前的线程
                 * 只有当以后又来了另一个线程成功获取到读锁，才会更新cachedHoldCounter中的数据，存储新线程的重入次数
                 * 
                 * 这样的机制下就会出现这样一种情况，就是原有的最后一次获取读锁的线程t将锁全部释放以后，没有其他线程再来获取读锁
                 * 因为t已经将所有的锁释放了，所以在执行释放锁操作之后，就会调用remove()方法，将该线程的ThreadLocalHoldCounter从该线程的ThreadLocalMap中删除，注意，并没有删除ThreadLocalMap
                 * 然后t又一次获取了读锁，这个时候正好cachedHoldCounter记录的线程id还是t线程的，但是重入次数count已经是0了，所以就会进入到这个分支中
                 * 
                 * 因为此时当前线程的ThreadLocalMap中已经没有了ThreadLocalHoldCounter，所以重新向readHold中set进去HoldCounter对象来创建ThreadLocalHoldCounter
                 * 这里就不能通过get()来初始化创建ThreadLocalHoldCounter了，具体原因可以见讲解ThreadLocal源码的文章
                 */
                readHolds.set(rh);
            // 重入的次数加1。这里需要注意，rh是指向一个HoldCounter对象的引用，对rh的修改操作，其实就是修改了指向的那个HoldCounter对象
            // 也就是说修改了rh，也就同步修改了cachedHoldCounter和readHolds中的HoldCounter对象的数据
            rh.count++;
        }
        // 获取读锁成功，返回1
        return 1;
    }
    // 如果CAS失败，则通过这个方法再去尝试获取读锁（如果此时其它线程仍在持有写锁，一样返回-1表示失败，因为写读，读写互斥）
    return fullTryAcquireShared(current);
}
 
// ReentrantReadWriteLock.Sync.exclusiveCount()
abstract static class Sync extends AbstractQueuedSynchronizer {
    // 划分的边界线，用16位来划分
    static final int SHARED_SHIFT   = 16;
    // 写锁的掩码，state值与掩码做与运算后得到写锁的真实值
    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;
  
    // 获取写锁被占用的次数
    static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }
    
    // 获取读锁被占用的次数
    static int sharedCount(int c) { return c &gt;&gt;&gt; SHARED_SHIFT; }
}
 
// ReentrantReadWriteLock.Sync.fullTryAcquireShared()
final int fullTryAcquireShared(Thread current) {
    /**
     * 调用该方法的线程都是希望获取读锁的线程，有3种情况：
     * 1、在尝试通过CAS操作修改state时由于有多个竞争读锁的线程导致CAS操作失败
     * 2、需要排队等待获取读锁的线程（公平锁）
     * 3、超过读锁限制的最大申请次数的线程
     */
    HoldCounter rh = null;
    // 自旋尝试获取锁
    for (;;) { 
        // 获取读写锁的状态变量
        int c = getState();
        // 判断当前写锁被持有的次数是否为0，如果不为0说明已经有线程持有写锁了，直接返回-1，因为写读，读写互斥
        if (exclusiveCount(c) != 0) {
            if (getExclusiveOwnerThread() != current)
                return -1;
        // 当前线程是否需要被阻塞（公平锁）
        } else if (readerShouldBlock()) {
            // 判断当前线程是不是第一个持有读锁的线程
            if (firstReader == current) {
                // assert firstReaderHoldCount &gt; 0;
            // 当前线程不是第一个持有读锁的线程    
            } else {
                // 判断rh是否为null，进而判断是不是刚刚进行第一轮循环
                if (rh == null) {
                    // 获取最后一个获取读锁的线程数据
                    rh = cachedHoldCounter;
                    // 判断该线程是不是最后一个获取读锁的线程
                    if (rh == null || rh.tid != getThreadId(current)) {
                        // 如果不是，则通过ThreadLocal获取该线程的重入次数保存器
                        rh = readHolds.get();
                        // 如果当前线程对该读锁的重入次数为0，则调用ThreadLocal的remove方法，将该ThreadLocal移除，避免ThreadLocal出现内存泄漏
                        // 只有从ThreadLocal中获取重入次数保存器时才需要remove，如果是cachedHoldCounter中的，就不会进到这个if分支中，不需要去做额外的删除，因为不会有内存泄漏的问题
                        if (rh.count == 0)
                            readHolds.remove();
                    }
                }
                // 当前线程获取锁失败
                if (rh.count == 0)
                    return -1;
            }
        }
        // 判断是否超过读锁的最大值
        if (sharedCount(c) == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // 尝试CAS修改读锁的state值
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            // 最新获取到读锁的线程设置相关的信息，这里就和tryAcquireShared中修改线程的重入次数信息基本一样了
            if (sharedCount(c) == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                // 当前线程重复获取锁（重入）
                firstReaderHoldCount++; 
            } else {
                // 在readHolds中记录获取锁的线程的信息
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                // 最后一下获取锁的线程将读锁全部释放之后，再次获取读锁就会进入到这个分支    
                else if (rh.count == 0)
                    // 重新将重入保存期添加到readHolds（ThreadLocal）中
                    readHolds.set(rh);
                rh.count++;
                // 更新最后一次成功获取到锁的线程
                cachedHoldCounter = rh; // cache for release
            }
            // 进入到这个if分支就是成功获取到读锁了，返回1
            return 1;
        }
    }
}
 
// AbstractQueuedSynchronizer.doAcquireShared()
// 详细讲解可以见AQS源码文章，这个方法相当于互斥锁的acquireQueued()方法
private void doAcquireShared(int arg) {
    // 将线程添加到AQS同步等待队列中
    final Node node = addWaiter(Node.SHARED);
    // 阻塞线程是否失败
    boolean failed = true;
    try {
        // 中断标记，是否要将当前线程中断
        boolean interrupted = false;
        // 自旋不断尝试获取锁
        for (;;) {
            // 获取当前节点的前一个节点
            final Node p = node.predecessor();
            // 如果前一个节点是头节点（说明是第一个排队的节点）
            if (p == head) {
                // 再次尝试获取读锁
                int r = tryAcquireShared(arg);
                // 如果成功了
                if (r &gt;= 0) {
                    // 头节点后移并传播
                    // 传播即唤醒后面连续的读节点，这也是我们在本章节最开始举的例子，当一个在等待队列中等待获取读锁的线程被唤醒并成功获取读锁后，就会开始将它后面连续的也是在等待申请读锁的线程一并唤醒
                    // 注意这里必须得是连续的，如果中间出现了一个等待申请写锁的线程，则唤醒操作到此为止
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    // 判断该线程是否被中断
                    if (interrupted)
                        selfInterrupt();
                    // 将阻塞标志设置为false，说明没有阻塞节点线程
                    failed = false;
                    return;
                }
            }
            // 如果没获取到读锁，判断是否可以将node节点阻塞，如果可以则将其阻塞，等待被唤醒
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  // 判断node节点能否被唤醒
                parkAndCheckInterrupt()) // 真正对node节点进行阻塞的方法，阻塞之后这个线程就会停在这个方法内
                // 如果parkAndCheckInterrupt()执行了阻塞并且返回当前线程的中断信号是true，则将这个方法中设置的中断信号变量设置为true，用来向上一层返回当前线程的中断标志
                interrupted = true;
        }
    } finally {
        // 如果阻塞线程失败了
        if (failed)
            // 取消获取锁
            cancelAcquire(node);
    }
}
 
// AbstractQueuedSynchronizer.setHeadAndPropagate()
// 将等待队列头节点后移，并向后传播唤醒连续的申请读锁的等待线程
private void setHeadAndPropagate(Node node, int propagate) {
    // h为旧的头节点
    Node h = head;
    // 设置当前节点为新头节点
    setHead(node);
    
    // 如果旧的头节点或新的头节点为空或者其等待状态小于0（表示状态为SIGNAL/PROPAGATE）
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
        (h = head) == null || h.waitStatus &lt; 0) {
        // 需要传播
        // 取下一个节点
        Node s = node.next;
        // 如果下一个节点为空，或者是需要获取读锁的节点
        if (s == null || s.isShared())
            // 唤醒下一个节点
            doReleaseShared();
    }
}
 
// AbstractQueuedSynchronizer.doReleaseShared()
// 这个方法只会唤醒一个节点
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            // 如果头节点状态为SIGNAL，说明要唤醒下一个节点
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                // 唤醒下一个节点
                unparkSuccessor(h);
            }
            else if (ws == 0 &amp;&amp;
                     // 把头节点的状态改为PROPAGATE成功才会跳到下面的if
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        // 如果唤醒后head没变，则跳出循环
        if (h == head)                   // loop if head changed
            break;
    }
}
</code></pre>
<p>这里面很多方法流程和ReentrantLock类似，如果有基础的话看这些源码会比较容易。</p>
<h5 id="大致的逻辑：">大致的逻辑：</h5>
<ol>
<li>先尝试获取读锁；</li>
<li>如果成功了直接结束；</li>
<li>如果失败了，进入doAcquireShared()方法；</li>
<li>doAcquireShared()方法中首先会生成一个新节点并进入AQS队列中；</li>
<li>如果头节点正好是当前节点的上一个节点，再次尝试获取锁；</li>
<li>如果成功了，则设置头节点为新节点，并传播；</li>
<li>传播即唤醒下一个读节点（如果下一个节点是读节点的话）；</li>
<li>如果头节点不是当前节点的上一个节点或者（5）失败，则阻塞当前线程等待被唤醒；</li>
<li>唤醒之后继续走（5）的逻辑；</li>
</ol>
<h5 id="在整个逻辑中是在哪里连续唤醒读节点的呢？">在整个逻辑中是在哪里连续唤醒读节点的呢？</h5>
<p>答案是在doAcquireShared()方法中，在这里一个节点A获取了读锁后，会唤醒下一个读节点B，这时候B也会获取读锁，然后B继续唤醒C，依次往复，也就是说这里的节点是一个唤醒一个这样的形式，必须得是在队列中连续的读节点才会被唤醒，而不是一个节点获取了读锁后一次性唤醒后面所有的读节点。</p>
<p>下面再讲一下非阻塞获取读锁的操作，相对就要简单很多了：</p>
<h5 id="在整个逻辑中是在哪里连续唤醒读节点的呢？-2">在整个逻辑中是在哪里连续唤醒读节点的呢？</h5>
<p>答案是在doAcquireShared()方法中，在这里一个节点A获取了读锁后，会唤醒下一个读节点B，这时候B也会获取读锁，然后B继续唤醒C，依次往复，也就是说这里的节点是一个唤醒一个这样的形式，必须得是在队列中连续的读节点才会被唤醒，而不是一个节点获取了读锁后一次性唤醒后面所有的读节点。</p>
<h5 id="非阻塞获取读锁">非阻塞获取读锁</h5>
<p>下面再讲一下非阻塞获取读锁的操作，相对就要简单很多了：</p>
<pre><code class="language-java">// ReentrantReadWriteLock.ReadLock.tryLock()
// 非阻塞的尝试获取读锁
public boolean tryLock() {
    return sync.tryReadLock();
}
 
// ReentrantReadWriteLock.Sync.tryReadLock()
// 非阻塞尝试获取读锁
final boolean tryReadLock() {
    // 获取当前线程
    Thread current = Thread.currentThread();
    // 自旋尝试获取读锁
    for (;;) { 
        // 获取读写锁状态变量的值
        int c = getState();
        /**
         * 条件1：获取互斥锁（读锁）的被持有的次数，判断是否不等于0
         * 条件2：判断当前线程是否持有互斥锁（写锁）
         * 
         * 如果条件1和条件2同时成立，表明其它线程获得了写锁，因为读写和写读互斥，直接返回-1，该线程获取读锁失败
         */
        if (exclusiveCount(c) != 0 &amp;&amp;
            getExclusiveOwnerThread() != current)
            return false;
        // 读锁被获取的次数    
        int r = sharedCount(c);
        // 读锁的总重入次数是否超过最大次数限制
        if (r == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        /**
         * 通过CAS操作设置state的值，如果成功表示尝试获取读锁成功，需要做以下几件事情：
         * 1、如果是第一获取读锁要记录第一个获取读锁的线程信息
         * 2、如果是当前获取锁的线程和第一次获取锁的线程相同，需要更新第一获取线程的重入次数
         * 3、更新获取读锁线程相关的信息
         * 
         * 这个if就只有一个CAS操作，没有阻塞操作了，如果CAS失败就继续自旋尝试获取锁
         */
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            // 下面的操作和之前讲过的一样
            if (r == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    cachedHoldCounter = rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
            }
            // 成功获取读锁，返回true
            return true;
        }
    }
}
</code></pre>
<h4 id="读锁释放锁">读锁释放锁</h4>
<h5 id="源码-3">源码</h5>
<pre><code class="language-java">// java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.unlock
public void unlock() {
    // 释放读锁（共享锁）
    sync.releaseShared(1);
}
 
// java.util.concurrent.locks.AbstractQueuedSynchronizer.releaseShared
public final boolean releaseShared(int arg) {
    // 如果尝试释放成功了，就唤醒下一个节点
    if (tryReleaseShared(arg)) {
        // 这个方法实际是唤醒下一个节点，在上一小节已经讲过了
        doReleaseShared();
        // 释放锁成功
        return true;
    }
    // 释放锁失败
    return false;
}
 
// java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryReleaseShared
// 只有所有持有该读锁的线程全部都完全释放了该锁时，才会返回true，其他情况一律返回false
protected final boolean tryReleaseShared(int unused) {
    // 获取当前线程
    Thread current = Thread.currentThread();
    // 当前线程是否为第一个获取读锁的线程
    if (firstReader == current) {
        // 如果第一个读者（读线程）是当前线程，就把它重入的次数减1。如果减到0了就把firstReader置为空。firstReader可以被置为空，cachedHoldCounter只要是写入数据之后就不会被置为空了
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--;
    } else {
        // 如果第一个读者不是当前线程，从记录最后一个获取读锁的本地缓存变量中获取重入次数保存期
        HoldCounter rh = cachedHoldCounter;
        /**
         * 条件1：cachedHoldCounter是否为空
         * 条件2：当前线程是否是最后一个获取读锁的线程
         * 
         * 条件1或条件2只要有成立的，就会进入到该if分支中，说明cachedHoldCounter还没有记录最后一个获取锁的线程或者当前线程并不是最后一个获取读锁的线程
         */
        if (rh == null || rh.tid != getThreadId(current))
            // 该线程不是最后获取读锁的线程，则从其ThreadLocal中获取重入次数保存器
            rh = readHolds.get();
        // 获取当前线程对读锁的重入次数
        int count = rh.count;
        // 如果当前线程的重入次数已经小于等于1了，说明这次释放了读锁之后该线程就完全释放了该读锁，需要将该线程对存储该读锁重入次数的ThreadLocal删除掉，否则可能会导致ThreadLocal内存泄漏
        if (count &lt;= 1) {
            // 调用ThreadLocal的remove()
            readHolds.remove();
            // 如果还没有释放锁这个线程的读锁重入次数就小于等于0了，说明出现了错误，抛出异常
            if (count &lt;= 0)
                throw unmatchedUnlockException();
        }
        // 将重入次数减1
        --rh.count;
    }
    // 再去更新读写锁的state变量
    for (;;) {
        // 共享锁获取的次数减1
        int c = getState();
        int nextc = c - SHARED_UNIT;
        // 通过CAS更新state
        if (compareAndSetState(c, nextc))
            // 如果减为0了说明已经没有线程持有该读锁了，这种情况才返回true。否则返回false
            return nextc == 0;
    }
}
 
// java.util.concurrent.locks.AbstractQueuedSynchronizer.doReleaseShared
// 行为跟方法名有点不符，实际是唤醒下一个节点
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            // 如果头节点状态为SIGNAL，说明要唤醒下一个节点
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                // 唤醒下一个节点
                unparkSuccessor(h);
            }
            else if (ws == 0 &amp;&amp;
                     // 把头节点的状态改为PROPAGATE成功才会跳到下面的if
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        // 如果唤醒后head没变，则跳出循环
        if (h == head)                   // loop if head changed
            break;
    }
}
</code></pre>
<h5 id="解锁的大致流程如下：">解锁的大致流程如下：</h5>
<ol>
<li>将当前线程重入的次数减1；</li>
<li>将共享锁总共被获取的次数减1；</li>
<li>如果共享锁获取的次数减为0了，说明共享锁被完全释放了，那就唤醒下一个节点；</li>
</ol>
<h5 id="举例">举例</h5>
<p>举个例子，t1、t2、t3三个节点依次获取了一次共享锁，三者释放的顺序分别为t1、t3、t2，那么最后t2释放共享锁的时候tryReleaseShared()才会返回true，因为此时读锁才被所有线程完全释放了。这样才会去唤醒等待队列中的下一个读节点。</p>
<p>至此我们就将读锁的主要源码分析完了，下面我们就举几个例子让大家能更直观的了解ReentrantReadWriteLock的执行流程。也能更深刻理解cachedHoldCounter、firstReader、firstReaderHoldCount的作用。</p>
<p><strong>例子1</strong>：第一个线程t1进来拿读锁，然后t1就一直不释放，第二个线程t2进来拿读锁，此时这个t2就是最后一个拿到读锁的线程，t2的读锁重入次数会记录在cachedHoldCounter中，并且也会存储到t2线程的ThreadLocal中一份。然后t2再去释放锁，此时就会将cachedHoldCounter的重入次数减为0，但是cachedHoldCounter中记录的线程id仍然是t2的，并不会因为t2完全释放了读锁就将cachedHoldCounter置为空，因为从时间角度上t2仍然是最后一个成功获取读锁的线程。同时t2绑定的存储重入次数计数器的ThreadLocal会被remove掉。如果t2释放了读锁之后又再一次获取读锁，这个时候它就会直接进入到获取读锁源码的else if (rh.count == 0)这个分支中，重新将t2线程的HoldCounter存储到ThreadLocal中，具体注释在上面源码中已经写好了。</p>
<p><strong>例子2</strong>：第一个线程t1进来拿读锁，这个时候t1是第一个拿到读锁的线程，所以它的读锁重入次数记录会被记录在firstReader和firstReaderHoldCount中，但是并不会使用ThreadLocal来记录t1的重入次数。然后t1不释放，第二个线程t2进来拿读锁，然后t2不释放，t1先释放，t1完全释放了读锁，这个时候因为t1是第一个获取所得读锁的线程，所以直接操作firstReader，将其置为空，并不会将firstReader指向t2。然后再来一个t3获取读锁，这是t3成了最后一次获取读锁的线程，将cachedHoldCounter保存t3的重入次数计数器，但是firstReader和firstReaderHoldCount不会有任何变化。最后t2、t3全部彻底释放读锁后，再来一个线程t4获取读锁，此时就会将firstReader和firstReaderHoldCount转而记录t4的重入信息，因为t4使该读锁被占有次数从0变为1，属于第一个成功获取读锁的线程。</p>
<p><strong>例子3</strong>：第一个线程t1拿读锁，然后t1不释放，第二个线程t2进来拿读锁，也先不释放，第三个线程t3进来拿读锁，也先不释放。t1获取到读锁后，它的重入次数信息被保存在firstReader和firstReaderHoldCount中，并不会记录到t1线程的ThreadLocal中，t2线程拿锁后，它的重入次数计数器就会存储到cachedHoldCounter本地缓存变量中一份，存储到t2绑定的ThreadLocal中一份，最后t3拿到读锁之后，cachedHoldCounter就会转而存储t3的重入次数信息，并且也会在t3绑定的ThreadLocal中存储一份重入次数计数器，这里需要注意，cachedHoldCounter指向的重入次数计数器和ThreadLocal中存储的重入次数计数器其实是同一个对象，改一个就全都改了。然后t3将读锁完全释放，cachedHoldCounter中记录的重入次数变为0，线程id仍然是记录的t3的，并不会转而记录t2线程的重入信息。后面再来一个t4获取读锁，这个时候cachedHoldCounter就会转而记录t4的重入信息，此时t4就成为了最后一个获取读锁的线程。</p>
<h3 id="WriteLock类源码解析">WriteLock类源码解析</h3>
<pre><code class="language-java">public static class WriteLock implements Lock, java.io.Serializable {
    private final Sync sync;
    /**
     * 通过ReentrantReadWriteLock中的公平锁或非公平锁来初始化sync变量
     */
    protected WriteLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    /**
     * 阻塞的方式获取写锁
     */
    public void lock() {
        sync.acquire(1);
    }
    /**
     * 中断的方式获取写锁
     */
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }
    /**
     * 尝试获取写锁
     */
    public boolean tryLock( ) {
        return sync.tryWriteLock();
    }
    /**
     * 超时尝试获取写锁
     */
    public boolean tryLock(long timeout, TimeUnit unit)
            throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }
    /**
     * 释放写锁
     */
    public void unlock() {
        sync.release(1);
    }
}
</code></pre>
<h4 id="写锁获取锁">写锁获取锁</h4>
<h5 id="源码-4">源码</h5>
<pre><code class="language-java">// java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.lock()
public void lock() {
    // 获取互斥锁（写锁）
    sync.acquire(1);
}
// java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire()
public final void acquire(int arg) {
    // 先尝试获取锁
    // 如果失败，则会进入队列中排队，后面的逻辑跟ReentrantLock一模一样了
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
// java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryAcquire()
protected final boolean tryAcquire(int acquires) {
    // 获取当前线程
    Thread current = Thread.currentThread();
    // 状态变量state的值
    int c = getState();
    // 互斥锁被获取的次数
    int w = exclusiveCount(c);
    // c != 0朔说明此时读写锁已经被线程占有了
    if (c != 0) {
        /**
         * 条件1：如果c!=0且w==0，说明共享锁被获取的次数不为0
         * 条件2：当前线程是不是持有该写锁的线程
         * 
         * 条件1和条件2只要有任意一个成立，就会进入该if分支中返回false
         * 条件1成立，说明此时已经有线程获取读锁了，如果获取读锁的线程是其他线程，那么读写互斥，不能够获取到写锁。如果获取读锁的线程就是当前线程，因为不允许锁升级，所以也不能获取到写锁，直接返回false
         * 条件2成立，说明该写锁已经被其他线程获取了，所以当前线程不能获取到该写锁，返回false
         */
        if (w == 0 || current != getExclusiveOwnerThread())
            // 返回false，获取写锁失败
            return false;
        // 溢出检测，写锁持有次数是否超过了最大限制
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // 到这里说明当前线程已经获取过写锁，这里是重入了，直接把state加1即可
        // 注意这里直接用state+acquires就行了，因为state后16为本来就是记录写锁占有次数的，直接在state基础上做加法即可
        setState(c + acquires);
        // 获取写锁成功
        return true;
    }
    // 如果c等于0，说明此时还没有线程持有该读写锁，那就尝试更新state的值（非公平模式writerShouldBlock()返回false，不会阻塞排队，直接去尝试CAS修改state）
    // 如果失败了，说明CAS获取写锁失败，返回false
    // 如果成功了，说明获取写锁成功，把自己设置为占有者，并返回true
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
// 获取写锁失败了后面的逻辑跟ReentrantLock是一致的，进入队列排队，这里就不列源码了
</code></pre>
<h5 id="写锁获取的过程大致如下：">写锁获取的过程大致如下：</h5>
<ol>
<li>尝试获取锁；</li>
<li>如果有读者占有着读锁，尝试获取写锁失败；</li>
<li>如果有其它线程占有着写锁，尝试获取写锁失败；</li>
<li>如果是当前线程占有着写锁，尝试获取写锁成功，state值加1；</li>
<li>如果没有线程占有着锁（<code>state==0</code>），当前线程尝试更新state的值，成功了表示尝试获取锁成功，否则失败；</li>
<li>尝试获取锁失败以后，进入队列排队，等待被唤醒；</li>
<li>后续逻辑跟ReentrantLock是一致；</li>
</ol>
<h5 id="非阻塞获取读锁-2">非阻塞获取读锁</h5>
<p>下面再讲一下非阻塞获取读锁的操作，相对就要简单很多了：</p>
<pre><code class="language-java">// ReentrantReadWriteLock.WriteLock.tryLock()
// 非阻塞的尝试获取写锁
public boolean tryLock( ) {
    return sync.tryWriteLock();
}
 
// ReentrantReadWriteLock.Sync.tryWriteLock()
final boolean tryWriteLock() {
    // 获取当前线程
    Thread current = Thread.currentThread();
    int c = getState();
    // 读锁或者写锁已经被线程持有
    if (c != 0) {
        int w = exclusiveCount(c);
        // 写锁第一次获取锁或者当前线程不是第一次获取写锁的线程（也就是不是owner），直接失败
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        // 超出写锁的最大次数，直接失败
        if (w == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
    }
    // 竞争写锁的线程修改state，
    // 如果成功将自己设置成锁的owner，
    // 如果失败直接返回
    if (!compareAndSetState(c, c + 1))
        return false;
    setExclusiveOwnerThread(current); // 设置当前线程持有锁
    return true;
}
</code></pre>
<h4 id="写锁释放锁">写锁释放锁</h4>
<h5 id="源码-5">源码</h5>
<pre><code class="language-java">// java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.unlock()
public void unlock() {
    sync.release(1);
}
 
//java.util.concurrent.locks.AbstractQueuedSynchronizer.release()
public final boolean release(int arg) {
    // 如果尝试释放锁成功（完全释放锁）
    // 就尝试唤醒下一个节点
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
 
// java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryRelease()
protected final boolean tryRelease(int releases) {
    // 如果写锁不是当前线程占有着，抛出异常
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    // 状态变量的值减1
    int nextc = getState() - releases;
    // 是否完全释放了该写锁
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        setExclusiveOwnerThread(null);
    // 设置状态变量的值
    setState(nextc);
    // 如果完全释放了写锁，返回true
    return free;
}
</code></pre>
<h5 id="写锁释放的过程大致为：">写锁释放的过程大致为：</h5>
<ol>
<li>先尝试释放锁，即状态变量state的值减1；</li>
<li>如果减为0了，说明完全释放了锁；</li>
<li>完全释放了锁才唤醒下一个等待的节点；</li>
</ol>
<h3 id="基于源码讨论一下锁升级和锁降级的问题">基于源码讨论一下锁升级和锁降级的问题</h3>
<h4 id="如果同一个线程先获取读锁，再获取写锁会怎样？">如果同一个线程先获取读锁，再获取写锁会怎样？</h4>
<pre><code class="language-java">protected final boolean tryAcquire(int acquires) {
    // 获取当前线程
    Thread current = Thread.currentThread();
    // 状态变量state的值
    int c = getState();
    // 互斥锁被获取的次数
    int w = exclusiveCount(c);
    // c != 0朔说明此时读写锁已经被线程占有了
    if (c != 0) {
        /**
         * 条件1：如果c!=0且w==0，说明共享锁被获取的次数不为0
         * 条件2：当前线程是不是持有该写锁的线程
         * 
         * 条件1和条件2只要有任意一个成立，就会进入该if分支中返回false
         * 条件1成立，说明此时已经有线程获取读锁了，如果获取读锁的线程是其他线程，那么读写互斥，不能够获取到写锁。如果获取读锁的线程就是当前线程，因为不允许锁升级，所以也不能获取到写锁，直接返回false
         * 条件2成立，说明该写锁已经被其他线程获取了，所以当前线程不能获取到该写锁，返回false
         */
        if (w == 0 || current != getExclusiveOwnerThread())
            // 返回false，获取写锁失败
            return false;
        // 溢出检测，写锁持有次数是否超过了最大限制
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // 到这里说明当前线程已经获取过写锁，这里是重入了，直接把state加1即可
        // 注意这里直接用state+acquires就行了，因为state后16为本来就是记录写锁占有次数的，直接在state基础上做加法即可
        setState(c + acquires);
        // 获取写锁成功
        return true;
    }
    
    ......
}
</code></pre>
<p>分析上面的源码，在tryAcquire()方法中，如果此时该线程已经获取了读锁了，那么该读写锁的state肯定不等于0（c != 0），然后就有两种可能，一个是此时还有有任何线程获取写锁（w == 0），这种情况下就会进入到if (w == 0 || current != getExclusiveOwnerThread())这个分支里，返回false获取写锁失败。返回之后外层方法会让当前线程阻塞等待。</p>
<p>这里例子说明了ReentrantReadWriteLock不允许锁升级。</p>
<p>可以通过下面的方法验证：</p>
<pre><code class="language-java">readLock.lock();
writeLock.lock();
writeLock.unlock();
readLock.unlock();
</code></pre>
<h4 id="如果同一个线程先获取写锁，再获取读锁会怎样？">如果同一个线程先获取写锁，再获取读锁会怎样？</h4>
<pre><code class="language-java">// ReentrantReadWriteLock.Sync.tryAcquireShared()
protected final int tryAcquireShared(int unused) {
    // 获取当前线程
    Thread current = Thread.currentThread();
    // 状态变量的值
    // 在读写锁模式下，高16位存储的是共享锁（读锁）被获取的次数，低16位存储的是互斥锁（写锁）被获取的次数
    int c = getState();
    /**
     * 条件1：获取互斥锁（读锁）的被持有的次数，判断是否不等于0
     * 条件2：判断当前线程是否持有互斥锁（写锁）
     * 
     * 如果条件1和条件2同时成立，表明其它线程获得了写锁，因为读写和写读互斥，直接返回-1，该线程获取读锁失败
     */
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    // 读锁被获取的次数
    int r = sharedCount(c);
    
    // 执行到这里说明此时还没有线程获取写锁，尝试去更新state的值获取读锁
    /**
     * 条件1：读者是否需要排队（是否是公平模式），readerShouldBlock()返回true说明需要排队
     * 条件2：读锁被持有次数是否小于上限
     * 条件3：尝试CAS更新读锁state值是否成功
     * 
     * 如果三个条件均成立，则说明当前线程尝试获取读锁成功，就可以执行后续的修改当前线程持有读锁重入次数的操作了
     */
    if (!readerShouldBlock() &amp;&amp;
        r &lt; MAX_COUNT &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        // 获取读锁成功
        // 判断之前是否有线程持有该读锁
        if (r == 0) {
            // 如果之前还没有线程获取读锁，记录第一个读者为当前线程，直接使用firstReader和firstReaderHoldCount进行记录，不适用ThreadLocal
            firstReader = current;
            // 第一个读者重入的次数为1
            firstReaderHoldCount = 1;
        // 如果有线程获取了读锁且是当前线程就是第一个读者
        } else if (firstReader == current) {
            // 则把其重入次数加1
            firstReaderHoldCount++;
        } else {
            ......
        }
        // 获取读锁成功，返回1
        return 1;
    }
    // 如果CAS失败，则通过这个方法再去尝试获取读锁（如果此时其它线程仍在持有写锁，一样返回-1表示失败，因为写读，读写互斥）
    return fullTryAcquireShared(current);
}
</code></pre>
<p>分析上面的源码，在tryAcquireShared()方法中，在if (exclusiveCount© != 0 &amp;&amp; getExclusiveOwnerThread() != current)分支处并不会返回，因为是当前线程获取的写锁，不满足getExclusiveOwnerThread() != current；如果在if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) 这个分支上原子更新成功就说明获取了读锁，然后就会执行后续的代码把其读锁重入次数+1。</p>
<p>这里例子说明了ReentrantReadWriteLock允许锁降级。</p>
<p>可以通过下面的方法验证：</p>
<pre><code class="language-java">writeLock.lock();
readLock.lock();
readLock.unlock();
writeLock.unlock();
</code></pre>
<h4 id="为什么不能锁升级">为什么不能锁升级</h4>
<p>通过上面的两个例子，我们可以感受到同一个线程先读后写和先写后读是完全不一样的，为什么不一样呢？</p>
<p><strong>先读后写</strong>，一个线程占有读锁后，其它线程还是可以占有读锁的，这时候如果在其它线程占有读锁之前让自己占有了写锁，其它线程又不能占有读锁了，这段程序会非常难实现，逻辑也很奇怪，所以，设计成只要一个线程占有了读锁，其它线程包括它自己都不能再获取写锁。</p>
<p><strong>先写后读</strong>，一个线程占有写锁后，其它线程是不能占有任何锁的，这时候，即使自己占有一个读锁，对程序的逻辑也不会有任何影响，所以，一个线程占有写锁后是可以再占有读锁的，只是这个时候其它线程依然无法获取读锁。</p>
<p>我们假设几个例子就能更好地理解为什么不能锁升级。</p>
<p>假设有 A，B 和 C 三个线程，它们都已持有读锁。假设线程 A 尝试从读锁升级到写锁。那么它必须等待 B 和 C 释放掉已经获取到的读锁。如果随着时间推移，B 和 C 逐渐释放了它们的读锁，此时线程 A 确实是可以成功升级并获取写锁。</p>
<p>但是我们考虑一种特殊情况。</p>
<p>假设线程 A 和 B 都想升级到写锁，那么对于线程 A 而言，它需要等待其他所有线程，包括线程 B 在内释放读锁。而线程 B 也需要等待所有的线程，包括线程 A 释放读锁。这就是一种非常典型的<strong>死锁</strong>的情况。谁都愿不愿意率先释放掉自己手中的锁。由此可见，是不能够允许锁升级的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/yu627482453">Bill Cipher</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantreadwritelock/">https://yu627482453.github.io/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantreadwritelock/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yu627482453.github.io" target="_blank">蝶梦庄生</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%A1%8C%E5%8A%A8%E9%98%B6%E6%AE%B5-%E5%AE%8C%E6%88%90/">行动阶段/完成</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0%E7%A9%BA%E9%97%B4-KnowladgeSpace-ProgramSpace-BasicsSpace/">笔记空间/KnowladgeSpace/ProgramSpace/BasicsSpace</a><a class="post-meta__tags" href="/tags/%E7%BB%86%E5%8C%96%E4%B8%BB%E9%A2%98-Java/">细化主题/Java</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E9%A2%98%E5%9C%BA%E6%99%AF-%E7%A8%8B%E5%BA%8F/">主题场景/程序</a></div><div class="post_share"><div class="social-share" data-image="https://api.yimian.xyz/img?type=moe" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng-jin-cheng-xie-cheng-de-xiang-xi-jie-shi/"><img class="prev-cover" src="https://api.yimian.xyz/img?type=moe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Java 多线程并发】 线程，进程，协程的详细解释</div></div></a></div><div class="next-post pull-right"><a href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-locks/java-duo-xian-cheng-bing-fa-reentrantlock/"><img class="next-cover" src="https://api.yimian.xyz/img?type=moe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Java 多线程并发】 ReentrantLock</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/java/java-web/java-web/" title="Java Web"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">Java Web</div></div></a></div><div><a href="/java/java-web/java-filter/" title="【Java】 Filter"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Filter</div></div></a></div><div><a href="/java/java-web/java-listener/" title="【Java】 Listener"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Listener</div></div></a></div><div><a href="/java/java-web/java-servlet/" title="【Java】 Servlet"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Java】 Servlet</div></div></a></div><div><a href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-jvm-yu-java-ti-xi-jie-gou/" title="【Java JVM】 JVM与Java体系结构"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="title">【Java JVM】 JVM与Java体系结构</div></div></a></div><div><a href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存"><img class="cover" src="https://api.yimian.xyz/img?type=moe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-10</div><div class="title">【Java JVM】 直接内存</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Bill Cipher</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">215</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yu627482453"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yu627482453" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/627482453@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">【Java 多线程并发】 ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Metadata-134"><span class="toc-number">1.1.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-63"><span class="toc-number">1.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E3%80%91-ReentrantReadWriteLock-2"><span class="toc-number">1.3.</span> <span class="toc-text">【Java 多线程并发】 ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-2"><span class="toc-number">1.4.</span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">互斥关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E5%92%8C%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">1.4.2.</span> <span class="toc-text">锁升级和锁降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.5.</span> <span class="toc-text">ReentrantReadWriteLock的使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%AF%BB%E8%AF%BB%E5%B9%B6%E5%8F%91%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.1.</span> <span class="toc-text">关于读读并发需要注意的事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-2"><span class="toc-number">1.6.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">读写锁的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3"><span class="toc-number">1.8.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%8A%B6%E6%80%81%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.1.</span> <span class="toc-text">读写状态的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8sharedCount-%E8%AE%A1%E7%AE%97%E8%AF%BB%E9%94%81%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">使用sharedCount()计算读锁被占用的次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8exclusiveCount-%E8%AE%A1%E7%AE%97%E5%86%99%E9%94%81%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">使用exclusiveCount()计算写锁被占用的次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%8C%81%E6%9C%89%E8%AF%BB%E9%94%81%E7%9A%84%E9%87%8D%E5%85%A5%E6%AC%A1%E6%95%B0"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">记录每个线程持有读锁的重入次数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.1.3.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.1.3.2.</span> <span class="toc-text">为什么这样设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0cachedHoldCounter%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">1.8.1.3.3.</span> <span class="toc-text">添加cachedHoldCounter的原因：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0firstReader-%E5%92%8C-firstReaderHoldCount%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">1.8.1.3.4.</span> <span class="toc-text">添加firstReader 和  firstReaderHoldCount的原因：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7-2"><span class="toc-number">1.8.3.</span> <span class="toc-text">主要属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.8.4.</span> <span class="toc-text">主要构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadLock%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.8.5.</span> <span class="toc-text">ReadLock类源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E9%94%81%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">读锁共享锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-2"><span class="toc-number">1.8.5.1.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E8%87%B4%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-number">1.8.5.1.2.</span> <span class="toc-text">大致的逻辑：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%95%B4%E4%B8%AA%E9%80%BB%E8%BE%91%E4%B8%AD%E6%98%AF%E5%9C%A8%E5%93%AA%E9%87%8C%E8%BF%9E%E7%BB%AD%E5%94%A4%E9%86%92%E8%AF%BB%E8%8A%82%E7%82%B9%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.8.5.1.3.</span> <span class="toc-text">在整个逻辑中是在哪里连续唤醒读节点的呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%95%B4%E4%B8%AA%E9%80%BB%E8%BE%91%E4%B8%AD%E6%98%AF%E5%9C%A8%E5%93%AA%E9%87%8C%E8%BF%9E%E7%BB%AD%E5%94%A4%E9%86%92%E8%AF%BB%E8%8A%82%E7%82%B9%E7%9A%84%E5%91%A2%EF%BC%9F-2"><span class="toc-number">1.8.5.1.4.</span> <span class="toc-text">在整个逻辑中是在哪里连续唤醒读节点的呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%8E%B7%E5%8F%96%E8%AF%BB%E9%94%81"><span class="toc-number">1.8.5.1.5.</span> <span class="toc-text">非阻塞获取读锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E9%94%81%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">读锁释放锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-3"><span class="toc-number">1.8.5.2.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.8.5.2.2.</span> <span class="toc-text">解锁的大致流程如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.8.5.2.3.</span> <span class="toc-text">举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteLock%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.8.6.</span> <span class="toc-text">WriteLock类源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E9%94%81%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">写锁获取锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-4"><span class="toc-number">1.8.6.1.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E9%94%81%E8%8E%B7%E5%8F%96%E7%9A%84%E8%BF%87%E7%A8%8B%E5%A4%A7%E8%87%B4%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.8.6.1.2.</span> <span class="toc-text">写锁获取的过程大致如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%8E%B7%E5%8F%96%E8%AF%BB%E9%94%81-2"><span class="toc-number">1.8.6.1.3.</span> <span class="toc-text">非阻塞获取读锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E9%94%81%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">写锁释放锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-5"><span class="toc-number">1.8.6.2.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E8%BF%87%E7%A8%8B%E5%A4%A7%E8%87%B4%E4%B8%BA%EF%BC%9A"><span class="toc-number">1.8.6.2.2.</span> <span class="toc-text">写锁释放的过程大致为：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E8%AE%A8%E8%AE%BA%E4%B8%80%E4%B8%8B%E9%94%81%E5%8D%87%E7%BA%A7%E5%92%8C%E9%94%81%E9%99%8D%E7%BA%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.7.</span> <span class="toc-text">基于源码讨论一下锁升级和锁降级的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%88%E8%8E%B7%E5%8F%96%E8%AF%BB%E9%94%81%EF%BC%8C%E5%86%8D%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">如果同一个线程先获取读锁，再获取写锁会怎样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%88%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81%EF%BC%8C%E5%86%8D%E8%8E%B7%E5%8F%96%E8%AF%BB%E9%94%81%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.8.7.2.</span> <span class="toc-text">如果同一个线程先获取写锁，再获取读锁会怎样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">1.8.7.3.</span> <span class="toc-text">为什么不能锁升级</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/design/she-ji-mo-shi/" title="无题"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/design/she-ji-mo-shi/" title="无题">无题</a><time datetime="2023-07-15T09:13:39.871Z" title="发表于 2023-07-15 17:13:39">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java 多线程并发】 线程"/></a><div class="content"><a class="title" href="/java/java-duo-xian-cheng-bing-fa/java-duo-xian-cheng-bing-fa-xian-cheng/java-duo-xian-cheng-bing-fa-xian-cheng/" title="【Java 多线程并发】 线程">【Java 多线程并发】 线程</a><time datetime="2023-07-10T06:15:00.000Z" title="发表于 2023-07-10 14:15:00">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java JVM】 直接内存"/></a><div class="content"><a class="title" href="/java/java-jvm/java-jvm-nei-cun-guan-li/java-jvm-zhi-jie-nei-cun/" title="【Java JVM】 直接内存">【Java JVM】 直接内存</a><time datetime="2023-07-10T00:00:00.000Z" title="发表于 2023-07-10 08:00:00">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/" title="【Redis】 排序"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Redis】 排序"/></a><div class="content"><a class="title" href="/database/redis/redis-chong-dian-gong-neng/redis-pai-xu/" title="【Redis】 排序">【Redis】 排序</a><time datetime="2023-07-09T06:07:00.000Z" title="发表于 2023-07-09 14:07:00">2023-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/" title="【Redis】 Lua脚本"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Redis】 Lua脚本"/></a><div class="content"><a class="title" href="/database/redis/redis-chong-dian-gong-neng/redis-lua-jiao-ben/" title="【Redis】 Lua脚本">【Redis】 Lua脚本</a><time datetime="2023-07-09T05:56:00.000Z" title="发表于 2023-07-09 13:56:00">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Bill Cipher</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c61a274b6f5aa26a58f6',
      clientSecret: '485a7761d321c8dcc5cae05d7256be9fb196d94a',
      repo: 'yu627482453.github.io',
      owner: 'yu627482453',
      admin: ['yu627482453'],
      id: '846050362e8205b6c60fcae749cd3c59',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>